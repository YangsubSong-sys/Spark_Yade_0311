// ChildView7.cpp : implementation file
//


#include <string.h> 
#include <stdio.h> 
#include <stdlib.h>
#include <conio.h> 
#include <math.h> 
#include "stdafx.h"
#include <direct.h> 


#include "MainFrm.h"
#include "BiOpTroCon.h"
#include "ChildView1.h"
#include "ChildView7.h"

#include "FileSysInfo.h"
#include "Contec.h"
#include "ModeAuto11.h"
#include "ChildView1.h"
#include "ModeSub71.h"
#include "ModeSet13.h"
#include "ModeSet15.h"//sylee121115-1
#include "ModeSet17.h"  
#include "ModeSet21.h" //sylee160524-2
#include "IniFile.h"  //sylee151028-1
#include "A_Define1.h"//sylee161126
#include "Globals.h"    //son220412
#include "ModeSub18.h"  //son230523 sylee230522 관련 추가
#include "shlwapi.h" //son240110 PathIsDirectory() 사용 관련 추가
#include <assert.h>

#ifdef DEF_CARD_A1  //sylee170328

#else  //#ifdef DEF_CARD_A1  

    //=======================================
#include "DioD64H.h"//sylee170229
#include "DioD96.h"//sylee170229
#include "UniDAQ.h"//sylee170229
#include "PCI_D64H.h" //sylee170229 ㅣ
CDIO_D64  pDIO_D64;//sylee170229
CDIO_D96  pDIO_D96;
extern CString str2;
//=======================================

#endif  //#ifdef DEF_CARD_A1 

//#include "Gnet1.h" 

#include<windows.h>
#pragma comment(lib,"winmm.lib")
#include <mmsystem.h> 


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int nLeakNearFlag1,nLeakNearPin1,nLeakNearPin2,nLeakNearLimit;//sylee241226
int nLeakACMode1;//sylee241120-2  //sylee241204
int  nLeakADCCo1;//sylee240119 
short nFlagLeakMPin1;  //sylee230526
int nLeakADhigh1;//sylee230907
int nLeakHighFlag1[11];//sylee230828
int nLeakHighFlag2;//sylee230830
int nLeakADCFlag1;//sylee230814-1
int nLeakADCPer1,nLeak1ADC_100M,nLeak2ADC_100M ;//sylee230822
int nLeakMode1;//sylee230822

int nSamePcbFlag;//sylee230222-1	     //sylee230426-5
int nManual4WStartFlag1; //sylee230426-8 MANUAL START:  ABORT DIO   //son 4W 정밀테스트 On Flag

int nADCFail200;//sylee221207  
double dADCPercent1;//sylee221220-1	
double dR101[511],dR101V[511],dR101I[511];//sylee221208  
float d4wI[MAX_4W_NET +1][510],d4wV[MAX_4W_NET +1][510];//sylee221206-2	//son231107 Def_4WMax1 -> MAX_4W_NET +1
int gn4W_Mode1,gn4W_Mode1_RangeADC1,gn4W_Mode1_RangeADC2;//sylee230124
int d4wIPo1,d4wVPo1,d4wNet1;//sylee221206-2
float d4wI2[51][510],d4wV2[51][510];//sylee230103-1
int d4wIPo2,d4wVPo2,d4wNet2;//sylee230103-1
int n4WVI2LogCo1;
int d4wVILog_Flag2;//sylee230103-1
short n4WNg1[MAX_4W_NET +1];		//son231107 Def_4WMax1 -> MAX_4W_NET +1
int nFlag_DIO_Manual1;//sylee230224
 
float d4W_Data1[MAX_4W_NET +1];//sylee230214-1	//son231107 Def_4WMax1 -> MAX_4W_NET +1
int nFlag_d4W_Data1;//sylee230224
int nFlag_d4W_Data1_Retry;//sylee230224
int nFlag_d4W_Data1_RetryCo1;//sylee230224
float d4W_Data1Retry[30];//sylee230214-1

int n4W_Data_Use1;//sylee230214-1
double  d4W_Data_CompareRate1,d4W_Data_R1,d4W_Data_Rate1;//sylee230214-1

 double dtmp1, dNgPercent;   //sylee221223
int nVbCheck1[10][3];//sylee230529  //sylee230817			

#define DEFINE_HVTIMEOUT1  15000000     // 15SEC //-SYLEE130703  15->15
#define ConLog1 1
#define  nSTI_ADC   6.5 //M  //SYLEE130102   //estimation

#define Simulator100 0    //real run
#define Simulator201 0    // real run
#define Simulator202 0    // real runs
#define Simulator203 0    // real run


//son201028 ChildView1과 공유하기 위해 멤버변수(m_ComiDaq2)를 글로별변수로 변경
CComiDaq    g_ComiDaq2;
int g_nCurDioCmd = 0; //son231018	
int g_nPrevDioCmd = 0xffff;		//son231018  //son241119 계측기 초기화 직후 main 장비 요청에 무응답 문제 수정

//CChildView7 sView7;       //son210810

extern int Check_4WErrorNet();  //son231020 
extern int __Check_4WErrorNet(bool bPrintOn, FILE *fp); //son231020

double  d4WADCPer1 ,d4WADCPer2,d4WADCPer3 , d4WADCSigma1; //sylee221208-1
int n4WAdcOK1[10];//sylee221212-1

int     g_nProRv2[10] = { 0, };      // hdpark220715 Leak Retry 판정R + Offset
int     g_nProRv3[10] = { 0, };      // hdpark220715
float g_fSparkRefData[DEF_MAX_PIN1];    // hdpark220511
short g_nSparkRefDataCount[DEF_MAX_PIN1];    // hdpark220511
int     g_nSparkWaitingEnable = 0;  // hdpark231121, 0 : disable, 2: enable
double  g_dWaitingSparkV;              // hdpark231121
double  g_dWaitingSparkVOrg;              // hdpark231121
double	g_dSparkRatio;               // hdpark231121

//yklee Leak 핀등록시 Spark SW판단시 Judge일 경우, 판단로직에 활용하며, Judge Fail시 Pin Learning 정보 기록 버퍼 관리용으로 활용중
SPARK_AI    g_tSparkAI[DEF_MAX_PIN1];    // hdpark240102  

const int g_bUseProgressiveFault = FALSE;   // hdpark231205

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
int nFlagLeak12;//sylee230315-1   //sylee230807
int nFlagLeak12Run1;//sylee230324  //sylee230807
int nFlagLeak12_Sel;//sylee230322  //sylee230807
int nFlagLeak12_Vol1,nFlagLeak12_Vol5,nFlagLeak12_Vol6,nFlagLeak12_VoiNo;//sylee230322  //sylee230807
int nFlagLeak12Voltage[10]; //sylee230315-1  //sylee230807
#endif  //son231122

int nFlag_4W_SetI;//sylee211118
int nFlag_NewSparkBaord;//SYLEE201024-1  //SPARK NEW BOARD  
int nSparkIPlus1;//SYLEE201027
int nFlagRunMode1;//syle201012      //son START+TEST 로 OnStart1()수행시 2로 표시, 나머지케이스는 모두 0 
int nFlag_LeakDischarge1;//sylee200916-1 

short nFlag_DIN_ABORT; //sylee231019

short nRunStep100;     //sylee231016

int nLeakDischarge1AD1, nLeakDischarge1AD2, nLeakDischarge1AD0;//sylee200916
double d4W_VC1[10], d4W_I1[10];//sylee200909
int n4W_PinFastADC1;//sylee200905

float dSparkV1[MAX_BLOCK + 1][MAX_PIECE + 1];//sylee200710 NEW_SPARK  //yklee 사용안함 
float dSparkI1[MAX_BLOCK + 1][MAX_PIECE + 1];//sylee200710 NEW_SPARK
float dSparkI12[MAX_BLOCK + 1][MAX_PIECE + 1];//sylee200710 NEW_SPARK //yklee Spark SW 판단시 VS 전압 버퍼 복사 및 로그 파일 작성 함수에서 사용
float dSparkV2[MAX_PIECE + 1];//sylee200710 NEW_SPARK  //yklee Spark Detect 시 VS 전압 저장 버퍼로 활용 
float dSparkI2[MAX_PIECE + 1];//sylee200710 NEW_SPARK

double dSparkLeakSet1; //sylee200710-1  NEW_SPARK  //yklee OLD Spark방식에서 V/I 값으로 VS Raw값에 반영, 현재 미사용
double dSparkLeakSet1_I;//sylee200710-1  NEW_SPARK //yklee Spark VB전류모드일때, ADC to Current 환산에 활용, 표기전류 수식에도 활용
double dSparkLeakSet1_V;//sylee200710-1  NEW_SPARK //yklee 레시피에 따른 HW세부 구동 전압(예:250V)으로써, Spark 감지 전압 값, Spark SW 판단에 활용

int nSpark_NetFailCheck1;//sylee200814 //yklee Leak DC 모드에서 Spark Net Fail시 AC 모드 Spark 체크 진입에 활용 [현재 미적용-용도 이해 필요]
int nFlag_Spark_PinOn;//sylee200710-1 NEW_SPARK //yklee Leak 핀등록시 Spark 발생때 버퍼+50 VB Read 실행 판단에 활용
int nSparkRefV;  //sylee200710-1 NEW_SPARK //yklee Recipe > Spark-V(2~250V) 에 설정된 Spark 감지 전압값, 
                                           //      Spark Detect 전압 설정시 HW Offset과 합산하여 설정에 활용
int nSparkPinNo1;//sylee200710-1 NEW_SPARK //yklee Leak 핀등록시 Spark 발생 판단시 발생 VB Pin번호 로그기록용으로 활용

int nSparkDetect1;  //yklee Leak 핀등록시 Spark 발생때 핀찾기 및 Error 로그 기록 판단에 활용
int nSparkMaxX;     //yklee Spark On시 MAP-Set3에 설정된 VS 전압 모니터링 버퍼 길이 [Map > Set3 > Spark Mon Count]
int nSparkMaxY;     //yklee Spark SW 판단시 Spark 발생 통계로그 버퍼 접근 Index에 활용 [Spark발생횟수 상세 로그버퍼 관리용] 
int nSparkGapMin;   //yklee Spark Mon Count와 연관지어 활용하려 시도하였으나, 현재 미사용중
int nSparkHWoffSet1;//yklee MAP-Set3의 Spark HW Offset설정값을 복사하여 Spark Detect 설정 및 SW 판단시 업체별 판단 로직에 활용중 
int nSparkSWoffSet1; //yklee  미사용중
int nSparkMaxXGap1;//sylee200710-1 NEW_SPARK //yklee Spark Wait Check일때 Mon Count와 연관지어 Wait Mon용으로 활용시도 용도로 보이나, 현재 미사용
int nSparkMaxXSet;//sylee210430  //yklee Spark Mon Count를 복사하여 Spark Wait Mon Count 설정 로직에 활용시도 용도로 보이나, 현재 미사용
double dSparkHiValue, dSparkLowValue;//sylee200710-1 NEW_SPARK  //ylkee 미사용중

int g_nPieceMax1Enable, g_nPieceMax1Disable;//sylee201029    //son201118 g_ (Global 변수 접두어) 추가 
extern  int nSparkV1Po1, nSparkI1Po1;//sylee200710 NEW_SPARK
extern  int nSparkV1Po2, nSparkI1Po2;//sylee200710 NEW_SPARK
extern  int nSpark1Po1_Start, nSpark1_Detect2, nSpark1_Detect2Co, nSpark1_Detect2_Step, g_nSpark1_Use;//sylee200721;//sylee200721 NEW_SPARK

extern  int nADCx5;//sylee180611-1
extern int nJigTestOpen, nJigTestShort;//sylee181008-1
extern CSysSet211  SysSet211;  //SYLEE181025
int n4W_Use;//sylee200612-4W정도개선
int n4w_AutoCalCo1; //sylee171020-1
int nProRv1_O;//sylee170814-1           //son 100 ohm의 ADC Raw R 값을 저장
int nHV_Vset1;//sylee200703 NEW_SPARK
extern short nBDLPinT2[DEF_MAX_PIN1];//sylee190104
extern double dAdcI;//sylee180823-1
int nFlag_ADICheck1, nFlag_ADIRet1;//sylee180823-1
extern int dAdcISet, dAdcISet2;//sylee200515-4W정도개선
int n4W_ADC_Fail_Flag; //ng //sylee200513-1-4W정도개선
int nPass2[DEF_MAX_PIECE1];//sylee171120-1  //son220823_6
int nPass2Flag;//sylee171120-1
int nG_Language;  //SYLEE150707     //son 2: chinese
extern int nPinAutoCal1[5];//sylee171020
extern int  gDef_Language1; //SYLEE151028   //1=KOREA ,2=ENGLISH, 3=CHINA
extern CSysInfo05  SysInfo05;  //sylee160616
extern CSysSet211  SysSet211;  //sylee160524-2
double n4WData1[5001][5];//sylee200415   //SYLEE200515-PATCH-debug
double n4WData1v[5001][5];//sylee200415  //SYLEE200515-PATCH-debug
double n4WData1i[5001][5];//sylee200415  //SYLEE200515-PATCH-debug
int nFlag_4W_OUT50V;//SYLEE200411   //SYLEE200515-PATCH
extern int  nAutoStartInterlock100;//sylee050308  //sylee150602
extern int  nHpin, nLpin;//sylee050309  //sylee150602
__int64   tStart121, tStart122, tStart123;  //debug
__int64   tStart221, tStart222, tStart223;  //debug
__int64   tStart321, tStart322, tStart323;  //debug
__int64   tStart1001, tStart1002;//SYLEE150426-2

int nShort_Flag1; //1:__LV  2:__HV  //sylee161026
int nStep1[10];//sylee150427
int nUse_US, nTk,nUse_4W,nUse_HR; //sylee150630  //SYLEE230315   
#ifdef __QUAD_LEAK1_LEAK2__  //son231122
int nUse_LEAK1, nUse_LEAK2;	//sylee230807
#endif  //son231122

short nPinSetSkipVb, nPinSetSkipVbCnt, nPinSetSkipVc, nPinSetSkipVcCnt; //sylee151005 //ACE400 //son230127


int ReadFile_SkipPieceInfo();//sylee160203-ITS      //son220621 A_PieceDisable1() -> ReadFile_SkipPieceInfo() 
int nRelay1OffSkip;//sylee170424-1

int nProcessStatus1;//sylee150506
int nAutoPress_Flag1;//sylee150213
int nAutoPress_nConEr_old1;//sylee150213

int nRecheck_old;//sylee131001
int nRecheck_old_Flag;//sylee131001    0  enable , 1= disable  //joytech
extern int nMultyNetTotal;//sylee150817

extern int g_nSelfTestInterlock; //sylee131121      //son defined in ChildView8.cpp
extern CSysSet17  SysSet17;
extern CSysSet12  SysSet12;  //Pin SETUP 

extern int n4w_Sample_Enable;//sylee150812-1
extern int n4w_Sample_SetCount;//sylee150812-1

//son200320-4WDUT16:  Multi DUT 구조로 수정
extern int n4w_Sample_RunCount[MAX_DUT];//sylee150812-1
extern int n4w_Sample_SheetCount[MAX_DUT]; //son211112 n4w_Sample_RunCount[dutIdx]는 양품인 경우만 증가
                                 //          n4w_Sample_SheetCount[dutIdx]는 불량, 양품 모두 증가. 실제 Sampling sheet 개수

extern int n4w_Sample_Old;//sylee150812-1 
int n4w_Sample_Finish;//sylee150812-1 
extern int n4w_Measure1_Enable;//sylee200512 //sylee200515-patch

int n4w_Sample_ok1;//sylee171103-5  //son 이번회차  sampling 수집 OK 표시
int n4w_Sample_RunCount_nTmp2;//sylee171103-5
int g_n4wSampleFailCo1 = 0; //sylee160611-1
bool g_b4wSampleEnd[MAX_DUT];   //son200320-4WDUT16:  신규 추가 
                                //                모든 DUT가 양품으로 판정이 되었다면 장비에게 4W Auto Sampling의 'END' Response을 보내기 위함.
                                //son211217_2  삭제
                                //son220203 4W Retest 안된다는 GTS 문제점 보고되어 20년 3월 기능 삭제했던 것 복구

extern bool    g_bUseLowerCalJig_4W;     //son220419_7  0: 기존 Pin 사용. 1: 하부핀 R 측정 모드      defined in ModeSub17.cpp                          

//son g_Map10_CellNo[][]에 TotalPiece 번호(Cell번호?)를 write.  (전체 block 기준으로 한 piece) 
//    Block이 6개,  Piece가 6개라면  1~36까지의 값이 할당.
//son g_Map10_CellNo[nBlockMaxY*nPieceMaxY][nBlockMaxX*nPieceMaxX]
short g_Map10_CellNo[DEF_MAX_PIECE1][DEF_MAX_PIECE1];//sylee130913  //son220823_6
short Map20[DEF_MAX_PIECE1][DEF_MAX_PIECE1];//sylee130913   //son220823_6

//son Cell의 Step 진행순서 (Step Direction 관련) 
short g_Map2_CellStep[MAX_CELL +1];//y,x     nanosys //sylee130821  //son231107  //son240510

//son Block의 Step 진행 순서 (Step Direction 관련)
//    SysInfoBlock.m_nStepDirection=3,4 일때 사용)
short g_Map3_BlockStep[MAX_CELL +1];//y,x    //sylee180419-1       //son231107  //son240510
//son ex) nDisCell1[][], g_Map10_CellNo[], g_Map2_CellStep[], g_Map3_BlockStep[][]  예제
//==> DS-015-AA-M_DD-Copy/Setup2/Block.ini <==
//         20
//          5   //Block row
//          4   //block Col
//          1
//          1         2         3         4
//          5         6         7         8
//          9        10        11        12
//         13        14        15        16
//         17        18        19        20
//          
// Piece는 모두 2 (row 1, col 2)
// MaxCellX = 4* 2  => 8
// MaxCellY = 5* 1 => 5
//
//
// Cell Display    (A, B, C, D 공통)
// g_Map10_CellNo[MaxCellY][MaxCellX] = 0, 0, 0, 0,
//                                      0,  1,  2,  3,  4,  5,  6,  7,  8
//                                      0,  9, 10, 11, 12, 13, 14, 15, 16,
//                                      0, 17, 18, 19, 20, 21, 22, 23, 24
//                                      0, 25, 26, 27, 28, 29, 30, 31, 32
//                                      0, 33, 34, 35, 36, 37, 38, 39, 40
//

// Cell Display (Block-Piece로 Auto 화면 표시, A, B, C, D 공통 )
// nDisCell1[1] = (0,0) (1,1)  (1,2)  (2,1)  (2,2)  (3,1)  (3,2)  (4,1)  (4,2) 
// nDisCell1[2] = (0,0) (5,1)  (5,2)  (6,1)  (6,2)  (7,1)  (7,2)  (8,1)  (8,2)
// nDisCell1[3] = (0,0) (9,1)  (9,2)  (10,1) (10,2) (11,1) (11,2) (12,1) (12,2)
// nDisCell1[4] = (0,0) (13,1) (13,2) (14,1) (14,2) (15,1) (15,2) (16,1) (16,2)  
// nDisCell1[5] = (0,0) (17,1) (17,2) (18,1) (18,2) (19,1) (19,2) (20,1) (20,2) 


//1)  SysInfo03.m_nType2= 1  : A 이면 
//
//// Cell의 Step 진행 순서 : 좌 -> 우 반복 진행
// g_Map2_CellStep[] =  0,   1,  2,  3,  4,  5,  6,  7,  8,  
//                           9, 10, 11, 12, 13, 14, 15, 16, 
//                          17, 18, 19, 20, 21, 22, 23, 24,
//                          25, 26, 27, 28, 29, 30, 31, 32, 
//                          33, 34, 35, 36, 37, 38, 39, 40
//
//
// // Block Step 진행 순서  : X방향. 좌->우 반복 진행. 일반적인 순서.
// g_Map3_BlockStep[] =  0,  1,  2,  3,  4,    ->
//                           5,  6,  7,  8,    ->
//                           9, 10, 11, 12,    ->
//                          13, 14, 15, 16,    ->
//                          17, 18, 19, 20,    ->
//                   

// 2)  SysInfo03.m_nType2= 2  : B 이면 
// 
// 
// Cell의 Step 진행 순서  : 좌우, 번갈아 진행
// g_Map2_CellStep[] =  0,  1,  2,  3,  4,  5,  6,  7,  8,      ->
//                         15, 16, 13, 14, 11, 12,  9, 10,      <-
//                         17, 18, 19, 20, 21, 22, 23, 24,      ->
//                         31, 32, 29, 30, 27, 28, 25, 26,  <-
//                         33, 34, 35, 36, 37, 38, 39, 40       ->
// 
// Block Step 순서: X 방향, 좌->우, 우->좌 번갈아 진행. 
// g_Map3_BlockStep [] =  0,  1,  2,  3,  4,    ->
//                            8,  7,  6,  5,    <-
//                            9, 10, 11, 12,    ->
//                           16, 15, 14, 13,    <-
//                           17, 18, 19, 20,    ->
//             

//
// 3)  SysInfoBlock.m_nStepDirection= 3  : C 이면 
// 
// // Cell Step 진행 순서   : 상->하 반복 진행
// g_Map2_CellStep[] =  0, 1, 2,  9, 10, 17, 18, 25, 26, 33, 34,    ->
//                         3, 4, 11, 12, 19, 20, 27, 28, 35, 36,    ->
//                         5, 6, 13, 14, 21, 22, 29, 30, 37, 38,    ->
//                         7, 8, 15, 16, 23, 24, 31, 32, 39, 40     ->  
// 
// 
// // Block Step 진행 순서  : 상->하 반복 진행
// g_Map3_BlockStep[] =  0, 1, 5,  9, 13, 17,       ->
//                          2, 6, 10, 14, 18,       ->
//                          3, 7, 11, 15, 19,       ->
//                          4, 8, 12, 16, 20        ->
//                       
// 
// 4)  SysInfoBlock.m_nStepDirection= 4  : D 이면 
// 
// 
// // Cell 진행 순서  : 상->하,  하->상  번갈아 진행.  번호는 g_Map10_CellNo 기준
// g_Map2_CellStep[] =  0,  1,  2,  9, 10, 17, 18, 25, 26, 33, 34,      ->
//                         35, 36, 27, 28, 19, 20, 11, 12,  3,  4,      <-
//                          5,  6, 13, 14, 21, 22, 29, 30, 37, 38,      ->
//                         39, 40, 31, 32, 23, 24, 15, 16,  7,  8,      <-
// 
// 
// // Block Step 진행 순서 : 상->하,  하->상  번갈아 진행
// g_Map3_BlockStep[] =  0,  1,  5,  9, 13, 17,     ->
//                          18, 14, 10,  6,  2,     <-
//                           3,  7, 11, 15, 19,     ->
//                          20, 16, 12,  8,  4,     <-
//            
short nSelfBlock[DEF_MAX_PIECE1];//sylee140917  //son220823_6
int nOpenHighRFlag;//sylee141030 
//int dRec4w2[10][5];//sylee140714    //son220419_5 미사용으로 삭제
int g_nSkipPieceFlag1;//sylee160203-ITS   //son220624

//son total 개수가 2라면  g_nSkipPieceTemp[1], g_nSkipPieceTemp[2]에 skip할 piece 번호를 보관.
int g_nSkipPieceTemp[MAX_PIECE + 1];//sylee160203-ITS //son220624  //son g_nSkipPieceTemp[0]: Skip Piece 개수, 
                                                                  //    g_nSkipPieceTemp[1]~ : Skip해야할 piece 번호 

//son SkipPcs.txt 파일의 내용을 piece를 index로 해서 찾을 수 있는 구조로 저장.
int g_nSkipPieceInfo[MAX_PIECE + 1];//sylee160203-ITS //son220624  //son 실제 Skip Piece 체크에 사용.  
                                                                  //    g_nSkipPieceInfo[0]: Skip Piece 개수
                                                                  //    2: Skip(requested by 메인장비).  index는  nPiece, 

int nBarcodefile_MC_Mode1;//sylee240130 //son241013 1: 4W Csv 기록    1이 아니면: 4W CSV 기록 안함

int nSystemErrorFlag, n4Wcheck1Mes1, nEstModeRun2, nPinConMode1, nPinConMode2;//sylee150921-1
int nAHV_EST1_MODEL_TYPE1, nAHV_EST1_MODEL_TYPE2;//sylee150615-import
int nFlag_Open_SetStart;//sylee150427
int nFlag_Open_SetMode;//sylee150427
int nFlag_Open_SetStart_Status;//sylee150427    0=wait,  1=skip,   2= did, 3= runing 4=cancel 
int nFlag_HV_SetEnd;//sylee150427
int nFlag_HV_SetEnd_Skip;//sylee150427    0=idle, 1=skip
int nOpenUse1;//sylee150627
int SWStart1, QC_Count1;
//sylee151210-MEMORYDEL double  QC_Data1[100][300];
double dEtT_ADC[3010][3][7];//SYLEE130329 
double dEtT_ADC_HR[300][3][7];//SYLEE150407

short nCycleRunFlag;//cycle//sylee130805    //son 0:CycleTest Stop 2: Cycle Test Enable 
int nCycleRunCount;//cycle//sylee130805     //son SysSet17.m_nSet1(Cycle Run Count)까지 계속 증가시킴 
short nCycleRunStatus;//cycle//sylee130805  //son if (SysSet17.m_nSet1 > nCycleRunCount) 인 동안 status는 1
int nCycleRunPass;//cycle//sylee130805
int nCycleRunShort;//cycle//sylee130805
int nCycleRunOpen;//cycle//sylee130805 
short GraphDisplay1[5001];//sylee130913
double  g_VSet1, g_VSet2, g_VSet3, g_VSet4;//sylee130430
double  g_VSet3_old, g_VSet3_Fisrt;//sylee140923-1 
int nOpenPassNetFlag; //syle121118 
int nLVshortUse1;//sylee150622
int nOpenSetFlag1;//SYLEE121204
int n4WSetFlag1;//SYLEE150721-3
short nOpen2Li1[DEF_MAX_PIECE1][11][2];   //[ip][ max list 10]  [0] vb  [1]vc]  //sylee160616  //sylee160628-1 add  //sylee160801-3 //son220823_6

int nReFlagOpenOld[DEF_MAX_PIECE1];//  1 PASS  //SYLEE121129    //son220823_6
                                    //son index                  Piece
                                    //son nReFlagOpenOld[0]      open Pass 수량   
                                    //son nReFlagOpenOld[piece]  1: open Pass Piece 표시 

int nReFlagOpenCur[DEF_MAX_PIECE1];//  1:PASS  2:Open 불량 //son Retest 할 대상인 Piece를 2로 표시한다. //son220823_6
                                    //son index                  Piece
                                    //son nReFlagOpenCur[0]      Open Pass 수량 
                                    //son nReFlagOpenOld[piece]  1:PASS  2:Open 불량

int nReFlagLvCur[DEF_MAX_PIECE1];//  1 PASS //son220823_6

//int nReFlagCom[DEF_MAX_PIECE1];//  1 PASS //son220823_6

int nFileCount; //estimation
int nFileCount_HR; //estimation//sylee150407
int  nICheck, nICheckCount, nICheckSet;//SYLEE140617

int nReSheetFlag1;      //son RESHEET flag //son 메인장비에서 DIO[DIN_RESHEET] 신호를 받았을때 설정된다.
int nReSheetCellNo, nReSheetCellStatus;//sylee131127

//son 자체적으로 RESHEET 예상상태로 판단되었을 때 설정된다.
//short nReSheetRes[5001];//sylee131127      
short nReSheetRes[MAX_CELL +1];//sylee131127  //son240510  5001 ->MAX_BLOCK_PICE1 -> 'MAX_CELL +1'         
                            //   enum BLOCK_RES_TYPE을 value 로 사용 
                            //    1:BLOCK_RES_PASS,    2:BLOCK_RES_OPEN,     3:BLOCK_RES_SHORT, 4: BLOCK_RES_O_S, 
                            //    5:BLOCK_RES_NO_TEST, 7:BLOCK_RES_RUN_FAIL, 8:BLOCK_RES_4W  
                            //    9:BLOCK_RES_PIECE_DISABLE,  10: BLOCK_RES_SPARK

//son210420 RESHEET 수신시 마지막 4w Log를 지우고 다시 작성하기 위해 file Name을 저장
//char g_LastD_Log4w_ResheetfName[MAX_DUT][FILE_PATH_SIZE];   //son210715 [MAX_DUT] 추가 
char g_LastD_Log4w_ResheetfName[FILE_PATH_SIZE];    //son220624_3 RESHEET시에 이전 파일 삭제 기능은 현재 DUT에만 하는게 맞다.
                                                    //            현재 DUT만 삭제하도록  1 DUT 구조로 원상복구

double dCalA1[10][5];//sylee140106  //4WIRESETUP
short nSelfTimeStep;//sylee140917

//-------------------------------------------
//son 4W 측정  R 값 저장 : Log4w CSV 저장용
float d4W_Log1[DEF_MAX_BLOCK1][MAX_4W_NET +1];//sylee150722    //son220823_6  //son231107 Def_4WMax1 -> MAX_4W_NET +1

//-------------------------------------
//son 해당 블록의  DUT Id 저장   
//    d4W_Log1을 Log4W CSV에 저장할때 사용.  Multi DUT 기능 도입으로 4WCsv 파일은 DUT별로 생성.  
//    해당 DUT에 맞는 block만 해당 DUT의 4W Csv log 파일에 step으로 출력된다. 
//    blockIndex는 1부터 사용.  vaule인 dutIdx는 0부터 Write. 
int   g_d4W_Log1_nBlockDutInfo[DEF_MAX_BLOCK1];         //son200320-4WDUT16: 신규 추가  //son220823_6

//-----------------------------------------
//son 4W Auto Sampling: 양품인 R 값만 저장   
        //son200320-4WDUT16: d4W_Log2를 Multi DUT 구조로 수정.
float d4W_Log2[MAX_DUT][MAX_4W_SAMPLE + 10][MAX_4W_NET +1];//sylee150812-1  //son210928
											//son231107 Def_4WMax1 -> MAX_4W_NET +1
//son211112 GTS Unitech 요구사항. 4W_Setup_A.txt에 step, BarCode 정보 추가 요청
C4wSamplingInfo g_4wSampling[MAX_DUT][MAX_4W_SAMPLE + 1];      //son211112


//son220124 제이텍 요구사항.  d:\log4w\폴더명에 LotName 추가 
char   g_strLotName[MAX_BARCODE_STR + 1];   //son220124 BarCode.txt 내 Lot Name 정보 

//son231026 대만MST 유니텍, 나노시스  READ style 4w log 요청관련  추가
char   g_strModelName[MAX_MODELNAME_STR +1];  //son231026 BarCode.txt 내 ModelName 정보  
char   g_strSheetNo[MAX_SHEETNO_STR +1];      //son231026 BarCode.txt 내 SheetNo 정보 
char   g_strTotalNo[MAX_SHEETNO_STR +1];      //son240109 BarCode.txt 내 TotalNo 정보 . size는 ShortNo와 동일하게 하자.
char   g_strBarCode[MAX_BARCODE_STR +1];      //son240622 BarCode.txt 내 BarCode 정보보관

//---------------------------------
//son 4W Auto Sampling: VC값 저장
float d4W_Log3[MAX_4W_SAMPLE + 10][MAX_4W_NET +1];//sylee150812-1  //son210928 //son231107 Def_4WMax1 -> MAX_4W_NET +1

//---------------------------------
//son 4W Auto Sampling: I값 저장
float d4W_Log5[MAX_4W_SAMPLE + 10][MAX_4W_NET +1];//sylee150812-1  //son210928 //son231107 Def_4WMax1 -> MAX_4W_NET +1

int  nAutoSelf_Jigup_Event1;
int  nAutoSelf_OPen1_Run_Flag;//SYLEE140823
int  nAutoSelf_OPen1_Run_Status;//SYLEE140823
int  nAutoSelf_OPen1_Error;//SYLEE140823
int  nAutoSelf_LvShort1_Run_Flag;//SYLEE140823
int  nAutoSelf_LvShort1_Run_Status;//SYLEE140823
int  nAutoSelf_LvShort1_Error;//SYLEE140823

int  nBuzzer1;//sylee160908-1       
int  nEsModelLoadStatus;//sylee130206
extern double dEsModel[1000][10];//  a,b,c, //estimation
extern int nFlagEstModelMake;//sylee130325  //estimation    //son  EstMode 관련된 기능은 현재 모두 제거해야 한다.
                                                            //son  옛날 삼성전기꺼. drop 됨.
extern int nFlagEstModelMakeSelect;//sylee130325    //estimation    //son 삭제필요
extern int nFlagEstModelMakeCount;//sylee130325    //estimation     //son 삭제필요

extern CSysSet21  SysSet21; //SYLEE130618  
extern CSysSet22  SysSet22; //SYLEE130618  
int nShortPinRe2[301][301], nShortPinRe3[301][301]; //sylee150622
double d4W_R1[MAX_4W_NET +1];//sylee180220-5  //son231107 Def_4WMax1 -> MAX_4W_NET +1


long nHVDStopTime1, nHVDStopTime2, nHVDStopTime3;//sylee121103
int nHVDStopFlag, nShortFlag; 
int nIndexSig1;   //son  1: 정방향으로 block 증가 2: reverse block process
int nRetestFlag, nStepStatus1;

int nRefreshFlag1, nDisplayFlag1;
int nProRv1_Est_nb1, nProRv1_Est_nb2, nProRv1_Est_nb3, nProRv1_Est_i; //sylee130325 //estimation

extern __int64 GetMilSecond2();

extern int nCardVb;//sylee120914
extern int nCardVc;//sylee120914
extern void DoEvents();
extern void DoEvents2();

//son231012_2extern int nIADC1;  //sylee20120228
extern double dIADC1; //son231012_2 int nIADC1  -> double dIADC1으로 수정. 소수점이하 잘리는 문제보완.

extern int g_CheckFlag1; //sylee121115
int nBlockMaxXTotal, nBlockMaxYTotal;   //SYLEE120901  

short nDisBlock1[MAX_BLOCK + 1][MAX_BLOCK + 1];//Y,X, => BLOCK//SYLEE130221JOYTECH  //son220823_3 Def_MaxPiece1-> MAX_BLOCK+1
                            //son   nDisBlock1[0][1]=SysInfoBlock.m_nRow;
                            //son   nDisBlock1[0][2]=SysInfoBlock.m_nCol;

short nDisPiece1[MAX_PIECE + 1][MAX_PIECE + 1];//Y,X, => BLOCK //SYLEE120901//SYLEE130221JOYTECH    //son220823_3
                            //son   nDisPiece1[0][1]=SysInfoPiece.m_nRow;
                            //son   nDisPiece1[0][2]=SysInfoPiece.m_nCol;

short nDisCell1[MAX_BLOCK + 1][MAX_BLOCK + 1][2];//Y,X, [BLOCK,PIECE]//SYLEE120901//SYLEE130221JOYTECH  //son220823_3 Def_MaxPiece1-> MAX_BLOCK+1
                     //nDisCell1[TotPieceRow][TotPieceCol][0]=nDisBlock1[blockRow][blockCol];// [1,1],[2,1]      block No
                     //nDisCell1[TotPieceRow][TotPieceCol][1]=nDisPiece1[pieceRow][pieceCol];// [1,1~3] [2,1~3]  piece No
                     //
            //son  [CellRow],[CellCol] : 화면에 표시할 cell의 x, y 정보
            // ex) nDisCell1[][][]      BlockCol 3, blockRow 2, pieceCol 2, pieceRow 3 인 경우  
            //             Col=1    Col=2   Col=3   Col=4   Col=5   Col=6
            // posRow=1     1-1      1-2     2-1     2-2     3-1    3-2
            // posRow=2     1-3      1-4     2-3     2-4     3-3    3-4
            // posRow=3     1-5      1-6     2-5     2-6     3-5    3-6
            // posRow=4     4-1      4-2     5-1     5-2     6-1    6-2
            // posRow=5     4-3      4-4     5-2     5-3     6-3    5-4
            // posRow=6     4-5      4-6     5-4     5-5     6-5    6-6                  


int OpenErrC, nOpenErrFlag[DEF_MAX_PIECE1];  //OPENPIN->SHORTCHECK  //son220823_6 
 short nOpenErrData[DEF_MAX_PIECE1][MAX_ERR_COUNT][OP_TO_NUM];   //memory         //son210712  5000 -> MAX_ERR_COUNT, 3->OP_TO_NUM   //son220823_6
   
    //son   nOpenErrData[piece][0][1]    : 해당 piece의 open error Count  (pieceOpenErrCnt)
    //son   nOpenErrData[piece][pieceOpenErrCount][0:OP_TO_FIRST_PIN]   : Apin (대표핀) 
    //son   nOpenErrData[piece][pieceOpenErrCount][1:OP_TO_TEST_PIN]    : Bpin (테스트핀)

//son nOpenErrData[piece][err][]를 조사해서 같은 대표핀의 err를 찾기 쉽도록 nOpenErrList[대표핀][]으로 정리한다. 
//    nOpenErrData는 같은 대표핀이 모여있으므로 nOpenErrList는 시작과 끝 위치만 표시함
//    ** Short Test에서 OPen 에러를 참고하기 위한 용도 **
short nOpenErrList[Def_SwitchMaxPin][OPERR_NUM];  //SYLEE130109-1  nSwitchMaxPin    //son210712 3-> OPERR_NUM
        //son   nOpenErrList[대표핀][0:OPERR_START]=nk;         // g_waOpenErrData에서의  start 위치
        //son   nOpenErrList[대표핀][1:OPERR_END]=nk;           // g_waOpenErrData에서의  end   위치


//ex)  nOpenErrList[대표핀]에서 nOpenErrData[]를 참조해서 open err를 표현한다.
//nOpenErrData[piece: 1]  piece err     First    Test 
//                           1     1        0        1
//                           1     2        0        6
//                           1     3        0       42
//                           1     4        8        9
//                           1     5        8     8200
//                           1     6        8     8201
//
//nOpenErrList[   0] =    1   3  //대표핀 0의 err는 err1부터 err3까지 : err1(0,1), err2(0,6), err3(0,42)
//nOpenErrList[   8] =    4   6  //대표핀 8의 err는 err4부터 err6까지 : err1(8,9), err2(8,8200), err3(8,8201)


int  nSTI_Adc1, nSTI_Adc1Raw;  //estimation
int nSelfTestHWError1;
short nVBC[DEF_MAX_PIN1];
int* pVBC;

// int nHVCalFlag1,nHVCalFlag1Co1;//sylee20120812
int nDualNetSig1, nStepI, nCellNo, nDualFlag;
int nMulNetFlag;//sylee20120831     //son DUT 번호: 1 ~ 32

CModeSub71  Sub71;

short nProType;//sylee130915
//son240502 int nDioCo1[20];
int nAutoProcess1, nAutoContinueFail, nAutoContinueFail2w, nAutoContinueFail4w;
int nCC;    //son 1:__CC,  2:__CV  
int nVRel, nIR;
short nOpShortLt1[DEF_MAX_PIECE1][3000][2];//piece,list , pin //sylee121117-shortlist   //son220823_6

double nVSet, dProT1;
double IADClog1[DEF_MAX_PIECE1][100];//sylee20120812    //son220823_6

extern float ng4WSet[DEF_MAX_PIECE1][MAX_4W_NET +1][NUM_4W_GRID_COL]; // piece, pin list  
                            //SYLEE131022//#4WIRE#    //4WCODE_131118   //son220823_6   //son231107 10001 -> MAX_4W_NET +1
                            //son211022 15 -> NUM_4W_GRID_COL로 수정  4W jigTest 잘 안되는 문제관련

//son  net이  PASS이면  2으로 표시
short ng4WResult[MAX_4W_NET +1];//sylee131022  //4WCODE_131118 //son 2: 이전 test에서 pass,  3: fail  //son231107
                        //son index는 4wNet 번호. 값이 2이면 해당 4WNet은 양품이다. 
                        //    n4W_Pass1이 1일때 이 값을 2로 설정함.  mode 171~175중에 하나라도 양품체크가 되면 이 값이 2가된다.



//son  net이  fail이면  3으로 표시
short ng4WResult_2[MAX_4W_NET +1];//sylee131022  //4WCODE_160528-5   mohm detect  //son231107

//son231108 short ng4WResult_3[MAX_4W_NET +1];//sylee200604 //son 현재 미사용	//son231107 Def_4WMax1 -> MAX_4W_NET +1 

short n4WSort1[MAX_4W_NET +1];//sylee191122-1//sylee200515  //son231107

extern CFileSysInfo  FileSysInfo01;
extern CSysInfoSer13  SysInfoSer13;
extern CFileSysInfo    FileSysInfo01;
extern CSysInfoView01  SysInfoView01;

extern CSysInfoPieceRange  SysInfoPieceRange;
extern CSysInfoBlock  SysInfoBlock;
extern CSysInfo05  SysInfo05;
extern CSysInfo19  SysInfo19;
extern CSysInfo20  SysInfo20;
extern CSysInfoPiece  SysInfoPiece;
extern CSysInfo05  RunInfo05;
extern CSysSet13  SysSet13;  //SETUP  
extern CSysSet15  SysSet15;  //SETUP    //sylee121115 
extern CSysSet16  SysSet16;  //SETUP    //sylee121115    //estimation
extern CSysSet19  SysSet19;  //SETUP    //sylee150407    //estimation
extern CSysSet21  SysSet21;  //SETUP    //sylee130618
extern CSysSet22  SysSet22;  //SETUP    //sylee130618
extern int fileCopy(const char* src, const char* dst);

//son 4W 창의 Grid에 출력될 내용. 
extern double dR14w[15][MAX_4W_NET +1];//sylee170803  110->15   //son231107 dSet4WTot1 ->  MAX_4W_NET +1
extern double dVB14w[15][MAX_4W_NET +1];//sylee170803  110->15  //son231107 dSet4WTot1 ->  MAX_4W_NET +1
extern double dVC14w[15][MAX_4W_NET +1];//sylee170803  110->15  //son231107 dSet4WTot1 ->  MAX_4W_NET +1
extern double dI14w[15][MAX_4W_NET +1];//sylee170803  110->15   //son231107 dSet4WTot1 ->  MAX_4W_NET +1

extern int dRec4w[15][11];
extern int dRec4w1[15][11]; //  from "C:\\ACE500\\SETUP\\SysSet21_4W.ini"
//////////////////////////////////////////////////////////////
// recipe 상속

_int64   tStart11, tStart12; //sylee20120120
extern CSysInfoSer13  SysInfoSer13;
int nProcessFlag1;//SYLEE20111225       //son AProcess101()이 수행중인지 표시하는 Flag

//son220824_2 begin: DefDutMax(33) -> MAX_DUT1(33)
extern int nBDLHead1[MAX_DUT1][5][20];
extern short nBDLData2[MAX_DUT1][DEF_MAX_PIN1][10];//open data 
extern short nBDLData3[MAX_DUT1][DEF_MAX_PIN1][10];//short data   
//son220824_2 end


//Def_MaxPiece 21->201
//son 이전 first open test에서 pass 여부
short nBDLData2Op_Old[DEF_MAX_PIECE1][DEF_MAX_PIN1];//[5];    //sylee160211-1   //sylee160308-1  //sylee160527  //son220823_6

//son first open test에서 pass여부 저장.   (0: 검사안함 또는 open,  1: Pass)
short nBDLData2Op_Cur[DEF_MAX_PIECE1][DEF_MAX_PIN1];//[5];    //sylee160211-1   //sylee160308-1  //sylee160527  //son220823_6

short nBDLData2Op_Po[DEF_MAX_PIN1]; //sylee160211-1   //sylee160308-1  //sylee160527
short nBDLData2Op_Po_old[DEF_MAX_PIN1]; //sylee160801-3  

//======================================================
int nSelf1_Use, nSelf1_SetStartPin, nSelf1_SetEndPin, nSelf1_SetDelay, nSelf1_SetCount;
int nSelf1_RunEnable;//sylee190105
int nSelf1_RunPin1, nSelf1_RunErr1, nSelf1_RunSetSum1;
int OnSelfTr1_Flag_Step1, OnSelfTr1_Flag_Run1;//sylee181117
int OnSelfTr1_Stop1;//sylee190103-1
__int64  tStart201, tStart202, tStart203;//sylee181117

extern short nBDLData3P[DEF_MAX_PIN1][10];//short data  
extern short nBDLData31P[Def_MaxPiece3][DEF_MAX_PIN2];
extern void ReadFileB(int nDUT);
extern int PinDataLine;
extern int PinDataS1[DEF_MAX_PIN1][2];
extern int PinDataS2[DEF_MAX_PIN1][5];
extern int nPinDa1H[MAX_DUT1][5][20];//SYLEE180810-1-DUT16 //son220824_2 begin: DefDutMax(33) -> MAX_DUT1(33)
extern int nPinOp1[DEF_MAX_PIN1][10];
extern int nPinSh1[DEF_MAX_PIN1][10];
extern double nCalC[30][10][100];

//son190704-4WDUT16: gd4W1[][][]를 g_s4WNet[] 구조체로 변경. g_s4WNet[]는 Globals.cpp 로 이동
//float gd4W1[MAX_4W_NET +1][15];//SYLEE20120116  //4W NETLIST;   //sylee200515    //son210223: 미사용이므로 삭제

extern int g_nPinPieceNo[MAX_DUT1][DEF_MAX_PIN1];//SYLEE180810-1-DUT1 //son220824_2 begin: DefDutMax(33) -> MAX_DUT1(33)
extern int nBlockPieceYX1[MAX_BLOCK + 1][MAX_PIECE + 1];// BLOCK, PIECE //son220823_3 301->MAX_BLOCK+1, MAX_PIECE+1 
extern int nBlockPieceNo1[MAX_BLOCK + 1][MAX_PIECE + 1];// BLOCK, PIECE //son220823_3 301->MAX_BLOCK+1, MAX_PIECE+1 
int nShortCo1[DEF_MAX_BLOCK1][DEF_MAX_PIECE1];// BLOCK, PIECE//sylee201224   //son220823_6
int nShortCo1Spark[DEF_MAX_BLOCK1][DEF_MAX_PIECE1];// BLOCK, PIECE//sylee201224  //son220823_6

extern void DoEvents();
extern int  ReadFile1();
extern void OnRsModeAuto(int a);
extern void OnRsModeRange(int a, int b);  //MODE Range(0~10)
extern double OnRsMeas1(int a, int nMode2);  //measure?  //nMode2=1 R,    2= C
extern BOOL OpenRS(int nInt);
extern BOOL CloseRS(int nInt);
extern BOOL ReadRS(int nPort);
extern BOOL WriteRS(int nPort, char* cStr);
extern void ReadPinPieceNo(int nDUT);//sylee180810-1-DUT16

int nConFail[DEF_MAX_PIN1][5];  //son231107 ConFail 관련 dSetPieceTot1 ->  DEF_MAX_PIN1
                            //son nConFail[i][1] = (int)nFailL1[i][F_VB_PIN]; 
                            //son nConFail[i][2] = (int)nFailL1[i][F_VC_PIN];
                            //son nConFail[i][3] = 1;//발생 횟수

int nConFailold[DEF_MAX_PIN1][5]; 
int nConFailOpen[DEF_MAX_PIN1][5];  //sylee140516 //son231107 dSetPieceTot1 ->  DEF_MAX_PIN1  
                            //son nConFailOpen[i][1] = (int)nFailL1Open[i][F_VB_PIN];
                            //son nConFailOpen[i][2] = (int)nFailL1Open[i][F_VC_PIN]; 
                            //son nConFailOpen[i][3] = 1;//발생 횟수
                            
                                        //son231107 dSetPieceTot1 ->  DEF_MAX_PIN1 
int nConFailoldOpen[DEF_MAX_PIN1][5]; //sylee140516    //son231107 dSetPieceTot1 ->  DEF_MAX_PIN1

int nConFail4w[MAX_4W_NET +1][7];     //son231107 dSet4WTot1 ->  MAX_4W_NET +1
int nConFailold4w[MAX_4W_NET +1][7];  //son231107 dSet4WTot1 ->  MAX_4W_NET +1

//son 현재 검사에서 사용되는 검사 설정을 저장 
double nProStep1[10][20];   // testType  1:TEST_OPEN, 2:TEST_U_SHORT, 3:TEST_SHORT, 4:TEST_HR_SHORT, 
                            //           5:TEST_LEAK1, 6:TEST_LEAK2, 7:TEST_4W
                            //son   nProStep1[testType][1] : real R. ohm
                            //son   nProStep1[testType][2] : Raw  R. ADC 
                            //son   nProStep1[testType][3] : 해당 검사의 Recipe m_nMode 값, Test mode 

double nRecipe[10][20], nProStep2[10][20];

long  nEt_StepSum, nEt_LogCount;  //estimation

short nEtLog[401][11][1001];//step,count,time  //estimation  //sylee130317//sylee130408  //SYLEE150610- 310->1001
float nEtLogTime[401][11][1001];//step,count,time   //estimation  //sylee130317  //sylee130408   //SYLEE150610- 310->1001
 
int nuShortEnableRun; //sylee20120304  
int n4WEnableRun; //sylee20120304  //son231020 n4WEnableRun->nRecipe_4W_Use 로 통일 //son240817 n4WEnableRun 원상복구 
int nRecipe_4W_Use;//sylee230523 //son231020 Recipe step 중에 4W 가 있다고 표시 
int nVbSet[10];//sylee20120306
int nOpenRetryFlag1, nOpenMoreThanFlag, n4wMoreThanFlag;//sylee160617-1
int PinData[DEF_MAX_PIN1][10];   //file reading
int PinDataP1[DEF_MAX_PIN1][10];  //piece sort
int PinDataP2[300][3]; // piece header
int PinDS1[DEF_MAX_PIN1][5];
int nPcb1[5000][2]; //PCB NO , PIN NO
int PinDS1R1[DEF_MAX_PIN1];

//son 검사 종류별 불량수 저장
int nFailCount[TEST_MAX];//sylee20111212    //son TEST_TYPE(1:open 2:ushort 3:short 4:hr 5:leak1 6:leak2   7:4w)    
                            //son231109 15 -> TEST_MAX

//son Cell별 Fail Count
//int nFailCountP2[6001][15];//sylee210311 2000->6001   //[50]=cell  //sylee130416 
int nFailCountP2[MAX_CELL +1][TEST_MAX];//sylee210311 2000->6001 //son231107  //son240510 10000: MAX_CELL
               //두번째 index enum TEST_TYPE (1:open 2:ushort 3:short 4:hr 5:leak1 6:leak2  7:4w,  11: open+4w,  12: allShort)  


//son Short 측정결과 상세 data 저장
int nFailL1Co;      //son 현재 테스트 수행중인 Block의 Short 불량 전체 개수. 
double nFailL1[DEF_MAX_PIN1][F_FAIL_ITEM_NUM];  //[10]=1,2= pinno,  //son220920 20: F_FAIL_ITEM_NUM
                            //son  1:                 : nMode1(1=o, 2=us, 3=short, 4=hr, 5=hv, 6=4W)
                            //     2:F_BLOCK          : block No
                            //     3:F_PIECE          : piece No
                            //     4:F_VB_PIN         : Pin Vb
                            //     5:F_VC_PIN         : Pin Vc
                            //     6:F_RAW_R          : 측정값 ADC raw R  
                            //     7:F_PRORV_REAL_R   : nProRv1Real // nProRv1 판정 real R
                            //     8:F_PRO_STEP_REAL_R: nProStep1[nMode1][1] real R
                            //     9:F_VSET           : nVSet 
                            //    10:F_ISET           : nISet
                            //    11:F_MODE1          : m_nMode1 (dRec 배열의 해당 Mode)
                            //    12:F_VB             : Sub71.V1  // VB
                            //    13:F_VC             : Sub71.X1  // VC
                            //    14:F_I              : Sub71.Y1  // I 
                            //    15:F_REAL_R         : Sub71.R1  // 측정값 real R 
                            //    16:F_TEST_TYPE      : nMod1    // TEST_TYPE(1:open 2:ushort 3:short 4:hr 5:hv   7:4w)
                            //    17:F_PRORV_RAW_R    : nProRv1 // nProRv1 판정 ADC raw R

double nISetVal1;

//son Open 측정 결과 상세 data 저장  : SaveOpenErrorData(nPieceNo, nPinA, nPinB) 참조
//                                     ** m_list1에 출력할 Open 불량 내용을 저장한다.

int nFailL1CoOpen;  //son 현재 테스트 수행중인 Block의 Open 불량  전체 개수
                    //  nFailL1Open[nFailL1CoOpen] 상세 데이터와 세트이다.
                    //  g_n4WFailCount와 함께 RETEST의 기준 값이 된다. 
                    //  이 값이  0보다 크면  nDioS2=DOUT_CMD_RETEST를 장비로 보내고 장비가 다시 TEST 요청.
double nFailL1Open[DEF_MAX_PIN1][F_FAIL_ITEM_NUM];  //[10]=1,2= pinno, //sylee120921    //son220920 20: F_FAIL_ITEM_NUM
                            //son  1:                 : Open 불량 수량  //nFailL1Open[nFailL1CoOpen][1]=nFailL1CoOpen   
                            //     2:F_BLOCK          : block No
                            //     3:F_PIECE          : piece No
                            //     4:F_VB_PIN         : Pin Vb
                            //     5:F_VC_PIN         : Pin Vc
                            //     6:F_RAW_R          : 측정값 ADC raw R // No-Cal
                            //     7:F_PRORV_REAL_R   : nProRv1Real // nProRv1 판정 real R  : nProStep1[nb1][1]
                            //     8:F_PRO_STEP_REAL_R: nProStep1[nMode1][1]      //해당 testType의 Cal 적용 real R 값 
                            //     9:F_VSET           : nVSet 
                            //    10:F_ISET           : nISet
                            //    11:F_MODE1          : m_nMode1 (dRec 배열의 해당 Mode)
                            //    12:F_VB             : Sub71.V1  // VB
                            //    13:F_VC             : Sub71.X1  // VC
                            //    14:F_I              : Sub71.Y1  // I 
                            //    15:F_REAL_R         : Sub71.R1  // 측정값  real R  
                            //    16:F_TEST_TYPE      : nMod1   // TEST_TYPE(1:open 2:ushort 3:short 4:hr 5:hv   7:4w)
                            //    17:F_PRORV_RAW_R    : nProRv1 // nProRv1 판정 ADC Raw R : nProStep1[nb1][2]   

int nRunStop2, nRunProc1;
int AProStart1, AProStart2, nAutoClear1, nDioOff1, nDioOff1c, nBDLk;
long lm_nCon;
int nMCon1, nMCon2, nMCon3, nMCon4, nStop, nProRv1Real, nRsModeC1, nRsModeR1O, nRsModeR1S;
int Disp1, nSetCC;
int g_nPieceMax1;   //son nPieceMax1-> g_nPieceMax1

__int64 tStart, tStart1, tStart2, tStart3, tEnd, tElip;
int g_n4WFailCount; //son220920  n4WFailCount -> g_n4WFailCount
int nBlockMax1;

#define _4W_FAIL_ITEM_NUM       30      //son221114
#define F_4W_NET_SPECIAL        25      //son221114

//son 4w Fail 만 모아놓은 리스트
//double n4WFail1[Def_4WMax1][25];//sylee210112  20->25     //son index 1부터 사용
double n4WFail1[MAX_4W_NET +1][_4W_FAIL_ITEM_NUM];  //son221114 30:_4W_FAIL_ITEM_NUM 
                                                    //son231107 MAX_4W_NET-> MAX_4W_NET+1 10000개 처리 오류 수정
            //son        n4WFail1[g_n4WFailCount][0]=g_n4WFailCount;
            //son        n4WFail1[g_n4WFailCount][1]=(int)g_s4WNet[dutIdx].saData[net-1].waPin[0];  //PIN1
            //son        n4WFail1[g_n4WFailCount][2]=(int)g_s4WNet[dutIdx].saData[net-1].waPin[1];  //PIN2
            //son        n4WFail1[g_n4WFailCount][3]=(int)g_s4WNet[dutIdx].saData[net-1].waPin[2];  //PIN3
            //son        n4WFail1[g_n4WFailCount][4]=(int)g_s4WNet[dutIdx].saData[net-1].waPin[3];  //PIN4
            //son        n4WFail1[g_n4WFailCount][5]=g_s4WNet[dutIdx].saData[net-1].dRefLow;  //set LOW        //son211005
            //son        n4WFail1[g_n4WFailCount][6]=g_s4WNet[dutIdx].saData[net-1].dRefAvg;  //SET AVE
            //son        n4WFail1[g_n4WFailCount][7]=g_s4WNet[dutIdx].saData[net-1].dRefHigh; //SET HIGH   //son211005
            //
            //son        n4WFail1[g_n4WFailCount][8]=dR14w[6][net] ;  //FAIL R   
            //son        n4WFail1[g_n4WFailCount][9]=dVB14w[6][net];  //  VB
            //son        n4WFail1[g_n4WFailCount][10]=dVC14w[6][net];  //  VC
            //son        n4WFail1[g_n4WFailCount][11]=dI14w[6][net];  //  I
            //son        n4WFail1[g_n4WFailCount][12]=m_nMode1;  //  MODE  SET
            //son        n4WFail1[g_n4WFailCount][13]=  (dR14w[6][net] /g_s4WNet[dutIdx].saData[net-1].dRefHigh) * 100. ; //RefHigh대 측정값비율 
            //son        n4WFail1[g_n4WFailCount][14]=t1;////PIECE  no   //sylee20120314
            //son        n4WFail1[g_n4WFailCount][15]=net;  // net no
            //son        n4WFail1[g_n4WFailCount][16]=2;  // range down   1:RangeIn, 2:RangeDown,  3:RangeUp
            //son        n4WFail1[g_n4WFailCount][17]=nBlockCountP;  // block no
            //son        n4WFail1[g_n4WFailCount][18]=1;  //son RefHigh대 측정값 비율로 정렬 완료 표시
            //son        n4WFail1[g_n4WFailCount][19]=2;  //contact fail
            //son        n4WFail1[g_n4WFailCount][20]=1;  //son pin contact fail
            //son        n4WFail1[g_n4WFailCount][21]=1;  //son pin1 fail
            //son        n4WFail1[g_n4WFailCount][22]=1;  //son pin2 fail
            //son        n4WFail1[g_n4WFailCount][23]=1;  //son pin3 fail
            //son        n4WFail1[g_n4WFailCount][24]=1;  //son pin4 fail
            //son        n4WFail1[g_n4WFailCount][25:F_4W_NET_SPECIAL]=1;  //son221114  4W 특수넷 표시. g_s4WNet[dutIdx].saData[net-1].bNetSpecial

//double n4WFail2T[Def_4WMax1][25];//temp//sylee160605-1    //son index 1부터 사용
double n4WFail2T[MAX_4W_NET +1][_4W_FAIL_ITEM_NUM]; //son221114 25 -> _4W_FAIL_ITEM_NUM(30)
                                                    //son231107 MAX_4W_NET-> MAX_4W_NET+1 10000개 처리시 오류 수정

DWORD LoadWAV(HWND hWnd, LPCTSTR lpszWave);

//son Block-Piece Grid Graph 출력용 이전 테스트 결과 (CChildView7::GraphDisplayBlock() 참고)
short nBlockRes[MAX_CELL +1];   //son240510 6001 -> MAX_BLOCK_PIECE1 -> 'MAX_CELL +1'
                            //   enum BLOCK_RES_TYPE을 value로 사용가능 
                            //    1:BLOCK_RES_PASS,    2:BLOCK_RES_OPEN,     3:BLOCK_RES_SHORT, 4: BLOCK_RES_O_S, 
                            //    5:BLOCK_RES_NO_TEST, 7:BLOCK_RES_RUN_FAIL, 8:BLOCK_RES_4W  
                            //    9:BLOCK_RES_PIECE_DISABLE,  10: BLOCK_RES_SPARK
//short nBlockRes[6001];//SYLEE130222JOYTECH      
                            //son 1:pass 2:open    3:SHORT  4:OPEN+SHORT  
                            //    5:test 7:RunFail 8:4W O,  9:PieceDisable   10:SPARK


//PIECE, Recipe step별  Open 불량 error count   //SYLEE160731-3  IMPORT
//son OpenTest에서 현재 Recipe(Open) Step의 ErrCount가 SysInfo05.m_nConEr Range를 넘었는지 확인할 때 사용한다.
//    핀설정단계까지는 새로 해서 테스트한 Retry1까지의 Fail 개수 (timeDelay retry는 포함하지 않음.)
int nFailPiece[MAX_PIECE + 1][50];//  [200] piece   [10] Recipe step   //sylee130416    //son210730 MAX_PIECE

int nShCal1[10][30][20];//R,piece, step //sylee20120717

//stop  //sylee20120714,sajangnim120714 
short nOpenSu1[DEF_MAX_PIN2];//sylee20120714    //sylee150917-2  16400  33000
short nOpenFail1[DEF_MAX_PIECE1];//sylee20120921//100=piecemax   //son Piece별 Open 불량 개수.  //son220823_6
                                                                //    nFailL1CoOpen를 piece별로 나누어 놓은 것.

short nShortFail1[DEF_MAX_PIECE1];//sylee20120921//100=piecemax //son220823_6
short nOpenFail14W[DEF_MAX_PIECE1];//sylee131022//100=piecemax   //4WCODE_131118    //son220823_6

//son 4W 테스트 결과 Grid Graph 출력용 변수
short nOpenFail14WBlock[DEF_MAX_PIECE1][DEF_MAX_PIECE1];//sylee131022//100=piecemax    //4WCODE_131118  //son220823_6

short nShortFail1Flag1;//sylee20120921//100=piecemax

int nProOneP_ModelCount1;//sylee130916

int nProOneP_Flag1;//sylee130916  //son 0: not use. model retry End.
                                  //son 1: model retry start (BDL 파일 처음 load)
                                  //son 2: model make (BDL file 정상여부 체크중. Short가 없어)   
                                  //son 3: run  etc  disable (Short가 있어)
                                  //son 4: ????
                            
int nProOneP_RunFlag1;      //son 1: ???  //son piece 1개로 통검사를 위한 flag??

int nProOneP_ModelCheck1;//sylee131018
int nProOneP_ModelCheck1Retry;//sylee131018

short nProOneP_ShortPin[301][1000];  //SYLEE161212   51->101
short nProOneP_Short1_Li[5001][2];
short nProOneP_Short1[5001];//process
short nProOneP_Open1[5001][2];
int nProOneP_Short1_Co, nProOneP_Open1_Co;

int nOpen_PassCo2;
int nProcessFail1;  //son 1이면 GraphDisplayBlock()을 무조건 O+S로 표시, nDioS2도 O+S로 응답.
int nShortRetestFlag1;//sylee170618-1

//HOLD170414 short nFlag_VsetRun1;//sylee170412-1

struct CgRun05  //SETUP Recipe
{
    int m_nShortDisable1; //sylee180331-1 
    int m_nCon; int m_nConU;    int m_nConIs;   int m_nConIsU;    int m_nMs;    int m_nHv;
    int m_nSp;  //son 0: Spark Disable  1: Spark Enable  (Recipe > Spark Enable  combo박스 )
    int m_nPr;  int m_nConEr;   int m_nIsEr;    int m_nConErSt; int m_nReCh;
    int m_nConFail;     int m_nHR;  int m_nHRL;     int m_nDelay1;  int m_nShortR;  int m_nShortRU;
    int m_nShortR2;     int m_nShortR2U;    int m_nOpenV;   int m_nShort1V;     int m_nShort2V;     int m_nHRV;
    int m_nCC[7];   int m_nStep[10];    int m_nMode1;  int m_nOpenErrorLimit;   int m_nOpenShortLimit;
    int m_nPer3;    int m_nPer4;    int m_nPer5;    int m_n4WErrPerLimit;       int m_nProSpMode;
    int m_n4WSet1;  int m_nHVCal1;  int m_nCycle;   int m_nUniversal;   int m_nS4;
    int m_nSparkSet_B; //son Recipe > Spark I (1~15) edit박스 설정값 
    int m_nS6;  int m_nS7;    int m_nS8;    int m_nS9;
    int m_nSparkSet;//sylee140923  //son Recipe > Spark-V(2~250V) edit박스 설정값
    int m_nHv2; //sylee140923
    int m_nHv2R; //sylee140923
    int m_nHv2RU; //sylee140923

};


struct CgRun20  //SETUP ErrCount
{
    int m_nUse;
    int m_nPass;
    int m_nOpen;
    int m_nShort;
    int m_nOpenShort;
    int m_nFail;
    int m_nTotle;
};

CgRun05  gRun05;
CgRun20  gRun20; //son BigLabel 출력을 위한 gRun20  
CgRun20  gRun21;

extern byte g_bComiDOutVal;  //son240430 직전에  메인장비로 보낸 Output 값을 확인하기 위해 bDOUT 값을 보관

extern int dRecSetup[80][11]; //SYLEE130618 
__int64   tStart5001, tStart5002, tStart5003; //sylee150509-1debug
short nSelfOpenPin[DEF_MAX_PIECE1];//sylee141020    //son220823_6
short nSelfOpenPinCount;
//void CalibrationLS1_Func();//sylee140708     //son220419_5 미사용으로 삭제 

int nBlockMaxLast1;//sylee170417-1      //son 최대 가용 블록 개수


int nPinToPiece(int nPin)//SYLEE171225-2        //son190704-4WDUT16
{
    int nPieceNo;

    int dutId = getDutId();                 //son190704-4WDUT16
    nPieceNo = g_nPinPieceNo[dutId][nPin];  //SYLEE180810-1-DUT16   //son190704-4WDUT16

    if (nPieceNo < 0) {
        nPieceNo = 0;
    }

    if (nPieceNo >= DEF_MAX_PIECE1) //son220823_6
    {
         
            nPieceNo = DEF_MAX_PIECE1 - 1;//sylee180905-1  //son220823_6 
        
    }

    return nPieceNo;
}



int n4W_IDropCheck1(int nNet);//sylee180823-1 //sylee180912-1

int n4W_IDropCheck1(int nNet)//sylee180823-1 //sylee180912-1
{

    if (nFlag_ADICheck1 == 1) {//sylee180823-1
        if (nFlag_ADIRet1 > 0 && nFlag_ADIRet1 <= 2) {//sylee180917-1
            Sub71.OnPinAllReset1(); ///PIN ALL RESET               
            return -1;
        }
    }
    nFlag_ADIRet1 = 0;//sylee180823-1
    return 1;
}


int n4W_Percent_Check1(int nNet)//sylee190116-1
{

    if (SysSet19.m_nSet10 <= 0) {//sylee190116-1
        return 1;
    }

    if (nFlag_ADIRet1 > 0 && nFlag_ADIRet1 <= 2) {//sylee180917-1
        Sub71.OnPinAllReset1(); ///PIN ALL RESET               
        return -1;
    }

    return 1;
}



void nDebugFileLog1()
{
 

}


CString LoadMessage(UINT uFileType, CString strFile, UINT uNum)//sylee151028-1
{
    CString KeyName, strData, fName, strbuf;


    if (uFileType == 1) {
        fName = "\\Message_CHI.ini";
    }
    else {
        fName = "\\Message_CHI.ini";
    }

    //fName = "C:\\ACE500\\Data" + fName; //son201118
    strData = SysInfoView01.m_pStrFilePath1;    //son210514
    fName = strData + "\\Data" + fName; //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1

    CIniFile iniFile(fName);
    KeyName.Format("%d", uNum);
    strbuf = iniFile.ReadString(strFile, KeyName, "Not defined Message");

    return strbuf;
}




CString LoadMessage2(UINT uFileType, CString strFile, UINT uNum)//sylee180731-1
{
    CString KeyName, strData, fName, strbuf;
    fName = "\\Message_L.ini";

    //fName = "C:\\ACE500\\Data" + fName; //son201118
    strData = SysInfoView01.m_pStrFilePath1;    //son210514
    fName = strData + "\\Data" + fName; //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1

    CIniFile iniFile(fName);
    KeyName.Format("%d", uNum);
    strbuf = iniFile.ReadString(strFile, KeyName, "Not defined Message");

    return strbuf;
}



#if 0 //son220419_5 미사용으로 삭제 
int CalibrationLS1(int mode, double  dRealStart, double  dRealEnd)//sylee140106    
{
    int  nRealStartPos, nRealEndPos;
    int  nRlistEnd, nCount, nTmpos1;

    double  dTmp1, dA, dA1, dA2, dB, dB1, dB2;
    double  dSumX, dSumY, dSumXX, dSumXY, dSumYX, dSumYY;
    //----------------------------------------------------------
    double** dCalTable1 = new double* [8];//sylee140729
    for (int i = 0; i < 8; i++) {
        dCalTable1[i] = new double[MAX_CAL_RLIST + 10];    //son220408 200-> MAX_CAL_RLIST+10
    }
    //----------------------------------------------------------
    //    ::ZeroMemory(&dCalTable1, sizeof(dCalTable1));
    //----------------------------------------------------------
    //read set  
    nRlistEnd = MAX_CAL_RLIST;   //son220408 MAX_CAL_RLIST:128
    //----------------------------------------------------------
    nRealStartPos = 1;
    int RList;
    for (RList = 1; RList <= nRlistEnd; RList++)
    {
        dTmp1 = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_REF_R][RList];     //son220407
        if (dTmp1 > dRealStart) {
            nRealStartPos = RList - 1;
            if (nRealStartPos < 1) {
                nRealStartPos = 1;
            }
            break;
        }
        if (nRealStartPos > 1) {
            for (RList = nRealStartPos; RList >= 1; RList--) {
                dTmp1 = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_USE][RList]; //son220407
                if (dTmp1 == 1) {
                    nRealStartPos = RList;
                }
                else {
                    if (RList == 1) {
                        nRealStartPos = 1;
                    }
                }
            }
        }
    }
    //----------------------------------------------------------
    nRealEndPos = 1;
    for (RList = 1; RList <= nRlistEnd; RList++) {
        dTmp1 = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_REF_R][RList];     //son220407
        if (dTmp1 >= dRealEnd) {
            nRealEndPos = RList;
            if (nRealEndPos < 1) {
                nRealEndPos = 1;
            }
            break;
        }
        if (nRealEndPos > 1) {
            for (RList = nRealEndPos; RList >= 1; RList--) {
                dTmp1 = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_USE][RList];       //son220407
                if (dTmp1 == 1) {
                    nRealEndPos = RList;
                }
                else {
                    if (RList == 1) {
                        nRealEndPos = 1;
                    }
                }
            }
        }
    }
    //----------------------------------------------------------
    nTmpos1 = 0;
    for (RList = nRealStartPos; RList <= nRealEndPos; RList++) {
        dTmp1 = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_USE][RList];       //son220407
        if (dTmp1 == 1) {
            nTmpos1++;
            dCalTable1[1][nTmpos1] = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_REF_R][RList];//real R        //son220407
            dCalTable1[2][nTmpos1] = SysInfoSer13.m_nData[PART_UPPER][mode][CAL_REF_RAWR][RList];//RAW R      //son220407
        }
    }
    dCalTable1[0][0] = nTmpos1;
    nCount = nTmpos1;
    //----------------------------------------------------------
    dSumX = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumX = dSumX + dCalTable1[2][i];
    }
    //----------------------------------------------------------
    dSumY = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumY = dSumY + dCalTable1[1][i];
    }
    //----------------------------------------------------------
    dSumXX = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumXX = dSumXX + dCalTable1[2][i] * dCalTable1[2][i];
    }
    //----------------------------------------------------------
    dSumXY = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumXY = dSumXY + dCalTable1[2][i] * dCalTable1[1][i];
    }
    //----------------------------------------------------------
    dSumYX = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumYX = dSumYX + dCalTable1[1][i] * dCalTable1[2][i];
    }
    //----------------------------------------------------------
    dSumYY = 0.0;
    for (i = 1; i <= nCount; i++) {
        dSumYY = dSumYY + dCalTable1[1][i] * dCalTable1[1][i];
    }
    //----------------------------------------------------------
    dA1 = (nCount * dSumXY) - (dSumX * dSumY);
    dA2 = (dSumXX * nCount) - (dSumX * dSumX);
    dA = dA1 / dA2;
    dB1 = (-dSumX * dSumXY) + (dSumXX * dSumY);
    dB2 = dA2;
    dB = dB1 / dB2;
    //----------------------------------------------------------
    if (mode >= 171 && mode <= 177) {
        dCalA1[mode - 170][1] = dA;
        dCalA1[mode - 170][2] = dB;
    }
    //----------------------------------------------------------        
    //sylee140825 for( i=0; i<5; i++){

    for (i = 0; i < 8; i++) {  //sylee140825 메모리 증가 문제  수정.
        delete[] dCalTable1[i];
    }
    delete[] dCalTable1;


    return 1;
}
#endif

#if 0 //son220419_5 미사용으로 삭제 
void CalibrationLS1_Func()
{

    double a, b;

    a = dRec4w1[1][2];    //son 171 Min R
    b = dRec4w1[1][3];    //son 171 Max R
    CalibrationLS1(171, a, b);//sylee140707 bntech mode 1

    a = dRec4w1[2][2];    //son 172 Min R
    b = dRec4w1[2][3];    //son 172 Max R
    CalibrationLS1(172, a, b);//sylee140106 mode 2

    a = dRec4w1[3][2];    //son 173 Min R
    b = dRec4w1[3][3];    //son 173 Max R
    CalibrationLS1(173, a, b);//sylee140106  mode 3

    a = dRec4w1[4][2];    //son 174 Min R
    b = dRec4w1[4][3];    //son 174 Max R
    CalibrationLS1(174, a, b);//sylee140201  mode 4   4W  

    a = dRec4w1[5][2];    //son 175 Min R
    b = dRec4w1[5][3];    //son 175 Max R
    CalibrationLS1(175, a, b);//sylee140708   4w mode5

    a = dRec4w1[6][2];    //son 176 Min R
    b = dRec4w1[6][3];    //son 176 Max R
    CalibrationLS1(176, a, b);//sylee140201  mode 4   4W  

    a = dRec4w1[7][2];    //son 177 Min R
    b = dRec4w1[7][3];    //son 177 Max R
    CalibrationLS1(177, a, b);//sylee140708   4w mode5
    ::ZeroMemory(&dRec4w2, sizeof(dRec4w2));//sylee140714

    double dA, dB;  //4WSETUP

    for (int i = 1; i <= 7; i++) {
        for (int j = 2; j <= 3; j++) {
            dA = dCalA1[i][1];
            dB = dCalA1[i][2];
            dRec4w2[i][j] = (int)(dRec4w[i][j] / dA - dB);
            if (dRec4w2[i][j] < 0) {
                dRec4w2[i][j] = 0;
            }
        }
    }
    return;
}
#endif
 

void Sound201() {


    
}


/////////////////////////////////////////////////////////////////////////////
// CChildView7

IMPLEMENT_DYNCREATE(CChildView7, CFormView)

CChildView7::CChildView7()
    : CFormView(CChildView7::IDD)
{

    AProStart1 = 0;
    AProStart2 = 0;
    SWStart1 = 1;


}

CChildView7::~CChildView7()
{


    nAutoProcess1 = 0;

    if (SWStart1 == 1) {
        SWStart1 = 2;
        Sub71.AOnPoweroff2();//sylee20120702          Sub71.AOnPoweroff();
    }

}




void CChildView7::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChildView7)
        // NOTE: the ClassWizard will add DDX and DDV calls here

    DDX_Control(pDX, IDC_COMIDAQCTRL1, g_ComiDaq2);     /*//son201028*/
    DDX_Control(pDX, IDC_LABEL1, m_Label1);
    DDX_Control(pDX, IDC_LABEL2, m_Label2);
    DDX_Control(pDX, IDC_LABEL3, m_Label3);
    DDX_Control(pDX, IDC_LABEL4, m_Label4);
    DDX_Control(pDX, IDC_LABEL5, m_Label5);
    DDX_Control(pDX, IDC_LABEL6, m_Label6);
    DDX_Control(pDX, IDC_LABEL7, m_Label7);
    DDX_Control(pDX, IDC_LABEL8, m_Label8);
    DDX_Control(pDX, IDC_LABEL9, m_Label9);
    DDX_Control(pDX, IDC_LABEL10, m_Label10);
    DDX_Control(pDX, IDC_LABEL12, m_Label12);
    DDX_Control(pDX, IDC_LABEL17, m_Label17);
    DDX_Control(pDX, IDC_LABEL18, m_Label18);
    DDX_Control(pDX, IDC_LABEL20, m_Label20);
    DDX_Control(pDX, IDC_LABEL21, m_Label21);
    DDX_Control(pDX, IDC_LABEL23, m_Label23);
    DDX_Control(pDX, IDC_LABEL27, m_Label27);
    DDX_Control(pDX, IDC_LABEL29, m_Label29);
    DDX_Control(pDX, IDC_LABEL32, m_Label32);

    DDX_Control(pDX, IDC_LABEL101, m_Label101);    /*son Status 출력 */
    DDX_Control(pDX, IDC_LABEL102, m_Label102);    /*son block, step 상태 출력 */
    DDX_Control(pDX, IDC_LABEL112, m_Label112);    /*son Recipe 관련 출력. */
    DDX_Control(pDX, IDC_LABEL115, m_Label115);
    DDX_Control(pDX, IDC_LABEL501, m_Label501);

    DDX_Control(pDX, IDC_LABEL301, m_Label301);
    DDX_Control(pDX, IDC_LABEL701, m_Label701);
    DDX_Control(pDX, IDC_LABEL702, m_Label702);
    DDX_Control(pDX, IDC_LABEL703, m_Label703);
    DDX_Control(pDX, IDC_LABEL704, m_Label704);

    DDX_Control(pDX, IDC_LABEL131, m_Label131);
    DDX_Control(pDX, IDC_LABEL132, m_Label132);
    DDX_Control(pDX, IDC_LABEL133, m_Label133);
    DDX_Control(pDX, IDC_LABEL134, m_Label134);
    DDX_Control(pDX, IDC_LABEL135, m_Label135);
    DDX_Control(pDX, IDC_LABEL136, m_Label136);

#ifndef __AUTO_COUNT_DISPLAY_DISABLE__ //son220401    //sylee230125
    DDX_Control(pDX, IDC_LABEL201, m_Label201);
    DDX_Control(pDX, IDC_LABEL202, m_Label202);
    DDX_Control(pDX, IDC_LABEL203, m_Label203);
    DDX_Control(pDX, IDC_LABEL204, m_Label204);
    DDX_Control(pDX, IDC_LABEL205, m_Label205);
    DDX_Control(pDX, IDC_LABEL206, m_Label206);


    DDX_Control(pDX, IDC_LABEL302, m_Label302);
    DDX_Control(pDX, IDC_LABEL303, m_Label303);
    DDX_Control(pDX, IDC_LABEL304, m_Label304);
    DDX_Control(pDX, IDC_LABEL305, m_Label305);
    DDX_Control(pDX, IDC_LABEL306, m_Label306);
#endif  //son220401

    DDX_Control(pDX, IDC_LABEL601, m_Label601);
    DDX_Control(pDX, IDC_LABEL602, m_Label602);
    DDX_Control(pDX, IDC_LABEL603, m_Label603);
    DDX_Control(pDX, IDC_LABEL604, m_Label604);

    DDX_Control(pDX, IDC_LABEL700, m_Label700);

    DDX_Control(pDX, IDC_LABEL1003, m_Label1003);
    DDX_Control(pDX, IDC_LABEL1004, m_Label1004);
    DDX_Control(pDX, IDC_LABEL1015, m_Label1015);
    DDX_Control(pDX, IDC_LABEL1031, m_Label1031);
    DDX_Control(pDX, IDC_LABEL1032, m_Label1032);
    DDX_Control(pDX, IDC_LIST1, m_list1);
    //son Error, Finish 등 주요 정보 출력.

    DDX_Control(pDX, IDC_BUTTON2002, m_button1);
    DDX_Control(pDX, IDC_BUTTON2001, m_button2001);
    DDX_Control(pDX, IDC_BUTTON2003, m_button2003);

#ifndef __AUTO_COUNT_DISPLAY_DISABLE__ //son220401   //sylee230125
    DDX_Control(pDX, IDC_LABEL_1, m_Label2001);
#endif //son220401
    DDX_Control(pDX, IDC_LABEL_1007, m_Label2002);
    DDX_Control(pDX, IDC_LABEL_1008, m_Label2003);
    DDX_Control(pDX, IDC_LABEL_1009, m_Label2004);
    DDX_Control(pDX, IDC_LABEL_1005, m_Label2005);

    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChildView7, CFormView)
    //{{AFX_MSG_MAP(CChildView7)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_CREATE()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildView7 diagnostics

#ifdef _DEBUG
void CChildView7::AssertValid() const
{
    CFormView::AssertValid();
}

void CChildView7::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}
#endif //_DEBUG



__int64 CChildView7::GetMicroSecond()  //sylee
{
    LARGE_INTEGER frequency;
    LARGE_INTEGER now;

    if (!QueryPerformanceFrequency(&frequency))
        return (__int64)GetTickCount();

    if (!QueryPerformanceCounter(&now))
        return (__int64)GetTickCount();

    return((((__int64)now.QuadPart) * ((__int64)1000000)) / ((__int64)frequency.QuadPart));
}


__int64 CChildView7::GetuSecond()  //sylee
{
    LARGE_INTEGER frequency;
    LARGE_INTEGER now;

    if (!QueryPerformanceFrequency(&frequency))
        return (__int64)GetTickCount();

    if (!QueryPerformanceCounter(&now))
        return (__int64)GetTickCount();

    return((((__int64)now.QuadPart) * ((__int64)1000000)) / ((__int64)frequency.QuadPart));
}

__int64 CChildView7::Get_uSecond1()  //sylee130107  //estimation
{
    LARGE_INTEGER frequency;
    LARGE_INTEGER now;
    double temp1;


    if (!QueryPerformanceFrequency(&frequency))
        return (__int64)GetTickCount();

    if (!QueryPerformanceCounter(&now))
        return (__int64)GetTickCount();

    temp1 = (((double)now.QuadPart) * (1000000.)) / ((double)frequency.QuadPart);

    if (temp1 < 0) {
        AfxMessageBox(" Error No 1004. Get_uSecond1 <0 ?.", MB_OK);
    }

    return((__int64)temp1);
}



/////////////////////////////////////////////////////////////////////////////
// CChildView7 message handlers
BOOL CChildView7::OnEraseBkgnd(CDC* pDC)
{

    //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1) {//SYLEE20111225
        DrawGradation(pDC, RGB(221, 236, 255), RGB(86, 125, 204));
    }
    return TRUE;
    //  return CDialog::OnEraseBkgnd(pDC);
}

void CChildView7::DrawGradation(CDC* pDC, COLORREF rgbBegin, COLORREF rgbEnd)
{
    CRect Rect;

    //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1) {//SYLEE20111225

        GetClientRect(&Rect);

        COLORREF rgbReturn = 0;

        int byRBegin = GetRValue(rgbBegin);
        int byGBegin = GetGValue(rgbBegin);
        int byBBegin = GetBValue(rgbBegin);

        int byR = GetRValue(rgbBegin);
        int byG = GetGValue(rgbBegin);
        int byB = GetBValue(rgbBegin);

        int byR_diff = 0;
        int byG_diff = 0;
        int byB_diff = 0;

        byR_diff = byRBegin - GetRValue(rgbEnd);
        byG_diff = byGBegin - GetGValue(rgbEnd);
        byB_diff = byBBegin - GetBValue(rgbEnd);

        CPen* pNewPen = NULL;
        CPen* pOldPen = NULL;

        int byOffset = 0;
        int nPercent = 0;

        for (int i = 0; i < Rect.bottom; ++i)
        {

            pNewPen = new CPen(PS_SOLID, 1, RGB(byR, byG, byB));
            rgbReturn = RGB(byR, byG, byB);
            pOldPen = pDC->SelectObject(pNewPen);

            pDC->MoveTo(0, i);
            pDC->LineTo(Rect.right, i);

            nPercent = i * 100 / Rect.bottom;

            byOffset = byR_diff * nPercent / 100;
            byR = byRBegin - byOffset;
            byOffset = byG_diff * nPercent / 100;
            byG = byGBegin - byOffset;
            byOffset = byB_diff * nPercent / 100;
            byB = byBBegin - byOffset;

            pDC->SelectObject(pOldPen);
            delete pNewPen;

        }

    }
}



BOOL PlayResource(LPSTR lpName)
{
    //    BOOL bRtn;
    LPSTR lpRes;
    HANDLE hRes;
    HRSRC hResInfo;
    HINSTANCE Nl = AfxGetInstanceHandle();

    /* Find the WAVE resource. */
    hResInfo = FindResource(Nl, lpName, "WAVE");
    if (hResInfo == NULL)
        return FALSE;
    /* Load the WAVE resource. */

    hRes = LoadResource(Nl, hResInfo);
    if (hRes == NULL)
        return FALSE;

    /* Lock the WAVE resource and play it. */
    lpRes = (LPSTR)LockResource(hRes);
    if (lpRes == NULL)
        return FALSE;
 
    FreeResource(hRes);
    return TRUE;
}

 


//son 화면을 다시 그려야 할 때 호출됨. (WM_PAINT 수신시 호출)
//    화면이 가려지거나, UpdateWindow 함수와 InvalidateRect 함수 호출시 발생함.
void CChildView7::OnPaint()
{
    // int i;

       //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1)//SYLEE20111225
    {

        CPaintDC dc(this); // device context for painting
        CString str;


        //g_nInitFlag2=1;//SYLEE20120118????????????
        //son MainFrm에서 SwitchView(VIEW_ID7)를 통해서 들어온 경우
        if (g_nInitFlag1 == 7 && g_nInitFlag2 == 1)  //init 
        {

            ::ZeroMemory(&nOpenSu1, sizeof(nOpenSu1));//sylee20120714  PARKPONGKU CJ;
            ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20120921//100=piecemax
            ::ZeroMemory(&nShortFail1, sizeof(nShortFail1));////sylee20120921//100=piecemax
            ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee130122//100=piecemax
            ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee130122//100=piecemax 
            ::ZeroMemory(&nShortFail1Flag1, sizeof(nShortFail1Flag1));////sylee20120921//100=piecemax           
            ::ZeroMemory(&nConFailoldOpen, sizeof(nConFailoldOpen));//sylee140516   
            ::ZeroMemory(&nConFailold, sizeof(nConFailold));
            ::ZeroMemory(&nShortCo1, sizeof(nShortCo1));//sylee201224
            ::ZeroMemory(&nShortCo1Spark, sizeof(nShortCo1Spark));//sylee201224

            nAutoProcess1 = 1;
            nReSheetFlag1 = 0;
            //for (int dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++)     //son210715 Multi DUT 추가
            //    sprintf(g_LastD_Log4w_ResheetfName[dutIdx], ""); //son210420 추가   //son210715
            sprintf(g_LastD_Log4w_ResheetfName, ""); //son220624_3 

            g_nInitFlag2 = 2;
            nRunProc1 = 0;
            ReadFileB(1);//sylee20111103

            //son201216 ComiDaq 디바이스를 ChildView1과 공유하기 위한 ComiDaq 초기화 함수 추가.
            Init_ComiDaqDevice();
            MyTrace(PRT_BASIC, "ChildView7-> Init_ComiDaqDevice() Called. \n");


            //  DIO.m_pBoard[0] = &g_ComiDaq2;

            g_nInitFlag2 = 0;
            A_OnInit();

            nDisplayRef1 = 3;

            SetTimer(VIEW7_TIMER_VIEW_INIT, 100, NULL);  //son 100ms         SetTimer(10 for VIEW INIT 
#ifdef _PC_TEST_
            //son200827  timer가 너무 많이 쌓여서 디버그시에 오동작하는 걸 막기위해 
            //           _PC_TEST_ 옵션사용시에만 Timer 길이를 조정한다. 
            SetTimer(VIEW7_TIMER_DIO, 2000, NULL); //son 2sec          SetTimer(70 for DIO
#else
            //son 실제 계측기 동작코드
            //son240718 SetTimer(VIEW7_TIMER_DIO, 10, NULL);   //son 10ms          SetTimer(70 for DIO
            SetTimer(VIEW7_TIMER_DIO, 20, NULL);   //son240718 10 ms -> 50 ms  //son240808 50 -> 20 msec
#endif      
            SetTimer(VIEW7_TIMER_SCREEN_REFRESH, 3000, NULL); //sylee130117 //son SetTimer(50 for screen Refresh (3sec)

         //sylee210317-1    FileSysInfo01.LoadSaveSub17(2); //4w.ini load  //sylee160518

            Comi_DoPutByte(DOUT_CMD_ALL_OFF);  //son231016 //son240430
            MyTrace(PRT_LEVEL3, "Line_%d OnPaint(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son211215 //son220318


        }

    }//     if( nProcessFlag1 !=1)//SYLEE20111225

}


//son201216 ComiDaq 디바이스를 ChildView1과 공유하기 위한 ComiDaq 초기화 함수 추가.
//          ChildView1에서 Init_ComiDaqDevice()를 먼저 호출할 수도 있다.
void CChildView7::Init_ComiDaqDevice()

{
    static bool bFlag_ComdaqInit;



    //son 프로그램 수행과정에서 1회만 수행하게 하기 위해 static 로컬 변수 flag를 사용한다.
    if (bFlag_ComdaqInit == false)
    {
        //  m_ComiDaq1.SetDeviceId(COMI_SD414);
        g_ComiDaq2.SetDeviceId(COMI_SD424);
        g_ComiDaq2.SetDevInstance(0);

        //  if (m_ComiDaq1.GnDeviceLoad() == cmFALSE) {
        if (g_ComiDaq2.GnDeviceLoad() == 0) {
            AfxMessageBox("  Communication Error 2 !, \n  Comizoa  Digital Card   Loading Fail !!");
        }

        bFlag_ComdaqInit = true;
        MyTrace(PRT_BASIC, "Init_ComiDaqDevice() Called. bFlag_ComdaqInit=%d \n", bFlag_ComdaqInit);
    }

    //son210115 메인핸들러 소통 드라이브 In/Out path를 로딩한다.
    //
    //   SysInfoView01.m_pStrFileDrive1 초기화 없이 STEPPATH.TXT access시에 down 문제보완을 
    //   위해  A_OnInit()에서 호출하던 FileSysInfo01.LoadFileDrive1()을 Init_ComiDaqDevice() 으로 이동함.
    //   LoadSaveBlockInfo(_LOAD)보다 먼저 LoadFileDrive1()이 호출되어야 한다.
    //   ChildView1, ChildView7에서 공통으로 사용되고 가장 먼저 초기화되므로 이쪽 위치가 더 적절하다.
    FileSysInfo01.LoadFileDrive1();//sylee201201-1      

}


BOOL CChildView7::PreTranslateMessage(MSG* pMsg)
{
    // TODO: Add your specialized code here and/or call the base class
    CString str;
    int x, y;

    //son AProcess101()이 수행중이 아니고 
    if ((nProcessFlag1 != 1) && (nAutoProcess1 == 1))//SYLEE20111225 //sylee20120202
    {

        if (nDisplayRef1 == 3)//DEMO
        {
            nDisplayRef1 = 1; //DEMO
            if (nBlockCountP <= 0) {
                nBlockCountP = 0;
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH
                m_list1.ResetContent();
            }
        }


        if (nDisplayRef1 == 1)//DEMO
        {
            nDisplayRef1 = 2; //DEMO//sylee130416

            nOpen_PassCo2 = 0;//sylee170327

            //son Block-Piece Grid를 다시 그린다.
            for (x = 1; x <= nCellMax; x++) {  //test  display
                y = nBlockRes[x];
                GraphDisplayBlock(x, y);//display-no1            

                if (y == 2 || y == 8) {
                    nOpen_PassCo2++;//sylee170327
                }
            }
        }

        if (nSW_StartFlag == 1) { //SYLEE130312JOYTECH
            nSW_StartFlag = 2; //SYLEE130312JOYTECH
            SetFocus();//sylee130312joytech
        }

        /////////////////////////////////////////////////////////////////////////
        //CYCLE RUN
        if (nCycleRunFlag == 2 && nCycleRunStatus == 0)// cycle run 
        {
            //son Cycle RUN 이 On 이면 엔터키가 입력된 것처럼 message를 조작한다.
            if (SysSet17.m_nSet1 > nCycleRunCount) {
                nCycleRunCount++;//cycle//sylee130805
                nCycleRunStatus = 1;//cycle//sylee130805 
                pMsg->message = WM_KEYDOWN;  
                pMsg->wParam = VK_RETURN;

                str.Format("  ***>Cycle Run Set=%d, Count=%d ", SysSet17.m_nSet1, nCycleRunCount);
                m_list1.AddString(str);
                nlist1++;
            }
            else {
                nCycleRunFlag = 0;
                //  str.Format("  ***>Cycle Completed " );           
                str.Format("  ***>Jig Test  Completed ");
                m_list1.AddString(str);
                nlist1++;
            }
        }

        ///////////////////////////////////////////////////////////////////

        //son 엔터키 입력시 처리
        if ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_RETURN))
        {
            // hdpark230105 spark begin, spark test
            if ((GetKeyState(VK_CONTROL) & 0x8000) && (GetKeyState(VK_SHIFT) & 0x8000))
            {
				Sub71.m_bSparkCal = TRUE;
                SysSet13.m_nSet16 = 0; // Skip LV Short in Leak Test 
                Sub71.m_bSparkVerification = TRUE;
            }
            else
            {
				Sub71.m_bSparkCal = FALSE;
                SysSet13.m_nSet16 = 1;
                Sub71.m_bSparkVerification = FALSE;
            }
            // hdpark230105 spark end

            if (nProcessStatus1 != 1)//sylee170114
            {
                if (SysInfo05.m_nCycle > 0) {   //sylee20120818
                    DoEvents();
                    Sleep(500);     //son 500 msec
                    DoEvents();
                }
#ifdef _PC_TEST_
                nManualStartFlag = 0;//sylee130306joytch
                nKeyStartFlag = 0;//sylee130306joytch
//son240103     gRun05.m_nReCh = 0;

                //son221103_3 _PC_TEST_ 일때에는 Block-Piece MAP을 다시 그리지 않도록 한다.
                //          이전 nBlockRes[] 상태를 유지함.

#else
                nManualStartFlag = 1;//sylee130306joytch
                nKeyStartFlag = 1;//sylee130306joytch

                //                   AfxMessageBox("  test333  ? nKeyStartFlag=1 ", MB_OK);
                nReSheetFlag1 = 0;//sylee140304  //sylee140402patch
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE140402
                ::ZeroMemory(&nReSheetRes, sizeof(nReSheetRes));//sylee141027-interlock  //resheet

                ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));//sylee180521-1
                ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee180521-1
                ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee180521-1
                ::ZeroMemory(&nShortCo1, sizeof(nShortCo1));//sylee201224
                ::ZeroMemory(&nShortCo1Spark, sizeof(nShortCo1Spark));//sylee201224
                nAutoReTest[nBlockCountP] = 0;//sylee180521-1

                //son Block-Piece Grid를 다시 그린다.
                int y;
                for (int x = 1; x <= nCellMax; x++) {  //test  display
                    y = nBlockRes[x];
                    GraphDisplayBlock(x, y);//display-no1            
                }
                m_list1.ResetContent();//sylee20120825  choi dl req.
                nlist1 = 0;

                nFlagAutoPress1 = 0;//sylee150413

                //son Block 정보를 업데이트한다.
                DisplayBlock_Map1();  //sylee180502-1

#endif //son221103_3 _PC_TEST_ 일때에는 Block-Piece 맵을 다시 그리지 않도록 한다.

                MyTrace(PRT_LEVEL1, "\n\n\n         <==== RECV ENTER KEY DOWN\n");    //son211018 for debug
                OnStart1();     //son 엔터키 입력시 Auto Test 진행 
                //SYLEE150817 nMulNetFlag=1; 
                return TRUE;

            }// if( nProcessStatus1!=1){//sylee170114

        }   //end of        if ((pMsg->message == WM_KEYDOWN)&& (pMsg->wParam == VK_RETURN)) {

    } //    if( nProcessFlag1 !=1){//SYLEE20111225


    return CFormView::PreTranslateMessage(pMsg);
}


//son Auto Test 진행 
//son  OnStart1()-> SetTimer(20, ..) -> OnTimer() case 20: -> AProcess100()이 수행됨.
void CChildView7::OnStart1()
{
    int i;
    CString str;
 

    if (nSelfTestHWError1 != 0) {//sylee141030
        PowerCheckError1();// auto run중에 switch box check 하지 말라  141117
        if (nSelfTestHWError1 > 0) {
            //AfxMessageBox("  \n\n ERROR 7101 계측기의 전원이 꺼져서  테스트를 진행 할수 없습니다.\n\n  셀프테스트 화면에서 진단해서 문제를 해결 해주십시요  ");
            return;
        }
    }
    nSystemErrorFlag = 0;

    if ((nRunProc1 == 0) && (nAutoProcess1 == 1))   //local start
    {

        nRunProc1 = 1;

        if (OnRecipeErrorCheckFlag == 1) {
            OnRecipeErrorCheck();//sylee140127
        }
        if (nBlockMax == 1 || nCellMax == 1)
        {
            nDisplayRef1 = 10; //DEMO
            //sylee170622-2 if(  SysInfo05.m_nDual==2 ){ //sylee20120720                        
            //sylee170622-2 }else{  
            if (nBlockMax == 1)//sylee20120711
            {
                if (nCellMax > 0)
                {
                    //son Block-Piece Grid를 다시 그린다.
                    for (i = 1; i <= nCellMax; i++)
                    {
                        //__LINE_PRT__
                        if (nAutoReTest[nBlockCountP] != 0) {
                            if (GraphDisplay1[i] == 0) {//sylee121129
                                GraphDisplayBlock(i, 0);    //son Grid 0으로 초기화
                            }
                        }
                        else {
                            GraphDisplayBlock(i, 0);    //son Grid 0으로 초기화
                        }
                    }
                    UpdateData(FALSE);
                }
            }
            //sylee170622-2 }            
        }

        //son nBlockCountP 값을 증가
        Increase_nBlockCountP();//sylee20120630     //son220624 OnInitRunP1() -> Increase_nBlockCountP()

        //son 4W CSV 출력할 때 해당 block의 dutIdx가 무엇인지를 확인하기 위해 저장해 둔다.
        int dutIdx = get4wDutIdx();
        g_d4W_Log1_nBlockDutInfo[nBlockCountP] = dutIdx;    //son201209: 4W Log CSV 파일 가로누적  관련 추가
                                                            // ARun201_4w_3()에서도  이 코드를 수행하는데 4W CSV 누적파일 생성을  
                                                            // PC 테스트할 때는 거기까지 수행이 안 돼서 여기에도 추가함

        str.Format("Block=%d, Starting", nBlockCountP);         //son STATUS 값 설정
        Label101_Status_SetCaption(str); //son240712
        //son240714 MyTrace(PRT_LEVEL2, "Line_%d OnStart1(): DUT_%d, %s\n", __LINE__, dutIdx + 1, str.GetBuffer(100));   //son200821   //son210722

        str.Format("%d", nMulNetFlag);//sylee180810-1-dut16
        m_Label8.SetCaption(str);//sylee180810-1-dut16          //son DUT 값 설정
        str.Format("                                      ");
        Label102_Cycle_SetCaption(str, false); //son240712 

        int c, c2, c3;
        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) {//sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) {//sylee180810-1-dut16 //son220824_2 
            c = nPinDa1H[nMulNetFlag][2][0];
            c2 = nPinDa1H[nMulNetFlag][2][1];
            c3 = nPinDa1H[nMulNetFlag][2][2];
        }
        else {
            c = nPinDa1H[1][2][0];
            c2 = nPinDa1H[1][2][1];
            c3 = nPinDa1H[1][2][2];
            //sylee150920 str.Format("%d", PinData[0][2]);//sylee150920
        }
        str.Format("%d", c);  //sylee180810-1-dut16     
        m_Label6.SetCaption(str);  //           //son TPin 값 설정
        str.Format("%d", c2);//sylee180810-1-dut16  
        m_Label18.SetCaption(str);          //son HPPin 값 설정
        str.Format("%d", c3);//sylee180810-1-dut16 
        m_Label20.SetCaption(str);          //son LPin 값 설정


        //son  OnStart1()-> SetTimer(20, ..) -> OnTimer() case 20: -> AProcess100()이 수행됨.
        SetTimer(VIEW7_TIMER_PROCESS, 10, NULL);  //son 10ms    //son SetTimer(20, 
    }

}



void CChildView7::OnTimer(UINT nIDEvent)
{

    int x, y;
    CString str;
    int nRet;//sylee151016

    if (SysSet211.m_nSet14 == 1) {//sylee160928
        if (nBuzzer1 == 2) {
            Beep(311, 200);
            Sleep(10);
            Beep(392, 300);
            nBuzzer1 = 0;
        }
        else if (nBuzzer1 == 1) {
            Beep(494, 500);
            nBuzzer1 = 0;
        }
    }

    //son AProcess101()이 수행중이 아니고
    if ((nProcessFlag1 != 1) && (nAutoProcess1 == 1))//SYLEE20111225
    {

        switch (nIDEvent)
        {

            case VIEW7_TIMER_VIEW_INIT: //son case 10: //VIEW INIT  100ms   
            {
                KillTimer(VIEW7_TIMER_VIEW_INIT);   //son KillTimer(10): 일회성 Timer로 사용하기 위해 Kill

                nSW_StartFlag = 1; //SYLEE130312JOYTECH

                if (nBlockCountP <= 0) {
                    nBlockCountP = 0;
                    ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH 
                    MyTrace(PRT_LEVEL1, "Line_%d OnTimer(): Recv VIEW7_TIMER_VIEW_INIT! nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n\n",
                            __LINE__, nBlockMax, nBlockMaxLast1, nBlockCountP);

                }

                nlist1 = 0;
                tStart = 0;
                tEnd = 0;
                tElip = 0;

                if (nDioOff1 == 2) {
                    nDioOff1c++;
                    if (nDioOff1c > 30) {
                        nDioOff1c = 0;
                        nDioOff1 = 0;
                        Comi_DoPutByte(DOUT_CMD_ALL_OFF); //son 장비로 초기화 요청 //son231016 //son240430
                        MyTrace(PRT_LEVEL1, "Line_%d OnTimer() TIMER_VIEW_INIT: Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n",
                                __LINE__); //son211215  
                    }
                }
                else {
                    nDioOff1c = 0;
                }
            }
                break;


            //son 엔터키입력시 또는  OnStart1()-> AutoTest 검사 수행 루틴
            case VIEW7_TIMER_PROCESS: //son case 20:  //Process   
            {
                KillTimer(VIEW7_TIMER_PROCESS);     //son KillTimer(20): 일회성 Timer로 사용하기 위해 Kill
                Comi_DoPutByte(DOUT_CMD_ALL_OFF);   //son 장비로 초기화 요청    //son231016  //son240430
                MyTrace(PRT_LEVEL3, "Line_%d OnTimer() TIMER_PROCESS: Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n",
                        __LINE__); //son211215  //son220318


                if (g_nSelfTestInterlock != 1)//sylee131121
                {
                    nBlockCountP--;
                    str.Format(" Error.  SelfTest Check! ");
                    Label101_Status_SetCaption(str); //son240712
                    MyTrace(PRT_LEVEL1, "Line_%d OnTimer() TIMER_PROCESS: %s : nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                            __LINE__, str.GetBuffer(100), nBlockMax, nBlockMaxLast1, nBlockCountP);

                    //sylee150529mes        AfxMessageBox(" ERORR 5001,     꼭!  셀프테스트를   정상 진행하십시요 ! \n\n      STOP으로   진행 할수 있으나 측정에 문제 될수 있습니다. ");    
                    AfxMessageBox(" ERROR 5001,     Selftest Check!!        ");
                    //break;
                }

                //son Self Test가 완료되었다면
                else//SYLEE131121
                {
                    int c1, c2, c3;//sylee150920

                    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1)  //son220824_2
                    {
                        c1 = nPinDa1H[nMulNetFlag][2][0];
                        c2 = nPinDa1H[nMulNetFlag][2][1];
                        c3 = nPinDa1H[nMulNetFlag][2][2];
                    }
                    else {
                        c1 = nPinDa1H[1][2][0];
                        c2 = nPinDa1H[1][2][1];
                        c3 = nPinDa1H[1][2][2];
                        //sylee150920 str.Format("%d", PinData[0][2]);//sylee150920
                    }

                    DisplayRes1_BigLabel(TEST_DIS_RUN);//DEMO   //son220824
                    DoEvents();

                    int nA, nB, nC, nD;//sylee140324

                    //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
                    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1)   //son220824_2 
                    {
                        nA = nBDLHead1[nMulNetFlag][3][1];
                        nB = nBDLData2[nMulNetFlag][0][1];
                        nC = nBDLData3[nMulNetFlag][0][1];
                    }
                    else {//sylee151016  dut1  //sylee150924
                        nA = nBDLHead1[1][3][1];
                        nB = nBDLData2[1][0][1];
                        nC = nBDLData3[1][0][1];
                    }
                    nD = nB + nC;

                    //son BDL Error가 있다면
                    if (nA != nD)//sylee140324  interlock 
                    {

                        str.Format("*  BDL Error ! [setup][piece point]piece range?");
                        Label101_Status_SetCaption(str); //son240712
                        m_list1.AddString(str);
                        nlist1++;
                        str.Format("* => Dut=%d  Error", nMulNetFlag);//sylee151016                           
                        m_list1.AddString(str);//sylee151016
                        nlist1++;//sylee151016
                        DisplayRes1_BigLabel(TEST_DIS_ERROR);   //son220824
                        DoEvents();

                        nBlockCountP = 0;
                        str.Format("BDL  Loading Fail !      \n\n   Manager Call !       \n\n ");
                        errMessageBox(7000, str);   //son230912
                        MyTrace(PRT_LEVEL2, "Line_%d OnTimer() TIMER_PROCESS: %s nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                                __LINE__, str.GetBuffer(100), nBlockMax, nBlockMaxLast1, nBlockCountP);

                    }

                    //son BDL Error가 없다면
                    else//sylee140324
                    {

                        nRet = AInterStart1();//sylee151016

                        //son PieceRangeSetCheck를 수행한 결과에 이상이 없다면
                        if (nRet == 1)//sylee151016
                        {
                            //son-32KPIN-20200212: nReSheetFlag1 값 추적을 위해 추가
                            str.Format("%d", nReSheetFlag1);
                            m_Label17.SetCaption(str);
                            UpdateData(FALSE);

                            //-------------------
                            //son Auto Test 진행
                            //-------------------
                            nProcessStatus1 = 1;//sylee150506
                            AProcess100();    //SYLEE20111212
                            nProcessStatus1 = 0;//sylee150506

                        }
                        else
                        {
                            nBlockCountP = 0;//sylee151016
                            // KillTimer(VIEW7_TIMER_PROCESS);
                            nRunProc1 = 0;        //sylee151016  

                            DisplayRes1_BigLabel(TEST_DIS_FAIL);//sylee151016   //son220824
                            //  nlist1 =0;//sylee151016
                            str.Format(" * Error  ");  //sylee151016
                            m_list1.AddString(str); //sylee151016
                            str.Format(" * 1)=>[setup] [piece point] pin range check!");  //sylee151016
                            m_list1.AddString(str); //sylee151016                            
                            str.Format(" * 2) => BDL  FILE Check?  ");  //sylee151016
                            m_list1.AddString(str); //sylee151016
                            str.Format(" * Error : BDL FILE Check!   pin range check!");  //sylee151016
                            Label101_Status_SetCaption(str); //sylee151016   //son240712
                            MyTrace(PRT_LEVEL2, "Line_%d OnTimer() TIMER_PROCESS: %s nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                                    __LINE__, str.GetBuffer(100), nBlockMax, nBlockMaxLast1, nBlockCountP);

                        }

                        nAutoSelf_Jigup_Event1 = 0;//sylee140825  //sylee140916
                        if (nBlockCountP >= nBlockMax)//sylee140916
                        {
                            if (nAutoReTest[nBlockCountP] > (gRun05.m_nReCh)) {
                                nAutoSelf_Jigup_Event1 = 1;//sylee140825                      
                            }
                            else //SYLEE140903
                            {
                                if (nRetestFlag != 1) { //sylee150125patch
                                    if (nFailL1Co <= 0 && nFailL1CoOpen <= 0 && g_n4WFailCount <= 0) { //SYLEE140903 
                                        nAutoSelf_Jigup_Event1 = 1; //SYLEE140903
                                    } //SYLEE140903
                                }
                            }
                        } //sylee140916
                    }//sylee140324
                }//SYLEE131121

                nRunProc1 = 0;



                //SYLEE141202 YESTECH    
                nAutoSelf_Jigup_Event1 = 0; //ONLYSET-JOYTECH 


                //---------------------------
                //son Cycle Run Delay 
                if (nCycleRunFlag == 2)// cycle run 
                {
                    if (SysSet17.m_nSet2 > 0)  //son Cycle Delay Second
                    {
                        str.Format("  ***>Cycle Run Set=%d, Count=%d ", SysSet17.m_nSet1, nCycleRunCount);
                        m_list1.AddString(str);
                        nlist1++;

                        for (int k1 = 1; k1 <= (SysSet17.m_nSet2 * 10); k1++)
                        {
                            DoEvents();

                            //son delay를 10 이하로 설정했다면 dealy보다 더 짧게 쉰다. 왜 이런 코드??
                            if (k1 < 100) {
                                Sleep(20);  //son 20 msec 
                            }
                            else {
                                Sleep(100);  //son 0.1초 * for 문 10회하면 이 부분때문에 delay 초수 만큼 쉬게 됨.
                            }
                            if (nCycleRunFlag != 2) {
                                k1 = SysSet17.m_nSet2 * 10 + 1;
                            }

                            if (nCycleRunShort >= SysSet17.m_nSet3) {
                                str.Format("  ***>Jig Test   Short Error Set=%d, Short Error=%d ", SysSet17.m_nSet3, nCycleRunShort);
                                m_list1.AddString(str);
                                nlist1++;
                                nCycleRunFlag = 0;  //son Short가 기준 이상이면 Cycle Test를 중단시킨다.
                                str.Format("  ***>Jig Test   Stoped ");
                                m_list1.AddString(str);
                                nlist1++;
                                k1 = SysSet17.m_nSet2 * 10 + 1;
                            }

                            int x, y;

                            if ((k1 % 10) == 2)
                            {
                                //son Block-Piece Grid를 다시 그린다.
                                for (x = 1; x <= nCellMax; x++) {  //test  display
                                    y = nBlockRes[x];
                                    GraphDisplayBlock(x, y);//display-no1                    
                                }
                            }
                        }
                    }
                    nCycleRunStatus = 0;//cycle//sylee130805 
                }


                if (nAutoSelf_Jigup_Event1 == 1) { //sylee140916
                    int nSelCo;
                    nSelCo = 0;
                    for (x = 1; x <= nCellMax; x++) {
                        if (nSelfBlock[x] == 1) {//sylee140917
                            nSelCo++;
                        }
                    }
                    nAutoSelf_Jigup_Event1 = 2;
                }

                if (nAutoSelf_Jigup_Event1 == 2)
                {
                    nSelfTimeStep = 0;//sylee140917

                    //son 조건이 맞는다면  Auto Test반복을 위한 Timer 40을 구동시킨다.
                    SetTimer(VIEW7_TIMER_PRINT, 30, NULL);  //son SetTimer(40, 
                }
            }
                break;

            // Camera View 설정



            case VIEW7_TIMER_INIT: //init   //case 30:  //son 안쓰는 걸로 보임. 추후 삭제 필요
                KillTimer(VIEW7_TIMER_INIT);     //son KillTimer(30). 
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130603
                break;




            case VIEW7_TIMER_PRINT://Print  //case 40:  
                nSelfTimeStep++;//sylee140917
                Sleep(5);
                if (nSelfTimeStep > 3) {
                    if (nAutoSelf_Jigup_Event1 == 2) { //sylee140916   
                        nAutoSelf_Jigup_Event1 = 3;
                        AutoSelf_Fun1_OpenLvShort1();//sylee140825
                        nAutoSelf_Jigup_Event1 = 0;
                    }
                    KillTimer(VIEW7_TIMER_PRINT);        //son KillTimer(40)
                }
                break;


            case VIEW7_TIMER_SCREEN_REFRESH: //son case 50: screen refresh, 3Sec
            {
                //son220823_5 Cell이 많을 때 그림그리는데 오래 걸려서 타이머가 너무 많이 쌓이는 문제 개선. 
                //          동작도중에는  kill 하고 동작이 끝나면 다시 start한다.
                KillTimer(VIEW7_TIMER_SCREEN_REFRESH);

                if (nDisplayRef1 == 2 || nDisplayRef1 == 3) {//DEMO//sylee130416
                    if (nDisplayRef1 == 3) {//sylee130416
                        nDisplayRef1 = 0;
                    }
                    //__LINE_PRT__
                    //son Block-Piece Grid를 다시 그린다.
                    for (x = 1; x <= nCellMax; x++) {
                        y = nBlockRes[x];
                        GraphDisplayBlock(x, y);
                        DisplayRes1_BigLabel(Disp1);    //son220824
                    }
                }

                if (nProcessStatus1 == 0 && nErrPinClear == 1) { //sylee180510-1   //sylee180516-1
                    nErrPinClear = 0;
                    ::ZeroMemory(&nErrPin1O, sizeof(nErrPin1O));//sylee170810
                    ::ZeroMemory(&nErrPin1S, sizeof(nErrPin1S));//sylee170810
                    ::ZeroMemory(&nErrPin1S0, sizeof(nErrPin1S0));//sylee180510-1
                    m_Label115.SetCaption("  ");
                }

                //son220823_5 타이머 다시 start. 
                //if (nCellMax > 600) //son Cell이 너무 많아서 속도가 느려지는 걸 보완하기 위해 Timer주기를 2배로 늘린다. 
                //    SetTimer(VIEW7_TIMER_SCREEN_REFRESH, 6000, NULL); 
                //else
                SetTimer(VIEW7_TIMER_SCREEN_REFRESH, 3000, NULL);


            }
                break;

                //////////////////////////////////////////////////////////////////////////////////////////

            case VIEW7_TIMER_SELF_TR: //son case 60:   // Process //sylee181117  
                KillTimer(VIEW7_TIMER_SELF_TR);     //son KillTimer(60)  : 일회성으로 사용
                break;


                //////////////////////////////////////////////////////////////////////////////////////////



            case VIEW7_TIMER_DIO: //son case 70    DIO  10ms
                //son240502 OnTimer() -> case VIEW7_TIMER_DIO(70): 처리 기능을 함수로 분리.
                Process_ViewTimerDio();     //son240502
                break;



                //son-RESHEET-20200225 신규 추가
                //son timer수신시에   CSV log한다.
            case VIEW7_TIMER_4W_LOG:    //son case 80:
                KillTimer(VIEW7_TIMER_4W_LOG);     //son 일회성으로 이용하기 위해 KillTimer

                //son 4W data 결과 파일에 d4W_Log1[Block][net]를 write
                //son     ex)  D:\\log4w\\Log4W_%04d%02d%02d_%02d%02d%02d_ALL_Ok.CSV  
                if (n4WSetFlag1 == 1){ 
                    ARun201_4w_Logging2_Sheet();			 
				} 
                break;

        }


    } //    if( nProcessFlag1 !=1)//SYLEE20111225


    if (nMulNetFlag<1 || nMulNetFlag> MAX_DUT) { //SYLEE180810-1-DUT16 //son220824_2 DefDutMax2 -> MAX_DUT
        nMulNetFlag = 1;//sylee150817
    }


    CFormView::OnTimer(nIDEvent);
}


//son240502 OnTimer() -> case VIEW7_TIMER_DIO(70): 처리 기능을 함수로 분리.
void CChildView7::Process_ViewTimerDio()
{
    int nCurStates;
    int nDioAllOff;
    int i;

    if (g_nInitFlag1 != 7)      //son201028 ChildView7이 구동중일 때에만 아래 코드가 동작하도록 수정!!! 
        return;


#ifdef _PC_TEST_
    //son Debug 중 Timer가 너무 많이 쌓여서 오동작하는 일을 막기 위해  timer가 
    //    _PC_TEST_ 디버그시에는 더이상 들어오지 않게 일단 중지하고 이  timer 처리 완료 시점에 다시 시작한다.
    KillTimer(VIEW7_TIMER_DIO);
    //MyTrace(PRT_LEVEL3,"ChildView7: Recv VIEW7_TIMER_DIO\n");
#endif


    //-------------------------------------------------
    //son 장비 PC와 통신하여 필요한 값을 받아 온다.
    //-------------------------------------------------
    nDioAllOff = 0;//SYLEE130227JOYTECH
    nCurStates = g_ComiDaq2.DiGetAll();

//son231018 begin:
#ifdef __2BYTE_DIO__
    g_nCurDioCmd = nCurStates & 0x01ff;  //son231018 mask로 2byte 중 9 bit를 처리하도록 한다.  
#else
    g_nCurDioCmd = nCurStates & 0xff;  //son mask로 1byte 중 8 bit를 처리하도록 한다.  
#endif

	
    //son240722 Comi_DoPutByte(DOUT_CMD_ALL_OFF)을 즉시 보냈지만 장비에서 이전 Command를 미처 끄지 않은 상태에서
    //    계측기가 너무빨리 read해서 같은 Command를 계속 처리하는 문제 보완. 
    //    Command가 기존과 달라졌을 때에만 처리하는 기능 추가
     if (g_nCurDioCmd == g_nPrevDioCmd)  //son240722 
             goto TASK_EXIT_TIMER_DIO; //son 마무리 작업하고 return   //son240722


    if (g_nCurDioCmd != g_nPrevDioCmd)
    {
        //son231018 나노시스 요구사항. 원격 4W Ref 초기화 기능
        if (g_nCurDioCmd == DIN_CMD_4W_REF_INIT)  //son  0x100:256
        {
            MyTrace(PRT_BASIC, "ChildView7                         <======== DIN_4W_REF_INIT (0x%04x)\n", g_nCurDioCmd);     
#ifdef __NANOSYS__CUSTOMER
            FileSysInfo01.Init_4wFile_Ref_AllDut(); //son 모든 4W Ref.High와 Ref.Low 를 0으로 만든다. 
#endif
            Comi_DoPutByte(DOUT_CMD_ACK_4W_REF_INIT); //son240430
            MyTrace(PRT_LEVEL1, "LINE_%d Comi_DoPutByte(): 0x%02x  =========> ACK_4W_REF_INIT \n",    //son231018
                    __LINE__, DOUT_CMD_ACK_4W_REF_INIT); 

            KillTimer(VIEW7_TIMER_DIO); //son240718 sleep 중 timer 쌓이지 않게 stop

            //son231019 ACK를 보내고 나서 다음번 4W_REF_INIT 수신 못하는 현상 관련해서
            //son231019 1초 기다린 다음 DOUT_CMD_ALL_OFF 보내고 g_nPrevDioCmd는 0으로 초기화하기로함
            Sleep(1000);     //son231019 1000 msec
            Comi_DoPutByte(DOUT_CMD_ALL_OFF); //son240430
            MyTrace(PRT_LEVEL1, "Line_%d Comi_DoPutByte(): 0     =========> ALL_OFF\n", __LINE__);
            //son231019 g_nPrevDioCmd = g_nCurDioCmd;  
            g_nPrevDioCmd = 0;               

            AfxMessageBox("The 4W Ref Low/High value of the current BDL has been reset. \n\nPlease set 4w Ref Low/High again in the 4W Setup window and proceed to test.");

            //son 4W.ini를 로드하고  Error 여부를 체크
            Check_4WErrorNet();  //son231019_2 

#ifndef _PC_TEST_
            SetTimer(VIEW7_TIMER_DIO, 20, NULL);    //son240718  sleep 중 timer 쌓이지 않게 stop 후 다시 start  //son240808 50 -> 20 msec
#endif

            goto TASK_EXIT_TIMER_DIO; //son240502  마무리 작업하고 return 
        }

        //son231019 ABORT+SKIP+DUT1+DUT2 (0x6c:108) 수신시 ChildView7에서는 무시한다. ChildView1에서만 처리함
        if (g_nCurDioCmd == DIN_CMD_BDL_LOAD) {
            MyTrace(PRT_BASIC, " Discarded in ChildView7           <======== DIN_CMD_BDL_LOAD (0x%04x)\n", g_nCurDioCmd);  
            //g_nPrevDioCmd = g_nCurDioCmd; //son 여기서 change하면 ChildView1에서 처리 안 될수도..
            
            goto TASK_EXIT_TIMER_DIO;   //son240502  마무리 작업하고 return 
        }

    }
//son231018 end

    //son 1byte를  8byte 값으로 변환
    for (i = 0; i < DIN_NUM; i++) {         //son230914 8 -> 16:DIN_NUM
        nDio[i] = (nCurStates >> i) & 0x1;
    }



    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //son240426 ABORT 신호 받고  ACK_SKIP_ABORT(0x05: PASS+OPEN)를 장비로 보냈는데 
    //          바로 직후에 START+TEST+ABORT(0x07)이 들어와서 Comi_DoPutByte(DOUT_CMD_ALL_OFF)를 못 보내
    //          장비에 PASS+OPEN 에러가 계속 발생해 있는 문제점 수정.  
    //          다음의 4W 정밀테스트를 위한 command 전처리 코드를 Comi_DoPutByte(DOUT_CMD_ALL_OFF) 초기화
    //          판단 코드 앞으로 옮겨서  START+TEST+ABORT에 포함된 ABORT 때문에 Comi_DoPutByte(DOUT_CMD_ALL_OFF)를 
    //          포기하지 않도록 한다.

    //--------------------------------------------------
    // 4W 정밀테스트 전처리
    //
    //son TEST+ABORT    (0x06) or //4W Manual ABORT DIO	
    //son ABORT+RESHEET (0x84)    //4W Target DIO
    //--------------------------------------------------
    //son TEST+ABORT : Handler Manual창 4W 정밀테스트 요청인지를 체크해서 command 전처리   (Block Retest 필요없음) 

 
    nFlag_DIN_ABORT=0;      //son231110
    if(SysSet13.m_nSet18==1)//sylee230426-8 MANUAL START:  4W Manual ABORT DIO	
    {
        if( nDio[DIN_ABORT] == 1 )     //son231110 
        {
            nFlag_DIN_ABORT=1;      //sylee231019  

            //son231110 여기서  nDio[DIN_ABORT] =0 하면 관계없는 ABORT only command가 아예 처리가 안되거나
            //          ABORT+SKIP 조합 command가 'SKIP'으로 오동작하는 문제가 발생하므로 여기서는 삭제함.        
            //son231110 nDio[DIN_ABORT] =0; //sylee231019
            
            if (g_nCurDioCmd != g_nPrevDioCmd)  //son240119 
            {
                MyTrace(PRT_LEVEL1, "\n");
                MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== (0x%02x) ABORT signal(nFlag_DIN_ABORT=%d)\n",    //son240112 
                        nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                        nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                        nCurStates, nFlag_DIN_ABORT);    
            }
        } //son231110

        //son231110 START+ABORT+TEST+SKIP의 경우에는 아래코드 수행되지 않게 "&& nDio[DIN_START]== 0 && nDio[DIN_SKIP]" 추가
        //     1) 'START+ABORT+TEST', 'ABORT+TEST'와 'ABORT+RESHEET'에만 4W 정밀 테스트 포함한 테스트가 수행되어야 한다.
        //     2) 'START+ABORT+TEST+SKIP'이나 'ABORT+SKIP'은 4W 정밀테스트 아닌 일반 테스트가 수행된다.
        //     3) 그외의 다른 모든 Command에는 영향이 없어야 한다.
        //son240112 START+ABORT+TEST 도 처리되도록  "&& nDio[DIN_START]== 0" 삭제
        //if ((nFlag_DIN_ABORT==1 && nDio[DIN_TEST]==1 && nDio[DIN_START]==0 && nDio[DIN_SKIP]==0 ) //ABORT+TEST //sylee231018//son231110     
        if ((nFlag_DIN_ABORT==1 && nDio[DIN_TEST]==1  && nDio[DIN_SKIP]==0) //ABORT+TEST  or START+ABORT+TEST //son240112
                || (nFlag_DIN_ABORT == 1 && nDio[DIN_RESHEET] == 1              //ABORT+RESHEET //sylee23101//son231110 
                    && nDio[DIN_START]==0 && nDio[DIN_TEST] == 0 &&  nDio[DIN_SKIP] == 0 ))  //son231110 
        {
            nDio[DIN_ABORT] =0;     //son  ABORT+TEST -> TEST로 만들어서 TEST action을 수행하기 위해 ABORT를 꺼버린 것. 
            //  이런 편법보다는 TEST 부분을 함수로 만들고 해당 함수를 호출하는 방식으로 바꾸어야 한다.
            //  TEST 부분 함수로 만든다면 nFlag_DIN_ABORT도 필요 없다.
            if (g_nCurDioCmd != g_nPrevDioCmd)  //son240119 
                MyTrace(PRT_BASIC, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== DIN 4W %sABORT+%s (0x%04x) ABORT removed. nManual4WStartFlag1=%d\n",   //son231110
                        nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                        nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                        (nDio[DIN_START] == 1)? "START+" : "",
                        (nDio[DIN_TEST] == 1)? "TEST" :
                        (nDio[DIN_RESHEET] == 1)? "RESHEET" : "Undef_CodeErr!!!", nCurStates, nManual4WStartFlag1);     

            if( nManual4WStartFlag1 !=1){
                if( n4w_Sample_Enable != 1 ){  //sylee230426-8
                    nManual4WStartFlag1=1; //sylee230426-8 MANUAL START:  ABORT DIO
                    Sleep(200);  
                }      
            }                    
        }
    }
    else{
        nManual4WStartFlag1=0;					  
    }


    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    //-------------------------------------------------------------------------
    //son 이전 상태가 혹시 있다면 장비 신호 초기화를 한다.
    //     nDioAllOff=1 로 만들고  이게 1이라면  Comi_DoPutByte(DOUT_CMD_ALL_OFF) 응답
    //
    //     이렇게 복잡하게 하지 말고 이 코드는 지우고 실제 Command 처리 마지막  부분에서 
    //     1초 Timer를 설정해서 Timer수신하면  Comi_DoPutByte(DOUT_CMD_ALL_OFF) 를 직접 호출하는 코드를 넣는게 나아 보임.
    //-------------------------------------------------------------------------
    //REMOTE START EVENT

    //son240430 begin: DOUT_CMD_ACK_SKIP_ABORT (PASS+OPEN)을 보내고 장비쪽으로 초기화 안주는 문제점 보완. 
    if (g_nCurDioCmd != g_nPrevDioCmd)
    {
        //son 이전 Command 응답으로 DOUT_CMD_ACK_SKIP_ABORT 를 보낸 적이 있다면
        if (g_bComiDOutVal == DOUT_CMD_ACK_SKIP_ABORT)
        {
            nDioAllOff = 1;  //son Comi_DoPutAll(0)을 보내기 위해 1로 셋팅
            nRunOld_StartTest = D_OFF;
        }
    }
    //son240430 end.                

    //son Map > Set1 > '* 4W MANUAL -ABORT DIO'  On이면
    if(SysSet13.m_nSet18==1) {//sylee231019 
        //son ABORT+RESHEET :  Handler Target창 4W 정밀테스트 요청 (Block Retest 필요없음)
        if (nDio[DIN_START] == 0 && nDio[DIN_TEST] == 0  && nDio[DIN_ABORT] == 1  && nDio[DIN_RESHEET] == 1) { //SYLEE231019 
        }
        else 
        {
            if (nRunOld_AbortSkip != D_OFF) {    //2    //son240503
                nRunOld_AbortSkip = D_OFF;     //old state     2=off start //DEMO2  //son240503
                nDioAllOff = 1;//SYLEE130304JOYTECH
                //son       ABORT+RESHEET 이면 Test가 진행되므로 nDioAllOff = 1이 되는 것이 맞는 것으로 보임.
            }
        }

    }
//son240801    else   //sylee231019
    {
        //son ABORT+SKIP : Handler 수동 Mode에서 검사 (Block Retest 없음)
        //SYLEE150812   if( nDio[DIN_DUT1] == 1 && nDio[DIN_DUT2] == 1  ){ //SYLEE130221JOYTECH-MANUAL START ONE
        if (nDio[DIN_START]==0 && nDio[DIN_TEST] == 0
                && nDio[DIN_ABORT] == 1 && nDio[DIN_SKIP] == 1) { //SYLEE130221JOYTECH-MANUAL START ONE  //SYLEE150812
        }
        else {
            if (nRunOld_AbortSkip != D_OFF) {    //2    //son240503
                nRunOld_AbortSkip = D_OFF;     //old state     2=off start //DEMO2  //son240503
                //son 장비초기화
                nDioAllOff = 1;//SYLEE130304JOYTECH 
            }
        }
    } //sylee231019 

    //son START+TEST+ABORT+SKIP++DUT1 : Handler 수동 Mode에서 검사 (Retry없음)
    if (nDio[DIN_START] == 1 && nDio[DIN_TEST] == 1
            && nDio[DIN_ABORT] == 1 && nDio[DIN_SKIP] == 1 && nDio[DIN_DUT1] == 1) { //SYLEE150604  //autopress

    }
    else {
        if (nRunOld_AutoPress != D_OFF) { //SYLEE150604  //autopress
            nRunOld_AutoPress = D_OFF;  //SYLEE150604  //autopress
            //son 장비초기화
            nDioAllOff = 1; //SYLEE150604  //autopress 
        }
    }


    // START off  
    if (nDio[DIN_START] == 0)
    {
        if (nRunOld_Start != D_OFF) {
            nRunOld_Start = D_OFF;     //old state     2=off start //DEMO2
            //son 장비초기화
            nDioAllOff = 1;//SYLEE130227JOYTECH 
        }

        // START off & TEST  off   
        if (nDio[DIN_TEST] == 0) {
            if (nRunOld_StartTest != D_OFF) {
                nRunOld_StartTest = D_OFF;     //old state     2=off start //DEMO2
            }
        }

        // START off & ABORT off    
        if (nDio[DIN_ABORT] == 0) {
            if (nRunOld_StartAbort != D_OFF) {
                nRunOld_StartAbort = D_OFF;     //old state     2=off start //DEMO2
            }
        }

        // START off & SKIP off    
        if (nDio[DIN_SKIP] == 0) {
            if (nRunOld_StartSkip != D_OFF) {
                nRunOld_StartSkip = D_OFF;     //old state     2=off start //DEMO2
            }
        }
    }

    // TEST off    
    if (nDio[DIN_TEST] == 0) {
        if (nRunOld_Test != D_OFF) {
            nRunOld_Test = D_OFF;     //old state     2=off start //DEMO2
            //son 장비초기화
            nDioAllOff = 1;//SYLEE130227JOYTECH 
        }
    }
    // ABORT off  
    if (nDio[DIN_ABORT] == 0) {
        //son240502 nDioCo1[i] = 0;  //son 미사용 코드 삭제
        if (nRunOld_Abort != D_OFF) {
            nRunOld_Abort = D_OFF;     //old state     2=off start //DEMO2

            //son 장비초기화
            nDioAllOff = 1;//SYLEE130227JOYTECH 
        }
    }

    // SKIP off면    
    if (nDio[DIN_SKIP] == 0) {
        if (nRunOld_Skip != D_OFF) {
            nRunOld_Skip = D_OFF;     //old state     2=off start //DEMO2

            //son 장비초기화
            nDioAllOff = 1;//SYLEE130227JOYTECH
        }
    }

    if (nDioAllOff == 1)
    {

        //son 장비의 모든 신호를 Off한다. (Action 시작 전 일종의 초기화)
        Comi_DoPutByte(DOUT_CMD_ALL_OFF);//SYLEE130227JOYTECH  //son231016 //son240430
        MyTrace(PRT_LEVEL3, "Line_%d OnTimer() TIMER_DIO: Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n",
                     __LINE__); //son211215  //son220318

    }
    //REMOTESTART


    //START OFF + TEST  ON    //sylee150413 autopress
    //----------------------------------------------------------------------------------------------
    //son START+TEST+ABORT+SKIP (1111 : 0x0f) : Handler 수동 Mode에서 검사.(Retry없음)
    //    or  START+TEST+ABORT+SKIP + RESHEET (1000 1111: 0x8f)  : Handler 수동 모드 검사 with RESHEET
    //----------------------------------------------------------------------------------------------
    if (nDio[DIN_START] == 1 && nDio[DIN_TEST] == 1 && nDio[DIN_ABORT] == 1 && nDio[DIN_SKIP] == 1 
            && nDio[DIN_REVERSE] == 0)
        Process_HandlerManualTest(nCurStates);    //son240502



    //START ON + TEST Off+abort on///sylee130218joytech-skip
    //----------------------------------------------------------------------------------------
    //                              +REVERSE(0x10)   +RESHEET(0x80)   +REVERSE+RESHEET(0x90)
    //son START+ABORT 0101(0x05)    00010101(0x15)   10000101(0x85)   10010101(0x95) 
    //----------------------------------------------------------------------------------------
    else if (nDio[DIN_START] == 1 && nDio[DIN_ABORT] == 1)
    {
        //son240426 START+ABORT+TEST가 들어오기 직전에  START+ABORT 신호만 일시적으로 발생하는 문제관련
        //    일시적 START+ABORT가 아니라 진짜 START+ABORT일 때만 동작하도록 한다.
        //    false인 경우는 g_nPrevDioCmd에 g_nCurDioCmd 저장 안 하고 return해서 이번 command를 버린다. 
        //    계측기SW가 Comi_DoPutByte(0)를 보내기 전에는 장비측에서 이전 command를 유지하므로 버리고 다시 읽어도 된다.
        //    이 경우는 일시적인 신호이므로 버려야 제대로 된 신호를 다시 받아서 처리 되는 것.
        if (Check_DIN_Val(0xffff &nCurStates) == false) //son240426
            goto TASK_EXIT_TIMER_DIO;   //son240502  마무리 작업하고 return 

        Process_StartSkip_Or_StartAbort(nCurStates);     //son240502
    }

    //----------------------------------------------------------------------------------------
    //                              +REVERSE(0x10)   +RESHEET(0x80)   +REVERSE+RESHEET(0x90)
    //son START+SKIP  1001(0x09)    00011001(0x19)   10001001(0x89)   10011001(0x99)
    //----------------------------------------------------------------------------------------
    else if (nDio[DIN_START] == 1 && nDio[DIN_SKIP] == 1)  
        Process_StartSkip_Or_StartAbort(nCurStates);     //son240502


    //----------------------------
    //son START+TEST : 0011(0x03)
    //----------------------------
    else if (nDio[DIN_START] == 1 && nDio[DIN_TEST] == 1)
        Process_StartTest(nCurStates);    //son240502


    //SYLEE130221JOYTECH-MANUAL START ONE  //SYLEE150812       
    //--------------------------
    //son ABORT+SKIP : 1100(0x0c)
    //--------------------------
    //son ABORT+SKIP    : Handler Target 창에서 테스트요청 (Block Retest 필요없음
    else if (nDio[DIN_START]==0 && nDio[DIN_TEST]==0 && nDio[DIN_ABORT]==1 && nDio[DIN_SKIP]==1) //ABORT+SKIP
        Process_HandlerTargetTest(nCurStates);  //son240502

    //--------------------------
    //son ABORT+RESHEET : 0x84 
    //--------------------------
    //son ABORT+RESHEET : Handler Target창 4W 정밀테스트 요청 (Block Retest 필요없음) 
    else if (SysSet13.m_nSet18==1   //son Map > Set1 > '* 4W MANUAL -ABORT DIO'  On이고
              && nFlag_DIN_ABORT==1 &&  nDio[DIN_RESHEET]==1    //ABORT+RESHEET  //son231110
              && nDio[DIN_START]==0 && nDio[DIN_TEST]==0 && nDio[DIN_SKIP]==0 )
        Process_HandlerTargetTest(nCurStates);  //son240502

    //START OFF + TEST  ON  
    //-----------------------------------
    //son TEST(0010: 0x02) : 2~n 테스트
    //-----------------------------------
    else if (nDio[DIN_START] == 0 && nDio[DIN_TEST] == 1)
        Process_Test(nCurStates);   //son240502


    //--------------------------------------
    //son   ABORT(0100: 0x04) : 2~n Block ABORT 
    //---------------------------------------
    else if (nDio[DIN_ABORT] == 1) 
    {
        //son240426 START+ABORT+TEST가 들어오기 직전에  ABORT 신호만 일시적으로 발생하는 문제관련
        //    일시적 ABORT가 아니라 진짜 ABORT일 때만 동작하도록 한다.
        //    false인 경우는 g_nPrevDioCmd에 g_nCurDioCmd 저장 안하고 return해서 이번 command를 버린다.
        //    계측기SW가 Comi_DoPutByte(0)를 보내기 전에는 장비측에서 이전 command를 유지하므로 버리고 다시 읽어도 된다.
        //    이 경우는 일시적인 신호이므로 버려야 제대로 된 신호를 다시 받아서 처리 되는 것.
        
        //son 다시 읽어 보니 ABORT가 아니라면 마무리 작업하고 return 
        if (Check_DIN_Val(0xffff &nCurStates) == false) //son240426 
            goto TASK_EXIT_TIMER_DIO;  //son240502 

        Process_Skip_Or_Abort(nCurStates);   //son240502
    }

    //--------------------------------------
    //son or SKIP(1000: 0x08) : 2~n Block SKIP 
    //---------------------------------------
    else if (nDio[DIN_SKIP] == 1)     //son  ABORT 또는 SKIP
        Process_Skip_Or_Abort(nCurStates);   //son240502


    if (g_nCurDioCmd != g_nPrevDioCmd)  //son240119
        g_nPrevDioCmd = g_nCurDioCmd;   //son240119

TASK_EXIT_TIMER_DIO:  //son240502

#ifdef _PC_TEST_
    // VIEW7_TIMER_DIO 디버그중 타이머 쌓이는 현상을 막기 위해 Timer처리 완료 시점에 다시 시작
    SetTimer(VIEW7_TIMER_DIO, 2000, NULL); //son 2sec          SetTimer(70 for DIO
#endif

    return;
}



//----------------------------------------------------------------------------------------------
//son START+TEST+ABORT+SKIP (1111 : 0x0f) : Handler 수동 Mode에서 검사.(Retry없음)
//    or  START+TEST+ABORT+SKIP + RESHEET (1000 1111: 0x8f)  : Handler 수동 모드 검사 with RESHEET
//----------------------------------------------------------------------------------------------
void CChildView7::Process_HandlerManualTest(int nCurStates) //son240502
{
    int i, x, nRet = 0;


    nDualNetSig1 = 3;

    //son 이전 상태가 START 0 & TEST 0이었을 때만 다음 코드 수행
    if (nRunOld_StartTest == D_OFF)  //sylee20120824  START   on  test on 
    {
        MyTrace(PRT_LEVEL1, "\n\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== START+TEST+ABORT+SKIP (0x%02x) %s ManualMode\n",    //son210331 
                nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                nCurStates, (nDio[DIN_RESHEET] == 1) ? " + RESHEET" : "");

        nKeyStartFlag = 0;//sylee130306joytch 

        //son OnStart1()이 수행중이 아니라면
        if (nRunProc1 == 0)
        {

            nIndexSig1 = 1;///sylee120827  //son 1: 정방향 block process 
            nBlockCountP = 0;
            MyTrace(PRT_LEVEL2, "Line_%d OnTimer() START+TEST+ABORT+SKIP (0x0f): nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                    __LINE__, nBlockMax, nBlockMaxLast1, nBlockCountP);

            //son Block Test 전체 재시작이므로 Retest 여부를 초기화
            for (i = 0; i <= nCellMax; i++) {//sylee120827
                nAutoReTest[i] = 0;
            }
            m_list1.ResetContent();//sylee120824
            nlist1 = 0;


            //son START+RESHEET인지 확인하고 RESHEET 관련 action을 한다.
            //    nReSheetRes[] 초기화, nReSheetFlag1 설정. 
            Check_DIN_StartResheet();           //son200821-RESHEET기능보완
            //son220804_3  d4W_Log1[][] 데이터 지우는 기능 Check_DIN_StartResheet() 내부로 이동. 코드 간소화.

            //son Block-Piece Grid Graph를 다시 그린다.
            ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE131123
            for (x = 1; x <= nCellMax; x++) {  //SYLEE131123
                GraphDisplayBlock(x, nBlockRes[x]); //son240502 nBlockRes[x] 값은 여기서 무조건 0이다.
            }

            UpdateData(FALSE);

            OnRecipeErrorCheckFlag = 1;//sylee140127

            nFlagAutoPress1 = 2;//sylee150413
            nRunOld_AutoPress = D_ON;  //SYLEE150604  //autopress

            //son Block 정보를 업데이트한다.
            DisplayBlock_Map1();  //sylee180502-1

            //----------------------
            //son Start Test

            nRet = Read_DUTNo(nDio[DIN_DUT1], nDio[DIN_DUT2], __LINE__);    //son240502 
            if (nRet == 1) {
                //son 엔터키 입력이 들어온 것처럼 OnStart1()을 강제수행한다.
                //    OnStart1()-> SetTimer(20, ..) -> OnTimer() case 20: -> AProcess100()이 수행됨.

                nFlagRunMode1 = 0;//sylee201012
                OnStart1();//sylee20120720     //autopress
            }
            //  nFlagAutoPress1=0;//sylee150413

            OnRecipeErrorCheckFlag = 0;//sylee140127

            nRunProc1 = 1;
            nRunOld_StartTest = D_ON;//DEMO2  1=start   //sylee20120824
            nRunOld_StartAbort = D_ON; //sylee20121007
            nRunOld_StartSkip = D_ON; //sylee20121007
            nRunOld_Start = D_ON; //DEMO2  1=start
            nRunOld_Test = D_ON; //DEMO2  1=start   //sylee20120824

            Comi_DoPutByte(DOUT_CMD_ALL_OFF);//MEMO   PASS OFF //son231016 //son240430
            MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO START+TEST+ABORT+SKIP Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF \n", __LINE__);  //son220318
            ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH   m_list1.ResetContent();

            m_list1.ResetContent();

        }
    }


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

//--------------------------
//son ABORT+SKIP    : 0x0c
//son ABORT+RESHEET : 0x84 
//--------------------------
//son ABORT+SKIP    : 메인 Handler Target 창에서 테스트요청 (Block Retest 필요없음
//son ABORT+RESHEET : 메인 Handler Target창 4W 정밀테스트 요청 (Block Retest 필요없음) 
void  CChildView7::Process_HandlerTargetTest(int nCurStates) //son240502
{
    int i, x, nRet = 0;

    OnRecipeErrorCheckFlag = 0;//sylee140127
    if (nRunOld_AbortSkip == D_OFF && nManualStartFlag != 1)    //son240503
    {
        //son210715 if( nRunOld_AbortSkip== D_OFF.. 내부로 이동
        MyTrace(PRT_LEVEL1, "\n\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== ABORT+%s(0x%02x) Manual Mode Test\n", //son210331
                nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                (nDio[DIN_SKIP] == 1)? "SKIP" :                         
                (nDio[DIN_RESHEET] == 1)? "RESHEET" : "Undef_CodeErr!!!",   //son231110
                nCurStates);

        nRunOld_AbortSkip = D_ON;   //son240503
        nManualStartFlag = 1;       //son nManualStartFlag 1 이면 block retest를 안 한다.
        nKeyStartFlag = 0;//sylee130306joytch
        nReSheetFlag1 = 0;//sylee140304
        //                  AfxMessageBox("  test333-3  ? nKeyStartFlag=0 ", MB_OK);
        //sylee150817        if( SysInfo05.m_nDual!=2 ){

        nDualNetSig1 = 3;

        //son 이전 상태가 START 0 & TEST 0이었을 때만 다음 코드 수행
        if (nRunOld_StartTest == D_OFF)  //sylee20120824  START   on  test on 
        {
            //son OnStart1()이 수행중이 아니라면
            if (nRunProc1 == 0)
            {
                //son +REVERSE 라면
                if (nDio[DIN_REVERSE] == 1) {//sylee120827  print 
                    nIndexSig1 = 2;///sylee120827   //son 2: reverse block process
                    nBlockCountP = nBlockMax + 1;  //son Block을 End 위치로 옮겨서 끝에서부터 시작한다.
                }
                else {
                    nIndexSig1 = 1;///sylee120827   //son 1: 정방향 block process
                    nBlockCountP = 0;   //son START+TEST 이므로 BlockId를 0으로 초기화한다.
                }
                MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO ABORT+%s(0x%02x): nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                        __LINE__, 
                        (nDio[DIN_SKIP] == 1)? "SKIP" :                         
                        (nDio[DIN_RESHEET] == 1)? "RESHEET" : "Undef_CodeErr!!!",
                        nCurStates, nBlockMax, nBlockMaxLast1, nBlockCountP);     //son220317

                //son Block-Piece를 초기화.
                for (i = 0; i <= nCellMax; i++) {//sylee120827
                    if (GraphDisplay1[i] == 0) {
                        GraphDisplayBlock(i, 0);//sylee121129
                    }
                    nAutoReTest[i] = 0;
                }
                UpdateData(FALSE);//sylee121007
                m_list1.ResetContent();//sylee120824
                nlist1 = 0;
                ::ZeroMemory(&nReSheetRes, sizeof(nReSheetRes));//sylee141027-interlock  //resheet
                nFlagAutoPress1 = 0;//sylee150413

                //----------------------
                //son Start Test
                
                nRet = Read_DUTNo(nDio[DIN_DUT1], nDio[DIN_DUT2], __LINE__);    //son240502 
                if (nRet == 1) {
                    nFlagRunMode1 = 0;//sylee201012
                    OnStart1();//sylee20120720  -MANUAL
                }
                nRunProc1 = 1;

                Comi_DoPutByte(DOUT_CMD_ALL_OFF);//MEMO   PASS OFF //son231016 //son240430
                MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO ABORT+%s(0x%02x): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", //son220318
                        __LINE__,  (nDio[DIN_SKIP] == 1)? "SKIP" :                         
                        (nDio[DIN_RESHEET] == 1)? "RESHEET" : "Undef_CodeErr!!!", nCurStates); 

                m_list1.ResetContent();

                //son Block-Piece Grid를 초기화하고 다시 그린다.
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH
                for (x = 1; x <= nCellMax; x++) {  //test  display
                    GraphDisplayBlock(x, nBlockRes[x]);   // son nBlockRes[x]는 여기서 모두 0. 0으로 초기화하는 것.
                }

                UpdateData(FALSE);
            }
        }

        //sylee150817 }

    }

}

//----------------------------
//son START+TEST : 0011(0x03)
//----------------------------
void CChildView7::Process_StartTest(int nCurStates) //son240502
{
    int i, x, nRet;

    nDualNetSig1 = 3;

    //son 이전 상태가 START 0 & TEST 0이었을 때만 다음 코드 수행
    if (nRunOld_StartTest == D_OFF)  //sylee20120824  START   on  test on 
    {
        //son210715 if( nRunOld_StartTest== D_OFF) 내부로 이동
        MyTrace(PRT_LEVEL1, "\n\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== START+TEST(0x%02x) %s\n",   //son210331
                nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                nCurStates, (nDio[DIN_RESHEET] == 1) ? " + RESHEET" : "");

        //son240622 BarCode.txt는 START+TEST 송신 직전에 Main PC에서 생성. sheetNo등의 정보 불일치를 최대한 막기위해
        //   계측기는 START+TEST 수신하자마자 ReadBarCode_TXT() 호출해서 BarCode.txt를 read한 정보를 보관해 둔다.
        ReadBarCode_TXT();  //son240622 "BarCode.txt" 정보 획득.

        nKeyStartFlag = 0;//sylee130306joytch
        //   AfxMessageBox("  test333-2  ? nKeyStartFlag=0 ", MB_OK);
        if (nRunProc1 == 0)
        {
            //son +REVERSE 라면
            if (nDio[DIN_REVERSE] == 1) {//sylee120827  print 
                nIndexSig1 = 2;///sylee120827   //son 2: reverse block process
                //son Block을 End 위치로 옮겨서 끝에서부터 시작한다. 
                nBlockCountP = nBlockMax + 1;
            }
            else {
                nIndexSig1 = 1;///sylee120827   //son 1: 정방향 block process
                //son START+TEST 이므로 BlockId를 0으로 초기화한다.
                nBlockCountP = 0;
            }
            MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO START+TEST(0x03): nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                    __LINE__, nBlockMax, nBlockMaxLast1, nBlockCountP);     //son220317


            //son Block Test 전체 재시작이므로 Retest 여부를 초기화
            for (i = 0; i <= nCellMax; i++) {//sylee120827
                nAutoReTest[i] = 0;
            }
            m_list1.ResetContent();//sylee120824
            nlist1 = 0;

            //son START+RESHEET인지 확인하고 RESHEET 관련 action을 한다.
            //    nReSheetRes[] 초기화, nReSheetFlag1 설정. 
            Check_DIN_StartResheet();   //son200821-RESHEET기능보완     
                        //son220804_3  d4W_Log1[][] 데이터 지우는 기능 Check_DIN_StartResheet() 내부로 이동. 코드 간소화.

            //son Start 신호가 있으니 Block-Piece Grid를 초기화하고 다시 그린다.
            ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE131123
            for (x = 1; x <= nCellMax; x++) {  //SYLEE131123
                GraphDisplayBlock(x, nBlockRes[x]);    //son nBlockRes[x]는 여기서 모두 0. 0으로 초기화하는 것.
            }

            UpdateData(FALSE);

            OnRecipeErrorCheckFlag = 1;//sylee140127
            nFlagAutoPress1 = 0;//sylee150413 

            //son SkipPcs.txt 파일을 Read한다.
            ReadFile_SkipPieceInfo();//sylee160203-ITS    //son220621 A_PieceDisable1() -> ReadFile_SkipPieceInfo() 

            //son Block 정보를 업데이트한다.
            DisplayBlock_Map1();  //sylee180502-1

            //-----------------
            //son Start Test

            nRet = Read_DUTNo(nDio[DIN_DUT1], nDio[DIN_DUT2], __LINE__);    //son240502 
            if (nRet == 1) {
                Sub71.m_bFirstStep = TRUE;      //hdpark20240129
                Sub71.m_bSparkCal = FALSE;
                SysSet13.m_nSet16 = 1; // hdpark230105 spark test, recover lv short 
                Sub71.m_bSparkVerification = FALSE;// hdpark230105 spark
                nFlagRunMode1 = 2;//sylee201012

                OnStart1();//sylee20120720    
            }
            OnRecipeErrorCheckFlag = 0;//sylee140127

            nRunProc1 = 1;
            nRunOld_StartTest = D_ON;//DEMO2  1=start   //sylee20120824
            nRunOld_StartAbort = D_ON;   //sylee20121007
            nRunOld_StartSkip = D_ON;   //sylee20121007
            nRunOld_Start = D_ON;//DEMO2  1=start
            nRunOld_Test = D_ON;//DEMO2  1=start   //sylee20120824

            //son 이 위치에서 장비 초기화를 전송하면 이상해 보일 수 있지만
            //    OnStart1()이 실제로는 Timer로  10ms 이후에 AProcess100()이 수행되기 이전에 
            //    Comi_DoPutByte(DOUT_CMD_ALL_OFF) 이 수행되므로 문제가 없음.
            //    OnStart1()-> SetTimer(20, ..) -> OnTimer() case 20: -> AProcess100()이 수행됨.
            Comi_DoPutByte(DOUT_CMD_ALL_OFF);//MEMO   PASS OFF //son231016 //son240430
            MyTrace(PRT_LEVEL3, "Line_%d TIMER_DIO START+TEST Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318

            ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH    

            m_list1.ResetContent();


        }
    }

} 

//-----------------------------------
//son TEST(0010: 0x02) : 2~n 테스트
//-----------------------------------
void CChildView7::Process_Test(int nCurStates) //son240502
{
    int nRet;


    //son 이전 상태가 only TEST 0이었을 때만 다음 코드 수행
    if (nRunOld_Test == D_OFF) //DEMO2   START 과거 상태가  OFF이었다면 
    {
        //son210715  if( nRunOld_Test== D_OFF) 내부로 이동
        MyTrace(PRT_LEVEL1, "\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== TEST(0x%02x)\n", //son210331
                nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                nCurStates);

        nKeyStartFlag = 0;//sylee130306joytch
        //                                      AfxMessageBox("  test333-4  ? nKeyStartFlag=0 ", MB_OK);

        if (nRunProc1 == 0)
        {

            m_list1.ResetContent();//sylee120824
            nlist1 = 0;
            OnRecipeErrorCheckFlag = 1;//sylee140127
            nFlagAutoPress1 = 0;//sylee150413

            //son SkipPcs.txt 파일을 Read한다.
            ReadFile_SkipPieceInfo();//sylee160203-ITS //son220621 


            //----------------------
            //son Start Test
            //----------------------

            nRet = Read_DUTNo(nDio[DIN_DUT1], nDio[DIN_DUT2], __LINE__);    //son240502 
            if (nRet == 1) {
                Sub71.m_bFirstStep = FALSE;      //hdpark20240129
                nFlagRunMode1 = 0;//sylee201012
                OnStart1();//sylee20120720   // only test
            }
            OnRecipeErrorCheckFlag = 0;//sylee140127

            nRunProc1 = 1;
            nRunOld_Test = D_ON;//DEMO2  1=start
            Comi_DoPutByte(DOUT_CMD_ALL_OFF);//MEMO   PASS OFF //son231016 //son240430
            MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO TEST(0x02): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318

        }
    }

} 

//son240430 START+ABORT 처리하는 기능을 별도 함수로 분리함.
//          START+ABORT+TEST가 들어오기 직전에  START+ABORT 신호만 일시적으로 발생하는 문제관련 추가
//
//son 첫번째 Block Start+ABORT 또는 첫번째 Block Start+skip. OnStart1()이 없다.
//son 해당 Block은 테스트 하지 않고 skip 해야 한다. 계측기 입장에서 ABORT==SKIP 임.
//----------------------------------------------------------------------------------------
//                              +REVERSE(0x10)   +RESHEET(0x80)   +REVERSE+RESHEET(0x90)
//son START+ABORT 0101(0x05)    00010101(0x15)   10000101(0x85)   10010101(0x95) 
//son START+SKIP  1001(0x09)    00011001(0x19)   10001001(0x89)   10011001(0x99)
//----------------------------------------------------------------------------------------
void CChildView7::Process_StartSkip_Or_StartAbort(int nCurStates)   //son240502
{
    int x;

    OnRecipeErrorCheckFlag = 0;//sylee140127

    if (nDio[DIN_ABORT] == 1) {//sylee130218joytech-skip
        nRunOld_Abort = D_ON;
    }

    if (nDio[DIN_SKIP] == 1) {//sylee130218joytech-skip
        nRunOld_Skip = D_ON;
    }


    nDualNetSig1 = 3;

    //son 이전 상태가 START 0 & TEST 0이었을 때만 다음 코드 수행
    if (nRunOld_StartTest == D_OFF)  //sylee140326
    {
        //son210715 if( nRunOld_StartTest == D_OFF) 내부로 이동
        MyTrace(PRT_LEVEL1, "\n\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <====  %s %s:0x%02x) %s \n",   //son210331
            nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
            nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
            (nDio[DIN_ABORT] == 1) ? " START+ABORT(0x05" : "", (nDio[DIN_SKIP] == 1) ? " START+SKIP(0x09" : "",
            nCurStates, (nDio[DIN_RESHEET] == 1) ? " + RESHEET" : "");

        //son 이전 상태가 START 0 & ABORT 0 또는 START 0 & SKIP 0 이었을 때만 다음 코드 수행
        if (nRunOld_StartAbort == D_OFF || nRunOld_StartSkip == D_OFF)  //sylee20130304 START   on  test on 
        {

            //son  START+ABORT 로 Block skip 하면서 1로 변경
            if (nRunOld_StartAbort == D_OFF && nDio[DIN_ABORT] == D_ON) {//sylee130304
                nRunOld_StartAbort = D_ON;
            }

            //son  START+SKIP 로  Block skip 하면서 1로 변경
            if (nRunOld_StartSkip == D_OFF && nDio[DIN_SKIP] == D_ON) {//sylee130304
                nRunOld_StartSkip = D_ON;
            }

            if (nRunProc1 == 0 || nRunProc1 == 1)
            {

                MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO START+%s %s : BlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                    __LINE__, (nDio[DIN_ABORT] == 1) ? "ABORT(0x05)" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x09)" : "",
                    nBlockMax, nBlockMaxLast1, nBlockCountP);   //son220317

            //son220804 begin:
            //   START+ABORT 수신시에 DOUT_CMD_ACK_SKIP_ABORT 신호를  Check_DIN_StartResheet() 이후에 주도록 수정함. 
            //   Check_DIN_StartResheet() 내부에서 g_ComiDaq2.DiGetAll()를 2회 더 체크하면서 Resheet 신호가 없어지는 문제 발생함.  
            //   Check_DIN_StartResheet() 수행이전에 DOUT_CMD_ACK_SKIP_ABORT 신호를 받아서 장비가 초기화 한 것이 원인. 

                //son START+RESHEET인지 확인하고 RESHEET 관련 action을 한다.
                Check_DIN_StartResheet();           //son200821-RESHEET기능보완
                            //son220804_3  d4W_Log1[][] 데이터 지우는 기능 Check_DIN_StartResheet() 내부로 이동. 코드 간소화.


                //son SKIP이나 ABORT 더 이상 주지 말라고 장비에 전송
                Comi_DoPutByte(DOUT_CMD_ACK_SKIP_ABORT);// 0x05: PASS(1) + OPEN (4)    //son231016  //son240430
                MyTrace(PRT_LEVEL1, "Line_%d TIMER_DIO START+%s %s: Comi_DoPutByte(): nDioS2=5 =======> ACK_SKIP_ABORT \n",
                    __LINE__, (nDio[DIN_ABORT] == 1) ? "ABORT(0x05)" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x09)" : "");      //son220317

            //son220804 end


                //son REVERSE mode 일때
                if (nDio[DIN_REVERSE] == 1) {//sylee120827  print 
                    nIndexSig1 = 2;///sylee120827   //son 2: reverse block process

                    //son Block을 End 위치로 옮겨서 끝에서부터 시작한다. 
                    nBlockCountP = nBlockMax + 1;

                }
                else {
                    //son START+SKIP 이므로 BlockId를 1로 초기화한다.
                    //    OnStart()가 없으므로... OnStart()내에서 nBlockCount++을 하는지? 
                    nIndexSig1 = 1;///sylee120827  //son 1: 정방향 block process
                    nBlockCountP = 1;

                }

                //son Start 신호가 있으니 Block-Piece Grid를 초기화하고 다시 그린다.
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE131205
                for (x = 1; x <= nCellMax; x++) {  //SYLEE131205
                    GraphDisplayBlock(x, nBlockRes[x]);    //son nBlockRes[x]는 여기서 모두 0. 0으로 초기화하는 것.
                    //SYLEE131205       UpdateData(FALSE); 
                }
                //----------------------------------------------------
                //son SKIP/ABORT 이므로 OnStart1()은 수행하지 않는다. 
                //----------------------------------------------------
                //son Block Test 전체 재시작이므로 Retest 여부를 초기화
                ::ZeroMemory(&nAutoReTest, sizeof(nAutoReTest));//SYLEE131205 
                UpdateData(FALSE);//sylee121007
                m_list1.ResetContent();//sylee120824
                nlist1 = 0;
                nRunProc1 = 0;//sylee121007
                nRunOld_StartTest = D_ON;//DEMO2  1=start   //sylee20120824
                nRunOld_Start = D_ON;//DEMO2  1=start

                //son201106 사장님 지시사항으로 코멘트처리. Start+skip 신호 계측기 미응답문제관련
                //nRunOld_Test = D_ON;//DEMO2  1=start   //sylee20120824 

                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH                                                

            }
        }

    }//end of if( nRunOld_StartTest== D_OFF)  //sylee140326


}

//son240426 ABORT 처리하는 기능을 별도 함수로 분리함.
//          START+ABORT+TEST가 들어오기 직전에  ABORT 신호만 일시적으로 발생하는 문제관련 추가
void CChildView7::Process_Skip_Or_Abort(int nCurStates)   
{

    //son 이전 상태가 only ABORT OFF 이었을 때 또는
    //son 이전 상태가 onl SKIP OFF 였을 때만 아래 코드 수행.
    if ((nDio[DIN_ABORT] == 1 && nRunOld_Abort == D_OFF)
            || (nDio[DIN_SKIP] == 1 && nRunOld_Skip == D_OFF))  //SYLEE130226
    {
        //son210715  if(  ( nDio[DIN_ABORT]==1 && nRunOld_Abort==D_OFF).. 내부로 이동
        MyTrace(PRT_LEVEL1, "\n\n\n");
        MyTrace(PRT_LEVEL1, "VIEW7_TIMER_DIO: nDio[] =%d%d%d%d %d%d%d%d :  <==== %s %s:0x%02x)  \n", //son210331
                nDio[DIN_RESHEET], nDio[DIN_DUT2], nDio[DIN_DUT1], nDio[DIN_REVERSE],   //son240119
                nDio[DIN_SKIP], nDio[DIN_ABORT], nDio[DIN_TEST], nDio[DIN_START],       //son240119
                (nDio[DIN_ABORT] == 1) ? "ABORT(0x04" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x08" : "", nCurStates);


        if (nDio[DIN_ABORT] == 1) {//sylee130226joytech-skip
            nRunOld_Abort = D_ON;   //son only ABORT 1로 변경
        }
        if (nDio[DIN_SKIP] == 1) {//sylee130226joytech-skip
            nRunOld_Skip = D_ON;        //son only SKIP 1로 변경
        }

        if (nRunProc1 == 0)
        {
            if (nBlockCountP >= nBlockMax) {
                nBlockCountP = 0;
                MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO %s %s : nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                        __LINE__, (nDio[DIN_ABORT] == 1) ? "ABORT(0x04)" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x08)" : "",   //son220317
                        nBlockMax, nBlockMaxLast1, nBlockCountP);

            }

            //son SKIP 했다고 Handler로 응답
            Comi_DoPutByte(DOUT_CMD_ACK_SKIP_ABORT);// 0x05: PASS ON+ OPEN ON     //460  //son231016 //son240430
            MyTrace(PRT_LEVEL1, "Line_%d TIMER_DIO %s %s: Comi_DoPutByte(): nDioS2=5 =======> ACK_SKIP_ABORT \n",
                    __LINE__, (nDio[DIN_ABORT] == 1) ? "ABORT(0x04)" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x08)" : "");  //son220317
            UpdateData(FALSE);

            if (nCellMax == 1) {
                nDisplayRef1 = 10; //DEMO 
                GraphDisplayBlock(1, 0);    //son Block-Piece Grid 0으로 초기화
                UpdateData(FALSE);
            }

            //son 화면에서의 블럭의 위치를 맞춘다.
            if (nIndexSig1 != 2) {//sylee180108-1  //son 1: 정방향 block process이면
                //son ABORT, SKIP이라서 OnStart1()을 수행하지 않았으므로 nBlockCountP++을 여기서 해준다. 
                nBlockCountP++;     //son Block의 번호
            }
            else//sylee180108-1 //son  nIndexSig1 2: reverse block process이면
            {
                if (nBlockCountP > 0) {//sylee180108-1
                    nBlockCountP--; //sylee180108-1
                }
                else {//sylee180108-1
                    nBlockCountP = nBlockMaxLast1 - 1;//sylee180108-1
                }//sylee180108-1

                MyTrace(PRT_LEVEL2, "Line_%d TIMER_DIO %s %s: nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
                        __LINE__, (nDio[DIN_ABORT] == 1) ? "ABORT(0x04)" : "", (nDio[DIN_SKIP] == 1) ? "SKIP(0x08)" : "",   //son220317
                        nBlockMax, nBlockMaxLast1, nBlockCountP);
            }//sylee180108-1

            //son200225 ABORT나 SKIP은 OnStart1() ->...-> AProcess100()이 수행이 안 돼서 
            //    마지막 블록이어도 4WCsv 로그를 안하는 문제가 있어서 보완
            //    맨 마지막 블록까지 도달했다면, 4W csv 로그를 출력한다.
            if (n4WSetFlag1 == 1)//SYLEE150721 
            {
                //son210318 Block이 1개 밖에 없을 때,  Skip이 오는 현상 있음. 이 때문에 Log가 2개  생성됨.
                //  START+TEST 시에 즉시 Log 생성되고 그 다음에 SKIP이 오면 마지막 Block이어서 같은 블록에 대해 또 로그됨.
                //  이를 막기 위해 1이 마지막 블록이면 SKIP이나 ABORT시에 추가 로그 안하도록 수정.
                if (nBlockMax > 1)  //son210318
                    //son  bUseTimer 를 true로 줘서 100ms 후에 CSV 로그한다. 
                    ifLastBlock_Log4WCsv(true); //son-RESHEET-20200225

            }

        }
    }

}

//son240502 Get_DIN_DUTNo(), ComDut1(__LINE__) 이중호출 코드를 하나의 함수로 간소화. 
int CChildView7::Read_DUTNo(int nDio_DUT1, int nDio_DUT2, int nLine) 
{
    int nRet = 1;   //son220317_2 Get_DIN_DUTNo() 호출 위치 이동
    //son  nMulNetFlag(DUT 번호) 1차 확인 (with nDio[DIN_DUT1], nDio[DIN_DUT2])
    //son 장비에서 보내온 DUT번호(DIO[6] DIO[5])로 nMulNetFlag 값을 결정한다. 
    if (SysSet13.m_nSet3 != 1) {//sylee181215-1 //son DMODE_SET13_SET1 다이얼로그에서 "DUT16 Use Z:\ Dut.ini"  이 1이 아니라면
        Get_DIN_DUTNo(nDio_DUT1, nDio_DUT2);    //son200902-코드간소화: 신규추가
        return nRet;
    }
    
    //son "Z:\\DUT.ini"에서 nMulNetFlag 번호를 확인.
    nRet = ComDut1(nLine);//sylee180810-1-dut16   //son220317_2 
    return nRet;
}




//son200902-코드간소화: 신규추가
//son 장비에서 보내온 DUT 번호로 nMulNetFlag 값을 결정한다.  (with nDio[DIN_DUT1], nDio[DIN_DUT2])
//     DIO[6] DIO[5]  
//     0      0      DUT1   
//     0      1      DUT2
//     1      0      DUT3   
//     1      1      DUT4   
void CChildView7::Get_DIN_DUTNo(int nDio_DUT1, int nDio_DUT2)
{
 

    //son DMODE_SET13_SET1 다이얼로그에서 "DUT16 Use Z:\ Dut.ini"  이 1이 아니라면

    int prevDutId = nMulNetFlag;    //son210722

    if (nMultyNetTotal != 1) {//sylee150917-9
        if (nDio_DUT1 == 1 && nDio_DUT2 == 0) {//sylee20120831  //SYLEE150812  ||->&&
            nMulNetFlag = 2; 
        }
        else if (nDio_DUT1 == 0 && nDio_DUT2 == 1) {//SYLEE150812  ||->&&
            nMulNetFlag = 3; 
        }
        else if (nDio_DUT1 == 1 && nDio_DUT2 == 1) {//SYLEE150812  ||->&&
            nMulNetFlag = 4; 
        }
        else if (nDio_DUT1 == 0 && nDio_DUT2 == 0) {//SYLEE150812
            nMulNetFlag = 1;//SYLEE150812 
        }

        if (prevDutId != nMulNetFlag)       //son210722 프린트 과부하를 막기 위해 달라졌을 때에만 출력.
            MyTrace(PRT_BASIC, "Get_DIN_DUTNo(): Block=%d, Recved DUT=%d\n", nBlockCountP, nMulNetFlag);     //son210715 
    }
    else {
        nMulNetFlag = 1;
        if (prevDutId != nMulNetFlag)       //son210722 프린트 과부하를 막기 위해 달라졌을 때에만 출력.
            MyTrace(PRT_BASIC, "Get_DIN_DUTNo() nDio[5]=%d, nDio[6]=%d No DUT Info!   Block=%d,  Use Default DUT=%d\n",    //son210715
                nDio_DUT1, nDio_DUT2, nBlockCountP, nMulNetFlag);
    }


}


//son "Z:\\DUT.ini"에서  DUT 번호확인하여 전역변수 nMulNetFlag 에 업데이트한다.
int CChildView7::ComDut1(int nLine)//sylee1810-1-dut16
{
    FILE* fp;
    char fName[200], sLenth[200];
    CString str;
    int nDUTNo;

    //son DMODE_SET13_SET1 다이얼로그에서 "DUT16 Use Z:\ Dut.ini"  이 1이 아니라면
    if (SysSet13.m_nSet3 != 1) {//sylee181215-1
        return 1;
    }

    if (nMultyNetTotal <= 1) {
        nMulNetFlag = 1;
        return 1;
    }

    ::ZeroMemory(&fName, sizeof(fName));


    strcat(fName, SysInfoView01.m_pStrFileDrive1);//sylee201201-1
    //sylee201201-1 strcat( fName , "Z:\\DUT.ini" );
    strcat(fName, "\\DUT.ini");

    fp = fopen(fName, "rt");
    if (fp == NULL) {
        str.Format("Error No 9001-1 (Line=%d) %s file read error !.", nLine, fName);
        MyTrace(PRT_BASIC, str);     //son221104_2
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
        return 0;
    }

    //----------------
    //son File Read
    ::ZeroMemory(&sLenth, sizeof(sLenth));
    fscanf(fp, "%s\n", sLenth);
    str.Format("%s", sLenth);

    //son "Z:\\DUT.ini"에서  DUT 번호확인
    nDUTNo = atoi(str);
    if (nDUTNo < 1) {
        str.Format("Error No 9001-2 : %s (nDUTNo=%d ??? <1  )  file read error !.\n Set nDutNo to 1 Automatically.\n", fName, nDUTNo);
        MyTrace(PRT_BASIC, str);     //son221104_2
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
        nDUTNo = 1;
    }
    if (nDUTNo > MAX_DUT) {        //son220322  16 -> MAX_DUT(32)
        str.Format("Error No 9001-3 : %s (nDUTNo=%d ??? > %d)  file read error !.\n \n Set nDutNo to 1 Automatically.\n", fName, nDUTNo, MAX_DUT);
        MyTrace(PRT_BASIC, str);     //son221104_2
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
        nDUTNo = 1;
    }

    //Task1:

    fclose(fp);

    //son200514 삭제.
    //    2번째 block TEST 신호 수신시에 DUT.ini가 없어서 못 여는 현상 발생관련.
    //    장비에서 DUT.ini를 삭제하거나 overwrite하도록 하고 계측기측에서 지우는 코드는 삭제한다.
/*
    //son 다음번 DUT.ini 를 새로 받기 위해 다 읽은 DUT.ini는 삭제한다.
    DeleteFile("Z:\\DUT.ini" );// file delete
    fp = fopen(fName,"rt");
    if(fp != NULL){
        fclose(fp);
        str.Format("Error No 9001-5 :%s    ->    file delete  error !.", fName );
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
    }
*/

    if (nBlockCountP > nBlockMax) {
        str.Format("COM >> BLOCK=1, DUT=%d", nDUTNo);
    }
    else {
        str.Format("COM >> BLOCK=%d, DUT=%d", nBlockCountP + 1, nDUTNo);
    }
    LogDebug3(str);

    // DUT 번호를 전역변수 nMulNetFlag 에 업데이트한다.
    nMulNetFlag = nDUTNo;

    if (nDUTNo > nMultyNetTotal) {
        str.Format("Error No 9001-6 !     COM >> file %s  * DUT=%d ???   >   * DUT Total=%d ???", fName, nDUTNo, nMultyNetTotal);
        MyTrace(PRT_BASIC, str);     //son221104_2
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
        return 0;
    }

#ifndef _PC_TEST_
#ifndef _WITHOUT_MAIN_  //son240901
    //son DUT id를 가져 갔다는 표시를 위해 00으로 설정한다.
    fp = fopen(fName, "wt");//sylee201202
    if (fp == NULL) {
        str.Format("Error No 9001-1 :%s file write error !.", fName);
        MyTrace(PRT_BASIC, str);     //son221104_2
        LogDebug3(str);
        AfxMessageBox(str, MB_OK);
        return 0;
    }
    fprintf(fp, "00\n");
    fclose(fp);
#endif
#endif

    return 1;
}


//son 수신한 DIN이 START+RESHEET인지 확인하고 RESHEET 관련 action을 한다.
bool CChildView7::Check_DIN_StartResheet()      //son200821-RESHEET기능보완 신규추가
{
    int nCurStates;

    //son Sheet restest를 시작할 때 이전 측정결과를 copy해야 한다.
    ::ZeroMemory(&nReSheetRes, sizeof(nReSheetRes));//sylee131127//resheet
    nReSheetFlag1 = 0;  //son210420 추가   

    //son RESHEET인지 확인  (전체 PCB를 두번 검사하라. from 메인장비 Handler )
    if (nDio[DIN_RESHEET] == 1)//sylee131127//resheet                                                                     
    {

        nCurStates = g_ComiDaq2.DiGetAll(); //sylee140326                                             
        nDio[DIN_RESHEET] = (nCurStates >> DIN_RESHEET) & 0x1;   //sylee140326


        if (nDio[DIN_RESHEET] == 1) //sylee140326     
        {

            nCurStates = g_ComiDaq2.DiGetAll(); //sylee140326                                             
            nDio[DIN_RESHEET] = (nCurStates >> DIN_RESHEET) & 0x1;   //sylee140326

            //son 진짜 RESHEET인지 3회를 확인 후.
            if (nDio[DIN_RESHEET] == 1) //sylee140326
            {

                MyTrace(PRT_LEVEL1, "START+RESHEET was recieved! \n");   //son210420


                //son RESHEET 관련 옵션이 모두 ON 이라면 RESHEET 플래그를 On한다.
                if ((SysSet13.m_nSet12 != 1) && (SysSet211.m_nSet16 == 1))//SYLEE180206-1 16->12//sylee171011-1 //resheet//SYLEE180206-1 16->12
                {
                    //son210420 START+SKIP+ RESHEET를 받았는데 Block이 1개인 경우는 파일을 지우지 않는다.
                    //    Block이 1개일때  START+SKIP+RESHEET를 받았다고 지워버리면 다음번 Block이 없어서 로그를 다시 만들 기회가 없다.
                    //    START+TEST+ RESHEET인 경우는 Block이 1개여도 현재 타임에 log를 만들거니까 여기서 지운다.
                    if (!(nDio[DIN_SKIP] == 1 && nBlockMax <= 1))   //son210420
                    //if(nBlockMax>1)//sylee180209-2    //son210420 삭제
                    {
                        //son220624_2  SkipPcs.txt 파일로만 piece skip을 결정하고, 이전상태의 pass여부는 체크하지 말라는 메인 장비 요청.
                        //             SheetRetest(RESHEET) 수신시 nReSheetFlag1을 1로 설정하지 않고, 이전 파일 지우기만 수행한다.
                        //son220624_2 nReSheetFlag1=1;//sylee171011-1 //resheet

                        //son220803 원상복구. true로 리턴이 안 돼서  d4W_Log1[][] 데이터가 지워져 버리는 문제 발생 보완을 위해 원상복구.
                        nReSheetFlag1 = 1;//sylee171011-1 //resheet

                        //son220804_2 RESHEET시에 이전 4W Csv 파일 삭제 기능을  Check_DIN_StartResheet()-> ifLastBlock_Log4WCsv()로 이동 
                        //   블록 끝까지 테스트 안 끝났는데  START+TEST가  중간에 들어오는 예외 케이스를 고려해야 함.  
                        //   Resheet 단계를 마지막 블록까지 가지 못해서 CSV 파일을 만들지 못했는데,  
                        //   이전 4W CSV만  지워 버려서  4W CSV 하나를 잃어버리는 문제점 보완.

                    }
                    else 
                    {
                        nReSheetFlag1 = 0;
                    }

                    //son Sheet restest를 시작할 때 이전 측정결과를 copy해야 한다.
                    for (int x = 1; x <= nCellMax; x++) {  //sylee131205//resheet
                        nReSheetRes[x] = nBlockRes[x];
                    }

                }
                else {//sylee131212
                    nReSheetFlag1 = 0;//sylee131212                                                 
                }//sylee131212      

            }//end of if( nDio[DIN_RESHEET]==1){ //sylee140326  #3

        }//end of if( nDio[DIN_RESHEET]==1){ //sylee140326  #2


    }

    //son RESHEET OFF
    else
    {
        nReSheetFlag1 = 0;//sylee131127

    }

    //-----------------------
    // Resheet 상황이라면
    //-----------------------
    //son d4W_Log1[][] 데이터는 지우지 않고 true로 리턴한다.
    if (nReSheetFlag1 == 1) //son210420
        return true;
    //--------------------------
    // Resheet 상황이 아니라면
    //--------------------------
    //son false로 리턴하면 d4W_Log1[][] 데이터는 지워야 한다.

    //son220804_3 begin: d4W_Log1[][] 데이터 지우는 기능 Check_DIN_StartResheet() 내부로 이동. 코드 간소화. 

    //son210420  RESHEET가 아닌 START+TEST 또는 START+ABORT(SKIP)일 때, d4W_Log1[][] 데이터를 지운다.
    if (n4WSetFlag1 == 1)
    {
        //son RESHEET가 아니라 새로운 START일 때에는 4W CsvLog 메모리 전체를 초기화한다.
        ::ZeroMemory(&d4W_Log1, sizeof(d4W_Log1));//sylee150722
        MyTrace(PRT_LEVEL2, "ZeroMemory(&d4W_Log1) All Block for New START. nBlockCountP=%d %s%s%s%s%s%s (DUT_%d_%d)\n",
            nBlockCountP,
            (nDio[DIN_START] == 1) ? "START+" : "", (nDio[DIN_TEST] == 1) ? "TEST" : "",
            (nDio[DIN_ABORT] == 1) ? "+ABORT" : "", (nDio[DIN_SKIP] == 1) ? "+SKIP" : "",
            (nDio[DIN_REVERSE] == 1) ? "+REVERSE" : "", (nDio[DIN_RESHEET]) ? "+RESHEET" : "",
            nDio[DIN_DUT1], nDio[DIN_DUT2]);
    }
    //son220804_3 end

    return false;   //son210420
}


//son240426 START+ABORT+TEST가 들어오기 직전에  ABORT 신호만 일시적으로 발생하는 문제 발생
//    진짜 ABORT인지를 확인하는 기능 필요.
// return : 다시 read해서 wVal과 같은 값이 읽히면 true
//          다시 read해서 wVal과 다른 값이 읽히면 false
bool CChildView7::Check_DIN_Val(unsigned short wVal)      
{
    unsigned short wCurStates;

    Sub71.Delay_100ns(100000);  //son240622 10 msec 
    wCurStates = 0xffff &(g_ComiDaq2.DiGetAll()); 

    if (wCurStates == wVal)
        return true;

    return false;
}


void CChildView7::OnInitialUpdate()
{
    CFormView::OnInitialUpdate();

    //OnInit(); 
}


//son PieceRangeSetCheck를 수행한다.
int CChildView7::AInterStart1()
{

    CString str;

    int nTOpenSum1, nTShortSum1, nT_TotalSum1, nT_TotalSum2;

    if (nMultyNetTotal <= 0 || nMultyNetTotal > MAX_DUT) {//SYLEE180810-1-DUT16 //son220824_2 DefDutMax2 -> MAX_DUT
        nMultyNetTotal = 1;
    }

    nTOpenSum1 = 0;
    nTShortSum1 = 0; nT_TotalSum1 = 0;


    for (int ip = 1; ip <= g_nPieceMax1; ip++) //sylee121128 
    {
      
           //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nTOpenSum1 = nTOpenSum1 + (g_pvBDLData2Op[nMulNetFlag][ip]->size() - 1);   //son200420-4WNET10000
        }
        else {
            nTOpenSum1 = nTOpenSum1 + (g_pvBDLData2Op[1][ip]->size() - 1);         //son200420-4WNET10000    
        }       
           //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1)   //son220824_2 
        {
            nTShortSum1 = nTShortSum1 + (g_pvBDLData31[nMulNetFlag][ip]->size() - 1);
        }
        else {
            nTShortSum1 = nTShortSum1 + (g_pvBDLData31[1][ip]->size() - 1);
        }

    }

    nT_TotalSum1 = nTOpenSum1 + nTShortSum1;


      //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
    {
        nT_TotalSum2 = nPinDa1H[nMulNetFlag][2][0];
    }
    else {
        nT_TotalSum2 = nPinDa1H[1][2][0];
    }


    if (nT_TotalSum1 != nT_TotalSum2)
    {
        str.Format(" Error 7201, *.bdl check!.  piece range set check! \n\n  BDL DUT=%d => \n\n  Open + Short= %d   (!=)  BDL Total Pin= %d ",
            nMulNetFlag, nT_TotalSum1, nT_TotalSum2);
        AfxMessageBox(str);

        nlist1 = 0;//sylee151016

        str.Format(" * DUT=%d ", nMulNetFlag);  //sylee151016
        m_list1.AddString(str); //sylee151016

        return -1;
    }

    //   }
    return 1;
}



int CChildView7::AProcess100()     //SYLEE20111212
{
    int c, a, c2, c3;//sylee150920
    CString str;

    nFlagLeakMPin1=0;  //sylee230526  //sylee230818
	nLeakNearFlag1=0;//sylee241226
	nLeakNearLimit=0;//sylee241226

	::ZeroMemory(&nVbCheck1, sizeof(nVbCheck1));//sylee230529-5	//sylee230817
    nLeakMode1=0;//sylee230822
    nFlagLeakMPin1=0;  //sylee230526 //sylee230818-2
	nLeakADhigh1=0;//sylee230907

	if(SysInfo05.m_nAC==1){	//sylee241204
		nLeakACMode1=2;//sylee241120-2
	}else{
		nLeakACMode1=0;//sylee241120-2
	}

 //////////////////////////////////////////////////////////////////////////////////////////////////////////
// sylee240119
	char  fName[FILE_PATH_SIZE];   //sylee240119   
  	FILE *fp; 
	CFile file; 

    if( SysSet19.m_nSet14 == 1) { //sylee240119 
        nLeakADCCo1=0;
        ::ZeroMemory(&fName, sizeof(fName));     strcat( fName ,"d:\\log\\LeakADC-2.csv"); 	DeleteFile(fName);
        ::ZeroMemory(&fName, sizeof(fName));  	strcat( fName ,"d:\\log\\LeakADC.csv");	    DeleteFile(fName);

        strcat( fName , str ); 
        fp = fopen(fName,"wt");
        if(fp == NULL){ 
            str.Format(" 0LEAK-ADC.CSV  file Data Saving Error !   file close!.");  AfxMessageBox(str, MB_OK);	
            return  0; 
        }   
        fprintf(fp, "*5ErrRate.%, *5AverageValue,*5ErrorValue , 5Max., 5Min. , *No, ," );     	
        for( int i=1; i<=7000; i++){	
            fprintf(fp, " *%d  ,",i);   
        }
        fprintf(fp," \n"  ); 
        fclose(fp); 
    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////
 

	int dutIdx1 = get4wDutIdx();  //sylee230818-2

    nSparkIPlus1 = 0;//SYLEE201027
	nLeakHighFlag2=0;//sylee230830

    if (SysSet19.m_nSet12 != 1) {//SYLEE201024-1  //SPARK NEW BOARD 
        nFlag_NewSparkBaord = 2;//SYLEE201024-1  //SPARK NEW BOARD    
    }
    else {
        nFlag_NewSparkBaord = 0;  //SPARK OLD BOARD
    }

#ifdef __JTECH__CUSTOMER   //SYLEE201012
    if (nFlagRunMode1 == 2) {//sylee201012
        Sleep(1000);//syle201012
    }
    if (nManualStartFlag == 1) {//syle201012
        Sleep(1000);//syle201012
    }
#endif


    //son 4WNet을 R 값 기준으로 값이 큰 것부터 sorting한 데이터를  n4WSort1[net]를  따로 만들어 둔다.
    //    회로 특성 때문인지  이렇게 하면 정도가 잘 나온다고.  from 이상윤부장님.
    ARun201_4w_Net_Sort1(); //sylee191122-1         //sylee200320-4WCVMODE   //sylee200515-patch 

    OnSelfTr1_Flag_Step1 = 1;//sylee181117
    OnSelfTr1_Flag_Run1 = 0;

    n4w_Sample_ok1 = 0;//sylee171103-5
    nFlagInsul1 = 0;//sylee170816-1
    nBuzzer1 = 0;//sylee160908-1
    nProcessFail1 = 0;//sylee170415 
    ::ZeroMemory(&nErrPin1S0, sizeof(nErrPin1S0));//sylee180510-1
    tStart1002 = 0;//sylee150520
    nRelay1OffSkip = 0;//sylee170424-1
    nShortRetestFlag1 = 0;//sylee170618-1


    //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1)//SYLEE20111225
    {
        MyTrace(PRT_LEVEL2, "Line_%d AProcess100(): nBlockMax=%d, nBlockCountP=%d, nAutoReTest[%d]=%d, m_nReCh=%d\n",     //son220503_4  //son240105
                        __LINE__, nBlockMaxLast1, nBlockCountP, nBlockCountP, nAutoReTest[nBlockCountP], gRun05.m_nReCh);  //son240709

        nDioOff1 = 0;

        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            c = nPinDa1H[nMulNetFlag][2][0];      //son BDL 파일 총 핀수
            c2 = nPinDa1H[nMulNetFlag][2][1];     //son BDL 파일 상부  핀수
            c3 = nPinDa1H[nMulNetFlag][2][2];     //son BDL 파일 하부 핀수
        }
        else {
            c = nPinDa1H[1][2][0];
            c2 = nPinDa1H[1][2][1];
            c3 = nPinDa1H[1][2][2];
            //sylee150920 str.Format("%d", PinData[0][2]);//sylee150920
        }

        if (nMultyNetTotal > 0) {//SYLEE171016
            if (nMulNetFlag > nMultyNetTotal) {
                str.Format("Error No 7112 ,  run dut=%d > dut total=%d    dut no. over error.   ", nMulNetFlag, nMultyNetTotal);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
            }
        }

        if (c < 1) {
            KillTimer(VIEW7_TIMER_PROCESS);     //son KillTimer(20)
            nRunProc1 = 0;
            str.Format("Error No 7111 ,   FILE LOAD?    Network Driver Check!. ( Z DRIVER)     Network Driver disconnection.       NETLIST SET PLEASE. !  \n\n  => [Open File]->BDL Folder-> *.BDL Select=> [Save File] \n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            DisplayRes1_BigLabel(TEST_DIS_IDLE);    //son220824
            return 0;
        }

        if (nAutoStartInterlock100 == 2) {//sylee050308   //sylee150602
            KillTimer(VIEW7_TIMER_PROCESS);      //son KillTimer(20)
            nRunProc1 = 0;
            str.Format(" Error 7211!  BDL  FILE CHECK!   ");//sylee050308
            AfxMessageBox(str);
            str.Format(" Error 7212!  Don't RUN!   MANAGER CALL!,  Engineer Call!    BDL LOADING ERROR .   TOTAL PIN=%d != ( open pin=%d + short pin=%d)????    ",
                nBDLHead1[1][3][1], nBDLData2[1][0][1], nBDLData3[1][0][1]);
            AfxMessageBox(str); //sylee050308
            DisplayRes1_BigLabel(TEST_DIS_IDLE);    //son220824
            return 0;
        }


        ///////////////////////////////////////////////////////////
        //초기 구동부 
        Comi_DoPutByte(DOUT_CMD_ALL_OFF);  //son231016 //son240430
        // PRT_LEVEL3 원래..
        MyTrace(PRT_LEVEL3, "Line_%d AProcess100(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son210722 삭제 //son240105 복구

        if (nBlockCountP >= nBlockMax) {
            if ((nAutoReTest[nBlockCountP] <= (gRun05.m_nReCh))) {  // retest  //sylee20120424  //SYLEE20120708
            }
            else {
                nBlockCountP = 0;
                ::ZeroMemory(&nAutoReTest, sizeof(nAutoReTest));//sylee20120424
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//sylee20120424                
            }
        }
        //son210722 MyTrace(PRT_LEVEL2, "Line_%d AProcess100(): nBlockMax=%d, nBlockMaxLast1= %d, nBlockCountP=%d\n", 
        //                        __LINE__, nBlockMax, nBlockMaxLast1, nBlockCountP);


        //-------------------------
        //son  Auto Test 실행!!
        //-------------------------
        if (nBDLData2[1][0][1] > 0 || nBDLData3[1][0][1] > 0)//
        {
            //son Block1개에 대한 Auto Test 를 수행한다.
            a = AProcess101();  //SYLEE20111212

            // hdpark220511 spark begin
            if (Sub71.m_bModifySparkMeas)
            {
                if (Sub71.fpSend)   fclose(Sub71.fpSend);
                if (Sub71.fpSpark)   fclose(Sub71.fpSpark);
                if (Sub71.fpSparkLog)   fclose(Sub71.fpSparkLog);
                if (Sub71.fpSparkWave)   fclose(Sub71.fpSparkWave);   //hdpark231121
            }
            // spark end
        }
        else
        {
            str.Format("Error No 7201 ,   Network Driver Check!. ( Z DRIVER)     Network Driver disconnection.        NETLIST SET PLEASE. !  \n\n ==>  [FILE]->[OPEN FILE]->[SAVE FILE].  \n\n   OPEN LIST?   SHORT LIST?   \n\n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            Comi_DoPutByte(DOUT_CMD_ALL_OFF);  //son231016  //son240430
            MyTrace(PRT_LEVEL3, "Line_%d AProcess100(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318

            DisplayRes1_BigLabel(TEST_DIS_IDLE);    //son220824
            if (nBlockCountP > 1) {
                nBlockCountP--;
            }

            MyTrace(PRT_LEVEL2, "\n%s\nLine%d AProcess100(): nBlockMax=%d, nBlockMaxLast1=%D nBlockCountP=%d\n",
                str.GetBuffer(100), __LINE__, nBlockMax, nBlockMaxLast1, nBlockCountP);
            return 0;
        }

        if (a == 0) {
            Comi_DoPutByte(DOUT_CMD_ALL_OFF);  //son231016  //son240430
            MyTrace(PRT_LEVEL3, "Line_%d AProcess100(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318
            return 0;
        }
        if (a == 2) {
            KillTimer(VIEW7_TIMER_PROCESS);  // end block  zero         //son KillTimer(20)
            nRunProc1 = 0;
            Comi_DoPutByte(DOUT_CMD_ALL_OFF);  //son231016  //son240430
            MyTrace(PRT_LEVEL3, "Line_%d AProcess100(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318
            return 0; //  break;
        }
        str.Format("Block=%d, End", nBlockCountP);
        Label101_Status_SetCaption(str); //son240712
        nRunProc1 = 0;
        nManualStartFlag = 0;//sylee130225 

    }//     if( nProcessFlag1 !=1){//SYLEE20111225


    if (g_VSet3_old != g_VSet3_Fisrt) {//sylee140923-1
        g_VSet3 = g_VSet3_Fisrt;
        g_VSet3_old = g_VSet3;
#ifdef __QUAD_LEAK1_LEAK2__  //son231122
	//sylee230807 //sylee230321	Sub71.AOnVBSet1(3,g_VSet3);  	 
#else  //son231122
	Sub71.AOnVBSet1(3,g_VSet3);  	 
#endif  //son231122
    }

    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        nAutoPress_Flag1 = 0;//sylee150213 
    }

    if (n4WSetFlag1 == 1)//SYLEE150721 
    {
        //-----------------------------
        //son RESHEET 응답이 아닌 경우
        //sylee170417-1  if(nBlockCountP==nBlockMax){
        if (nDioS2 != DOUT_CMD_RETEST)//sylee160520-1 <=========  // resheet 아닐 때.   //son231016
        {
            //son 맨 마지막 블록까지 도달했다면, 4W csv 로그를 출력한다.
            ifLastBlock_Log4WCsv(); //son-RESHEET-20200225

        }

    }

    //son200312-4WDUT16
    int dutIdx = get4wDutIdx();         //son190704-4WDUT16 g_s4WNet의 index. 0부터 시작함.
    if (n4w_Sample_Enable == 1)//sylee150812-1
    {
        if (n4w_Sample_SetCount > 0)//sylee150812-1             
        {
            //son200320-4WDUT16 : n4wSampleFailCo1-> n4wSampleFailCo1_Process100으로 이름변경
            int nEnd = (int)g_s4WNet[dutIdx].wCount;//sylee150813-1       //son190704-4WDUT16

#if 0   //son220518 삭제 begin
//son220518 NG가 있는데, 4W Sampling READ Count가 증가하는 문제 때문에 수정함. 
//          n4wSampleFailCo1_Process100로 4W Sampling Fail 개수를 또 카운트 하지 않고 
//          ARun201_4w_3()에서 이미 카운트한 g_n4wSampleFailCo1 를 사용하여 불일치가 발생하지 않도록 수정함. 

            int n4wSampleFailCo1_Process100 = 0;//sylee150813-1

            //son 이번회차  sampling 수집이  OK라면
            if (n4w_Sample_ok1 == 1) {//sylee171103-5
                n4w_Sample_RunCount_nTmp2 = n4w_Sample_RunCount[dutIdx];//sylee171103-5
            }
            else {
                n4w_Sample_RunCount_nTmp2 = n4w_Sample_RunCount[dutIdx] + 1;//sylee171103-5 ++
            }

            for (int net = 1; net <= nEnd; net++)//sylee150813-1     //son190704-4WDUT16
            {
                if (d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] == 0.0) {//sylee150813-1//SYLEE171103-1  -1
                    d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] = 999999;//SYLEE171103-1  -1
                }

                //son 9999999 등으로 에러 설정이 된 경우  n4wSampleFailCo1_Process100 카운트 증가
                if (d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] >= 200000) {//sylee171026-3//SYLEE171103-1  -1
                    n4wSampleFailCo1_Process100++;//sylee150813-1   //son200320-4WDUT16
                }//sylee150813-1
            }//sylee150813-1
#endif  //son220518 end

            if (n4w_Sample_RunCount[dutIdx] <= n4w_Sample_SetCount)//sylee150812-1
            {
                //auto screen display
                //if(n4wSampleFailCo1_Process100==0){     //son-4WDUT16-20200320
                if (g_n4wSampleFailCo1 == 0) {     //son220518
                    str.Format(" **>4W Sample_Dut%d  :Set=%d,Read=%d",
                        dutIdx + 1, n4w_Sample_SetCount, n4w_Sample_RunCount[dutIdx]);//SYLEE20121117
                }
                else {
                    if (n4w_Sample_RunCount[dutIdx] < 1) {//sylee171103-1
                        str.Format(" **>4W Sample_Dut%d  :Set=%d,Read=0,NG=%d ",
                            dutIdx + 1, n4w_Sample_SetCount, g_n4wSampleFailCo1);//SYLEE161209   //son220518
                    }
                    else {
                        if (n4w_Sample_ok1 == 1) {//SYLEE171103-5
                            str.Format(" **>4W Sample_Dut%d  :Set=%d,Read=%d,NG=%d ",
                                dutIdx + 1, n4w_Sample_SetCount, n4w_Sample_RunCount[dutIdx], g_n4wSampleFailCo1);//SYLEE171103-5    //son220518
                        }
                        else {
                            str.Format(" **>4W Sample_Dut%d  :Set=%d,Read=%d,NG=%d ",
                                dutIdx + 1, n4w_Sample_SetCount, n4w_Sample_RunCount[dutIdx], g_n4wSampleFailCo1);//SYLEE171103-5    //son220518
                        }
                    }
                }

                m_list1.AddString(str);
                //m_Label112.SetCaption(str); //TEST
            }

            //son Run Count가 SetCount에 도달했다면
            //   -> 100개를 설정했다면 100번째 sample일 경우에만 4W_Setup_A.txt를 생성한다.
            if (n4w_Sample_RunCount[dutIdx] == n4w_Sample_SetCount)//sylee150812-1         
            {
                //son 모두 양품일때에만 '4W_Setup_A.txt'를 생성한다.
                //if(n4wSampleFailCo1_Process100==0)//sylee150813-1                            
                if (g_n4wSampleFailCo1 == 0)//son220518
                {
                    //son 4W auto test 결과(d4W_Log2[dutIdx][j][net])를 '4W_Setup_A.txt'에 write한다.
                    ARun201_4w_Logging3_Sample2();//sampling    //SYLEE170114 

                    //son Map > Set1 > Check5(* Engneer => 4W V I File) 
                    if (SysSet13.m_nSet5 == 1) {   //SYLEE190220-1
                        //son VC log 출력
                        ARun201_4w_Logging3_Sample3();//sampling    //SYLEE190220-1

                        //son I log 출력
                        ARun201_4w_Logging3_Sample5();//sampling    //SYLEE190220-1
                    }
                    str.Format(" **>DUT_%d 4W Sample Finish! : Set=%d,Read=%d\n",
                        dutIdx + 1, n4w_Sample_SetCount, n4w_Sample_RunCount[dutIdx]);//SYLEE20121117                
                    MyTrace(PRT_BASIC, str);    //son211715
                    m_list1.AddString(str);
                    m_Label112.SetCaption(str);
                }//sylee150813-1                                                                  
            }
        }
    }

    if (nBuzzer1 != 1) {//sylee160928
        nBuzzer1 = 2;
    }

    nRelay1OffSkip = 0;//sylee170424-1
    if (nSelf1_RunEnable != 2) {
        OnSelfTr1_Flag_Step1 = 3;//sylee181117
    }

    return 1;

}



int CChildView7::AProcess101()    //SYLEE20111212
{
    // hdpark220511 spark begin

    Sub71.m_bModifySparkMeas = FALSE;
#ifdef SPARK_VB_READ
    Sub71.m_bModifySparkMeas = SysSet19.m_nSet11;   //son MAP > Set3 > Spark VB Mode 
//    Sub71.m_bSparkCal = SysSet19.m_nSet13;	//hdpark230223, hdpark230413 delete spark calibration ui 
#endif

	
    if(SysInfo05.m_nSp==0) 
        Sub71.m_bModifySparkMeas=0;//sylee230815


#ifdef DEF_CARD_A1 
    Sub71.m_bModifySparkMeas = 0;
#endif  
/*  hdlpark230516 move A_OnInit()   
	// hdpark230228 spark begin
    m_nUseACLeak = SysInfo05.m_nAC; //SysSet19.m_nSet14; 
	m_nSparkDetection[0] = SysInfo05.m_nSparkDetection[0];
	m_nSparkDetection[1] = SysInfo05.m_nSparkDetection[1];
	m_nSparkDetection[2] = SysInfo05.m_nSparkDetection[2];

	switch(SysInfo05.m_nSparkCurrentSet)
	{
	case 0 : SysInfo05.m_dSparkCurrentSet = 1.0;	break;
	case 1 : SysInfo05.m_dSparkCurrentSet = 2.0;	break;
	case 2 : SysInfo05.m_dSparkCurrentSet = 4.0;	break;
	case 3 : SysInfo05.m_dSparkCurrentSet = 6.0;	break;
	case 4 : SysInfo05.m_dSparkCurrentSet = 10.0;	break;
	case 5 : SysInfo05.m_dSparkCurrentSet = 15.0;	break;
	case 6 : SysInfo05.m_dSparkCurrentSet = 20.0;	break;
	}
*/
	// hdpark230228 spark end

    if (Sub71.m_bModifySparkMeas)
    {
        char szTime[24];
        char szPath[3][FILE_PATH_SIZE];  //hdpark231121

        GetDateAndTime(szTime);
        CTime t = CTime::GetCurrentTime();

        CString strFolder1 = "D:\\LogSpark\\";  // hdpark230412
        CString strFolder2 = "D:\\LogSpark2\\";
        CString strFolder3 = "D:\\LogSpark3\\"; // hdpark231121
        _mkdir(strFolder1);
        _mkdir(strFolder2);
        _mkdir(strFolder3);		//hdpark231121

        strFolder2 += szTime;
        strFolder3 += szTime;	//hdpark231121

        if (GetFileAttributes(strFolder1) == -1)
        {
            ::CreateDirectory(strFolder1, NULL);
        }

        if (GetFileAttributes(strFolder2) == -1)
        {
            ::CreateDirectory(strFolder2, NULL);
        }

        if (GetFileAttributes(strFolder3) == -1)	//hdpark231121
        {
            ::CreateDirectory(strFolder3, NULL);
        }

        sprintf(szPath[0], "%s\\%s.txt", strFolder1, szTime);
        sprintf(szPath[1], "%s\\%s_%02d.txt", strFolder2, szTime, t.GetHour());
        sprintf(szPath[2], "%s\\%s_%02d.txt", strFolder3, szTime, t.GetHour());	//hdpark231121
        Sub71.fpSparkLog = fopen(szPath[0], "a+t");
        Sub71.fpSpark = fopen(szPath[1], "a+t");
        Sub71.fpSparkWave = fopen(szPath[2], "a+t");	//hdpark231121

        CTime curTime = CTime::GetCurrentTime();

        if (Sub71.fpSpark != NULL)
        {
            fprintf(Sub71.fpSpark, "\n[%d/%d/%d %d:%d:%d]",
                curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        }

        if (Sub71.fpSparkWave != NULL)  //hdpark231121
        {
            fprintf(Sub71.fpSparkWave, "\n[%d/%d/%d %d:%d:%d]",
                curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        }
    }
    //hdpark220511 spark end

//    FILE* fp;//sylee181217-2 ,*fp7;
    CString str, str1, str2, str3, str4, str5, str6, str7, str9;
//    char   fName[200];//sylee181217-2 , fName7[200];  

    int    d1, nR1, nR2, nRet;
    int    nb1; //son 수행해야 할 Auto test Type
                //son 1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV) 5:Leak1(HV), 6:*Leak2(HV), 7: *4W

    int    nb2; //son Test mode  (전압별 key 값?)
    double nb3; //son 해당 Test mode의 기준 R AD 값? 

    int    nRun1, nHVUse_Est, nHVUse_Est_HR; //sylee150407

    int    nRetStautus;    //son 현재 block의 nBlockRes[nCellNo] 상태
    int    nRetStautus2;   //son 현재 block, piece의  nBlockRes[nCellNo] 상태
    double b;

    n4W_Use = 0;//sylee200612
    n4W_PinFastADC1 = 0; //sylee200905

    nRetStautus = 0;
    nRetStautus2 = 0;
    nHVUse_Est = 0;//SYLEE140210
    nHVUse_Est_HR = 0;//SYLEE150407


    if (nFlagOpenMes1 == 1) {//SYLEE210309-1
        if (OpenMes1Step < 1 || OpenMes1Step >= 200) {//SYLEE210309-1  1~200
            OpenMes1Step = 1;
            ::ZeroMemory(&OpenMes1, sizeof(OpenMes1));//SYLEE210309-1
        }
        else {
            OpenMes1Step++;
        }
        OpenMes1StepT++;
        if (OpenMes1StepT >= 10000) {//SYLEE210318
            OpenMes1StepT = 1;
        }
    }


    if (nProStep1[TEST_LEAK1][1] < 50000000) {//sylee151109-3 
        nFlagEstModelMake = 0;
    }

    //son200312-4WDUT16
    int dutIdx = get4wDutIdx();         //son190704-4WDUT16 g_s4WNet의 index. 0부터 시작함.

    //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1)//SYLEE20111225
    {

        d1 = gRun05.m_nDelay1 * 1000; //SYLEE151028 

        if (d1 > 0) {
            pDIO.Delay_us(d1);      //son?????   문제?   contec 전용코드인데 ICP-DAS에서 동작하나? 
        }

        nR1 = 0;  nR2 = 0;
        ::ZeroMemory(&nFailCount, sizeof(nFailCount));

        if (nAutoReTest[nBlockCountP] == 0) {//sylee130313joytech
            ::ZeroMemory(&nFailCountP2, sizeof(nFailCountP2));
            //SYLEE180521-2-IMPORT //sylee180612-1
        }
        else {//sylee130313joytech 

            for (int k1 = 0; k1 < 2000; k1++) {//sylee130312joytech  //sylee130416                        
                for (int k2 = 0; k2 < 15; k2++) {//sylee130312joytech
                    if (k2 == 12) {
                        continue;
                    }
                    if (k2 >= 2 && k2 <= 6) {//sylee141113 
                        continue;
                    }
                    nFailCountP2[k1][k2] = 0;
                }
            }
            //sylee180612-1 */
        }//sylee130313joytech


        ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));


        if (nAutoReTest[nBlockCountP] == 0 || (nManualStartFlag == 1)) {//sylee130225

            ::ZeroMemory(&nFailL1, sizeof(nFailL1));
            ::ZeroMemory(&nFailL1Open, sizeof(nFailL1Open));
            ::ZeroMemory(&nOpenSu1, sizeof(nOpenSu1));//sylee20120714  PARKPONGKU CJ;
            ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20120921//100=piecemax
            ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee130122//100=piecemax  //4WCODE
            ::ZeroMemory(&nShortFail1, sizeof(nShortFail1));////sylee20120921//100=piecemax 
            ::ZeroMemory(&nShortFail1Flag1, sizeof(nShortFail1Flag1));////sylee20120921//100=piecemax
            ::ZeroMemory(&nReFlagOpenOld, sizeof(nReFlagOpenOld));//SYLEE121129
            ::ZeroMemory(&GraphDisplay1, sizeof(GraphDisplay1));//SYLEE121129
            ::ZeroMemory(&ng4WResult, sizeof(ng4WResult));//sylee131022   //4WCODE_131118  
            ::ZeroMemory(&nBDLData2Op_Old, sizeof(nBDLData2Op_Old));//sylee160211-1   //sylee160308-1  //sylee160527
            ::ZeroMemory(&nBDLData2Op_Po_old, sizeof(nBDLData2Op_Po_old));//sylee160801-3
            ::ZeroMemory(&nErrPin1O2, sizeof(nErrPin1O2));//sylee170810
            ::ZeroMemory(&nErrPin1S2, sizeof(nErrPin1S2));//sylee170810
            ::ZeroMemory(&n4wFail1Old, sizeof(n4wFail1Old));//sylee160602-5
            ::ZeroMemory(&nPass2, sizeof(nPass2));//sylee171120-1   
            ::ZeroMemory(&d4W_R1, sizeof(d4W_R1));//sylee180220-5
            ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));//sylee180529-1 //sylee160203-ITS
            ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee180529-1  //sylee160203-ITS
            ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee180529-1  //sylee160203-ITS

            ::ZeroMemory(&nShortCo1, sizeof(nShortCo1));//sylee201224
            ::ZeroMemory(&nShortCo1Spark, sizeof(nShortCo1Spark));//sylee201224
            g_n4WFailCount = 0;//sylee180529-1  //sylee160203-ITS               
            nPass2Flag = 0;//sylee171120-1
            nFailL1Co = 0; //sylee120921 short
            nHVDStopFlag = 0;//sylee121009
            nOpenRetryFlag1 = 0;//sylee121117
            nICheck = 0;//SYLEE140617 
            nICheckSet = 0;//SYLEE140617
            nICheckCount = 0;//SYLEE140617
        }


        if (nBlockCountP == 1) {
            ::ZeroMemory(&dCalA1, sizeof(dCalA1));//temp//gobal       4W
            ::ZeroMemory(&nSelfBlock, sizeof(nSelfBlock));//sylee140917
            if (nAutoReTest[nBlockCountP] == 0) {//SYLEE131022   //4WC0DE_131118
                ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee130122//100=piecemax
            }
            //CalibrationLS1_Func(); //sylee140708  //son220419_5 미사용으로 삭제 
        }

        nSelfBlock[nBlockCountP] = 1;//sylee140917 
        nFailL1CoOpen = 0;//sylee120921 
        nRun1 = 0;
        nShortFlag = 0;//sylee120915;


        int  nShCo1, nLvFlag;//sylee131118

        ::ZeroMemory(&nReFlagOpenCur, sizeof(nReFlagOpenCur));//SYLEE121129    //son Piece별 Open불량여부 
        ::ZeroMemory(&nReFlagLvCur, sizeof(nReFlagLvCur));//SYLEE121129

        nLvFlag = 0;//sylee131118
        nOpenSetFlag1 = 0;//SYLEE121204                   
        n4WSetFlag1 = 0;//SYLEE150721

        //------------------------------------------
        //son 수행해야할 Auto Test 종류 확인
        //------------------------------------------

        //son   SysInfo05.m_nStep[i] 정보를 확인해서 nb1을 결정한다.
        //son   nb1에 맞게 Flag들을 초기화한다.
        for (int i = 1; i <= 7; i++)  //sylee20121204
        {
            //son SysInfo05.m_nStep[]:  0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV)
            //                          5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W 
            nb1 = SysInfo05.m_nStep[i];   //open, ushort, short, hr, hv
            if (nb1 == TEST_OPEN) {
                nOpenSetFlag1 = 1;//SYLEE121204
            }
            if (nb1 == TEST_U_SHORT || nb1 == TEST_SHORT || nb1 == TEST_HR_SHORT) {//sylee131118
                nLvFlag = 1;//sylee131118
            }
            if (nb1 == TEST_4W) {//sylee150721
                n4WSetFlag1 = 1;//SYLEE150721
            }
        }

        //  4W 화일초기화 안하여 이전것 기록관련 수정
        //if(nReSheetFlag1!=1)//sylee200828         //son210420 RESHEET 중일 때 테스트해야 할 블록도 초기화 안하는 문제 때문에 삭제
        if (nReSheetFlag1 != 1) //son221025 원상복구. Sheet Retest 일때 같은 블록 내에서 piece1은 이전에 테스트 Pass여서 SkipPcs.txt로 skip하고 
        {                    //   Piece2만 테스트할 수 있음. 이때 해당 블록을 초기화 해버리면 이전의 테스트 상태가 9999로 초기화되고
                             //   테스트를 새로 하지 않은 상태로 4W Log가 남을 수 있으므로, Sheet Retest 일때에는 블록초기화도 하지 않기로 한다.
                             //   대신 CChildView7::ARun201_4w_3() 내부에서 if(nReSheetFlag1==1)이면 net별로 9999999로 초기화하고 시작하는 걸로 수정.

            if (n4WSetFlag1 == 1) //son210420 4W 옵션이 On이 돼 있지 않다면 초기화가 의미 없다.  
            //                  //son210715 if( nProcessFlag1 !=1) 의 상단 위치에서 현재 위치로 이동.   if (n4WSetFlag1==1)이 의미가 있도록
            {
                //son220503_3 if(nAutoReTest[1]==0)//sylee200715-1    //son 첫번째 Block이 retest 중이 아니라면
                if (nAutoReTest[nBlockCountP] == 0)  //son220503_3 4W Retest 중 13번 block을 Retest해서 pass가 났는데 
                {                                 //            이전에 pass였던 net이 NG로 표시되는 문제관련 수정.
                                                  //            Retest 중에는 이전에 pass였던 4w net은 건너뛰고 테스트하는 기능이 있으므로 초기화하면 안됨.
                    //son200827: d4W_Log1 전체가 아니라 d4W_Log1[nBlockCountP]만 초기화하도록 수정함.
                    //           영풍베트남 RETEST 블록만 4W CSV 값이 write되는 문제 관련 수정. (나머지 block은 모두 NG 9999999)
                    //sylee200715-1: E&E 4W 유출 추정 문제 보완(CSV에 max값 초과하는 data. 관련메모리 초기화 추가) 
                    //son231205_2 memset(&d4W_Log1[nBlockCountP], 99999999, sizeof(d4W_Log1[nBlockCountP]));//sylee200715
                    memset(&d4W_Log1[nBlockCountP], 9999999, sizeof(d4W_Log1[nBlockCountP]));//sylee200715 //son231205_2  99999999 -> 9999999 Merge4w 문제 때문에 7자리로 수정   

                    MyTrace(PRT_LEVEL3, "AProcess101():  memset(&d4W_Log1[%d], 9999999... size=%d). nAutoReTest[%d]=%d\n",  //son231205_2  //son240714
                        nBlockCountP, sizeof(d4W_Log1[nBlockCountP]), nBlockCountP, nAutoReTest[nBlockCountP]);

                    memset(dR14w, 9999999, sizeof(dR14w));//sylee200715 //son231205_2
                }
            }
        }

        //son nProOneP_Flag1 2: BDL file 정상여부 체크중
        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {//sylee130927
            nProOneP_RunFlag1 = 1;
        }

        nRunMode_HV_LV = 0;//SYLEE150417-5  1= HV, 2=LV       



        nFastHv1_LVAd1 = (int)nProStep1[TEST_HR_SHORT][2];//sylee150417-5  //HR  RAW R    
        nFastHv1_LVAd2 = (int)nProStep1[TEST_SHORT][2];//sylee150605  SHORT RAW R

        int nHVFast1, nTmp1, nHV1, nLV1;//sylee150530  
#ifdef __QUAD_LEAK1_LEAK2__  //son231122
        int nHV2; //sylee230807                   
#endif  //son231122

        nHVFast1 = 1;//sylee150426-3          
        nHV1 = 0;//sylee150530
        nOpenUse1 = 0;//sylee150627
        nLVshortUse1 = 0;//sylee150622

        nLV1 = 0;//sylee150530   //move //sylee201116

        int step;
        for (step = 1; step <= 7; step++)  //sylee150622    
        {
            nb1 = SysInfo05.m_nStep[step];   //open, ushort, short, hr, hv 

            //son 2:uShort (LV), 3:Short(LV), 4:HR Short(LV)
            if (nb1 == TEST_U_SHORT || nb1 == TEST_SHORT || nb1 == TEST_HR_SHORT) {
                nLVshortUse1 = 1;//sylee150622
                nLV1 = 1;//sylee150530  //move //sylee201116
            }

            //son 5:Leak1  (HV)
            if (nb1 == TEST_LEAK1) {
                nHV1 = 1;//sylee150530
            }
#ifdef __QUAD_LEAK1_LEAK2__  //son231122
		 	if(nb1==TEST_LEAK2){//sylee230807
				nHV2=1;//sylee230315
			} 
#endif
            //son 1:open
            if (nb1 == TEST_OPEN) {///sylee150627
                nOpenUse1 = 1;///sylee150627
            }

            //son LEAK1(HV)
            if (nb1 == TEST_LEAK1) {
                nTmp1 = (int)nProStep1[TEST_LEAK1][3];//sylee150420-2      //son Recipe mode
                if (nHVFast1 == 1 && nTmp1 > 226 && nTmp1 <= 352) {//sylee150425-1   //sylee150420-2
                    nFastHv1_HV_VSet = (int)dRec[nTmp1][3];  //sylee150420-2 
                }//sylee150420-2
                break;//sylee150420-2
            }
        }

        if (nHVFast1 == 1 && nHV1 == 0) {//sylee150530
            nHVFast1 = 0;
        }


        if (nHVFast1 == 1 && nLV1 == 0) {//sylee150530
            nHVFast1 = 0;
        }

        int nHVDidFlag, nT10, nLV_No;//sylee150605

        nHVDidFlag = 0;//sylee150426-3
        nFlag_Open_SetMode = 0;//sylee150428
        nT10 = 0;
        nLV_No = 207;//sylee150605
        nFlag_4W_Use1 = 0;

        tStart2 = GetuSecond(); //SY   //sylee150826 move
        tStart1002 = GetuSecond();//SYLEE150826


        Sub71.OnRelayAllOff1(); //SYLEE180724

        //son Piece Disable 체크
        g_nPieceMax1Disable = 0;//sylee201029
        if (SysInfo19.m_nUse == 1) {  //sylee201029
            for (i = 1; i <= g_nPieceMax1; i++) {//sylee201029
                if (SysInfo19.m_nData[nBlockCountP][i] == 1) {//sylee201029
                    g_nPieceMax1Disable++;
                }
            }
        }

        //====================================================================================================

        int nHRUse;//sylee201116-1
        nHRUse = 0;//sylee201116-1            

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
		nFlagLeak12Run1=0;//sylee230324  //sylee230807
#endif
        nRunStep100=0;  //sylee231016
        for (step = 1; step <= 7; step++)  //sylee20111210                  
        {
            nRunStep100=step;   //sylee231016
            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                Sub71.OnSparkADC(0);//SYLEE200714 NEW_SPARK

            if (nFlagInsul1 == 1) {//sylee170816                         
                goto TaskP101;//sylee170816
            }

            nb1 = SysInfo05.m_nStep[step];   //open, ushort, short, hr, hv  
            if (nb1 == TEST_4W) {//sylee160528-1
                nFlag_4W_Use1 = 1;
            }

            //if (nb1 == 2 || nb1 == 3 || nb1 == 4) {//sylee201116-1
            if (nb1 == TEST_U_SHORT || nb1 == TEST_SHORT || nb1 == TEST_HR_SHORT) { //son220906
                nHRUse = 1;//sylee201116-1
            }

            if (nT10 == 0) {//sylee150701
                if (nb1 > 0) {//sylee150701
                    nT10 = 1;
                }
            }

            if (SysInfo05.m_nProSpMode == 4)//sylee150417-3                            
            {
                if (nHVFast1 == 1 && nHVDidFlag != 1)  //sylee150426-3                           
                {
                    if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3 || (nProOneP_Flag1 == 1 && nProOneP_RunFlag1 == 0))//SYLEE151120
                    {
                        if (nb1 == TEST_SHORT || nb1 == TEST_HR_SHORT)//sylee150417-6
                        {
                            if (nb1 == TEST_SHORT) {
                                nLV_No = 207; //sylee150605  //sylee170620   206->207
                            }
                            //syee201116 continue;  
                        }
                    }
                }
            }


            //-------------------------------
            //son LEAK1 HV 검사
            //-------------------------------
            //son 5: Leak1(HV ) 이면
            if (nb1 == TEST_LEAK1)
            {

                nHVDidFlag = 1;//sylee150426-3
                //sylee170411   if( SysSet13.m_nSet17==1 && nLV1==1){//sylee150415 fasthv //sylee150531
                if (nLV1 == 1) {//sylee150415 fasthv //sylee150531
             //sylee230830-2       nFastHv1RunStep = 1;//sylee150415 fasthv
				    nFastHv1RunStep = 0;//sylee230830-2 
                }
                else {
                    nFastHv1RunStep = 0;//sylee150415 fasthv
                }
                //son nb1= 5 (Leak1: HV) 이어도  
                //    SysSet13.m_nSet16= 1 ("LV Short Use" ON) 이므로 LV Short Test를 진행한다.
                if (SysSet13.m_nSet16 == 1)//sylee170211-2                              
                {
                    double dSet2;
                    //sylee200917   dSet2=500000.0;
                    if (nHRUse != 1) {//sylee201116-1
#if (defined(__NANOSYS__CUSTOMER) || defined(__LM__CUSTOMER))   //SYLEE211020add   //son220915_2
                        dSet2 = 5000000.0;//sylee200917  //sylee210215 
#else
                        dSet2 = 1000000.0;//sylee201116-1    100000->1000000
#endif

                        nFastHv1_LV_2 = (int)RCalCovert(MODE207_HR_SHORT_10V, dSet2, REAL_TO_RAW, PART_UPPER); //sylee170212-2    //son220412 
                        if (nFastHv1_LV_2 < 500) {//sylee170212-2   //sylee170228
                            nFastHv1_LV_2 = 500;  //2M
                        }
                        if (nFastHv1_LV_2 > 5000) {//sylee170212-2  //sylee170228
                            nFastHv1_LV_2 = 5000;  //100k
                        }
                        //son nMod1=4: HR Short(LV) 로 Short Test를 호출한다.
                        //son m_nMode1 = 207(Short 10 V)
                        //son230202 //nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LV_2, step, 1);   //sylee150415 fasthv //sylee150417-5, for hdpark_spark_test
                        //son230202 nLeakMode default 매개변수 추가. Leak인데 HR 테스트일 때 출력은 Leak로 출력하기 위함.
                        nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LV_2, step, 1, nb1);   //son230202 nb1(nLeakMode) 추가
#ifndef _PC_TEST_
                        if (nRet == 0) { nProcessFail1 = 1; }
#endif
                    }

                }//sylee170211-2
                //====================================================

            }

            if (nFlagAutoPress1 == 2) {//sylee150413 autopress
                if (nb1 != TEST_OPEN) {
                    // AfxMessageBox("   \n\n  DebugCode 1    autopress  short skip        \n\n ");    //sylee150610-1
                    continue;
                }
            }

            if (nb1 == TEST_HR_SHORT) {//SYLEE150407
                nHVUse_Est_HR = 1;//SYLEE150407
            }
            else {
                nHVUse_Est_HR = 0;//SYLEE150407
            }


            if (nb1 == TEST_LEAK1 || nb1 == TEST_LEAK2) //sylee140923
            {

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
                //sylee230807 //sylee230323	nHVUse_Est=1;//SYLEE140210
                nHVUse_Est=0;//sylee230323  //sylee230807
#else
                nHVUse_Est=1;//SYLEE140210	
#endif

                if (nb1 == TEST_LEAK1) {//sylee140923-1
                    g_VSet3 = (int)dRec[(int)nProStep1[TEST_LEAK1][3]][3]; //son test mode
                }
                if (nb1 == TEST_LEAK2) {//sylee140923-1
                    g_VSet3 = (int)dRec[(int)nProStep1[TEST_LEAK2][3]][3];
                }

#ifndef __QUAD_LEAK1_LEAK2__  //son231122
                if(g_VSet3_old!=g_VSet3){//sylee140923-1									   
                    Sub71.AOnVBSet1(3,g_VSet3);// int nVRel, int nVSet,  
                    g_VSet3_old=g_VSet3;
                }
#endif                

            }

            nShCo1 = 0;
            for (int g1 = 1; g1 <= g_nPieceMax1; g1++) {  //sylee20111210
                if (nShortFail1[g1] > 0) {
                    nShCo1++;
                }
            }

            //sylee230420  if ((SysSet13.m_nSet18 == 1) && (nb1 == TEST_OPEN)) {//sylee170712-1
		    if (nb1 == TEST_OPEN) {//sylee170712-1//sylee230420 

            }
            else {//sylee170712-1
                if (nShCo1 == g_nPieceMax1) {
                    //AfxMessageBox("   \n\n  DebugCode 3     short skip        \n\n ");    //sylee150610-1
                    continue;
                }
            }//sylee170712-1

            if (nManualStartFlag == 1) {//sylee130225joytech
                g_nSkipPieceFlag1 = 0;//sylee160203-ITS     //son220624
                ::ZeroMemory(&g_nSkipPieceInfo, sizeof(g_nSkipPieceInfo));//sylee160203-ITS     //son220624
                if (SysSet13.m_nSet11 != 1) {
                    nBlockCountP = 1;
                }
                nAutoReTest[nBlockCountP] = gRun05.m_nReCh;
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));
            }

            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh)//sylee121129                     
            {

                //sylee170807-5 if( nb1!=1 && nb1!=7 && nb1!=5 && nb1!=6){ //lv short//sylee140923
                if (nb1 != TEST_OPEN && nb1 != TEST_4W) { //sylee170807-5  

                    //son piece별 open pass 개수를 센다.
                    nReFlagOpenCur[0] = 0;
                    for (int g1 = 1; g1 <= g_nPieceMax1; g1++) {  //sylee20111210
                        if (nReFlagOpenCur[g1] == 1) { //  1 PASS
                            nReFlagOpenCur[0] = nReFlagOpenCur[0] + 1;
                        }
                    }

                    if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                        if (nReFlagOpenCur[0] == 0) {
                            continue;
                        }
                    }

                }
                else if (nb1 == TEST_LEAK1 || nb1 == TEST_LEAK2) {//hv  //sylee140923
                    nReFlagLvCur[0] = 0;
                    for (int g1 = 1; g1 <= g_nPieceMax1; g1++) {  //sylee20111210                                                    
                        if (nReFlagLvCur[g1] != 2) { //  1 PASS, no test //sylee150425-1 import
                            nReFlagLvCur[0] = nReFlagLvCur[0] + 1;
                        }
                    }
                    if (nLvFlag == 1) {//sylee131118
                        if (nReFlagLvCur[0] == 0) {
                            //  AfxMessageBox("   \n\n  DebugCode 2     short skip        \n\n "); //sylee150610-1
                            continue;
                        }
                    }
                }
            }

            int  n4WRunFlag;

            //sylee140923   if( nb1==6)  //4w //sylee20120306   //4WCODE_131118
            if (nb1 == TEST_4W) //4w //sylee20120306   //4WCODE_131118 //sylee140923
            {

                n4WRunFlag = 0;
                for (int k2 = 1; k2 <= g_nPieceMax1; k2++) {
                    if ((nManualStartFlag == 1)
                        || (nAutoReTest[nBlockCountP] == 0 && nOpenFail1[k2] == 0 && nShortFail1[k2] == 0)
                        || ((nAutoReTest[nBlockCountP] > 0) && nOpenFail1[k2] == 0 && nShortFail1[k2] == 0)) {//sylee131118
                        n4WRunFlag = 1;
                    }
                }

                if (n4WRunFlag == 0) {
                    step = 10;
                    continue;
                }
            }

          
            if (nb1 != TEST_4W) {//sylee140923
                nb2 = (int)nProStep1[nb1][3];          // mode 1~65     //son 해당 step(ex: Open)의 m_nMode값 (test mode)
                nb3 = (double)nProStep1[nb1][2];       // R  RAW        //son 해당 step(ex: Open)의 Cal 미적용 저항값
                nProRv1Real = (int)nProStep1[nb1][1];   // R  REAL       //son 해당 step(ex: Open)의 Cal 적용 저항값
//MyTrace(PRT_BASIC, "AProcess101()Line_%d: nb1=%d, nProRv1Real=%d, nProStep1[nb1][1]=%.0f\n", __LINE__, nb1, nProRv1Real, nProStep1[nb1][1]);
                //if(nFlag_Open_SetStart>0){//sylee150428

                if (nFlag_Open_SetStart > 0) {//sylee150428
                    if (step == nFlag_Open_SetStart) {//sylee150428
                        if (nb1 == TEST_OPEN) {//sylee150428
                            nFlag_Open_SetMode = nb2;//sylee150428
                        }
                    }
                }

            }

            //son 4W라면
            else {
                nb2 = 70;  // mode 1~65    R 
                nb3 = 0;  // R  RAW
                nProRv1Real = 0;  // R  RAW  REAL 
            }

            if (nb1 > 0)
            {
                if ((nBDLData2[1][0][1] < 1) && (nb1 == TEST_OPEN)) {
                    str.Format("Error No 7301 , \n\n\n   OPEN LIST IS ZERO. \n\n\n  [FILE]->[FILE OPEN]-> BDL SET!!!   CHECK? \n\n  OPEN RUN START STOP. \n\n   ");
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                    str.Format(" OPEN LIST IS ZERO.  [FILE]->[FILE OPEN]-> BDL SET !!!  ");
                    nFailCount[TEST_OPEN] = -1;//son210331 enum
                }

                //son SHORT, LEAK  인 경우
                if ((nb1 < TEST_4W) & (nb1 > TEST_OPEN)) { //sylee140923
                    if (nBDLData3[1][0][1] < 1) {
                        str.Format("Error No 7302 ,\n\n\n SHORT LIST IS ZERO. \n\n \n FILE BDL SET CHECK?   !!! \n\n\n SHORT(uS,HR,HV,S)RUN START STOP.\n  ");
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str);
                        nFailCount[TEST_OPEN] = -1;//son210331 enum
                    }
                }

                //son AProcess101()의 step 수행시작 표시
                nProcessFlag1 = 1;//SYLEE111225                    
                nDualFlag = 0;
                Sub71.m_nTestMode = nb2;        // hdpark230105 spark
                //-------------------------------
                //son 4W 검사
                //-------------------------------
                if (nb1 == TEST_4W)//4w //sylee140923  
                {

                    DisplayStatus_TestMode(TEST_4W); //SYLEE131118   //son220824
                    if (g_s4WNet[dutIdx].wCount >= 0) //sylee140210        //son190704-4WDUT16
                    {
                        //-------------------------
                        //son 4W Auto Sampling 
                        if (n4w_Sample_Enable == 1)//sylee160407-1   //sylee160518 
                        {

                            //===================================================================
                            int ipEnd3, ipEnd3_Err;  //sylee161122
                            ipEnd3_Err = 0;


                            //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
                            if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
                            {
                                ipEnd3 = SysInfoPieceRange.m_nPieceCount[nMulNetFlag];
                            }
                            else {
                                ipEnd3 = SysInfoPieceRange.m_nPieceCount[1];
                            }
                            for (int ip3 = 1; ip3 <= ipEnd3; ip3++) { //sylee161122                                                                                     
                                if (nOpenFail1[ip3] > 0 || nShortFail1[ip3] > 0) {
                                    ipEnd3_Err++;
                                    break;
                                }
                            }
                            //==============================================================================
                            //son 모든 piece에 Open Fail이 없다면 4w Sampling 수행
                            if (ipEnd3_Err == 0) {  //sylee161122
                                Sleep(300); //100ms   //sylee160603
                                //son 4W Auto Sampling 함수 -------   
                                nRet = ARun201_4w_3(step);
                            }
                        }


                        //-------------------------
                        //son 4W 측정 
                        else//sylee160407-1
                        {
                            //son 4W 측정 함수
                            nRet = ARun201_4w_3(step);   //sylee200515-patch
#ifndef _PC_TEST_
                            if (nRet == 0) { nProcessFail1 = 1; }
#endif

                        }//sylee160407-1
                    }
                    else {
                        str.Format("\n\nError No 7401      ,\n\n\n   4W NetList < 0  !!!     \n\n\n  4W FILE CHECK!        \n\n\n ");
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str);
                    }
                    ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    nRun1 = 1;

                }

                //-------------------------------
                //son Open 검사
                //-------------------------------
                else if (nb1 == TEST_OPEN)// 1:open
                {

                    DisplayStatus_TestMode(TEST_OPEN); //SYLEE131118 //son220824


#ifdef DEFINE_FAKEOPEN //sylee170415
                    nRet = ARun201_O31_F(nb1, nb2, nb3, step);   //SYLEE180412 FAKEOPEN ADD
#else  //DEFINE_FAKEOPEN //sylee170415 

                    //sylee120901   
                    nRet = ARun201_O11(nb1,  //son TEST_TYPE (1:TEST_OPEN)
                                       nb2,  //son Test mode (m_nMode1:  1~ 65 사이의 recipe 위치)
                                       nb3,  //son nProRv1 : Test mode의 기준 R값 (R RAW, Cal 미적용 R)
                                       step);//son Test step. TEST_OPEN 연관 
#endif//DEFINE_FAKEOPEN //sylee170415

#ifndef _PC_TEST_
                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                    nRun1 = 1;

                    //===============================================================================================================================
                }

                //-------------------------------
                //son Short 검사
                //-------------------------------
                else// SHORT    //if(nb1!=TEST_OPEN)
                {

                    //------------------------------------------------
                    //son Testmode가 216: MODE216_LEAK_30V  이상이면
                    //sylee130702    if( nb2>=61 && nb2<=70 ){  //hv 
                    if (nb2 >= MODE216_LEAK_30V)     //hv  //sylee130702  
                    {
                        //M&M       
                        if (nb1 != TEST_LEAK2) {//SYLEE140923
                            DisplayStatus_TestMode(TEST_LEAK1); //SYLEE120925   //son220824
                        }
                        else {
                            DisplayStatus_TestMode(TEST_LEAK2); //SYLEE140923   //son220824
                        }//SYLEE140923  

                        //sylee170614///////////////////////////////////////////////////////    

                        int nShortFlag1;
                        nShortFlag1 = 0;

                    
                        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
                        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
                        {
                            g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[nMulNetFlag];
                        }
                        else {
                            g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[4];
                        }
                        for (int ipk3 = 1; ipk3 <= g_nPieceMax1; ipk3++) {
                            if (nShortFail1[ipk3] > 0) {
                                nShortFlag1 = 1;
                            }
                        }
                        //sylee170614///////////////////////////////////////////////////////


                        if (nCycleRunFlag != 2 && nProOneP_Flag1 == 2   //son nProOneP_Flag1 2: model make 일 때
                            && ((nFailCount[TEST_OPEN] == 0 && nFailCount[TEST_SHORT] == 0 && nFailCount[TEST_HR_SHORT] == 0)//son210331 enum
                                || (nAutoReTest[nBlockCountP] == 0 && gRun05.m_nReCh == 0))
                            && nProOneP_RunFlag1 == 1
                            && (nReSheetFlag1 != 1))  //sylee140429-1
                        {
                            if ((nFlagEstModelMake < 1) && (nProStep1[TEST_LEAK1][1] < 50000000)) //sylee151109-2 //sylee151202
                            {
                                //if(nShortFlag1==0)   //sylee170614-1
                                if ((SysInfo05.m_nShortDisable1 != 7) && (nShortFlag1 == 0)) {//sylee180331-1 
                                    //son nProType  2: One piece 통검사
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 2);     //sylee160803-1 
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }
                                else {//sylee170614-1
                                    nRet = 0;//sylee170614-1
                                }//sylee170614-1

                                if (nRet != 1) {//sylee150423-3          //sylee150611   
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);   //multi piece
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }

                            }
                            else {//sylee151109-2
                                nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);  //multi piece
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif

                            }//sylee151109-2

                        }
                        else if (nCycleRunFlag != 2 && nProOneP_Flag1 == 3  //son nProOneP_Flag1 3: run  etc  disable 일 때
                            && ((nFailCount[TEST_OPEN] == 0 && nFailCount[TEST_SHORT] == 0 && nFailCount[TEST_HR_SHORT] == 0)//son210331 enum
                                || (nAutoReTest[nBlockCountP] == 0 && gRun05.m_nReCh == 0))
                            && nProOneP_RunFlag1 == 1
                            && (nReSheetFlag1 != 1))   //sylee150618
                        {

                            if (nProOneP_RunFlag1 == 1) {//sylee131018 //pass
                                if (nProOneP_ModelCheck1 == 1) {//sylee131018
                                    nProOneP_ModelCheck1 = 2; // mode retry no//sylee131018
                                }
                            }

                            if (nProOneP_RunFlag1 == 0)
                            {

                                if (nProOneP_ModelCheck1 == 1) {//sylee131018 //remodel 3
                                    nProOneP_ModelCheck1Retry++;//sylee131018                                                                         

                                    //remodel start                                                                       
                                    nProOneP_ModelCount1 = 0;
                                    ::ZeroMemory(&nProOneP_Short1_Co, sizeof(nProOneP_Short1_Co));
                                    ::ZeroMemory(&nProOneP_Open1, sizeof(nProOneP_Open1));
                                    ::ZeroMemory(&nProOneP_Short1, sizeof(nProOneP_Short1));//sylee131012
                                    nProOneP_ModelCheck1 = 0;//sylee131018
                                    nProOneP_ModelCheck1Retry = 0;//sylee131018


                                    if (nProOneP_ModelCheck1Retry <= 3) {// remodel retry
                                        str.Format(" ***Model Retry Start=%d *** ", nProOneP_ModelCheck1Retry);       
                                        Label102_Cycle_SetCaption(str); //son240712
                                        //remodel start                                                                       

                                        //son BDL 파일 처음  로딩했을 때 표시
                                        nProOneP_Flag1 = 1;//model start
                                        nProOneP_RunFlag1 = 1;

                                    }
                                    else {   //over
                                        str.Format(" ***Model Retry =%d   Over End *** ", nProOneP_ModelCheck1Retry);       
                                        Label102_Cycle_SetCaption(str); //son240712

                                        nProOneP_Flag1 = 0;//not use   give up
                                        nProOneP_RunFlag1 = 0;
                                    }
                                }

                                //sylee150611 nRet=ARun201_S2_SQ2_HV_Re_VB(nb1 , nb2 , nb3 , step , 1 );  //one piece
                            }


                            if ((nFlagEstModelMake < 1) && (nProStep1[TEST_LEAK1][1] < 50000000)) //sylee151109-2  //sylee151202
                            {
                                if ((SysInfo05.m_nShortDisable1 != 7) && (nShortFlag1 == 0)) {//sylee180331-1 
                                    //son nProType  2: One piece 통검사
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 2);     //sylee160803-1
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }
                                else {//sylee170614-1
                                    nRet = 0;//sylee170614-1
                                }//sylee170614-1

                                if (nRet != 1) {//sylee150611    
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);  //multone piece  //sylee150611
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }

                            }
                            else {//sylee151109-2
                                nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);  //multone piece  //sylee150611
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif

                            }//sylee151109-2

                        }
                        else 
                        {

                            nProRv1_Est_nb3 = (int)nb3;//sylee130329//estimation

                            //sylee151202 if(nFlagEstModelMake<1){//sylee151109-2
                            if ((nFlagEstModelMake < 1) && (nProStep1[TEST_LEAK1][1] < 50000000)) //sylee151109-2  //sylee151202
                            {
                                if ((SysInfo05.m_nShortDisable1 != 7) && (nShortFlag1 == 0)) {//sylee180331-1 if(nShortFlag1==0){//sylee170614-1
                                    //son nProType  2: One piece 통검사
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 2);     //sylee160803-1
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }
                                else {//sylee170614-1
                                    nRet = 0;//sylee170614-1
                                }//sylee170614-1

                                if (nRet != 1) {//sylee150618                                                                   
                                    nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);   //normal  
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }
                            }
                            else {//sylee151109-2
                                nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);  //sylee151109-2
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif
                            }//sylee151109-2


                            if (nFlagEstModelMake == 1 && SysSet16.m_nSet11 == 1) { //sylee130325//sylee130404//estimation
                                nProRv1_Est_nb1 = (int)nb1;//sylee130325 
                                nProRv1_Est_nb2 = (int)nb2;//sylee130325 
                                nProRv1_Est_nb3 = (int)nb3;//sylee130325 
                                nProRv1_Est_i = (int)step;//sylee130325 
                            }

                        }


                        //son 안쓰는 코드
                        if ((SysInfo05.m_nProSpMode == 2 || SysInfo05.m_nProSpMode == 4) && nFlagEstModelMake == 1 && SysSet16.m_nSet11 == 1) { //sylee150417-1
                            if (nCycleRunFlag != 2 && (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)
                                && nFailCount[TEST_OPEN] == 0 && nFailCount[TEST_SHORT] == 0 //son210331 enum
                                && nFailCount[TEST_HR_SHORT] == 0 && nProOneP_RunFlag1 == 1  //son210331 enum
                                && (nReSheetFlag1 != 1))
                            {
                                nProRv1_Est_nb1 = (int)nb1;
                                nProRv1_Est_nb2 = (int)nb2;
                                nProRv1_Est_nb3 = (int)nb3;
                                nProRv1_Est_i = (int)step;
                            }
                        }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//	if (nFastHv1RunStep == 2) {   nFastHv1RunStep=0; }//sylee230815-3  import

                        if (nFastHv1RunStep == 2) //sylee150415 fasthv
                        {

                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            //son High Voltage 처리 하기 전에 LV를 한번 더 체크한다.


                            if (nLV_No == 207) {//sylee150605
                                if (nFastHv1_LVAd1 < 200) {//sylee150417-5
                                    nFastHv1_LVAd1 = 200;
                                }
                                if (nFastHv1_LVAd1 > 5000) {//sylee150427
                                    nFastHv1_LVAd1 = 5000;
                                }
                                //nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LVAd1, step, 1);   //sylee150415 fasthv //sylee150417-5
                                nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LVAd1, step, 1, nb1);   //son230202 nb1(nLeakMode) 추가
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif

                            }
                            else {//sylee150605
                                if (nFastHv1_LVAd2 < 200) {//sylee150605
                                    nFastHv1_LVAd2 = 200;//sylee150605
                                }
                                if (nFastHv1_LVAd2 > 5000) {//sylee150605
                                    nFastHv1_LVAd2 = 5000;//sylee150605
                                }
                                //nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LVAd2, step, 1);   //sylee150605    //sylee170620
                                nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LVAd2, step, 1, nb1);   //son230202 nb1(nLeakMode) 추가
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif
                            }//sylee150605  

                            //son High Voltage 체크
                            if (nFastHv1RunStep == 3) {
                                nRet = ARun201_S2_SQ2_HV_Re_VB(nb1, nb2, nb3, step, 1);   ////sylee150415 fasthv
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                nFastHv1RunStep = 5;      //son 진행 경로를 써둔다. 5번째 step이라는 뜻
                            }
                            else {
                                nFastHv1RunStep = 4;
                            }

                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                        }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				 
                    }

                    //----------------------------------------------------------
                    //son  Testmode가 216(MODE216_LEAK_30V)보다 작으면 
                    else
                    {
                        //son dRec nVSet이 20V 보다 크면 
                        if (dRec[nb2][3] > 20) {  //    hv   r read
                            AfxMessageBox(" ERROR 7111 !  HV RUN ERROR.   HV No<216  , Vot.>20   ARun201_S2_Leak1 start ", MB_OK); //SYLEE150427
                            if (nb1 != TEST_LEAK2) {//SYLEE140923
                                DisplayStatus_TestMode(TEST_LEAK1); //SYLEE120925       //son220824
                            }
                            else {
                                DisplayStatus_TestMode(TEST_LEAK2); //SYLEE140923       //son220824
                            }//SYLEE140923                                                       


                        }

                        //son dRec nVSet이 20V보다 작거나 같으면
                        else    //lv   r read 
                        {
                            DisplayStatus_TestMode(TEST_SHORT);   //son220824 
                            if (nManualStartFlag == 1) {
                                DoEvents();
                            }
                            ///////////////////////////////////////////////////////////////////////////////////////////////////
                            //sylee131221                            
                            if (nProOneP_Flag1 == 3) {
                                nProOneP_Flag1 = 4;//sylee140429-2 
                            }

                            //-------------------------------
                            //son 일반적인  Short 검사
                            //-------------------------------
                            if ((nCycleRunFlag != 2 && nProOneP_Flag1 == 1 && nFailCount[TEST_OPEN] == 0) //son210331 enum 
                                || (nReSheetFlag1 == 1))//SYLEE140429-1
                            {

                                nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 1);   // normal 
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif

                                if (nFailCount[TEST_SHORT] == 0 && nFailCount[TEST_HR_SHORT] == 0)   //son210331 enum 
                                {

                                    if ((nProOneP_RunFlag1 == 1) && (nReSheetFlag1 != 1)) {//sylee131010 //SYLEE140429-1
                                        str.Format(" ***Model Start*** ");
                                        Label102_Cycle_SetCaption(str); //son240712
                                        DoEvents();
                                        //sylee131010
                                        //sylee150622    nRet=ARun201_LV_OneModel(nb1 , nb2 , nb3 , step ,2);
                                        nRet = ARun201_LV_OneModel(nb1, nb2, 2000, step, 2);
                                        //str.Format(" Model End " );       Label102_Cycle_SetCaption(str); //son240712
                                        if (nProOneP_Short1_Co == 0) {
                                            //son Short가 없으면 model make (BDL file 정상여부 체크중) 표시
                                            nProOneP_Flag1 = 2;   
                                            nProOneP_ModelCheck1 = 0;//sylee131018
                                        }
                                        else {
                                            //son Short가 있으면 'run etc disable' 표시
                                            nProOneP_Flag1 = 3; 
                                            nProOneP_ModelCheck1 = 1;//sylee131018
                                            ARun201_Short_Model1();  //sylee150622
                                        }
                                    }//sylee131010

                                }

                            }

                            //son nCycleRunFlag!=2 : Jig Test가 아니라면 
                            //    nProOneP_Flag1==2: BDL 파일 정상여부 체크중이라면 
                            //    nProOneP_RunFlag1==1 : 위와 비슷한 의미  ????
                            //    nFailCount[TEST_OPEN]==0     : Open Fail이 없다면
                            else if (nCycleRunFlag != 2 && nProOneP_Flag1 == 2  //sylee131022 nCycleRunFlag!=2 && 
                                && nFailCount[TEST_OPEN] == 0 && nProOneP_RunFlag1 == 1)  //son210331 enum
                            {
                                if (SysInfo05.m_nShortDisable1 != 7) {//sylee180714-1  //sylee180331-1 
                                    if (g_nSkipPieceFlag1 != 1) {//sylee160203-ITS        //son220624
                                        str.Format(" I Mode 2  Start ");
                                        Label102_Cycle_SetCaption(str); //son240712
                                        nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 2);  //one piece
                                    }
                                    else {//sylee160203-ITS
                                        nProOneP_RunFlag1 = 0;//sylee160203-ITS
                                    } //sylee160203-ITS
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif

                                    if (nProOneP_RunFlag1 == 0) {
                                        //str.Format(" I Mode 2  Fail ");       
                                        str.Format(" I Mode 2-2  Start ");   //son220908 sylee confirm 
                                        Label102_Cycle_SetCaption(str); //son240712
                                        nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 1);  //  piece
#ifndef _PC_TEST_
                                        if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                    }

                                }
                                else { //sylee180714-1  lvshort multi piece
                                    //str.Format(" I Mode 2-2  Start ");       
                                    str.Format(" I Mode 1  Start ");    //son220908 sylee confirm    
                                    Label102_Cycle_SetCaption(str); //son240712
                                    nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 1);  //  piece  //sylee180714-1
                                }


                            }
                            else if (nCycleRunFlag != 2 && nProOneP_Flag1 == 3  //sylee131022 nCycleRunFlag!=2 && 
                                && nFailCount[TEST_OPEN] == 0 && nProOneP_RunFlag1 == 1)  //son210331 enum
                            {
                                str.Format(" I Mode 3  Start ");
                                Label102_Cycle_SetCaption(str); //son240712
                                nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 3);  //one piece shortlist
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif

                                if (nProOneP_RunFlag1 == 0)
                                {
                                    if (nProOneP_ModelCheck1 == 1) //sylee131018 //remodel 3
                                    {
                                        nProOneP_ModelCheck1Retry++;//sylee131018                                                                     

                                        //remodel start                                                                       
                                        nProOneP_ModelCount1 = 0;
                                        ::ZeroMemory(&nProOneP_Short1_Co, sizeof(nProOneP_Short1_Co));
                                        //sylee150611   ::ZeroMemory(&nProOneP_Short1_Li, sizeof(nProOneP_Short1_Li));
                                        ::ZeroMemory(&nProOneP_Open1, sizeof(nProOneP_Open1));
                                        ::ZeroMemory(&nProOneP_Short1, sizeof(nProOneP_Short1));//sylee131012
                                        nProOneP_ModelCheck1 = 0;//sylee131018
                                        nProOneP_ModelCheck1Retry = 0;//sylee131018                                                                       

                                        if (nProOneP_ModelCheck1Retry <= 3) {// remodel retry
                                            str.Format(" ***Model Retry Start=%d *** ", nProOneP_ModelCheck1Retry);
                                            Label102_Cycle_SetCaption(str); //son240712
                                            //remodel start                                                                       
                                            nProOneP_Flag1 = 1;//model start
                                            nProOneP_RunFlag1 = 1;

                                        }
                                        else {   //over
                                            str.Format(" ***Model Retry =%d   Over End *** ", nProOneP_ModelCheck1Retry);
                                            Label102_Cycle_SetCaption(str); //son240712
                                            nProOneP_Flag1 = 0;//not use   give up
                                            nProOneP_RunFlag1 = 0;
                                        }
                                    }

                                    //str.Format(" I Mode 3  Fail ");
                                    str.Format(" I Mode 3-2  Start ");      //son220908 sylee confirm 
                                    Label102_Cycle_SetCaption(str); //son240712
                                    nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 1);  //one piece
#ifndef _PC_TEST_
                                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                                }

                            }
                            else {
                                nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, step, 1);   //normal
#ifndef _PC_TEST_
                                if (nRet == 0) { nProcessFail1 = 1; }
#endif
                            }
                            ///////////////////////////////////////////////////////////////////////////////////////////////////                                                        
                        }

                    }

                    nRun1 = 1;
                }

                //----------------------------------------------
                //son nFailCountP2[nCellNo][testType]  결정.
                //----------------------------------------------
                //son nFailCountP2[nCellNo][testType] 값을 여기서 결정하고 
                //    나중에   Graph 출력결과 및 Big Label 출력 결과등을 정해야 함
                if (nBlockMax == 1) {//sylee20120711
                    nBlockCountP = 1;
                }

                if (nPieceMax >= 1)  //sylee161214
                {
                    for (int ki = 1; ki <= nPieceMax; ki++)
                    {
                        nCellNo = nBlockPieceNo1[nBlockCountP][ki];//nBlockPieceNo1[blockno][pieceno]==CELLNO 
#ifdef _PC_TEST_
                        //son231019 아래 코드때문에 PC_TEST에서 4W 에러가 Grid Graph에 반영 안되는 현상 발생하여 삭제함 
                        //son231019 nFailPiece[ki][step] = 0;  //son220904 테스트를 위해 강제로 모든 step pass 설정. 
#endif
                        nFailCountP2[nCellNo][nb1] = 0; //son220904 retest로 pass인 cell이 노란색(open)으로 남는 현상관련 초기화추가
                        if (nFailPiece[ki][step] > 0) {////PIECE  error count //sylee20120314                                       
                            nFailCountP2[nCellNo][nb1] = 1;//ki=>PIECE      ,  nb1  ==> //  [1]=open   2 ushort    3  short   4  hr    5  hv   
                        }

                        //son220823 11:TEST_ALL_OPEN,  12:TEST_ALL_SHORT
                        nFailCountP2[nCellNo][TEST_ALL_OPEN] = nFailCountP2[nCellNo][TEST_OPEN] + nFailCountP2[nCellNo][TEST_4W];// PIECE OPEN TOTAL  ( OPEN +  4W )
                        nFailCountP2[nCellNo][TEST_ALL_SHORT] = nFailCountP2[nCellNo][TEST_U_SHORT]
                            										+ nFailCountP2[nCellNo][TEST_SHORT] 
																	+ nFailCountP2[nCellNo][TEST_HR_SHORT]
                            										+ nFailCountP2[nCellNo][TEST_LEAK1] 
																	+ nFailCountP2[nCellNo][TEST_LEAK2];// PIECE SHORT TOTAL                                     

                    }
                }


                tStart1 = GetuSecond();

                //son AProcess101()의 step 수행 종료  표시
                nProcessFlag1 = 0;//SYLEE20111225


                if (nRet != 1) {//PROCESS FAIL
                    nFailCount[TEST_OPEN] = 999;          //son210331 enum
                    nFailCount[TEST_U_SHORT] = 999;    //son210331 enum
                    nFailCount[TEST_SHORT] = 999;      //son210331 enum
                    nFailCount[TEST_HR_SHORT] = 999;   //son210331 enum
                    nFailCount[TEST_LEAK1] = 999;      //son210331 enum
                    nFailCount[TEST_LEAK2] = 999;//sylee140923 hv2 //son210331 enum
                }

            }//END OF if( nb1>0) 

            Sub71.AIRangeOff();// I range all off
            Sub71.AIVBOff();//VB OFF    

            nFailCount[TEST_ALL_SHORT] = nFailCount[TEST_U_SHORT] + nFailCount[TEST_SHORT]         //son210331 enum
                + nFailCount[TEST_HR_SHORT] + nFailCount[TEST_LEAK1]
                + nFailCount[TEST_LEAK2];//sylee140923 hv2


            if (nSelfTestHWError1 == 1) {//SYLEE141030
                break;
            }


            //====================================================

            //son191212:  재검을 했는데 Short가 발생하지 않은 경우  Leak1(HV) Test라면 LV Test를 한번 더 해야 한다.
            //    ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT , 207 ,  nFastHv1_LV_2 , step , 1 );  호출 부분. 
            //    유출을 막기 위한 것으로 양산 버전에 꼭 필요한 코드임.
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
			nShortRetestFlag1=0;//sylee230815

            if (nShortRetestFlag1 == 1)//sylee170618-1
            {
                if (nb1 == TEST_LEAK1)
                {
                    nHVDidFlag = 1;//sylee150426-3
                    if (nLV1 == 1) {//sylee150415 fasthv //sylee150531
                        nFastHv1RunStep = 1;//sylee150415 fasthv
                    }
                    else {
                        nFastHv1RunStep = 0;//sylee150415 fasthv
                    }

                    double dSet2;
                    dSet2 = 10000000.0;//10M  //sylee170620  


                    nFastHv1_LV_2 = (int)RCalCovert(MODE207_HR_SHORT_10V, dSet2, REAL_TO_RAW, PART_UPPER); //sylee170212-2 //son220412 

                    if (nFastHv1_LV_2 < 500) {//sylee170212-2   //sylee170228
                        nFastHv1_LV_2 = 500;  //2M
                    }
                    if (nFastHv1_LV_2 > 5000) {//sylee170212-2  //sylee170228
                        nFastHv1_LV_2 = 5000;  //100k
                    }

                    //nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LV_2, step, 1);   //sylee150415 fasthv //sylee150417-5
                    nRet = ARun201_S2_SQ2_LV_Re_VB(TEST_HR_SHORT, MODE207_HR_SHORT_10V, nFastHv1_LV_2, step, 1, nb1);  //son230202 nb1(nLeakMode) 추가
#ifndef _PC_TEST_
                    if (nRet == 0) { nProcessFail1 = 1; }
#endif
                    //  }//sylee170211-2
                }

            }//end of  if(nShortRetestFlag1==1)  //sylee170618-1
//////////////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////////////
			//====================================================

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
          /*  if(nb1>0){    //sylee230807
                Sub71.OnVBRelay2(1,OFF);	 Sub71.OnVBRelay2(2,OFF);	 Sub71.OnVBRelay2(3,OFF);//sylee230321
                Sub71.OnVBRelay2(4,OFF);	 Sub71.OnVBRelay2(5,OFF);	 Sub71.OnVBRelay2(6,OFF);//sylee230321
                Sub71.OnVBRelay2(7,OFF);	 Sub71.OnVBRelay2(10,OFF);   //sylee230321
            }
			*/

            if( nFlagLeak12==1 || nFlagLeak12==2 ){//sylee230315-1 //sylee230321  //sylee230807
                if(nb1==TEST_LEAK1){
                    Sub71.AOnVBSet1(4,nFlagLeak12_Vol6);  

                }
                if( nb1==TEST_LEAK2 ){//sylee230315-1
                    nFlagLeak12Run1=1;//sylee230324
                    Sub71.AOnVBSet1(4,nFlagLeak12Voltage[1]);  
                }
            }

            if( nFlagLeak12==1 || nFlagLeak12==2 ){//sylee230315-1 //sylee230321   //sylee230807
                if(nb1==TEST_OPEN){					 
                    Sub71.AOnVBSet1(4,nFlagLeak12_Vol6);  
                }		       
            }
            if(step==7){   //sylee230807
                if(  nFlagLeak12==1 ||  nFlagLeak12==2 ){  //sylee230321 
                    Sub71.AOnVBSet1(4,nFlagLeak12Voltage[1]);  
                }
            }
#endif  //son231122
        }//END OF for( step=1; step<=7; step ++)

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
        if(nFlagLeak12Run1 !=1){//sylee230324  //sylee230807
            Sub71.AOnVBSet1(4,nFlagLeak12Voltage[1]);  
        }
#endif  //son231122

        if (nProcessFail1 != 0) {//sylee170415
            nFailL1CoOpen = 1;
            nFailL1Co = 1;
        }
        //SYLEE150508   ????
        nFastHv1RunStep = 0;//sylee150415 fasthv

        for (int ki = 1; ki <= nPieceMax; ki++) {    //sylee121129
            if (nReFlagOpenCur[ki] == 1) {  //son 1:Pass
                nReFlagOpenOld[ki] = 1;
            }
        }

        //===========================================================================================================
        //--------------------------------------
        //son BigLabel 출력을 위한 gRun20  결정 
        //--------------------------------------
        tStart1 = GetuSecond();

#if 0 //#ifdef _PC_TEST_
        for (i = 1; i <= 15; i++)              //son220904 테스트를 위해 모두 pass로 설정
            nFailCount[i] = 0;
        nFailL1CoOpen = 0; 
        nFailL1Co = 0;
#endif
        //SYLEE150426-2  b=(tStart1-tStart2)/1000000.;

        b = (tStart1001 - tStart1002) / 1000000.;//SYLEE150426-2  //SYLEE150509
        dProT1 = b;

        if (nFailCount[TEST_OPEN] > 0 || g_n4WFailCount > 0) { //son210331 enum
            gRun20.m_nOpen = 1;
        }
        else {
            gRun20.m_nOpen = 0;
        }

        if (nFailCount[TEST_ALL_SHORT] > 0) {   //son210331 enum
            gRun20.m_nShort = 1;
            if (nCycleRunFlag == 2) {
                nCycleRunShort++;
            }

        }
        else {
            gRun20.m_nShort = 0;
        }


        if (nFailCount[TEST_OPEN] < 0) {//PROCESS ERROR //son210331 enum
            gRun20.m_nPass = 0;
            gRun20.m_nFail = 1;//???
            str.Format("Block=%d: Process Error  T=%4.2fS", nBlockCountP, b);

        }
        else if (((nFailCount[TEST_OPEN] > 0) && (nFailCount[TEST_ALL_SHORT] > 0))         //son210331 enum
            || ((g_n4WFailCount > 0) && (nFailCount[TEST_ALL_SHORT] > 0))) {  //SHORT+OPEN
            gRun20.m_nOpenShort = 1;
            gRun20.m_nPass = 0;
            gRun20.m_nFail = 1;
            gRun20.m_nShort = 1; //sylee130805
            str.Format("Block=%d: O+S,  T=%4.2fS", nBlockCountP, b);

        }
        else if ((nFailCount[TEST_OPEN] == 0) && (nFailCount[TEST_ALL_SHORT] == 0) && (g_n4WFailCount == 0)) {    //PASS  //son210331 enum

            gRun20.m_nOpenShort = 0;
            gRun20.m_nOpen = 0;
            gRun20.m_nPass = 1;
            gRun20.m_nFail = 0;
            gRun20.m_nShort = 0;
            str.Format("Block=%d: PASS,  T=%4.2fS", nBlockCountP, b);

        }
        else if ((g_n4WFailCount > 0) || (nFailCount[TEST_OPEN] > 0)) {  //OPEN   //son210331 enum

            gRun20.m_nOpenShort = 0;
            gRun20.m_nOpen = 1;
            gRun20.m_nPass = 0;
            gRun20.m_nFail = 1;
            gRun20.m_nShort = 0;
            str.Format("Block=%d: OPEN, T=%4.2fS", nBlockCountP, b);

        }
        else if (nFailCount[TEST_ALL_SHORT] > 0) {//SHORT      //son210331 enum
            gRun20.m_nOpenShort = 0;
            gRun20.m_nOpen = 0;
            gRun20.m_nPass = 0;
            gRun20.m_nFail = 1;
            gRun20.m_nShort = 1;
            str.Format("Block=%d: SHORT, T=%4.2fS", nBlockCountP, b);

        }
        else {  //예외 
            gRun20.m_nOpenShort = 0;
            gRun20.m_nOpen = 0;
            gRun20.m_nPass = 0;
            gRun20.m_nFail = 1;
            gRun20.m_nShort = 0;
            str.Format("Block=%d: ?,   T=%4.2fS", nBlockCountP, b);
        }



        /////////////////////////////////////////////////////////////////////////////////////////////////

        for (int j1 = 1; j1 <= g_nPieceMax1; j1++) //sylee120924
        {
            if (nShortFail1[j1] > 0) {
                nCellNo = nBlockPieceNo1[nBlockCountP][j1]; //sylee130515

                //son all short count 1로 설정   
                //sylee130515   nFailCountP2[j1][12]=1;                 
                nFailCountP2[nCellNo][TEST_ALL_SHORT] = 1;//sylee130515  //son220823 12:TEST_ALL_SHORT

                gRun20.m_nShort = 1;

                if (gRun20.m_nOpen == 1) {
                    gRun20.m_nOpenShort = 1;
                }
                else {
                    gRun20.m_nOpenShort = 0;
                }
            }

           //sylee230420  if (SysSet13.m_nSet18 == 1) {
            if (nShortFail1[j1] == 0 && nOpenFail1[j1] == 0) {//sylee171120-1                     
                nPass2[j1] = 1;      nPass2Flag = 1;//sylee171120-1
            }//sylee171120-1
           //sylee230420  }


        }

        //---------------------------------------------------------------------
        //son nDioS2(메인장비 응답 값), nRetStatus(for nBlockRes[nCellNo]) 결정
        //---------------------------------------------------------------------
        nDioS2 = 0;
        nCycleFlag = 0;//sylee20120818

        if (gRun20.m_nOpenShort == 1) {
            nRetStautus = BLOCK_RES_O_S;        //son220823 4: BLOCK_RES_O_S
            nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN);  //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler //son231016
        }
        else if (gRun20.m_nShort == 1) {
            nRetStautus = BLOCK_RES_SHORT;      //son220823 3: BLOCK_RES_SHORT
            nDioS2 = DOUT_CMD_SHORT;                //son 'SHORT(0x02)' IO Command : for Handler    //son231016
        }
        else if (gRun20.m_nOpen == 1) {
            nRetStautus = BLOCK_RES_OPEN;       //son220823 2: BLOCK_RES_OPEN
            nDioS2 = DOUT_CMD_OPEN;                 //son 'OPEN(0x04)' IO Command : for Handler //son231016
        }
        else if (gRun20.m_nPass == 1) {
            nRetStautus = BLOCK_RES_PASS;       //son220823 1: BLOCK_RES_PASS
            nDioS2 = DOUT_CMD_PASS;                 //son 'PASS(0x01)' IO Command : for Handler //son231016
            nCycleFlag = 1;//sylee20120818
            ::ZeroMemory(&nConFailoldOpen, sizeof(nConFailoldOpen));//sylee210115-2
            ::ZeroMemory(&nConFail, sizeof(nConFail));//sylee210115-2
            ::ZeroMemory(&nConFailold, sizeof(nConFailold));//sylee210115-2
            ::ZeroMemory(&nConFailOpen, sizeof(nConFailOpen));//sylee210115-2
            ::ZeroMemory(&nConFail4w, sizeof(nConFail4w));//sylee210115-2
            ::ZeroMemory(&nConFailold4w, sizeof(nConFailold4w));//sylee210115-2
        }
        //////////////////////////////////////////////////////////////////////
        //SYLEE121003
        if (nFailL1Co > 0)
        {
            if ((gRun20.m_nOpenShort != 1) && (gRun20.m_nShort != 1)) {
                nDioS2 = 0;
                if (nFailL1CoOpen > 0) {
                    nRetStautus = BLOCK_RES_O_S;        //son220823 4: BLOCK_RES_O_S
                    nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN);  //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler //son231016
                }
                else {
                    nRetStautus = BLOCK_RES_SHORT;      //son220823 3: BLOCK_RES_SHORT
                    nDioS2 = DOUT_CMD_SHORT;                //son 'SHORT(0x02)' IO Command : for Handler    //son231016
                }
            }
        }

        if (nCycleRunFlag == 2) {
            nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN);           //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler    //son231016
        }


        /////////////////////////////////////////////////////////////////////////////////////
        if (g_CheckFlag1 == 2)//sylee12115
        {
            //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1
            str3 = "";
            str2.Format(" Error No 2112 !\n\n %s\\SETUP\\SysSet15.ini.  file Data Loading Error  \n\n\n", SysInfoView01.m_pStrFilePath1);
            str3 += str2;
            str2.Format(" file check!  SW reload!  \n\n\n\n    *******<  Don't Start!!!  >*********** \n\n\n\n");
            str3 += str2;
            str2.Format("    *******<  Calibration Data Loss.  Maker Engneer Call !!!  >*********** \n\n\n\n  Process Error. \n\n");
            str3 += str2;
            AfxMessageBox(str3, MB_OK); //error messege  //son210514
            MyTrace(PRT_BASIC, str3);   //son220823

            nFailCount[TEST_OPEN] = 999;          //son210331 enum
            nFailCount[TEST_U_SHORT] = 999;    //son210331 enum
            nFailCount[TEST_SHORT] = 999;      //son210331 enum
            nFailCount[TEST_HR_SHORT] = 999;   //son210331 enum
            nFailCount[TEST_LEAK1] = 999;      //son210331 enum
            nFailCount[TEST_LEAK2] = 999;//sylee140923 hv2     //son210331 enum

            nRetStautus = BLOCK_RES_O_S;        //son220823 4: BLOCK_RES_O_S
            nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN);  //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler //son231016
            nBuzzer1 = 1;//sylee160908-1

        } //sylee121115

        //======================================================================================

//son231229 #ifndef _PC_TEST_
#if 1
        //--------------------------------------
        //son nRetestFlag 결정 
        //--------------------------------------
        nRetestFlag = 0;
        if (nAutoReTest[nBlockCountP] <= gRun05.m_nReCh)  // retest  //SYLEE20120714 <=
        {
            nReFlagOpenOld[0] = 0;
            ////////////////////////////////////////////////////////////////
            //sylee201029 int g_nPieceMax1Enable,g_nPieceMax1Disable;//sylee130604

            if (SysInfo19.m_nUse == 1) {     //son "\\SETUP2\\BlockDis.ini"에서  PieceDisable Use (Use이면 1)                     
                g_nPieceMax1Disable = 0;
                for (i = 1; i <= g_nPieceMax1; i++) {//sylee130604
                    //son Piece Disable 체크
                    if (SysInfo19.m_nData[nBlockCountP][i] == 1) {// i=ip
                        g_nPieceMax1Disable++;
                    }
                }
                g_nPieceMax1Enable = g_nPieceMax1 - g_nPieceMax1Disable;//sylee130604
            }
            else {
                g_nPieceMax1Enable = g_nPieceMax1;//sylee130604
            }//end of if(SysInfo19.m_nUse==1)


            int  nCellNo;

            for (i = 1; i <= g_nPieceMax1; i++)
            {
                //son 메인장비에서 DIO[DIN_RESHEET] 신호를 받았다면
                if (nReSheetFlag1 == 1) //sylee131205
                {
                    //son i번째 piece가 open pass라면
                    if (nReFlagOpenOld[i] == 1) {  //SYLEE121129
                        nReFlagOpenOld[0] += 1;       //son pass 개수 증가 
                    }
                    else {
                        nCellNo = nBlockPieceNo1[nBlockCountP][i];//sylee131205
                        nCellNo = nReSheetRes[nCellNo];//sylee131205

                        //son  nReSheetRes[nCellNo] 가 BLOCK_RES_PASS 라면 
                        if (nCellNo == 1) {//sylee131205
                            nReFlagOpenOld[0] += 1;//sylee131205  //son pass 개수 증가 
                        }//sylee131205
                    }
                }
                else {//sylee131205
                    if (nReFlagOpenOld[i] == 1) {  //SYLEE121129
                        nReFlagOpenOld[0] += 1;
                    }
                }//sylee131205
            }

            if (nReFlagOpenOld[0] == g_nPieceMax1Enable) { //sylee130604
                nRetestFlag = 0; //son 모든 piece가 Open pass 이므로 retest 안 한다.
            }
            else {
                nRetestFlag = 1;
            }


            //sylee160524-2  4w recheck enable  (0:enable, 1: disable)  
            if (SysSet211.m_nDisable4wRetest != 1) { //son220503
                if (g_n4WFailCount > 0) {//sylee131118  //4WCODE_131118
                    nRetestFlag = 1;
                }
            }

            //son n4w_Sample_Enable이고 m_nSet17(Enable4wAutoSamplingRetest) ==1 이면
            if ((SysSet211.m_nSet17 == 1) && (n4w_Sample_Enable == 1) && (n4w_Sample_SetCount > 0)) {//sylee171104-1
                if (g_n4wSampleFailCo1 > 0) {//sylee171104-1
                    if (nFailL1CoOpen == 0) {
                        nAutoReTest[nBlockCountP]++; //sylee171104-1
                        nRetestFlag = 0;//sylee171106-2
                    }//sylee171104-1
                }
            }

        }


        if (nAutoReTest[nBlockCountP] == (gRun05.m_nReCh + 1)) {
            nRetestFlag = 0;
        }
#endif
        //////////////////////////////////////////////////////////////////////////////////      
        //------------------------------------------------
        //son DOUT_CMD_RETEST를 메인 장비로 보내야 할 지 결정
        //------------------------------------------------
        if (nRetestFlag == 1)
        {
            nAutoReTest[nBlockCountP]++;
            if (gRun20.m_nPass != 1) {//sylee120923
                if (nAutoReTest[nBlockCountP] <= gRun05.m_nReCh) {  // retest  //SYLEE20120714 <=
                    if (nManualStartFlag != 1) {//sylee130225joytech                                      
                        if (SysSet211.m_nDisable4wRetest != 1) {//sylee160524-2   //son 4w recheck enable (0:enable, 1: disable)    //son220503
                            if ((nFailL1CoOpen > 0) || (g_n4WFailCount > 0)) {//sylee140407
                                if (nFlagAutoPress1 != 2) {//sylee150413
                                    nDioS2 = DOUT_CMD_RETEST;  //sylee20120714  parkpongku  only retest signal      //son231016
                                }
                            }

                        }
                        else {//sylee160526-1
                            if ((nFailL1CoOpen > 0)) {//sylee140407
                                if (nFlagAutoPress1 != 2) {//sylee150413
                                    nDioS2 = DOUT_CMD_RETEST;  //sylee20120714  parkpongku  only retest signal      //son231016
                                }
                            }
                        }//sylee160524-2    

                    }
                }
            }
        }


        if (nDioS2 > DOUT_CMD_PASS && nDioS2 != DOUT_CMD_RETEST) {  //son231016
            nBuzzer1 = 1;//sylee160908-1  
        }


        if (nOpenUse1 == 1) {//sylee150627
            if (nFlagEstModelMake == 1 && SysSet16.m_nSet11 == 1 && nDioS2 == DOUT_CMD_PASS) { //sylee130325  //sylee130331 //sylee130404   //son231016
                if (nHVUse_Est == 1) {//SYLEE140210
                    nFlagEstModelMakeSelect = 2;//sylee130325    //estimation
                    //sylee170411       if((SysSet13.m_nSet18==1) &&(nFlagEstModelMake<1)&&(nProStep1[TEST_LEAK1][1]<50000000)){//sylee151109-2  //sylee151202   
                    if ((nFlagEstModelMake < 1) && (nProStep1[TEST_LEAK1][1] < 50000000)) { //sylee170411   
                        //sylee160803-1     nRet=ARun201_S2_HV_2N1(nProRv1_Est_nb1 , nProRv1_Est_nb2 , nProRv1_Est_nb3 , nProRv1_Est_i,2);
                        // if(nRet==0){ nProcessFail1=1; }
                        nRet = ARun201_S2_SQ2_HV_Re_VB(nProRv1_Est_nb1, nProRv1_Est_nb2, nProRv1_Est_nb3, nProRv1_Est_i, 2);   //sylee160803-1   
#ifndef _PC_TEST_
                        if (nRet == 0) { nProcessFail1 = 1; }
#endif
                    }
                    else {//sylee150508  squre est
                        nRet = ARun201_S2_SQ2_HV_Re_VB(nProRv1_Est_nb1, nProRv1_Est_nb2, nProRv1_Est_nb3, nProRv1_Est_i, 1);   //sylee121016tes 
#ifndef _PC_TEST_
                        if (nRet == 0) { nProcessFail1 = 1; }
#endif
                    }//sylee150508
                    nFlagEstModelMakeSelect = 0;//sylee130325    //estimation
                    nFlagEstModelMakeCount++;//sylee130325}
                }
            }
        }//end of if(nOpenUse1==1){//sylee150627


        if (nSelfTestHWError1 == 1) {//SYLEE141030
            nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN); //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler  //son231016
            nBuzzer1 = 1;//sylee160908-1   
        }

        //son Retest 시에는 error.txt (error.csv)를 로그하지 않는다. 
        if (nDioS2 == DOUT_CMD_RETEST) {        //son 'SHORT(0x02)+OPEN(0x04)' IO Command : for Handler //son231016
            m_nFileLog_Error = 0; //sylee130220 error file
        }
        else {
            m_nFileLog_Error = 1; //sylee130220 error file
        }

        if (n4w_Sample_Enable == 1) {     //sylee160520
            m_nFileLog_Error = 0; // error file  delete
        }

        //son 왼쪽상단 제목 라벨에 'Cycle Time'  출력 
        nDioOff1 = 2;
        DisplayStatus_TestMode(31); //SYLEE120925   //son 31: Cycle Time    //son220824
        Label102_Cycle_SetCaption(str); //son240712



        if (Simulator100 == 7) {
            gRun20.m_nOpenShort = 0;
            gRun20.m_nOpen = 0;
            gRun20.m_nShort = 0;
            gRun20.m_nPass = 1;
        }

        if (nlist1 > 10) {//sylee20120711
            nlist1 = 0;
            m_list1.ResetContent();
        }

        if (n4w_Sample_Enable == 1) {//sylee201128-1
            if (gRun20.m_nPass == 1) {
                for (i = 1; i <= g_nPieceMax1; i++) {//sylee201128-1
                    if (nOpenFail14WBlock[nBlockCountP][i] > 0) {//sylee201128-1
                        gRun20.m_nOpen = 1;   //sylee201128-1 
                    }
                }
            }
        }

        //-------------------------------------------------
        //son OpenFail 값이 마이너스일 때  Big Label 설정
        if (nFailCount[TEST_OPEN] < 0) {//sylee20120308    //son210331 enum

            if (nFailCount[TEST_OPEN] == -1) {             //son210331 enum 
                DisplayRes1_BigLabel(TEST_DIS_FAIL);    //son220824
                str.Format("Block=%d:  Recipe Select? ", nBlockCountP);
                m_list1.AddString(str);
                nlist1++;
                nRetStautus = BLOCK_RES_RUN_FAIL; //son220823 7: BLOCK_RES_RUN_FAIL
                str.Format("Block=%d:  Fail  Process ", nBlockCountP);
            }
        }

        else
        {
            //---------------------------------
            //son Retest 일 때 Big Label 설정
            //    ???? nAutoReTest[nBlockCountP]>1 , 2 이상은 돼야     이전 Retest 요구상태에서 Retest한 결과를 찍게 된다.  
            //         nAutoReTest[nBlockCountP]>=1 가 맞는게 아닌지? 
            //    ????   m_list1.AddString(str); 이 없어서 기껏 만든 str은 아무데도 쓰지 않고 있음. 
            //         현재 Restest 일때에는 m_list1에 출력이 안되고 라벨에만 나온다.  
            //         makeProcess101_ErrorFile_forMainHandler()에서 fprintf()로 파일출력시에 동일한 str을  m_list1 출력함.
            if (nAutoReTest[nBlockCountP] > 1 && nManualStartFlag != 1)  // retest  //sylee130226joytech
            {
                if (gRun20.m_nOpenShort == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_O_S); //son220824
                    str.Format("Block=%d:  Retest=%d =>OPEN+SHORT : O=%d,u-S=%d,S=%d,HR-S=%d,HV1=%d,HV12=%d,4W=%d",
                        nBlockCountP, nAutoReTest[nBlockCountP] - 1,
                        nFailCount[TEST_OPEN], nFailCount[TEST_U_SHORT], nFailCount[TEST_SHORT],     //son210331 enum
                        nFailCount[TEST_HR_SHORT], nFailCount[TEST_LEAK1], nFailCount[TEST_LEAK2], //son210331 enum
                        g_n4WFailCount);

                }
                else if (gRun20.m_nOpen == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_OPEN);    //son220824
                    if (g_n4WFailCount == 0) {
                        str.Format("Block=%d: Retest=%d=> OPEN:=%d ",
                            nBlockCountP, nAutoReTest[nBlockCountP] - 1, nFailCount[TEST_OPEN]);   //son210331 enum  
                    }
                    else if (nFailCount[TEST_OPEN] == 0) {  //son210331 enum
                        DisplayRes1_BigLabel(TEST_DIS_4W);//sylee131022   //4WCODE_131118   //son220824
                        str.Format("Block=%d: Retest=%d=> 4W  :=%d", nBlockCountP, nAutoReTest[nBlockCountP] - 1, g_n4WFailCount);
                    }
                    else {
                        str.Format("Block=%d: Retest=%d=> OPEN:=%d, 4W Error=%d",
                            nBlockCountP, nAutoReTest[nBlockCountP] - 1, nFailCount[TEST_OPEN], g_n4WFailCount); //son210331 enum 
                    }
                }
                else if (gRun20.m_nShort == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_SHORT);   //son220824
                    str.Format("Block=%d: Retest=%d=>SHORT : u-S=%d,S=%d,HR-S=%d,HV1 S=%d,HV2 S=%d",
                        nBlockCountP, nAutoReTest[nBlockCountP] - 1,
                        nFailCount[TEST_U_SHORT], nFailCount[TEST_SHORT],      //son210331 enum
                        nFailCount[TEST_HR_SHORT], nFailCount[TEST_LEAK1], nFailCount[TEST_LEAK2]);     //son210331   
                }
                else if (gRun20.m_nPass == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_PASS);    //son220824
                    str.Format("Block=%d: PASS", nBlockCountP);
                }
                else {  // retest  // continue fail                               
                    DisplayRes1_BigLabel(TEST_DIS_O_S); //son220824
                    str.Format("Block=%d: Retest===>??????", nBlockCountP);
                }

            }

            //------------------------------------
            //son Retest가 아닐 때 Big Label 설정 
            //    ????   m_list1.AddString(str); 이 없어서 기껏 만든 str은 아무데도 쓰지 않고 있음. 
            //         현재 Restest 일때에는 m_list1에 출력이 안되고 라벨에만 나온다.  
            //         makeProcess101_ErrorFile_forMainHandler()에서 fprintf()로 파일출력시에 동일한 str을  m_list1 출력함.
            else
            {

                if (gRun20.m_nOpenShort == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_O_S); //son220824
                    //sylee140923str.Format("Block=%d: =>OPEN+SHORT : O=%d, u-S=%d, S=%d,HR-S=%d,HV1 S=%d, 4W=%d" , nBlockCountP,nFailCount[TEST_OPEN],nFailCount[TEST_U_SHORT],nFailCount[TEST_SHORT],nFailCount[TEST_HR_SHORT],nFailCount[TEST_LEAK1],g_n4WFailCount);  
                    str.Format("Block=%d: =>OPEN+SHORT : O=%d, u-S=%d, S=%d,HR-S=%d,HV1 S=%d,HV2 S=%d, 4W=%d",
                        nBlockCountP, nFailCount[TEST_OPEN], nFailCount[TEST_U_SHORT],    //son210331 enum
                        nFailCount[TEST_SHORT], nFailCount[TEST_HR_SHORT],            //son210331 enum
                        nFailCount[TEST_LEAK1], nFailCount[TEST_LEAK2], g_n4WFailCount); //son210331 enum  
                }
                else if (gRun20.m_nOpen == 1)
                {
                    DisplayRes1_BigLabel(TEST_DIS_OPEN);    //son220824
                    if (g_n4WFailCount == 0) {
                        str.Format("Block=%d: => OPEN :=%d ", nBlockCountP, nFailCount[TEST_OPEN]);   //son210331 enum  

                    }
                    else if (nFailCount[TEST_OPEN] == 0) { //son210331 enum
                        DisplayRes1_BigLabel(TEST_DIS_4W);//sylee131022   //4WCODE_131118   //son220824
                        str.Format("Block=%d: => 4W   :=%d", nBlockCountP, g_n4WFailCount);
                    }
                    else {
                        str.Format("Block=%d: => OPEN :=%d   ,  4W=%d",
                            nBlockCountP, nFailCount[TEST_OPEN], g_n4WFailCount);   //son210331 enum  
                    }
                }
                else if (gRun20.m_nShort == 1)
                {
                    DisplayRes1_BigLabel(TEST_DIS_SHORT);   //son220824
                    //sylee140923   str.Format("Block=%d: => SHORT:uS=%d,S=%d,HR=%d,HV1 S=%d" , nBlockCountP,nFailCount[TEST_U_SHORT],nFailCount[TEST_SHORT],nFailCount[TEST_HR_SHORT],nFailCount[TEST_LEAK1]);  
                    str.Format("Block=%d: => SHORT:uS=%d,S=%d,HR=%d,HV1 S=%d,HV2 S=%d",
                        nBlockCountP, nFailCount[TEST_U_SHORT], nFailCount[TEST_SHORT],     //son210331 enum 
                        nFailCount[TEST_HR_SHORT], nFailCount[TEST_LEAK1], nFailCount[TEST_LEAK2]);  //son210331 enum  
                }
                else if (gRun20.m_nPass == 1) {
                    DisplayRes1_BigLabel(TEST_DIS_PASS);    //son220824
                    str.Format("Block=%d: PASS", nBlockCountP);
                }
                else {  // retest  // continue fail                               
                    DisplayRes1_BigLabel(TEST_DIS_O_S); //son220824
                    str.Format("Block=%d: ===>??????", nBlockCountP);
                }
            }
        }   // if(  gRun20.m_nFail==1){     }else{



        if (nBlockCountP == 1) {
            if ((gRun05.m_nReCh + 1) <= 1) {
                if (nBlockMax > 1) {//sylee20120711
                    m_list1.ResetContent();
                    nlist1 = 0;
                }
            }
            else {

                if (nAutoReTest[nBlockCountP] == 1) {  // retest 
                    m_list1.ResetContent();
                    nlist1 = 0;
                }
            }
        }


        if (nSystemErrorFlag != 0) {//sylee141030
            m_list1.ResetContent();
            nlist1 = 0;
            if (nG_Language != 2) {//SYLEE150707
                str.Format(" * Error : 셀프테스트로 확인하십시요.");
            }
            else {
                str.Format(" * Error : Self Test Check!");
            }
            m_list1.AddString(str);
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
            nlist1++;

            if (nG_Language != 2) {//SYLEE150707
                str.Format(" *    -> 스위치 카드 전원, 불량 확인하세요 ");
            }
            else {
                str.Format(" *    -> switch card box  power check!,  switch card check! ");
            }
            m_list1.AddString(str);
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
            nlist1++;

            if (nG_Language != 2) {//SYLEE150707
                str.Format(" *    -> 계측기 메인 보드 전원확인하세요   ");
            }
            else {
                str.Format(" *    -> BBT Controller  Tester   Main board  power check!   ");
            }
            m_list1.AddString(str);
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
            nlist1++;

        }

        if ((nFailCount[TEST_OPEN] == 999) && (nFailCount[TEST_ALL_SHORT] == 999)) //son210331 enum                      
        {
            str.Format("Block=%d: =====>Process fail. Check Please.", nBlockCountP);
            m_list1.AddString(str);
            nlist1++;

            m_list1.ResetContent();//sylee141030
            nlist1 = 0;
            str.Format(" * Error  발생 !");
            m_list1.AddString(str);
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
            nlist1++;

        }
        /////////////////////////////////////////////////////////////////////////////////////////////////
        //---------------------------------------------------------------------
        //son Grid Graph 출력용  nBlockRes[nCellNo] 생성   
        //---------------------------------------------------------------------
        //son   nBlockRes[nCellNo] 은  Block-Piece  UI 결과값이다.  이 값을 여기서 결정하고 
        //      나중에  OnTimer()에서 nBlockRes[nCellNo]을 바탕으로 GraphDisplayBlock(x, y)를 호출해서 그린다.
        if (g_nPieceMax1 <= 1) {
            nBlockRes[nBlockCountP] = nRetStautus;   //nRetStautus=1 pass,  2=open,  5 =test
            if (nRetStautus == BLOCK_RES_OPEN) {//SYLEE131022   //4WCODE_131118 //son220823 2: BLOCK_RES_OPEN
                if (nOpenFail14WBlock[nBlockCountP][1] > 0) {//SYLEE131022
                    nBlockRes[nBlockCountP] = BLOCK_RES_4W;         //son220823 8: BLOCK_RES_4W
                }
            }
        }
        else
        {
#ifdef _PC_TEST_
            //::ZeroMemory(&nFailCountP2, sizeof(nFailCountP2));    //son220904 테스트를 위해 강제로 pass 설정

#endif
            for (i = 1; i <= g_nPieceMax1; i++)
            {
                if (nBlockMax == 1) {
                    nBlockCountP = 1;
                }

                nCellNo = nBlockPieceNo1[nBlockCountP][i];// BLOCK, PIECE

                if (g_nSkipPieceInfo[i] == 2) { //sylee160203-ITS        //son220624
                    nRetStautus2 = BLOCK_RES_PIECE_DISABLE;  //sylee160203-ITS      //son220823 9: BLOCK_RES_PIECE_DISABLE
                }
                else if (nFailCountP2[nCellNo][TEST_ALL_OPEN] == 0 && nFailCountP2[nCellNo][TEST_ALL_SHORT] == 1        //son220823
                    && (nShortCo1[nBlockCountP][i] <= 0) && (nShortCo1Spark[nBlockCountP][i] > 0))
                {
                    nRetStautus2 = BLOCK_RES_SPARK; // only  spark  //sylee201224   //son220823 10: BLOCK_RES_SPARK
                }
///son ???? nFailCountP2[nCellNo][TEST_ALL_OPEN] , nFailCountP2[nCellNo][TEST_ALL_SHORT] 값은 1보다 큰 값일 수 있는데
//          여기서 1과 같은지만 체크하는 것이 맞는지 모르겠음.  0보다 큰 경우에 처리하도록 수정해야 ??????

                else if ((nFailCountP2[nCellNo][TEST_ALL_OPEN] == 1) && (nFailCountP2[nCellNo][TEST_ALL_SHORT] == 1)) {   //sylee160203-ITS //son220823
                    nRetStautus2 = BLOCK_RES_O_S;// PIECE O+S ERROR                 //son220823 4: BLOCK_RES_O_S
                }
                else if (nFailCountP2[nCellNo][TEST_ALL_SHORT] == 1) {
                    nRetStautus2 = BLOCK_RES_SHORT;// PIECE  S ERROR                //son220823 3: BLOCK_RES_SHORT
                }
                else if (nFailCountP2[nCellNo][TEST_ALL_OPEN] == 1) {       //son220823
                    nRetStautus2 = BLOCK_RES_OPEN; // PIECE  O ERROR                //son220823 2: BLOCK_RES_OPEN

                    if (nOpenFail14WBlock[nBlockCountP][i] > 0) {//SYLEE131022
                        nRetStautus2 = BLOCK_RES_4W; // PIECE  O ERROR              //son220823 8: BLOCK_RES_4W
                    }
                }
                else if (nFailCountP2[nCellNo][TEST_ALL_OPEN] == 0 && nFailCountP2[nCellNo][TEST_ALL_SHORT] == 0) {     //son220823
                    nRetStautus2 = BLOCK_RES_PASS; // PIECE  PASS                   //son220823 1: BLOCK_RES_PASS
                }
                else {  //nFailCountP2[i][11]=-1;nFailCountP2[i][12]=-1
                    nRetStautus2 = BLOCK_RES_RUN_FAIL;                      //son220823 7: BLOCK_RES_RUN_FAIL
                }

                if (nRetStautus == BLOCK_RES_RUN_FAIL) {
                    nRetStautus2 = BLOCK_RES_RUN_FAIL; // run fail          //son220823 7: BLOCK_RES_RUN_FAIL
                }

                if (nFailCount[TEST_OPEN] == 999) {     //son210331 enum
                    nRetStautus2 = BLOCK_RES_O_S;// PIECE O+S ERROR         //son220823 4: BLOCK_RES_RUN_FAIL
                }

				nBlockRes[nCellNo] = nRetStautus2;              
            }

        }


        nDisplayRef1 = 1;//sylee120308

        if ((nAutoReTest[nBlockCountP] > 0) && (nAutoReTest[nBlockCountP] <= (gRun05.m_nReCh))) {  // retest  

        }
        else {
            //son Pass, Fail, OPEN,SHORT의 Count와 % 를 계산해서 Display
            Display_AutoCount();      //son220624  RunEnd1P1() -> Display_AutoCount()
        }
        //==========================================================================
        //son 메인장비로 제공하는 Error 파일 생성 : Z:\\ERROR.CSV 또는 Z:\\ERROR.TXT
        if (nFailL1Co > 0 || nFailL1CoOpen > 0 || g_n4WFailCount > 0) //SYLEE131118  //4WCODE_131118
        {
			OnPinMeasure1();//sylee241007
            if (makeProcess101_ErrorFile_forMainHandler() <= 0)  //son211217_1 가독성을 위해 AProcess101()로부터 별도의 함수로 분리
                return 0;
        }

    }    //  if( nProcessFlag1 !=1)//SYLEE20111225

	/*.//sylee230420    if (g_n4WFailCount > 0)    {
           str.Format("d:\\LOG\\4W_Errorlog_%02d%02d%02d%02d.csv", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour());
     }	*/

    //son220209 모든 케이스의 원인 표시 추가   
    MyTrace(PRT_LEVEL1, "nFailL1CoOpen=%d, nFailL1Co=%d, n4WFail=%d, g_n4wSampleFail=%d, nFailCount[]: OP_%d uS_%d S_%d HR_%d L1_%d L2_%d 4W_%d\n",
        nFailL1CoOpen, nFailL1Co, g_n4WFailCount, g_n4wSampleFailCo1,
        nFailCount[TEST_OPEN], nFailCount[TEST_U_SHORT], nFailCount[TEST_SHORT], nFailCount[TEST_HR_SHORT],
        nFailCount[TEST_LEAK1], nFailCount[TEST_LEAK2], nFailCount[TEST_4W]);

    // if(( nAutoReTest[nBlockCountP]!=0)&&(SysSet211.m_nDisable4wRetest!=1)){//sylee180521-1
    if ((SysSet211.m_nDisable4wRetest != 1)) {//sylee180521-1   //son 4w recheck enable (0:enable, 1: disable)  //son220503
        g_n4WFailCount = 0;     //son retry를 위해 4w FailCount를 초기화.
    }

    //sylee170411   if(SysSet13.m_nSet19==1){//sylee150407
    if (nFlagEstModelMake == 2) {//estimation
        if (nEstEnableHv == 1) {//estimation //sylee150407
            nFlagEstModelMake = 3;
        }
    }
    //sylee170411   }

    //son DOUT_CMD_CONFAIL 을 판단한다.
    if ((nAutoReTest[nBlockCountP] > (gRun05.m_nReCh))) {  // retest   //sylee150724
        if ((nManualStartFlag != 1) && (nKeyStartFlag != 1)) {//sylee180510-1-JTECH
            ContinueFailCheck();        //sylee141016 move
        }
    }

    if (nKeyStartFlag != 1)//sylee130306joytch     //sylee141201 move 
    {
        //son DOUT_CMD_CONFAIL 발생을 장비로 통보한다.
        if ((SysInfo05.m_nConFail > 0) && (nAutoContinueFail == 1))//sylee141201
        {
            Comi_DoPutByte(DOUT_CMD_CONFAIL);  //son CONFAIL 장비로 전송.  //son231016  //son240430
            MyTrace(PRT_LEVEL1, "Line_%d Comi_DoPutByte(): nDioS2=16 =========> CONFAIL \n", __LINE__);
            nAutoContinueFail = 0;//sylee180510-1
            //  AfxMessageBox("  test111 ? !.", MB_OK);          
        }
        else
        {
            //############################################################################## 
            if (n4w_Sample_Enable == 1) //sylee171103-1
            {

#if 1   //son220518 이 부분은 필요 없어 보임.  
                //          ARun201_4w_3()에서 이미 g_n4wSampleFailCo1를 카운트를 하고 있는데 초기화 하고 또 카운트함.

                if (n4w_Sample_SetCount > 0) //sylee171103-1
                {
                    int nEnd = (int)g_s4WNet[dutIdx].wCount;      //son190704-4WDUT16 
                    g_n4wSampleFailCo1 = 0;

                    if (n4w_Sample_ok1 == 1) {//sylee171103-5
                        n4w_Sample_RunCount_nTmp2 = n4w_Sample_RunCount[dutIdx];//sylee171103-5
                    }
                    else {
                        n4w_Sample_RunCount_nTmp2 = n4w_Sample_RunCount[dutIdx] + 1;//sylee171103-5 ++
                    }

                    for (int net = 1; net <= nEnd; net++) {       //son190704-4WDUT16
                        if (d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] == 0.0) { //sylee171103-3  +1
                            d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] = 999999;//sylee171103-3  +1
                        }
                        if (d4W_Log2[dutIdx][n4w_Sample_RunCount_nTmp2][net] >= 200000) {//sylee171026-3 
                            g_n4wSampleFailCo1++;
                        }
                    }
                }
#endif

                //son 해당 DUT의  Auto Sampling이 아직 끝나지 않았으면
                if (n4w_Sample_RunCount[dutIdx] < n4w_Sample_SetCount)//sylee171103-1
                {
                    //son 'OPEN 불량(0x04)' IO Command 설정: for Handler 
                    //    4w Sampling 한 보드는 메인장비에서 정상 보드 위치에 쌓으면 안되므로 'Open'으로 알려 준다.
                    //    실제로는 불량일 수도 양품일 수도 있음. 
                    nDioS2 = DOUT_CMD_OPEN;//  open //son231016
                }

                //son 해당 DUT의  Auto Sampling이 끝났으면
                else
                {
                    //son Fail이 없다면 'END' 시그널을 장비로 전송. END를 보내는 유일한 케이스
                    if ((g_n4wSampleFailCo1 == 0) && (nFailL1CoOpen < 1) && (nFailL1Co < 1))//sylee160611-2 
                    {

                        //son220203 4W Retest 안된다는 GTS 문제점 보고되어 20년 3월 기능 삭제했던 것 복구
                        //          다른 DUT도 체크해야 하는게 맞다. Multi DUT는 같은 PCB내에 다른 BDL의 Block(Multi DUT)이 존재하는 것이므로 
                        //          Sampling 카운트를 DUT 개수만큼 운용해야 한다. checkAllDUT_4wSampleEnd() 사용하는 코드 되살림.
#if 1   

                        //son 'END(0x20)' IO command 설정: for Handler
                        //    4W Auto-Sampling Mode Return 신호
                        g_b4wSampleEnd[dutIdx] = true;         //son200320-4WDUT16

                        //son 모든 DUT가 양품으로 판정이 되었다면 장비에게 4W Auto Sampling의 'END' Response을 보낸다.
                        //    메인 장비에 4wSampling Count를 알려주는 건 아니고 4w Sampling이 끝났다는 의미로 End Signal을 준다.  
                        if (checkAllDUT_4wSampleEnd() == true)
                            nDioS2 = DOUT_CMD_SAMPLING_END;//sylee160407-1   4W Auto Sampling END Rsp   //son231016

                        //son 사실 불량은 아니지만 다른 DUT 가 END 될때까지 기다려야 하므로 
                        //    장비에게는 Open 불량이라고 그냥 보내 준다. 
                        else
                            nDioS2 = DOUT_CMD_OPEN;//son  OPEN Rsp  //son231016

#else   
//son211217_2 20년 3월 이전 코드
//            son 메인 장비에 4wSampling Count를 알려주는 건 아니고 4w Sampling이 끝났다는 의미로 End Signal을 준다.  
                        nDioS2 = DOUT_CMD_SAMPLING_END;//sylee160407-1   4W Auto Sampling END Rsp   //son231016
#endif                  //son211217_2
                    }

                    //son Fail이 있다면  OPEN 불량이라고 전송.
                    else {
                        //son 'OPEN 불량(0x04)' IO Command 설정: for Handler 
                        nDioS2 = DOUT_CMD_OPEN;//sylee160611-2  //son231016
                    }
                }

                //son Enable4wAutoSamplingRetest(SysSet211.m_nSet17) 
                if ((SysSet211.m_nSet17 == 1) && (n4w_Sample_SetCount > 0))//sylee171103-2
                {
                    if (g_n4wSampleFailCo1 > 0)//sylee171103-2                                
                    {
                        if ((nAutoReTest[nBlockCountP] <= gRun05.m_nReCh) && (nBlockCountP > 0) && (nAutoReTest[nBlockCountP] != 0))
                        {
                            //son 'RETEST(0x08)' IO command 설정: for Handler
                            //    &&  (gRun20.m_nPass!=1) && (nFlag_Open1==1)  
                            nDioS2 = DOUT_CMD_RETEST;//sylee171103-2 retest                     //son231016
                        }
                    }
                }

                //son211220 4W sampling sheet번호. 양품, 불량 케이스 모두 증가. n4w_Sample_RunCount[dutIdx]는 양품만 증가.
                //          RETEST 일 때에는  해당 sheet를 다시 테스트하므로  증가하면 안된다.
                //          4W Error뿐 아니라 2W Open, Short 로 인한 Sampling Sheet 번호 변경을 위해 
                //          ARun201_4w_3()이 아니라 AProcess101()에서 SheetCount를 증가시킨다.  
                if (n4w_Sample_RunCount[dutIdx] >= 0 && n4w_Sample_RunCount[dutIdx] <= n4w_Sample_SetCount)
                {
                    if (nDioS2 != DOUT_CMD_RETEST)    //son RETEST일때에는 카운트 증가시키지 않는다.    //son231016
                    {
                        n4w_Sample_SheetCount[dutIdx]++;    //son211220
                        MyTrace(PRT_BASIC, "Increased n4w_Sample_SheetCount[%d]=%d\n", //son211715
                            dutIdx, n4w_Sample_SheetCount[dutIdx]);
                    }

                }
            }

            if (nProcessFail1 != 0) {//sylee170415
                //son 'SHORT(0x02)+OPEN(0x04)= 0x06' IO Command : for Handler
                nDioS2 = (DOUT_CMD_SHORT + DOUT_CMD_OPEN);//open+short  //son231016
            }

            //son 계측기-> Handler IO 출력한다. //son231016
            Comi_DoPutByte(nDioS2);  //son240430
            MyTrace(PRT_LEVEL1, "Line_%d Comi_DoPutByte(): nDioS2=%d (0x%02x) %s\n", __LINE__, nDioS2, nDioS2,  //son240430
                (nDioS2 == DOUT_CMD_ALL_OFF) ? "=======> ALL_OFF" :
                (nDioS2 == DOUT_CMD_PASS) ? "=======> PASS" :
                (nDioS2 == DOUT_CMD_SHORT) ? "=======> SHORT" :
                (nDioS2 == DOUT_CMD_OPEN) ? "=======> OPEN" :
                (nDioS2 == DOUT_CMD_ACK_SKIP_ABORT) ? "=======> ACK_SKIP_ABORT" :
                (nDioS2 == (DOUT_CMD_SHORT + DOUT_CMD_OPEN)) ? "=======> SHORT+OPEN" :
                (nDioS2 == DOUT_CMD_RETEST) ? "=======> RETEST" :
                (nDioS2 == DOUT_CMD_CONFAIL) ? "=======> CONFAIL" :
                (nDioS2 == DOUT_CMD_SAMPLING_END) ? "=======> SAMPLING_END" : 
                (nDioS2 == DOUT_CMD_ACK_4W_REF_INIT) ? "=======> ACK_4W_REF_INIT" : "======> Undef");    //son220211  //son231017 DOUT_CMD_ACK_4W_REF_INIT
//son240718	if (nDioS2 == DOUT_CMD_RETEST)      //son210331 RETEST 원인표시 로그 추가.
//son240718	MyTrace(PRT_LEVEL2, "   RETEST Cause: nFailL1CoOpen=%d, g_n4WFailCount=%d\n", nFailL1CoOpen, g_n4WFailCount); //son240714


            if (nFlagAutoPress1 == 2) {//SYLEE151222
                Sleep(50);
            }

            if (n4w_Sample_Enable == 1) //sylee160518   
            {
                //son 해당 DUT의  Auto Sampling이 아직 끝나지 않았으면
                if (n4w_Sample_RunCount[dutIdx] < n4w_Sample_SetCount) {
                    Sleep(300);
                }
                //son 해당 DUT의  Auto Sampling이 끝났으면
                else {
                    Sleep(500);
                }
            }
        }
        // AfxMessageBox("  test222 ? !.", MB_OK);
    }
    else {
        nKeyStartFlag = 0;//sylee130306joytch
    //  AfxMessageBox("  test333-5  ? nKeyStartFlag=0 ", MB_OK);
    }


    if (nRetestFlag != 1) {    //sylee141016 move                 
        ::ZeroMemory(&nOpenSu1, sizeof(nOpenSu1));//sylee20120714  PARKPONGKU CJ;
        ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20120921//100=piecemax
        ::ZeroMemory(&nShortFail1, sizeof(nShortFail1));////sylee20120921//100=piecemax
        ::ZeroMemory(&nShortFail1Flag1, sizeof(nShortFail1Flag1));////sylee20120921//100=piecemax       
        if (SysSet211.m_nDisable4wRetest != 1) {//sylee160602-5  4w recheck enable (0:enable, 1: disable)     //son220503
            ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));
        }
    }

    if (nSelfTestHWError1 == 1)//SYLEE141030
    {
        if (nG_Language != 2) {//SYLEE150707
            str.Format(" ERROR : 계측기 전원부 확인 하십시요  ");
        }
        else {
            str.Format(" ERROR :  Power on check!   BBT Controller.   ");
        }
        m_list1.AddString(str);
        nlist1++;
    }


    nFlag_Open_SetStart_Status = 0;
    if (nFlag_HV_SetEnd_Skip == 1) {//sylee150427    0=idle, 1=skip 
        ARun201_S2_SQ2_HV_Re_VB_Finish();//sylee150427 
        if (nFlag_Open_SetMode > 0) {
            nFlag_Open_SetStart_Status = 1;
            //sylee150519 disable             ARun201_O11_SetStart(nFlag_Open_SetMode);
            nFlag_Open_SetStart_Status = 2;
        }
        else {
            //SYLEE150508     AfxMessageBox(" ERORR NO 7801 :   Open  Set Start    Error.     Mode<=0  ", MB_OK);
        }
    }
    nFlag_HV_SetEnd_Skip = 0;

    //sylee170816   
    OnErrPin_Rank1(); //sylee170810-1 


TaskP101://sylee170816

    Sub71.OnRelay4W_OFF1();  //SYLEE181118

    if (nOpenUse1 == 1) {//sylee210507
        if (OpenMes1Mode > 0) {

            // MODE_SET21_SWOP1 ->  OPEN R Meas.Logging Mode On  (CModeSet21::m_check13)
            if (nFlagOpenMes1 == 1) {//SYLEE210309-1
                //son OpenTest 측정 R 값 출력
                ARun201_O11_Log1(OpenMes1Mode);//SYLEE210309-1  
            }
        }
    }

    nManual4WStartFlag1=0;     //son231110  ARun201_4w_3() 비정상종료시 초기화를 위해 추가


#ifdef	__BNTECH__CUSTOMER //sylee241129
    if( n4WSetFlag1==1){//sylee241129-1
		if( nDioS2!=8){//sylee241129-1
        	 Log4WCSV_ZDrive(nBlockCountP,2);//sylee241129-1    	 
		 }
	}
#endif

    return 1;
}


/**
 * @brief 	Leak 2 pin 정밀 측정 기능
 * @retval 	1 정상 완료 
 *
 * @author 	sylee 
 * @date 	2024-11-07
 * @version 1.0
 *
 * 수정 이력:
 * - 2024-11-07 BSW-139 sylee241107 최초 작성
 */
int CChildView7::OnPinMeasure1()//sylee241107
{

	CString   str,str1 , strfName,strfName1;
    int i,nDelay10,  nFil, Lo1, nPinA, nPinB;
    int nIFilter,nHVOffSet,nHVGain, nCC,  nVRel, nVSet,nIR, m_nMode1,nMod1; 
 	double nISet,dVbR1,dVbR2,InterI;
	
    nMod1=1;
	m_nMode1=6;//sylee241107

	int nRet;
	nRet=FileSysInfo01.LoadSaveSer13(_LOAD, m_nMode1, PART_UPPER);  //sylee241107
	if( nRet!=1){
	    str.Format("ERRor NO 3005,   \n JIg open test:  Calibration File reading Error , \n   Mode no= %d  ", m_nMode1 );
	    AfxMessageBox( str);
	    return 0; 
	}

	nCC= (int) dRec[m_nMode1][1];
	nVRel= (int)dRec[m_nMode1][2];
	nVSet= (int) dRec[m_nMode1][3];
	nIR= (int)dRec[m_nMode1][4];
	nISet= dRec[m_nMode1][5];
	nDelay10= (int)dRec[m_nMode1][6]*10;
	nFil=(int)dRec[m_nMode1][8];
	nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629		  
	nHVOffSet =(int) dRec[m_nMode1][10]; //SYLEE130629
	nHVGain = (int)dRec[m_nMode1][11];	//SYLEE130629

	if( nISet<0.1){
		AfxMessageBox(" Error No 12025, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!"); 
	}
	//ADC COUNT
	Sub71.nADCount1 = (int)dRec[m_nMode1][7];
		
	if(nIR==5){//uA
		InterI=	10.0;
	}
	else{
		InterI=nISet*0.9;
	}	
	//=========================================================================================
	//interlock    
	if( nCC!=1 && nCC!=2 ){
		AfxMessageBox(" Error No 12024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!"); 
		return 0;
	}
	
	if( nVSet<1 || nVSet>300 ){
		AfxMessageBox(" Error No 12025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!"); 
 		return 0;
	}
	
	if( nVRel<1  || nVRel>4 ){ 
		AfxMessageBox(" Error No 12025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!"); 
 		return 0; 
	}	
 
	Lo1=1000;//sylee130903  200nS-> 1sec  //sylee150708  200->1000
	Sub71.AOnReadVB1Run1(nVRel);//sylee130802

 
 Task101:    

        Sub71.AOnReadVB1Run1(nVRel); 

		if(nVSet<=5){
			dVbR2=nVSet*(0.35);//35%
		}else{
			dVbR2=nVSet*(0.1);//10%
		}
		dVbR1=nVSet-dVbR2;
		dVbR2=nVSet+dVbR2;
 
		if( Sub71.V1>300){
			 if(Lo1-->0){	
				 Sub71.Delay_100ns(30000);  //1ms     //sylee150708  1->3
				 goto Task101;
			 }
			 str.Format("Error No 12001,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1,nVSet,Sub71.V1,dVbR1,dVbR2); 
			 AfxMessageBox(str); 
       		 return 0;
		}

		if( Sub71.V1<dVbR1 || Sub71.V1>dVbR2 ){
			 if(Lo1-->0){
		//sylee121019	Sub71.Delay_100ns(100000);  //10ms   
				 Sub71.Delay_100ns(10000);  //1ms   
				 goto Task101;
			 }					   
			 str.Format("Error No 12013,\n \n\n  Power Check? \n\n\n  VB READ Error!!    Calibration NO=%d ! \n\n\n   VB Set=%d,    VB Read =%.2f \n\n\n,\n Range(VB low=%.2f, VB high =%.2f),",(int)m_nMode1, nVSet,Sub71.V1,dVbR1,dVbR2); 
			 AfxMessageBox(str);		 
   			return 0;
		} 
 
 	 	Sub71.AOnReadV1Enable1(nVRel); //SYLEE20120223   //VC SENSE INIT SET

        Sub71.FilterSet(nFil);//sylee130702 
		if(nIFilter==3){
			AfxMessageBox(" Errro No 12023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!"); 
			nIFilter=1;
		}
		Sub71.I_Filter(nIFilter);//sylee130629
	 	Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213       	
		Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 
    	Sub71.OnPinAllReset1(); ///PIN ALL RESET   //sylee170112
 
 
 
    for (i = 1; i <= nFailL1Co; i++)//SYLEE241107
	{	
		
 		if (nFailL1[i][F_RAW_R] <= 62000) {//sylee241007
			continue;
		}


//Task202:	
 
		Sub71.OnPinAllReset1();  //sylee241107
        nPinA = nFailL1[i][F_VB_PIN];       
		nPinB = nFailL1[i][F_VC_PIN]; 
		Sub71.AOnPinSet1(2,nPinA, 1);
		Sub71.Delay_100ns(100);  //10us  
		Sub71.AOnPinSet1(2, nPinB, 2); 	
		Sub71.Delay_100ns(nDelay10); 	
		if( nCC==2){ 
			Sub71.AOnReadV1I1(7);     	 		
		}else{ 
			Sub71.AOnReadV1I1(nVRel);  
		} 	
		Sub71.OnPinAllReset1();  
		
		Sub71.OnPinAllReset1();  //sylee241107
        nPinA = nFailL1[i][F_VB_PIN]-1;       
		nPinB = nFailL1[i][F_VC_PIN]-1; 
		Sub71.AOnPinSet1(2,nPinA, 1);
		Sub71.Delay_100ns(100);  //10us  
		Sub71.AOnPinSet1(2, nPinB, 2); 	
		Sub71.Delay_100ns(nDelay10); 	
		if( nCC==2){ 
			Sub71.AOnReadV1I1(7);     	 		
		}else{ 
			Sub71.AOnReadV1I1(nVRel);  
		} 	
		Sub71.OnPinAllReset1();  


		if(Sub71.Y1<0.0000001){
			Sub71.Y1=0.0000001;
		} 
	
		if( nFil==3 ){//HV OPEN ENABLE //SYLEE20120411
			if( nIR==1 || nIR==2 ){
				Sub71.R1=(Sub71.X1)/Sub71.Y1*1000.0;   
			}else if( nIR==3 ||  nIR==4 ){
				Sub71.R1=(Sub71.X1)/Sub71.Y1*1000000.0;
			}else if( nIR==5 ){	//sylee121115
				Sub71.R1=(Sub71.X1)/Sub71.Y1*1000.0; 
			} 
		}else{
			if( nIR==1 ||  nIR==2 ){
				Sub71.R1=((Sub71.V1-Sub71.X1)/Sub71.Y1)*1000.0;   
			}else if( nIR==3 ||  nIR==4 ||  nIR==5){
				Sub71.R1=((Sub71.V1-Sub71.X1)/Sub71.Y1)*1000000.0;//sylee121027->1000000=>1000
			}      
		}		
		if((Sub71.Y1<0.1)&&(Sub71.X1<5)){//interlock  //sylee121106
			Sub71.R1=9999999;
		}	  
	   RCalCovert( m_nMode1, Sub71.R1 , RAW_TO_REAL, PART_UPPER ); 	
 	   nFailL1[i][F_RAW_R]=1111;//sylee241107
	   nFailL1[i][F_REAL_R]=Sub71.R1;//sylee241107 
	
	}////for END      for( i=1; i<=nRCount ; i++){ //sylee241107
 
 
//Task211:
 

	Sub71.OnPinAllReset1(); ///PIN ALL RESET 
	Sub71.ARunoff1();      
	Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720
	Sub71.FilterSet(0);//sylee130704 
	Sub71.I_Filter(0);//sylee130704
	Sub71.AOnReadV1Enable1(5); //sylee130711
  
	return 1;

}//end of CChildView3::OnManualShort1(){//sylee131023

 



//son 메인장비로 제공하는 Error 파일 생성.  Z:\\ERROR.CSV 또는 Z:\\ERROR.TXT
//    error.txt 로그와 함께 m_list1에 error 출력도 하고 있다.
int CChildView7::makeProcess101_ErrorFile_forMainHandler()  //son211217_1 가독성을 위해  AProcess101()로부터 별도의 함수로 분리
{
    FILE* fp;
    char    fName[200], fName1[200];
    double  nFR11, nFR13, nFR12, nFR14, dtep1;
    CString str1, str2, str3, str4, str5, str6, str7, str9;
    int     i;


    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));


    //if (m_nFileLog_Error != 1)   //son211217_1        //son220322_2 Retest 시에 m_list1에 error 출력 안하는 문제 수정.
    //    return 1;

    if (SysSet13.m_nSet7 == 1) {//sylee130724
        str.Format("Z:\\ERROR.CSV");
    }
    else {
        str.Format("Z:\\ERROR.TXT");
    }

    if (m_nFileLog_Error == 1) { //sylee130220 error file
        strcat(fName, str);
        fp = fopen(fName, "wt");
    }

    if (m_nFileLog_Error == 1 && fp == NULL) { //sylee130220 error file
        //sylee130220 error file if(fp == NULL){ 
        str.Format("Error No7204 !  \n \n\n  NETWORK DRIVER CHECK!  file open?    \n\n  Saving Error !   %s file close! !     file close!", fName);
        MyTrace(PRT_BASIC, str);    //son220803_3
        AfxMessageBox(str, MB_OK); //error messege          
        return 0;
    }

    //else  //son220803_2  early return 이므로  else 필요 없어서 삭제함. indentation 단순화
    //{

    //------------------------
    //son OPEN real R 값 계산. 
    //------------------------
    //    nFailL1Open[i][F_RAW_R] 측정값 ADC R을 real ohm 값으로 변환하여  nFailL1Open[i][F_REAL_R]에 저장.
    for (i = 1; i <= nFailL1CoOpen; i++)
    {

        int nRCount, m_nMode1, nIn, nOut;
        double  aa, ab;
        aa = 0.0; ab = 0.0;
        nIn = 3;   nOut = 2;  // raw -> real         


        m_nMode1 = (int)nFailL1Open[i][F_MODE1];//input 1 //son220419_4 11:F_MODE1
        nRCount = (int)gdCal1[PART_UPPER][m_nMode1][0][0];// Cal  list sum
        Sub71.R1 = nFailL1Open[i][F_RAW_R]; //input2  //son220419_4 6:F_RAW_R

#ifdef _PC_TEST_
        if (OpenMes1Mode > 0)  //son211129  Recipe에 4W만 있는 경우,  _PC_TEST_ 에서 죽는 문제 있어서 이렇게 보완.
                            //           _PC_TEST_ 아니라 실제 구동되는 경우는 체크 없이 그냥 호출해야 한다는 이상윤 부장님 요구사항 반영함.  
#endif
        {
            int calPart = FileSysInfo01.checkUseCalDataPart(nFailL1Open[i][F_VB_PIN] - 1, nFailL1Open[i][F_VC_PIN] - 1);    //son220419_2
            //son ConMode=1 (raw -> real). AD Raw 값을 real R(ohm)값으로 convert     
            RCalCovert(OpenMes1Mode, Sub71.R1, RAW_TO_REAL, calPart); //SYLEE210310-1 //son220412 
        }

        if (Sub71.R1 < 0) {
            Sub71.R1 = 0.1;
        }
        nFailL1Open[i][F_REAL_R] = Sub71.R1;    //son real R //son220419_4 15:F_REAL_R

    }

    //------------------------
    //son SHORT real R 값 계산. 
    //------------------------
    //    nFailL1[i][F_RAW_R] 측정값 R을 real ohm 값으로 변환하여  nFailL1[i][F_REAL_R]에 저장.
    int calPart = PART_UPPER;  //son220412
    for (i = 1; i <= nFailL1Co; i++)
    {

        int nRCount, k, m_nMode1, nIn, nOut;
        double  aa, ab;

		if(nFailL1[i][F_RAW_R]==1111){//sylee241107
			continue;
		}
        aa = 0.0; ab = 0.0;
        nIn = CAL_REF_RAWR;   nOut = CAL_REF_R;  // raw -> real  //son220407 3:CAL_REF_RAWR 2:CAL_REF_R, 

        m_nMode1 = (int)nFailL1[i][F_MODE1];//input 1     //son220419_4 11:F_MODE1
        nRCount = (int)gdCal1[PART_UPPER][m_nMode1][0][0];// Cal  list sum
        Sub71.R1 = nFailL1[i][F_RAW_R]; //input2          //son220419_4 6:F_RAW_R

        calPart = FileSysInfo01.checkUseCalDataPart(nFailL1[i][F_VB_PIN] - 1, nFailL1[i][F_VC_PIN] - 1);    //son220419_2

        if ((Sub71.R1 > 0) && (nRCount > 0) && (nRCount <= MAX_CAL_RLIST))   //son220407 MAX_CAL_RLIST:128
        {
            //REAL R-> RAW
            if (m_nMode1 > 0)   //R==>I ONLY //SYLEE130215JOYTECH
            {
                for (k = 1; k <= nRCount; k++) {
                    if (Sub71.R1 > gdCal1[calPart][m_nMode1][nIn][k]) {
                        break;
                    }
                }
                if (k == 1) {  // min 값 보다  작은 경우 
                    if (gdCal1[calPart][m_nMode1][nIn][0] >= 0.0) {
                        if (gdCal1[calPart][m_nMode1][nIn][1] != 0) {
                            Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][nIn][1]) * gdCal1[calPart][m_nMode1][nOut][1];
                        }
                        else {
                            //error
                            str.Format("Error No 7221 ,   Calibration Raw Data zero.  Use Error!,    Divide by Zero. \n /gdCal1[calPart][m_nMode1][nIn][1] \n Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                            MyTrace(PRT_BASIC, str);     //son221104_2
                            AfxMessageBox(str);
                        }
                    }
                }
                else if (k == nRCount) {    // max????????????
                    if (gdCal1[calPart][m_nMode1][nIn][nRCount] != 0) {
                        Sub71.R1 = ((Sub71.R1 - gdCal1[calPart][m_nMode1][nIn][nRCount - 1]) / (gdCal1[calPart][m_nMode1][nIn][nRCount] - gdCal1[calPart][m_nMode1][nIn][nRCount - 1]))
                            * (gdCal1[calPart][m_nMode1][nOut][nRCount] - gdCal1[calPart][m_nMode1][nOut][nRCount - 1])
                            + gdCal1[calPart][m_nMode1][nOut][nRCount - 1]; //sylee20120627
                    }
                    else {
                        str.Format("Error No 7202 ,   Divide by Zero. \n  gdCal1[calPart][m_nMode1][nIn][nRCount]   \n  Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str);
                    }
                }
                else {
                    if ((gdCal1[calPart][m_nMode1][nIn][k] - gdCal1[calPart][m_nMode1][nIn][k - 1]) != 0.0) {
                        aa = (Sub71.R1 - gdCal1[calPart][m_nMode1][nIn][k - 1]) / (gdCal1[calPart][m_nMode1][nIn][k] - gdCal1[calPart][m_nMode1][nIn][k - 1]);  // [3]= lookup table Calibration Raw R
                        ab = gdCal1[calPart][m_nMode1][nOut][k] - gdCal1[calPart][m_nMode1][nOut][k - 1];
                        Sub71.R1 = ab * aa + gdCal1[calPart][m_nMode1][nOut][k - 1];
                    }
                    else {
                        Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][nIn][k - 1]) * gdCal1[calPart][m_nMode1][nOut][k - 1];
                    }
                }


            }
            else
            {

                for (k = 1; k <= nRCount; k++) {
                    if (Sub71.R1 < gdCal1[calPart][m_nMode1][nIn][k]) {
                        break;
                    }
                }


                if (k == 1) {  // min 값 보다  작은 경우 
                    if (gdCal1[calPart][m_nMode1][nIn][0] >= 0.0) {

                        if (gdCal1[calPart][m_nMode1][nIn][1] != 0) {
                            Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][nIn][1]) * gdCal1[calPart][m_nMode1][nOut][1];
                        }
                        else {
                            str.Format("Error No 7221 ,  Calibration Raw Data zero.  Use Error!,   Divide by Zero. \n /gdCal1[calPart][m_nMode1][nIn][1] \n Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                            MyTrace(PRT_BASIC, str);     //son221104_2
                            AfxMessageBox(str);
                        }

                    }
                }
                else if (k == nRCount) {    // max????????????
                    if (gdCal1[calPart][m_nMode1][nIn][nRCount] != 0) {
                        Sub71.R1 = ((Sub71.R1 - gdCal1[calPart][m_nMode1][nIn][nRCount - 1]) / (gdCal1[calPart][m_nMode1][nIn][nRCount] - gdCal1[calPart][m_nMode1][nIn][nRCount - 1]))
                            * (gdCal1[calPart][m_nMode1][nOut][nRCount] - gdCal1[calPart][m_nMode1][nOut][nRCount - 1])
                            + gdCal1[calPart][m_nMode1][nOut][nRCount - 1]; //sylee20120627
                    }
                    else {
                        str.Format("Error No 7202 ,   Divide by Zero. \n  gdCal1[calPart][m_nMode1][nIn][nRCount]   \n  Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str);
                    }
                }
                else {
                    if ((gdCal1[calPart][m_nMode1][nIn][k] - gdCal1[calPart][m_nMode1][nIn][k - 1]) != 0.0) {
                        aa = (Sub71.R1 - gdCal1[calPart][m_nMode1][nIn][k - 1]) / (gdCal1[calPart][m_nMode1][nIn][k] - gdCal1[calPart][m_nMode1][nIn][k - 1]);  // [3]= lookup table Calibration Raw R
                        ab = gdCal1[calPart][m_nMode1][nOut][k] - gdCal1[calPart][m_nMode1][nOut][k - 1];
                        Sub71.R1 = ab * aa + gdCal1[calPart][m_nMode1][nOut][k - 1];
                    }
                    else {
                        Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][nIn][k - 1]) * gdCal1[calPart][m_nMode1][nOut][k - 1];
                    }
                }

            }
        }

        if (Sub71.R1 < 0) {
            Sub71.R1 = 0.1;
        }
        nFailL1[i][F_REAL_R] = Sub71.R1;    //son real R      //son220419_4 15:F_REAL_R
	 
    }
    //################################################################################################
    if (nFailL1Co > 1 || nFailL1CoOpen > 1) {//sylee20120921
        nlist1++;
    }
    //################################################################################################

    double nPinA1, nPinB1;//sylee150921-1

    for (int pi1 = 1; pi1 <= g_nPieceMax1; pi1++)    //log  piece sort  //sylee120924-1
    {
//son230726 begin:  
        //son 헤더 출력
        if ((nFailL1CoOpen > 0 || nFailL1Co > 0) && (pi1 == 1))
        {
            MyTrace(PRT_LEVEL3, "---------- Open(Count:%d)  Short(Count:%d) Fail List  --------------------\n", nFailL1CoOpen, nFailL1Co);
            MyTrace(PRT_LEVEL3, "        Piece   PinA    PinB     ProvR  ProvRawR    realR      rawR        VB        VC       I      VSet       ISet \n");
        }
            
//son230726 end

        //----------------------------
        //son Piece별 OPEN Error 출력 
        //----------------------------
        for (i = 1; i <= nFailL1CoOpen; i++)
        {

            if (pi1 != nFailL1Open[i][F_PIECE]) {   //sylee120924 //son220419_4 3:F_PIECE //son230726 
                continue;							//son230726
            }

            nPinA1 = nFailL1Open[i][F_VB_PIN];//sylee150921-1 //son220419_4 4:F_VB_PIN
            nPinB1 = nFailL1Open[i][F_VC_PIN];//sylee150921-1 //son220419_4 5:F_VC_PIN

//son230726 begin:
            //son Open Fail D:\Log 프린트문 추가
            MyTrace(PRT_LEVEL3, "OPEN:  %4.0f,  %5.0f,  %5.0f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f \n",
                                 nFailL1Open[i][F_PIECE], nPinA1, nPinB1, 
                                 nFailL1Open[i][F_PRORV_REAL_R], nFailL1Open[i][F_PRORV_RAW_R], 
								 nFailL1Open[i][F_REAL_R], nFailL1Open[i][F_RAW_R],
                                 nFailL1Open[i][F_VB],  nFailL1Open[i][F_VC], nFailL1Open[i][F_I],
                                 nFailL1Open[i][F_VSET], nFailL1Open[i][F_ISET]);

//son230726 end

            if (nPinConMode2 == 2) {//sylee150921-1  32k->16k
                if (nPinA1 > 16384) {
                    nPinA1 = nPinA1 - 8192;
                }
                if (nPinB1 > 16384) {
                    nPinB1 = nPinB1 - 8192;
                }
            }


            if (nFailL1Open[i][F_TEST_TYPE] == TEST_OPEN) {   //OPEN(1) //son220318_3 //son220419_4 16:F_TEST_TYPE

                if (nFailL1Open[i][F_REAL_R] <= (nFailL1Open[i][F_PRORV_REAL_R] * 1.1)) {  //SYLEE20120702 //son220419_4 15:F_REAL_R, 7:F_PRORV_REAL_R
                    //QCTESTDEBUGMODE
                    if (m_nFileLog_Error == 1) { //sylee130220 error file
                        fprintf(fp, " %4.0f C:%5.0f/%5.0f", nFailL1Open[i][F_PIECE], nPinA1, nPinB1);
                    }
                    str.Format("       %4.0f    C-O: %5.0f/%5.0f", nFailL1Open[i][F_PIECE], nPinA1, nPinB1);

                }
                else {

                    if (m_nFileLog_Error == 1) { //sylee130220 error file
                        fprintf(fp, " %4.0f O:%5.0f/%5.0f", nFailL1Open[i][F_PIECE], nPinA1, nPinB1);
                    }
                    str.Format("       %4.0f    O: %5.0f/%5.0f", nFailL1Open[i][F_PIECE], nPinA1, nPinB1); //son220419_4 3:F_PIECE
                }

            }
            else {

                if (m_nFileLog_Error == 1) { //sylee130220 error file
                    fprintf(fp, " %4.0f ?: %5.0f/%5.0f   ", nFailL1Open[i][F_PIECE], nPinA1, nPinB1); //son220419_4 3:F_PIECE
                }

            }

            dtep1 = nFailL1Open[i][F_REAL_R]; //son220419_4 15:F_REAL_R
            if (dtep1 >= 1000000000) {      //son Giga
                nFR12 = dtep1 / 1000000000;
                nFR11 = 3;
            }
            else if (dtep1 >= 1000000) {    //son Mega
                nFR12 = dtep1 / 1000000;
                nFR11 = 2;
            }
            else if (dtep1 >= 1000) {       //son Kilo
                nFR12 = dtep1 / 1000;
                nFR11 = 1;
            }
            else {
                nFR12 = dtep1;
                nFR11 = 0;
            }
            //  fprintf(fp, "  %.2f  ",  nFR12  );

            str1.Format(" %.2f  ", nFR12);

            if (SysInfo05.m_nHVCal1 == 1 && SysSet13.m_nSet14 == 1) {//sylee180220-1
                if (nFR11 == 1) {
                    str2.Format("K");
                }
                else if (nFR11 == 2) {
                    str2.Format("M");
                }
                else if (nFR11 == 3) {
                    str2.Format("G");
                }
                else {
                    str2.Format("");
                }
            }
            else {//sylee180220-1
                str2.Format("");//sylee180220-1
            }//sylee180220-1

            if (nFailL1Open[i][F_TEST_TYPE] == TEST_OPEN) {    //OPEN (1)   //son220318_3 //son220419_4 16:F_TEST_TYPE
                str3.Format("  ( > ");
                if (nFR11 == 2 || nFR11 == 3) {   //SYLEE120922
                    str1.Format("  ");
                    str2.Format("1M OVER");
                }
            }
            else {// short 
                str3.Format("  ( <");
                if ((nFR11 == 3) || ((nFR11 == 2) && (nFR12 > 200))) {     //SYLEE120922
                    str1.Format("  ");
                    str2.Format("200M OVER");
                }
            }

            dtep1 = nFailL1Open[i][F_PRORV_REAL_R]; //son220419_4 7:F_PRORV_REAL_R
            if (dtep1 >= 1000000000) {
                nFR14 = dtep1 / 1000000000;
                nFR13 = 3;
            }
            else if (dtep1 >= 1000000) {
                nFR14 = dtep1 / 1000000;
                nFR13 = 2;
            }
            else if (dtep1 >= 1000) {
                nFR14 = dtep1 / 1000;
                nFR13 = 1;
            }
            else {
                nFR14 = dtep1;
                nFR13 = 0;
            }
            str4.Format("%.0f ", nFR14);

            if (nFR13 == 1) {
                str5.Format("K)");
            }
            else if (nFR13 == 2) {
                str5.Format("M)");
            }
            else if (nFR13 == 3) {
                str5.Format("G)");
            }
            else {
                str5.Format(")");
            }
            str6.Format("\n");

            int nTmpR1, nTmpMod1;//sylee151118
            int nTemp1;


            nTmpR1 = (int)nFailL1Open[i][F_MODE1]; //son220419_4 11:F_MODE1

            nTmpMod1 = nTmpR1 % 5;//sylee151118

            if (nTmpMod1 == 2) {//sylee151118
                nTmpR1 = 10000;
                if (nFailL1Open[i][F_MODE1] == MODE7_OPEN_10V) {//sylee151118 //son220419_4 11:F_MODE1
                    nTmpR1 = 100000;//sylee151118
                }

            }
            else if (nTmpMod1 == 3) {//sylee151118
                nTmpR1 = 100000;//100K
            }
            else {//sylee151118

                nTemp1 = ((int)(nFailL1Open[i][F_REAL_R] / 50)) * 50;//sylee161118 //son220419_4 15:F_REAL_R

                //sylee161118   nTmpR1=300;
                nTmpR1 = nTemp1;//sylee161118

                if (nFailL1Open[i][F_MODE1] == MODE6_OPEN_10V) {//sylee151118 //son220419_4 11:F_MODE1
                    nTmpR1 = 1000;//sylee151118
                }
            }


            double dI1Per1;

            dI1Per1 = nFailL1Open[i][F_ISET] * 0.1;//sylee161121    //son220920 10:F_ISET
            if (dI1Per1 < 1) {
                dI1Per1 = 1;
            }

            if (SysInfo05.m_nHVCal1 == 1 && SysSet13.m_nSet14 == 1)//sylee140929   real r display
            {

                if (nFailL1Open[i][F_REAL_R] <= 0) { //sylee140929 //son220419_4 15:F_REAL_R
                    str7.Format(", R= 0 ohm  ");
                }
                else if (nFailL1Open[i][F_I] < dI1Per1)//sylee161122 //son220920 14:F_I
                {
                    if (nFailL1Open[i][F_REAL_R] < 100000) { //son220419_4 15:F_REAL_R
                        nTemp1 = ((int)(nFailL1Open[i][F_REAL_R] / 50)) * 50;
                        if (nTemp1 >= 100000) {
                            str7.Format(", R > 100 kohm");
                        }
                        else if (nTemp1 >= 1000) {
                            str7.Format(", R > %d kohm", (int)(nTmpR1 / 1000));
                        }
                        else {
                            str7.Format(", R > %d ohm", nTemp1);
                        }
                    }
                    else {
                        str7.Format(", R> 100 Kohm");
                    }

                }
                else if (nFailL1Open[i][F_VC] > 320)//sylee161203 //son220920 13:F_VC
                {
                    if (nFailL1Open[i][F_REAL_R] < 100000) { //son220419_4 15:F_REAL_R
                        nTemp1 = ((int)(nFailL1Open[i][F_REAL_R] / 50)) * 50;
                        if (nTemp1 >= 100000) {
                            str7.Format(", R > 100 kohm");
                        }
                        else if (nTemp1 >= 1000) {
                            str7.Format(", R > %d kohm", (int)(nTmpR1 / 1000));
                        }
                        else {
                            str7.Format(", R > %d ohm", nTemp1);
                        }
                    }
                    else {
                        str7.Format(", R> 100 Kohm");
                    }


                }
                else {//sylee161121
                    if (nTemp1 >= 100000) {
                        str7.Format(", R> 100 Kohm");
                    }
                    else if (nTemp1 >= 1000) {
                        str7.Format(", R= %d kohm", (int)(nFailL1Open[i][F_REAL_R] / 1000)); //son220419_4 15:F_REAL_R
                    }
                    else {
                        str7.Format(", R= %.1f ohm", nFailL1Open[i][F_REAL_R]); //son220419_4 15:F_REAL_R
                    }
                }//sylee161121

                //son Error file -> Refer.value Disable 이 Off 라면
                if (SysSet13.m_nSet15 != 1) {
                    //son  ( >     200    K)    , R> 100 Kohm
                    str2 = str3 + str4 + str5 + str7;
                }
                else {
                    //son  , R> 100 Kohm
                    str2 = str7;
                }
            }
            else {//sylee140929                                      
                if (SysSet13.m_nSet15 != 1) {
                    str2 = str3 + str4 + str5;
                }
            }//sylee140929 

            str1 = str2 + str6;

            if (m_nFileLog_Error == 1) { //sylee130220 error file
                fprintf(fp, str1);
            }
            if (SysInfo05.m_nHVCal1 == 1 && SysSet13.m_nSet14 == 1) {
                m_list1.AddString(str + str7);
            }
            else {
                m_list1.AddString(str);
            }
            m_list1.SetTopIndex(m_list1.GetCount() - 1);

        }
 

        //----------------------------
        //son Piece별 Short Error 출력 
        //----------------------------
        for (i = 1; i <= nFailL1Co; i++)
        {

            nPinA1 = nFailL1[i][F_VB_PIN];//sylee150921-1 //son220419_4 4:F_VB_PIN
            nPinB1 = nFailL1[i][F_VC_PIN];//sylee150921-1 //son220419_4 5:F_VC_PIN

            if (nPinConMode2 == 2) {//sylee150921-1  32k->16k
                if (nPinA1 > 16384) {
                    nPinA1 = nPinA1 - 8192;
                }
                if (nPinB1 > 16384) {
                    nPinB1 = nPinB1 - 8192;
                }
            }


            if (pi1 != nFailL1[i][F_PIECE]) {   //piece  //sylee120924
                continue;
            }

//son230726 begin:
            //son Short Fail D:\Log 프린트문 추가
            MyTrace(PRT_LEVEL3, "SHORT: %4.0f,  %5.0f,  %5.0f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f, %8.2f \n",
                                 nFailL1[i][F_PIECE], nPinA1, nPinB1, 
                                 nFailL1[i][F_PRORV_REAL_R], nFailL1[i][F_PRORV_RAW_R],
								 nFailL1[i][F_REAL_R], nFailL1[i][F_RAW_R],
                                 nFailL1[i][F_VB],  nFailL1[i][F_VC], nFailL1[i][F_I],
                                 nFailL1[i][F_VSET], nFailL1[i][F_ISET]);

//son230726 end

            //son SHORT
            if (nFailL1[i][F_TEST_TYPE] >= TEST_U_SHORT && nFailL1[i][F_TEST_TYPE] <= TEST_LEAK2)  //SHORT   //sylee140923  //son220318_3 //son220915
            {

                //-----------------
                //son  근접 Short
                
                //son 측정값 real R이  판정 real R보다는 작지만 판정 real R * 0.9 보다 크거나 같은  경우.
                //   ex)  판정 realR *0.9 <  측정 realR  < 판정 realR
                if (nFailL1[i][F_REAL_R] >= (nFailL1[i][F_PRORV_REAL_R] * 0.9))  //SYLEE20120702  //son220920
                {
                    if (nFailL1[i][F_TEST_TYPE] == TEST_U_SHORT) {    //son220318_3 2:TEST_U_SHORT//son220915 16:F_TEST_TYPE
                        str.Format("      %4.0f  U: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                    }
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_SHORT) { //son220318_3 3:TEST_SHORT    //son220915
                        str.Format("      %4.0f  S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                    }
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_HR_SHORT) { //son220318_3 4:TEST_HR_SHORT  //son220915
                        if (SysSet13.m_nShortDetailOff == 1) {//sylee210824 //son220318_2
                            str.Format("      %4.0f  S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                        }
                        else {
                            str.Format("      %4.0f  H: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                        }
                    }
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1 || nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {    //son220318_3 //son220915 
                        if (nHVDStopFlag == 1) {//sylee121009
                            if (nPinA1 == -1) {//SPARK  
#if (defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER) || defined(__CCTC__CUSTOMER))   //sylee221207 //son231205 | => || 로 오류 수정 
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    
                                    str.Format("      %4.0f  K1%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f  K2%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
    #else
                                //son230417 if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) { //son220915 16:F_TEST_TYPE
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   //son230417
                                    str.Format("      %4.0f  K1: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f  K2: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);
                                }    
    #endif //sylee231016 end
#else
                                str.Format("      %4.0f  K: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1); //sylee200811 k   
#endif                                   
                            }
                            else if (nPinB1 == -1)  // hdpark231205 leak fail->pass, 진행성 불량 표시, 영풍
                            {
                                if (g_bUseProgressiveFault)
                                {
                                    if (SysSet13.m_nShortDetailOff == 1) {
                                        str.Format("      %4.0f  Sx: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f  S: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);        // 임시 테스트용, Main 변경 없이 임시로 사용.
                                    }
                                }
                            }
                            else {
                                if (SysSet13.m_nShortDetailOff == 1) {//sylee210824 //son220318_2
                                    str.Format("      %4.0f  S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1); //sylee210824                                                       
                                }
                                else {
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {                    
                                            str.Format("   %4.0f  L%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],  nFailL1[i][F_STEP], nPinB1, nPinA1);
                                        }
                                        else {
                                            str.Format("    %4.0f  Z%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nFailL1[i][F_STEP],nPinB1, nPinA1);//sylee231016 
                                        }
    #else
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    //son220915 16:F_TEST_TYPE                      ;
                                            str.Format("   %4.0f  L: %5.0f/%5.0f,", nFailL1[i][F_PIECE],  nPinB1, nPinA1);
                                        }
                                        else {
                                            str.Format("    %4.0f  Z: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee231016 
                                        }                                            
    #endif //sylee231016 end
                                     
                                }
                            }
                            fprintf(fp, " ***> LEAK Time over !  (1) ");//sylee210623
                        }
                        else {
                            if (nPinA1 == -1) {//SPARK    
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER) || defined(__CCTC__CUSTOMER)   //sylee221207  //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin

                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  
                                    str.Format("      %4.0f  K1%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f  K2%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
    #else
    
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    //son220915 16:F_TEST_TYPE
                                    str.Format("      %4.0f  K1: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f  K2: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);
                                } 
    #endif  //sylee231016 end
#else
                                str.Format("      %4.0f  K: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1); //sylee200811 k  
#endif                                   
                            }
                            else if (nPinB1 == -1) // hdpark231205 leak fail->pass, 진행성 불량 표시
                            {
                                if (g_bUseProgressiveFault)
                                {
                                    if (SysSet13.m_nShortDetailOff == 1) {//sylee210824      //son220318_2 
                                        str.Format("      %4.0f  Sx: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f  S: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                }
                            }
                            else {
                                if (SysSet13.m_nShortDetailOff == 1) {//sylee210824      //son220318_2 
                                    str.Format("      %4.0f  S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                                else {
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     
                                        str.Format("      %4.0f  L%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f  Z%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }

    #else
                                     if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    //son220915 16:F_TEST_TYPE
                                        str.Format("      %4.0f  L: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f  Z: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
    #endif //sylee231016 end
                                }
                            }
                        }
                    }


                    if (m_nFileLog_Error == 1) { //sylee130220 error file
                        if ((nFailL1[i][F_TEST_TYPE] == TEST_LEAK1       //son220325    //son220915 16:F_TEST_TYPE
                            || nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) && nHVDStopFlag == 1) {  //SYLEE121012  //sylee140923     //son220915

                            if (SysSet13.m_nShortDetailOff == 1) {//sylee210824    //son220318_2
                                fprintf(fp, " %4.0f S: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                            }
                            else {
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     
                                    fprintf(fp, " %4.0f L%1.0f: %5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);//SYLEE210623
                                }
                                else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) { 
                                    fprintf(fp, " %4.0f Z%1.0f: %5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                }
                                else {
                                    fprintf(fp, " %4.0f S: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }

    #else
                                 if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {      //son220325   //son220915
                                    fprintf(fp, " %4.0f L: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);//SYLEE210623
                                }
                                else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {//sylee210421 NANOSYS       //son220325    //son220915
                                    fprintf(fp, " %4.0f Z: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                                else {
                                    fprintf(fp, " %4.0f S: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
    #endif //sylee231016 end
                            }
                            fprintf(fp, " ***> LEAK Time over !  (2) ");//sylee210623

                        }
                        else 
                        {
                            if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1
                                || nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) //SYLEE121121  //sylee140923     //son220325   //son220915
                            {
                                if (nPinA1 == -1) {//SPARK                                      
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    
                                        fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }

    #else
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    //son220915 16:F_TEST_TYPE
                                        fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    }
     
    #endif //sylee231016 begin
#else
                                    fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);//SYLEE200811 K 
#endif
                                }
                                else if (nPinB1 == -1) // hdpark231205 leak fail->pass, 진행성 불량 표시
                                {
                                    if (g_bUseProgressiveFault)
                                    {
                                        if (SysSet13.m_nShortDetailOff == 1) {
                                            fprintf(fp, " %4.0f Sx:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinA1);
                                        }
                                        else {
                                            fprintf(fp, " %4.0f S: %5.0f/- ", nFailL1[i][F_PIECE], nPinA1);
                                        }
                                    }
                                }
                                else {
                                    if (SysSet13.m_nShortDetailOff == 1) {//sylee210824    //son220318_2
                                        fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else {
#ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {      
                                            fprintf(fp, " %4.0f L%1.0f:%5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);//SYLEE210623
                                        }
                                        else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) { 
                                            fprintf(fp, " %4.0f Z%1.0f: %5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                        }
                                        else {//sylee210421 NANOSYS
                                            fprintf(fp, " %4.0f S: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }
#else
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {      //son220325   //son220915 16:F_TEST_TYPE
                                            fprintf(fp, " %4.0f L:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);//SYLEE210623
                                        }
                                        else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {//sylee210421 NANOSYS  //son220915
                                            fprintf(fp, " %4.0f Z:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }
                                        else {//sylee210421 NANOSYS
                                            fprintf(fp, " %4.0f S: %5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        } 
#endif  //sylee231016 end 
                                    }
                                }

                            }
                            else
                            {
                                if (nFailL1[i][1] != 2) {//sylee170921-1
                                    if (nPinA1 == -1) {//SPARK
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER) || defined(__CCTC__CUSTOMER)   //sylee221207  //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   
                                            fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                        }
                                        else {
                                            fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                        }
    #else
                                       if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   //son220915 16:F_TEST_TYPE
                                            fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                        }
                                        else {
                                            fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                        } 
    #endif //sylee231016 end

#else
                                        fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1); //sylee200811-1 k
#endif                                            
                                    }
                                    else {
#if (defined(__NANOSYS__CUSTOMER) || defined(__LM__CUSTOMER)) //sylee210303 NANOSYS  //son220915_2 
                                        if (nFailL1[i][1] == TEST_SHORT || nFailL1[i][1] == TEST_HR_SHORT) {//sylee210303 NANOSYS
                                            fprintf(fp, " %4.0f H:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210303 NANOSYS
                                        }
                                        else if (nFailL1[i][1] == TEST_U_SHORT) {//sylee210421 NANOSYS
                                            fprintf(fp, " %4.0f U:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }

    #ifdef __RECIPE_LEAK_MORE1  //sylee231016
                                        else if (nFailL1[i][1] == TEST_LEAK1) { 
                                            fprintf(fp, " %4.0f L%1.0f:%5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                        }
                                        else if (nFailL1[i][1] == TEST_LEAK2) { 
                                            fprintf(fp, " %4.0f Z%1.0f:%5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                        }
    #else
                                        else if (nFailL1[i][1] == TEST_LEAK1) {//sylee210421 NANOSYS
                                            fprintf(fp, " %4.0f L:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }
                                        else if (nFailL1[i][1] == TEST_LEAK2) {//sylee210421 NANOSYS
                                            fprintf(fp, " %4.0f Z:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        } 
    #endif          
                                        else {
                                            fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }
#else
                                        if (nFailL1[i][1] == TEST_SHORT) {//SYLEE210623
                                            fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                        }
                                        else {
                                            if (SysSet13.m_nShortDetailOff == 1) {//sylee210824   //son220318_2
                                                fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1); //sylee210824
                                            }
                                            else {
                                                fprintf(fp, " %4.0f H:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);//SYLEE210623
                                            }
                                        }
#endif
                                    }
                                }
                                else {//sylee170921-1
                                    if (nPinA1 == -1) {//SPARK  //sylee170921-1                                                 

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER) || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     
                                            fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                        }
                                        else {
                                            fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                        }
    #else
                                        if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {    //son220915 16:F_TEST_TYPE
                                            fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                        }
                                        else {
                                            fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                        }
    #endif //sylee231016 end
#else
                                        fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k 
#endif
                                    }
                                    else {//sylee170921-1
                                        fprintf(fp, " %4.0f U:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                }//sylee170921-1
                            }
                        }
                    }//endof if(  m_nFileLog_Error==1) //sylee130220 error file

                }

                //son 측정값 real R이  판정 real R *0.9 보다 작은  경우.
                //   ex)  측정 R  < 판정 realR *0.9   < 판정 realR
                else//end of if(nFailL1[i][F_REAL_R]>=(nFailL1[i][F_PRORV_REAL_R]*0.9))  //SYLEE20120702   //son220920
                {

                    //son 2:TEST_U_SHORT
                    if (nFailL1[i][F_TEST_TYPE] == TEST_U_SHORT) {           //son220325    //son220915 16:F_TEST_TYPE
                        str.Format("       %4.0f   U: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                    }

                    //son 3:TEST_SHORT
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_SHORT) {        //son220325    //son220915 16:F_TEST_TYPE
                        str.Format("       %4.0f   S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                        //TEMPQCTEST    str.Format("      %4.0f, %4.0f,    ,%5.0f,%5.0f,", dRecRef1[i-1], nFailL1[i][F_PIECE],nPinB1,nPinA1  );
                    }

                    //son 4:TEST_HR_SHORT
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_HR_SHORT) { //son220325    //son220915 16:F_TEST_TYPE
                        if (SysSet13.m_nShortDetailOff == 1) {//sylee210824   //son220318_2
                            str.Format("       %4.0f  S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                        }
                        else {
                            str.Format("       %4.0f  H: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                        }
                    }

                    //5:TEST_LEAK1, 6:TEST_LEAK2
                    else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1 || nFailL1[i][F_TEST_TYPE] == TEST_LEAK2)//sylee140923  //son220325 //son220915 16:F_TEST_TYPE
                    {
                        if (nHVDStopFlag == 1) {//sylee121009
                            if (nPinA1 == -1) {//SPARK 
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   
                                    str.Format("      %4.0f   K1%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);//sylee200811 k 
                                }
                                else {
                                    str.Format("      %4.0f   K2%1.0f: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);//sylee200811 k 
                                }
    #else
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  //son220915 16:F_TEST_TYPE
                                    str.Format("      %4.0f   K1: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k 
                                }
                                else {
                                    str.Format("      %4.0f   K2: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k 
                                } 
    #endif //sylee231016 end
#else
                                str.Format("      %4.0f   K: %5.0f/*=> Spark! ,", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k 
#endif

                            }
                            else if (nPinB1 == -1) // hdpark231205 leak fail->pass, 진행성 불량 표시
                            {
                                if (g_bUseProgressiveFault)
                                {
                                    if (SysSet13.m_nShortDetailOff == 1) {//sylee210824    //son220318_2
                                        str.Format("      %4.0f   Sx: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f   S: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                }
                            }
                            else {

                                if (SysSet13.m_nShortDetailOff == 1) {//sylee210824    //son220318_2
                                    str.Format("      %4.0f   S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                                else {
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     
                                        str.Format("      %4.0f   L%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
                                    else {   
                                        str.Format("      %4.0f   Z%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nFailL1[i][F_STEP],nPinB1, nPinA1);
                                    }
    #else
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     //son220325 //son220915 16:F_TEST_TYPE
                                        str.Format("      %4.0f   L: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else {   //son Leak2 
                                        str.Format("      %4.0f   Z: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
    #endif //sylee231016 end
                                }
                            }
                            fprintf(fp, " ***> LEAK Time over !  (3) ");//sylee210623
                        }
                        else {
                            if (nPinA1 == -1) {//SPARK
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin

                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  
                                    str.Format("      %4.0f   K1%1.0f: %5.0f/ *=> Spark!,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f   K2%1.0f: %5.0f/ *=> Spark!,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                }
    #else
     
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  //son220915 16:F_TEST_TYPE
                                    str.Format("      %4.0f   K1: %5.0f/ *=> Spark!,", nFailL1[i][F_PIECE], nPinB1);
                                }
                                else {
                                    str.Format("      %4.0f   K2: %5.0f/ *=> Spark!,", nFailL1[i][F_PIECE], nPinB1);
                                }
    #endif //sylee231016 end
#else
                                str.Format("      %4.0f   K: %5.0f/ *=> Spark!,", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k  
#endif

                            }
                            else if (nPinB1 == -1) // hdpark231205 leak fail->pass, 진행성 불량 표시
                            {
                                if (g_bUseProgressiveFault)
                                {
                                    if (SysSet13.m_nShortDetailOff == 1) {
                                        str.Format("      %4.0f   Sx: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f   S: %5.0f/-,", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                }
                            }
                            else {
                                if (SysSet13.m_nShortDetailOff == 1) {//sylee210824   //son220318_2
                                    str.Format("      %4.0f   S: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                                else {
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin

                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     
                                        str.Format("      %4.0f   L%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f   Z%1.0f: %5.0f/%5.0f,", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
    #else

                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     //son220325 //son220915 16:F_TEST_TYPE
                                        str.Format("      %4.0f   L: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else {
                                        str.Format("      %4.0f   Z: %5.0f/%5.0f,", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }    
    #endif //sylee231016 end
                                }
                            }
                        }
                    }

                    if (m_nFileLog_Error == 1) //sylee130220 error file
                    {
                        if ((nFailL1[i][F_TEST_TYPE] == TEST_LEAK1      //son220325 //son220915 16:F_TEST_TYPE
                            || nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) && nHVDStopFlag == 1) {  //SYLEE121012   //son220325

                            if (nPinA1 == -1) {//SPARK   
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  
                                    fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);   //sylee220722
                                }
                                else {
                                    fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);   //sylee220722
                                }
    #else
                                if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) { //son220915 16:F_TEST_TYPE
                                    fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);   //sylee220722
                                }
                                else {
                                    fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);   //sylee220722
                                }    
    #endif //sylee231016 end
#else
                                fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k    
#endif

                            }
                            else if (nPinB1 == -1) // hdpark231205 leak fail->pass, 진행성 불량 표시
                            {
                                if (g_bUseProgressiveFault)
                                {
                                    if (SysSet13.m_nShortDetailOff == 1) {
                                        fprintf(fp, " %4.0f Sx:%5.0f/-", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f S:%5.0f/- ", nFailL1[i][F_PIECE], nPinA1);
                                    }
                                }
                            }
                            else {
                                if (SysSet13.m_nShortDetailOff == 1) {//sylee210824   //son220318_2
                                    fprintf(fp, " %4.0f S:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                                else {
#ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   
                                        fprintf(fp, " %4.0f L%1.0f:%5.0f/%5.0f", nFailL1[i][F_PIECE], nFailL1[i][F_STEP],nPinB1, nPinA1);//sylee210623
                                    }
                                    else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) { 
                                        fprintf(fp, " %4.0f Z%1.0f:%5.0f/%5.0f", nFailL1[i][F_PIECE], nFailL1[i][F_STEP],nPinB1, nPinA1);//sylee210623
                                    }
#else
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  //son220325 //son220915 16:F_TEST_TYPE
                                        fprintf(fp, " %4.0f L:%5.0f/%5.0f", nFailL1[i][F_PIECE],nPinB1, nPinA1);//sylee210623
                                    }
                                    else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {//sylee210421 NANOSYS       //son220325 //son220915 16:F_TEST_TYPE
                                        fprintf(fp, " %4.0f Z:%5.0f/%5.0f", nFailL1[i][F_PIECE],nPinB1, nPinA1);//sylee210623
                                    } 
#endif //sylee231016 end
                                    else {
                                        fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                }
                            }
                            fprintf(fp, " ***> LEAK Time over !  (4) ");//sylee210623


                        }
                        else
                        {
                            if (nFailL1[i][1] != 2)//sylee170921-1
                            {
                                if (nPinA1 == -1) {//SPARK  
#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  
                                        fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }
    #else
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) { //son220915 16:F_TEST_TYPE
                                        fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    } 
    #endif //sylee231016 end
#else
                                    fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);//sylee200811-1 k   
#endif 
                                }
                                else
                                {
#if (defined(__NANOSYS__CUSTOMER) || defined(__LM__CUSTOMER)) //sylee210303 NANOSYS    //son220915_2                                            
                                    if (nFailL1[i][1] == TEST_SHORT || nFailL1[i][1] == TEST_HR_SHORT) {//sylee210303 NANOSYS
                                        fprintf(fp, " %4.0f H:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210303 NANOSYS
                                    }
                                    else if (nFailL1[i][1] == TEST_U_SHORT) {//sylee210421 NANOSYS
                                        fprintf(fp, " %4.0f U:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    else if (nFailL1[i][1] == TEST_LEAK1) { 
                                        fprintf(fp, " %4.0f L%1.0f:%5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
                                    else if (nFailL1[i][1] == TEST_LEAK2) { 
                                        fprintf(fp, " %4.0f Z%1.0f:%5.0f/%5.0f ", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);
                                    }
    #else
                                    else if (nFailL1[i][1] == TEST_LEAK1) {//sylee210421 NANOSYS
                                        fprintf(fp, " %4.0f L:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else if (nFailL1[i][1] == TEST_LEAK2) {//sylee210421 NANOSYS
                                        fprintf(fp, " %4.0f Z:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
    #endif //sylee231016 end
                                    else {
                                        fprintf(fp, " %4.0f S:%5.0f/%5.0f ", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
#else

                                    if (SysSet13.m_nShortDetailOff == 1) {//sylee210824    //son220318_2
                                        fprintf(fp, " %4.0f S:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                    }
                                    else {
                                        if (SysSet13.m_nShortDetailOff == 1) {//sylee210824  //son220318_2
                                            fprintf(fp, " %4.0f S:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210824
                                        }
                                        else {
                                            if (nFailL1[i][1] == TEST_HR_SHORT) {//sylee210623
                                                fprintf(fp, " %4.0f H:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                            }
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                            else if (nFailL1[i][1] == TEST_LEAK1) { 
                                                fprintf(fp, " %4.0f L%1.0f:%5.0f/%5.0f", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);//sylee210623
                                            }
                                            else if (nFailL1[i][1] == TEST_LEAK2) { 
                                                fprintf(fp, " %4.0f Z%1.0f:%5.0f/%5.0f", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1, nPinA1);//sylee210623
                                            }
    #else
                                             else if (nFailL1[i][1] == TEST_LEAK1) {//sylee210623
                                                fprintf(fp, " %4.0f L:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210623
                                            }
                                            else if (nFailL1[i][1] == TEST_LEAK2) {//sylee210623
                                                fprintf(fp, " %4.0f Z:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210623
                                            } 
    #endif //sylee231016 end
                                            else {//sylee210623
                                                fprintf(fp, " %4.0f S:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);//sylee210623
                                            }
                                        }
                                    }
#endif
                                }

                            }
                            else {   //sylee170921-1     
                                if (nPinA1 == -1) {//SPARK  //sylee170921-1   

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)  || defined(__CCTC__CUSTOMER)   //sylee221207 //son231205 | => || 로 오류 수정
    #ifdef __RECIPE_LEAK_MORE1  //sylee231016 begin
                                    if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {  
                                        fprintf(fp, " %4.0f K1%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2%1.0f:%5.0f/*=>Spark!", nFailL1[i][F_PIECE],nFailL1[i][F_STEP], nPinB1);
                                    }
    #else
                                     if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) { //son220915 16:F_TEST_TYPE
                                        fprintf(fp, " %4.0f K1:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    }
                                    else {
                                        fprintf(fp, " %4.0f K2:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);
                                    } 
    #endif //sylee231016 end
#else
                                    fprintf(fp, " %4.0f K:%5.0f/*=>Spark!", nFailL1[i][F_PIECE], nPinB1);//sylee200811 k   
#endif 
                                }
                                else {
                                    fprintf(fp, " %4.0f U:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinB1, nPinA1);
                                }
                            }

                        }
                    }//end of   if(  m_nFileLog_Error==1) //sylee130220 error file


                }  //end of if(nFailL1[i][F_REAL_R]>=(nFailL1[i][F_PRORV_REAL_R]*0.9))  //SYLEE20120702  


            }
            else {  //end of if(nFailL1[i][F_TEST_TYPE]>=2 && nFailL1[i][F_TEST_TYPE]<=6 ){  //SHORT   //sylee140923 //son220915
                if (m_nFileLog_Error == 1) { //sylee130220 error file
                    fprintf(fp, " %4.0f ??  S:%5.0f/%5.0f", nFailL1[i][F_PIECE], nPinA1, nPinB1);//sylee210623
                }
            }  //end of if(nFailL1[i][F_TEST_TYPE]>=2 && nFailL1[i][F_TEST_TYPE]<=6 )  //SHORT    //sylee140923 //son220915



			if(nLeakACMode1==2){//sylee241120-2   //sylee241204-2
				if(nFailL1[i][F_AC] ==1){///sylee241122
				   fprintf(fp, " ,-R");//sylee241122
				}
			}

            dtep1 = nFailL1[i][F_REAL_R];           //son220915
            if (dtep1 >= 1000000000) {
                nFR12 = dtep1 / 1000000000;
                nFR11 = 3;
            }
            else if (dtep1 >= 1000000) {
                nFR12 = dtep1 / 1000000;
                nFR11 = 2;
            }
            else if (dtep1 >= 1000) {
                nFR12 = dtep1 / 1000;
                nFR11 = 1;
            }
            else {
                nFR12 = dtep1;
                nFR11 = 0;
            }
            //  fprintf(fp, "  %.2f  ",  nFR12  );

            str1.Format("%.2f", nFR12);

            //son SysSet13.m_nSet14: "Display Error Pin    Real  R." 
            if (SysInfo05.m_nHVCal1 == 1 && SysSet13.m_nSet14 == 1) {//sylee180220-1
                if (nFR11 == 1) {
                    str2.Format("K");
                }
                else if (nFR11 == 2) {
                    str2.Format("M");
                }
                else if (nFR11 == 3) {
                    str2.Format("G");
                }
                else {
                    str2.Format("");
                }
            }
            else {//sylee180220-1
                str2.Format("");//sylee180220-1
            }//sylee180220-1


            if (nFailL1[i][F_TEST_TYPE] == TEST_OPEN) {    //OPEN        //son220325 //son220915 16:F_TEST_TYPE
                str3.Format("  ( > ");
                if (nFR11 == 2 || nFR11 == 3) {   //SYLEE120922
                    str1.Format("  ");
                    str2.Format("1M OVER");
                }
            }
            else {// short 
                str3.Format("  ( < ");
                if ((nFR11 == 3) || ((nFR11 == 2) && (nFR12 > 200))) {     //SYLEE120922
                    str1.Format("  ");
                    str2.Format("200M OVER");
                }
            }

            //////////////////////////////////////////////////////////
            //sylee220725
            if (nFailL1[i][F_TEST_TYPE] == TEST_U_SHORT) {        //son220915 16:F_TEST_TYPE
                nFailL1[i][F_PRORV_REAL_R] = nProStep1[TEST_U_SHORT][1];    //son 7: F_PRORV_REAL_R
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_SHORT) {     //son220915
                nFailL1[i][F_PRORV_REAL_R] = nProStep1[TEST_SHORT][1];
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_HR_SHORT) {  //son220915
                nFailL1[i][F_PRORV_REAL_R] = nProStep1[TEST_HR_SHORT][1];
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {     //son220915
                nFailL1[i][F_PRORV_REAL_R] = nProStep1[TEST_LEAK1][1];
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {     //son220915
                nFailL1[i][F_PRORV_REAL_R] = nProStep1[TEST_LEAK2][1];
            }
            //////////////////////////////////////////////////////////

            dtep1 = nFailL1[i][F_PRORV_REAL_R];
            if (dtep1 >= 1000000000) {
                nFR14 = dtep1 / 1000000000;
                nFR13 = 3;
            }
            else if (dtep1 >= 1000000) {
                nFR14 = dtep1 / 1000000;
                nFR13 = 2;
            }
            else if (dtep1 >= 1000) {
                nFR14 = dtep1 / 1000;
                nFR13 = 1;
            }
            else {
                nFR14 = dtep1;
                nFR13 = 0;
            }
            str4.Format("%.0f", nFR14);

            if (nFR13 == 1) {
                str5.Format("K)");
            }
            else if (nFR13 == 2) {
                str5.Format("M)");
            }
            else if (nFR13 == 3) {
                str5.Format("G)");
            }
            else {
                str5.Format(")");
            }

#if 0   //son220719 삭제 
            if (nFailL1[i][9] == 1) {//sylee161209                               
                str6.Format(" ,uShort\n");
            }
            else if (nFailL1[i][9] > 20) {//sylee161209                            
                str6.Format(" ,Leak\n");
            }
            else { //sylee161209                                
                str6.Format(" ,HR Short\n");
            }
#else   



	 #ifndef __DISPLAY_ERRORFILE_STEP  //sylee231201  

			if (nFailL1[i][F_TEST_TYPE] == TEST_U_SHORT) {      //son 2: TEST_U_SHORT
                str6.Format(" ,uShort \n");  //sylee231201    
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_SHORT) {   //son 3: TEST_SHORT
                str6.Format(" ,Short \n");  //sylee231201  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_HR_SHORT) {//son 4: TEST_HR_SHORT
                str6.Format(" ,HR Short \n" ); //sylee231201   
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   //son 5: TEST_LEAK1
                str6.Format(" ,Leak1 \n");  //sylee231201  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {   //son 6: TEST_LEAK2
                str6.Format(" ,Leak2 \n");  //sylee231201  
            }
            else {
                //son230417 적용보류.  str6.Format(" ,Undef Short? \n");   //son230417
                str6.Format("\n");   
            }
    
     #else//sylee231201  

		    //son220719 begin  
            // BH에서 Leak 50M ohm 으로 설정했는데 20Mohm으로 출력되는 문제 관련 수정
            // Leak 출력 기준을  nFailL1[i][9:F_VSET] 이 아니라 nFailL1[i][F_TEST_TYPE:F_TEST_TYPE]   으로 수정
            if (nFailL1[i][F_TEST_TYPE] == TEST_U_SHORT) {      //son 2: TEST_U_SHORT
                str6.Format(" ,uShort  Step%1.0f \n",nFailL1[i][F_STEP]);  //sylee231016  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_SHORT) {   //son 3: TEST_SHORT
                str6.Format(" ,Short Step%1.0f\n",nFailL1[i][F_STEP]);//sylee231016  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_HR_SHORT) {//son 4: TEST_HR_SHORT
                str6.Format(" ,HR Short Step%1.0f\n",nFailL1[i][F_STEP]);//sylee231016  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK1) {   //son 5: TEST_LEAK1
                str6.Format(" ,Leak1 Step%1.0f\n",nFailL1[i][F_STEP]);//sylee231016  
            }
            else if (nFailL1[i][F_TEST_TYPE] == TEST_LEAK2) {   //son 6: TEST_LEAK2
                str6.Format(" ,Leak2 Step%1.0f\n",nFailL1[i][F_STEP]);//sylee231016  
            }
            else {
                //son230417 적용보류.  str6.Format(" ,Undef Short? \n");   //son230417
                str6.Format("\n");   
            }	

     #endif//sylee231201  
 

 
     
#endif  //son220719 end

            if (SysInfo05.m_nHVCal1 == 1 && SysSet13.m_nSet14 == 1)//sylee140929   real r display
            {

                int nShortVal;

                if (nFailL1[i][F_VB] <= 10) {//sylee150622  //son220915 12:F_VB
                    nShortVal = 1000;
                }
                else {
                    nShortVal = 500000; //500k
                }

                // hdpark220914 comment, use 200 MOhm with leak, 김영필이사 요청
                //if(0)  // (nFailL1[i][F_REAL_R] > 150000000)  


				int nRefLeakR;

				nRefLeakR=MAX_LEAK_USER_R * 1000;

	            if (nFailL1[i][F_REAL_R] >  nRefLeakR ) //sylee230828   MAX_LEAK_USER_R=kohm
                {                                         
                     str7.Format(", R >%d Mohm , Over",  int(nRefLeakR/1000000));  
                     str9.Format(", R >%d Mohm , Over",  int(nRefLeakR/1000000));                    
                }
                else //sylee140929 
                {
                    dtep1 = nFailL1[i][F_REAL_R];   //son220915 15:F_REAL_R
                    if (dtep1 >= 1000000000) {
                        nFR14 = dtep1 / 1000000000;   
                        nFR13 = 3;
                    }
                    else if (dtep1 >= 1000000) {
                        nFR14 = dtep1 / 1000000;      
                        nFR13 = 2;
                    }
                    else if (dtep1 >= 1000) {
                        nFR14 = dtep1 / 1000;         
                        nFR13 = 1;
                    }
                    else {
                        nFR14 = dtep1;                
                        nFR13 = 0;
                    }

                    if (nFR13 == 1) {
                        str2.Format("K");
                    }
                    else if (nFR13 == 2) {
                        str2.Format("M");
                    }
                    else if (nFR13 == 3) {
                        str2.Format("G");
                    }


                    double dtep2;//sylee170703-1

                    if (nFailL1[i][F_RAW_R] > 62000) {//sylee170703-1 //son220419_4 6:F_RAW_R
                        if (dtep1 >= 1000000) {//sylee170703-1
                            dtep2 = dtep1 / 1000000.;
                            str1.Format(", R< %.1fM ", dtep2);
                            str9.Format("  R< %.1fM ", dtep2);
                            str2.Format("");
                        }
                        else if (dtep1 >= 1000) {//sylee170703-1
                            dtep2 = dtep1 / 1000.;
                            str1.Format(", R< %.1fK ", dtep2);
                            str9.Format("  R< %.1fK ", dtep2);
                            str2.Format("");
                        }
                        else {  //sylee170703-1 
                            dtep2 = dtep1;//SYLEE210310
                            str1.Format(", R< %.1f ", dtep2);
                            str9.Format("  R< %.1f ", dtep2);
                            str2.Format("");
                        }
                    }
                    else {
                        dtep2 = dtep1;   //SYLEE210421<===========
                        str1.Format(", R= %.1f ", nFR14);
                        str9.Format("  R= %.1f ", nFR14); //sylee150622-3
                    }//sylee161214-2                                     


                    CString  str10;//sylee241107
                    double  dFailVset1, dI1, dI2, dI3;//sylee241107
                    if(nFailL1[i][F_REAL_R]>0){//sylee241107 	
                        dFailVset1=nFailL1[i][F_VSET];
                        if(dFailVset1=15) dFailVset1=10;
                        dI1=(dFailVset1/nFailL1[i][F_REAL_R]);//sylee241107
                        dI2=dI1*1000.;//sylee241107
                        dI3=dI2*1000.;//sylee241107						
                        if(dI2>0.001){ //sylee241107 
                            if(dI2> nFailL1[i][F_ISET]){
                                dI2=nFailL1[i][F_ISET];//sylee241107 
                            }
                            str10.Format(",(%.3f mA)", dI2);//sylee241107
                        }else{
                            str10.Format(",(%.3f uA)", dI3);//sylee241107
                        }
                        str1 = str1 +str2 + str10 ;//sylee241107 
                    }else{//sylee241107 
                        str1 = str1 + str2;
                    }
                    str7 = str1;
                    str9 = str9 + str2;//sylee150622-3
                }

                //son "Check15: Error file -> Refer.value Disable"  Off이면 
                if (SysSet13.m_nSet15 != 1) {
                    str2 = str3 + str4 + str5 + str7;
                }
                else {
                    str2 = str7;
                }

            }
            else {//sylee140929                                   
                if (SysSet13.m_nSet15 != 1) {  
                    str2 = str3 + str4 + str5;
                }
            }//sylee140929 

            //   str2= str3+str4+str5;//판정조건 
            str1 = str2 + str6;


            if (m_nFileLog_Error == 1) { //sylee130220 error file

                if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                {
                    if (nPinA1 == -1) {//SPARK//sylee200714 NEW_SPARK

						if(nFailL1[i][F_TEST_TYPE] == TEST_LEAK1)	// hdpark230331
						{
							if(m_nSparkDetection[1] == 0)	str1.Format(" ( %.1fV/ %.1fV ) \n  ", nFailL1[i][F_VC], nFailL1[i][F_VB]); //son220915 12:F_VB, 13:F_VC
							else							str1.Format(" ( %.2fmA ) \n  ", nFailL1[i][F_I]); //hdpark230105 spark 
						}
						else if(nFailL1[i][F_TEST_TYPE] == TEST_LEAK2)
						{
							if(m_nSparkDetection[2] == 0)	str1.Format(" ( %.1fV/ %.1fV ) \n  ", nFailL1[i][F_VC], nFailL1[i][F_VB]); //son220915 12:F_VB, 13:F_VC
							else							str1.Format(" ( %.2fmA ) \n  ", nFailL1[i][F_I]); //hdpark230105 spark 
						}
                        fprintf(fp, str1);

                    }
                    else {//sylee200714
                        fprintf(fp, str1);
                    }
                }
                else
                    fprintf(fp, str1);


            }

            //sylee150622   m_list1.AddString(str);

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
            {
                if (nPinA1 == -1) {//SPARK//sylee200714 NEW_SPARK
					if(nFailL1[i][F_TEST_TYPE] == TEST_LEAK1)	// hdpark230331
					{
						if(m_nSparkDetection[1] == 0)	str9.Format(" ( %.1fV/ %.1fV ) \n  ", nFailL1[i][F_VC], nFailL1[i][F_VB]); //son220915 12:F_VB, 13:F_VC
						else							str9.Format(" ( %.2fmA ) \n  ", nFailL1[i][F_I]); //hdpark230105 spark 
					}
					else if(nFailL1[i][F_TEST_TYPE] == TEST_LEAK2)
					{
						if(m_nSparkDetection[2] == 0)	str9.Format(" ( %.1fV/ %.1fV ) \n  ", nFailL1[i][F_VC], nFailL1[i][F_VB]); //son220915 12:F_VB, 13:F_VC
						else							str9.Format(" ( %.2fmA ) \n  ", nFailL1[i][F_I]); //hdpark230105 spark 
					}
                }
            }

            m_list1.AddString(str + str9);//sylee150622 
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
         
        }  //end of     for(i=1; i<=nFailL1Co; i++)

    }//log  piece sort   //sylee120924-1


//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    if (n4w_Sample_Enable == 1) {//sylee171102-1
        g_n4WFailCount = 0;//SYLEE171102-1
    }


    //4w cal convert  //sylee20120301start
    //-------------------------------------

    CString strE, strE1, strE2, strE3, strE4;   //son221114

    for (i = 1; i <= g_n4WFailCount; i++)     //4WCODE_131118
    {

        int n4wCalErrLog1;
        double d4wCalR1;

        n4wCalErrLog1 = 1;
        d4wCalR1 = 0;

        //son221114 begin:
        strE.Format("E");
        strE1.Format("E1");     //son Ref High Fail    : Ref High Limit 보다 Fail R 값이 큼
        strE2.Format("E2");     //son Ref Low Fail     : Ref Lower Limit 보다 Fail R 값이 작음
        strE3.Format("E3");     //son Out of RangeFail : Ref Low, High 바깥의 영역.  
        strE4.Format("E4");     //son Pin Contact Error: Fail 인데 Range In? 이상 케이스  

#ifdef __GTS_4W_SPCIALNET__
        //son 특수넷일 때에는 4W Error Code를 E가 아니라 G로 출력한다. (GTS 유니텍 요구사항)
        if (n4WFail1[i][F_4W_NET_SPECIAL] == 1)
        {
            strE.Format("G");
            strE1.Format("G1");
            strE2.Format("G2");
            strE3.Format("G3");
            strE4.Format("G4");
        }
#endif
        //son221114 end
        //son220504 n4WFail1[i][8] 은 이미 real R 값이므로 Real R 로 또 바꿀 필요가 없음. 
        //          n4WFail1[i][8]=Sub71.R1; 은 코멘트로 막혀 있고,  d4wCalR1 도 사용하는 부분이 없음. 
        //          불필요한 코드이므로 #if 0과 #endif 로 코멘트 처리함.
#if 0
        //--------------------
        //son Raw R -> Real R
        if (n4wCalErrLog1 == 1)
        {
            int ka, k, m_nMode1, nPo;
            double aa, ab;

            nPo = 0;       aa = 0.0;     ab = 0.0;

            m_nMode1 = (int)n4WFail1[i][12];//sylee160605-1  13->12
            Sub71.R1 = n4WFail1[i][8];
            ka = (int)gdCal1[PART_UPPER][m_nMode1][0][0];// Cal  list sum 

            calPart = FileSysInfo01.checkUseCalDataPart(n4WFail1[i][1] - 1, n4WFail1[i][3] - 1);    //son220504

            if ((Sub71.R1 > 0) && (ka > 0) && (ka <= MAX_CAL_RLIST))       //son220407 128: MAX_CAL_RLIST                              
            {
                for (k = 0; k < ka; k++) {
                    if (gdCal1[calPart][m_nMode1][CAL_USE][k] == 1) {  //gdCal1[calPart][m_nMode1][CAL_USE][k]  cal enable 1,0        //son220407
                        if (Sub71.R1 < gdCal1[calPart][m_nMode1][CAL_REF_RAWR][k]) {    //gdCal1[calPart][m_nMode1][CAL_REF_RAWR][k]  cal R raw                                                            
                            nPo = k;
                            k = ka + 1;
                        }
                    }
                }

                if (nPo == 0) {   //gdCal1[calPart][m_nMode1][CAL_REF_R][k]  cal ref  R 
                    //v=nCalC[m][1][k];
                    if (gdCal1[calPart][m_nMode1][CAL_REF_RAWR][0] > 0.0) {
                        //sylee20120112 Sub71.R1=((gdCal1[calPart][m_nMode1][CAL_REF_RAWR][k]-Sub71.R1)/gdCal1[calPart][m_nMode1][CAL_REF_RAWR][k])*gdCal1[calPart][m_nMode1][CAL_REF_R][k];
                        if (gdCal1[calPart][m_nMode1][CAL_REF_R][0] <= 0.0) {  //[2] cal. real r,   [2] cal. real r      //son220407
                            Sub71.R1 = 0.0; //sylee20120112
                        }
                        else {
                            //son Raw R -> Real R
                            Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][CAL_REF_RAWR][0]) * gdCal1[calPart][m_nMode1][CAL_REF_R][0];       //son220407
                        }

                    }
                }
                else {
                    if ((gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo] - gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo - 1]) != 0.0) {
                        aa = (Sub71.R1 - gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo - 1])
                            / (gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo] - gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo - 1]);  // [3]= lookup table Calibration Raw R        //son220407
                        ab = gdCal1[calPart][m_nMode1][CAL_REF_R][nPo] - gdCal1[calPart][m_nMode1][CAL_REF_R][nPo - 1];// [2]= lookup table Calibration real R      //son220407
                        Sub71.R1 = ab * aa + gdCal1[calPart][m_nMode1][CAL_REF_R][nPo - 1];
                    }
                    else {
                        Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo - 1]) * gdCal1[calPart][m_nMode1][CAL_REF_R][nPo - 1];       //son220407
                    }
                }

                if (nPo == ka) {//sylee20120115
                    Sub71.R1 = (Sub71.R1 / gdCal1[calPart][m_nMode1][CAL_REF_RAWR][nPo]) * gdCal1[calPart][m_nMode1][CAL_REF_R][nPo];       //son220407
                }
            }  //end of  if( Sub71.R1>0   &&   (ka>0) &&   (ka<=128) )                                  
            // n4WFail1[i][8]=Sub71.R1;
            d4wCalR1 = Sub71.R1;
        }//end of if(n4wCalErrLog1==1)
#endif


        //calibration covert  //sylee20120301end
        //###########################################################################################################################

        //---------------------
        //son Error.txt 4W 출력
        //---------------------

        int piece1;

        piece1 = (int)n4WFail1[i][14];     //son piece no 

        //son EnablePrint_4WErrorType  ( Manual > Set1 > 12) Print : 4W E1, E2, E3, E4  ON 일 때 )
        if (SysSet211.m_nSet25 == 1)//SYLEE181025-1  //if(SysSet211.m_nSet25==1)//SYLEE181025-1   
        {

            if (m_nFileLog_Error == 1) //SYLEE131129
            {
                str = '%';//sylee160528-3

                //sylee181005-5 fprintf(fp, "  %d E:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1],n4WFail1[i][2],n4WFail1[i][3],n4WFail1[i][4] );

                if (n4wCalErrLog1 == 1) // Cal.  covert
                {
                    if (n4WFail1[i][12] <= MODE174_4W) //sylee140610   //son240103  MODE174_4W: 174
                    {
                        if (n4WFail1[i][8] <= MAX_4W_R) //SYLEE171026-2  100ohm->20-0ohm  //son240103 MAX_4W_R: 200000
                        {
                            //son VC 값이 9.95보다 작으면 
                            if (n4WFail1[i][10] < 9.95)    //sylee200320-4WCVMODE  9.95 ->10 //sylee200612 10->9.95
                            {
                                //son 4w error시에 오차 % 출력 Disable이면  
                                if (SysSet211.m_nSet12 == 1)   //sylee160528-1
                                {
                                    //son Fail인데 측정 R 값이 범위내라면.  측정 R 값 > RefLow &&  측정 R 값이 < RefHigh 
                                    if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171106-1
                                        //fprintf(fp, "  %d E4:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE4,   //son221114
                                            n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Pin Contact Error!  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//SYLEE210108-1
#else
                                        fprintf(fp, "   Pin Contact Error!  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 

                                    }
                                    else {//sylee171106-1
                                        //if (n4WFail1[i][8] <= n4WFail1[i][5]) {//sylee181005-5
                                        //    fprintf(fp, "  %d E1:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        //}
                                        //else {
                                        //    fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        //}
                                        fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, (n4WFail1[i][8] <= n4WFail1[i][5]) ? strE1 : strE2,  //son221114
                                            n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5

#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   %.2fmohm  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else  
                                        fprintf(fp, "   %.2fmohm  (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif
                                    }//sylee171106-1

                                }
                                else
                                {

                                    //son Fail인데 측정 R 값이 범위내라면.  측정 R 값 > RefLow &&  측정 R 값이 < RefHigh 
                                    if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171106-1
                                        //fprintf(fp, "  %d E4:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE4,
                                            n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5

#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Pin Contact Error!  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#else  
                                        fprintf(fp, "   Pin Contact Error!  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 
                                    }

                                    else {//sylee171106-1  
                                        if ((SysInfo05.m_n4WErrPerLimit > 0) && (((n4WFail1[i][8] / n4WFail1[i][7]) * 100 - 100.) > SysInfo05.m_n4WErrPerLimit)) { //sylee170915-1                                                                  
                                            //fprintf(fp, "  %d E3:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                            fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE3, //son221114
                                                n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                            fprintf(fp, "   Out of 4W Range.  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1   
#else  
                                            fprintf(fp, "   Out of 4W Range.  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1    
#endif 

                                        }
                                        else {//sylee170915-1
                                            //if (n4WFail1[i][8] <= n4WFail1[i][5]) {
                                            //    fprintf(fp, "  %d E1:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                            //}
                                            //else {
                                            //    fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                            //}
                                            fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, (n4WFail1[i][8] <= n4WFail1[i][5]) ? strE1 : strE2,
                                                n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                            fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f)(%.2f~ %.2fmohm) \n",
                                                n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else  
                                            fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f~ %.2fmohm) \n",
                                                n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][5], n4WFail1[i][7]);
#endif 
                                        } //sylee170915-
                                    }//sylee171106-1                                                                 

                                }

                            }
                            //son VC 값이 9.95보다 크거나 같으면 
                            else {
                                //sylee160526   fprintf(fp, "   %.1fmohm over (%.2f~ %.2fmohm) \n" ,n4WFail1[i][8] ,n4WFail1[i][5],n4WFail1[i][7] );
                                //fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE2,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "   %.1fmohm over (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else  
                                fprintf(fp, "   %.1fmohm over (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                            }
                        }
                        //son R 값이 200 ohm 범위를 넘었으면
                        else {
                            if (n4WFail1[i][19] == 2) {//sylee181005-2
                                //fprintf(fp, "  %d E4:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE4,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "  Pin Contact Error! (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#else  
                                fprintf(fp, "  Pin Contact Error! (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 

                            }
                            else {//sylee181005-2
                                //fprintf(fp, "  %d E3:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE3,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "  Out of 4W Range .  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);  //SYLEE150211 //ACE380  //sylee160528-1
#else   
                                fprintf(fp, "  Out of 4W Range .  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);   //SYLEE150211 //ACE380  //sylee160528-1
#endif 

                            }//sylee181005-2
                        }


                    }
                    //son CV 모드 일 때 
                    else //sylee140617
                    {

                        if (n4WFail1[i][8] <= MAX_4W_R) //sylee140610  //SYLEE171026-2  100ohm->20-0ohm   //son240103 MAX_4W_R: 200000
                        {
                            //son VC 값이 9.95보다 작으면 
                            if (n4WFail1[i][10] < 9.95)
                            {
                                //son Disable4wResultErrRate :4w error시에 오차 % 출력 여부      
                                if (SysSet211.m_nSet12 == 1) { //sylee160528-1
                                    //if (n4WFail1[i][8] <= n4WFail1[i][5]) {//sylee181005-5
                                    //    fprintf(fp, "  %d E1:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                    //}
                                    //else {
                                    //    fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                    //}
                                    fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, (n4WFail1[i][8] <= n4WFail1[i][5]) ? strE1 : strE2,   //son221114
                                        n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                    fprintf(fp, "   %.2fmohm  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else   
                                    fprintf(fp, "   %.2fmohm  (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                                }
                                else
                                {
                                    if ((SysInfo05.m_n4WErrPerLimit > 0) && (((n4WFail1[i][8] / n4WFail1[i][7]) * 100 - 100.) > SysInfo05.m_n4WErrPerLimit)) { //sylee170915-1                                                                  
                                        //fprintf(fp, "  %d E3:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE3,   //son221114
                                            n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Out of 4W Range.  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1
#else
                                        fprintf(fp, "   Out of 4W Range.  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1
#endif 

                                    }
                                    else {//sylee170915-1
                                        //if (n4WFail1[i][8] <= n4WFail1[i][5]) {//sylee181005-5
                                        //    fprintf(fp, "  %d E1:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        //}
                                        //else {
                                        //    fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                        //}
                                        fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, (n4WFail1[i][8] <= n4WFail1[i][5]) ? strE1 : strE2, //son221114
                                            n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else   
                                        fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                                    } //sylee170915-1
                                }
                            }
                            //son VC 값이 9.95보다 크거나 같으면 
                            else {
                                //fprintf(fp, "  %d E2:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE2,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "   %.1fmohm over (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else
                                fprintf(fp, "   %.1fmohm over (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                            }
                        }
                        //son R 값이 200 ohm 범위를 넘었으면
                        else {   
                            if (n4WFail1[i][19] == 2) {//sylee181005-2  //son contact fail
                                //fprintf(fp, "  %d E4:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE4,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "  Pin Contact Error! (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#else   
                                fprintf(fp, "  Pin Contact Error! (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 

                            }
                            else {//sylee181005-2
                                //fprintf(fp, "  %d E3:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE3,   //son221114
                                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "   Out of 4W Range.  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee140728  //sylee160528-1
#else  
                                fprintf(fp, "   Out of 4W Range.  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee140728  //sylee160528-1
#endif 

                            } //sylee181005-2
                        }

                    }//sylee140617

                }
                else {// NO Cal.  covert
              
                    fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, (n4WFail1[i][8] <= n4WFail1[i][5]) ? strE1 : strE2,    //son221114
                        n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);//sylee181005-5
                    fprintf(fp, "   %.1f mohm  (%.2f~ %.2f mohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
                }

            }//SYLEE131129                           


            //------------------------
            //son m_list1 용 str 출력 
            //------------------------
//son221114 begin:            
            CString str1, str2;
            str1.Format("  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE,
                n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);
            if (n4WFail1[i][8] <= 200000) //sylee171026-1
            {

                if (n4WFail1[i][10] < 9.95) {//sylee200320-4WCVMODE  9.95->10.0 //sylee200612 10.0->9.95
                    str2.Format("  %.2f mohm  (%.2f~ %.2f mohm) ", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);           //SYLEE131022
                }
                else {
                    str2.Format(" %.2f mohm over (%.2f~ %.2f mohm) ", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);           //SYLEE131022                                          
                }

                if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171104-5
                    str2.Format(" Pin Contact Error!(%.2f~ %.2f mohm) ", n4WFail1[i][5], n4WFail1[i][7]);
                }
            }
            else {
                if (n4WFail1[i][19] == 2) {//sylee181005-2                                              
                    str2.Format(" *Pin Contact Error! (%.2f~ %.2f mohm) ", n4WFail1[i][5], n4WFail1[i][7]);    //sylee181005-2
                }
                else {//sylee181005-2  
                    str2.Format(" >200ohm over (%.2f~ %.2f mohm) ", n4WFail1[i][5], n4WFail1[i][7]);       //SYLEE150211 //ACE380
                }//sylee181005-2  
            }
            str = str1 + str2;
            //son221114 end

        }

        //son EnablePrint_4WErrorType  ( Manual > Set1 > '12) Print : 4W E1, E2, E3, E4' OFF 일 때 )
        else   ////if(SysSet211.m_nSet25==1)//SYLEE181025-1  
        {

            if (m_nFileLog_Error == 1) //SYLEE131129
            {
                str = '%';//sylee160528-3

                //fprintf(fp, "  %d E:  %.0f/%.0f, %.0f/%.0f,", piece1, n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);
                fprintf(fp, "  %d %s:  %.0f/%.0f, %.0f/%.0f,", piece1, strE,    //son221114
                    n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);


                if (n4wCalErrLog1 == 1) // Cal.  covert
                {
                    //son 4W CC 모드
                    if (n4WFail1[i][12] <= MODE174_4W) //sylee140610   //son240103  MODE174_4W: 174
                    {
                        if (n4WFail1[i][8] <= MAX_4W_R) //SYLEE171026-2  100ohm->20-0ohm  //son240103 MAX_4W_R: 200000
                        {
                            //son  VC 값이 10보다 작으면
                            if (n4WFail1[i][10] < 10.0) //sylee200320-4WCVMODE  9.95->10.0     //sylee200612
                            {
                                //son 4w error시에 오차 % 출력 Disable이면 
                                if (SysSet211.m_nSet12 == 1)   //sylee160528-1
                                {
                                    //son Fail인데 측정 R 값이 범위내라면.  측정 R 값 > RefLow &&  측정 R 값이 < RefHigh 
                                    if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171106-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Pin Contact Error!  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#else
                                        fprintf(fp, "   Pin Contact Error!  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 

                                    }
                                    else {//sylee171106-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   %.2fmohm  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else 
                                        fprintf(fp, "   %.2fmohm  (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                                    }//sylee171106-1


                                }
                                //son 4w error시에 오차 % 출력 ON이면 
                                else
                                {
                                    //son Fail인데 측정 R 값이 범위내라면.  측정 R 값 > RefLow &&  측정 R 값이 < RefHigh 
                                    if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171106-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Pin Contact Error!  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#else   
                                        fprintf(fp, "   Pin Contact Error!  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee171106-1
#endif 

                                    }
                                    else //sylee171106-1                                                           
                                    {
                                        if ((SysInfo05.m_n4WErrPerLimit > 0) && (((n4WFail1[i][8] / n4WFail1[i][7]) * 100 - 100.) > SysInfo05.m_n4WErrPerLimit)) { //sylee170915-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                            fprintf(fp, "   Out of 4W Range.  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1
#else   
                                            fprintf(fp, "   Out of 4W Range.  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1
#endif 

                                        }
                                        else {//sylee170915-1   
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                            fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else   
                                            fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                                        } //sylee170915-
                                    }//sylee171106-1

                                }

                            }
                            //son  VC 값이 10보다 크거나 같으면 
                            else {
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "   %.1fmohm over (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else 
                                fprintf(fp, "   %.1fmohm over (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 
                            }
                        }

                        //son R 값이 200 ohm을 넘으면
                        else 
                        {
                            if (n4WFail1[i][20] != 1) {//sylee210113-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "  Out of 4W Range .  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);  //SYLEE150211 //ACE380  //sylee160528-1
#else  
                                fprintf(fp, "  Out of 4W Range .  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);   //SYLEE150211 //ACE380  //sylee160528-1
#endif 
                            }
                            //son Pin Contact Fail --------------
                            else {

                                fprintf(fp, "  Pin Contact Fail, ");//sylee210113-1

                                if (n4WFail1[i][21] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][1]);//sylee210113-1
                                }
                                if (n4WFail1[i][22] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][2]);//sylee210113-1
                                }
                                if (n4WFail1[i][23] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][3]);//sylee210113-1
                                }
                                if (n4WFail1[i][24] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][4]);//sylee210113-1
                                }
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "(%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);   //SYLEE150211 //ACE380  //sylee160528-1
#else  
                                fprintf(fp, "(%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);    //SYLEE150211 //ACE380  //sylee160528-1
#endif
                            }

                        }
                    }
                    //son 4W CV 모드
                    else //sylee140617
                    {        
                        if (n4WFail1[i][8] <= MAX_4W_R) //sylee140610  //SYLEE171026-2  100ohm->20-0ohm  //son240103 MAX_4W_R: 200000
                        {
                            //son VC 값이 10보다 작으면 
                            if (n4WFail1[i][10] < 10.0) //sylee200320-4WCVMODE  9.95->10.0     //sylee200612
                            {
                                //son 4w error시에 오차 % 출력 Disable이면 
                                if (SysSet211.m_nSet12 == 1) { //sylee160528-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                    fprintf(fp, "   %.2fmohm  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else   
                                    fprintf(fp, "   %.2fmohm  (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                                }
                                //son 4w error시에 오차 % 출력 ON이면
                                else 
                                {
                                    if ((SysInfo05.m_n4WErrPerLimit > 0) && (((n4WFail1[i][8] / n4WFail1[i][7]) * 100 - 100.) > SysInfo05.m_n4WErrPerLimit)) { //sylee170915-1  
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   Out of 4W Range.  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1
#else
                                        fprintf(fp, "   Out of 4W Range.  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);//sylee170915-1    
#endif 

                                    }
                                    else {//sylee170915-1   
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                        fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else 
                                        fprintf(fp, "   %.2fmohm,  %.1f%s (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][8] / n4WFail1[i][7] * 100 - 100., str, n4WFail1[i][5], n4WFail1[i][7]);
#endif 
                                    } //sylee170915-1

                                }
                            }
                            //son VC 값이 10보다 크거나 같으면
                            else 
                            {
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "   %.1fmohm over (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);
#else
                                fprintf(fp, "   %.1fmohm over (%.2f~ %.2fmohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
#endif 

                            }
                        }
                        else 
                        {

                            if (n4WFail1[i][20] != 1) {//sylee210113-1
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "  Out of 4W Range .  (%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);  //SYLEE150211 //ACE380  //sylee160528-1
#else  
                                fprintf(fp, "  Out of 4W Range .  (%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);   //SYLEE150211 //ACE380  //sylee160528-1
#endif 
                            }
                            else {

                                fprintf(fp, "  Pin Contact Fail, ");//sylee210113-1

                                if (n4WFail1[i][21] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f,", n4WFail1[i][1]);//sylee210113-1
                                }
                                if (n4WFail1[i][22] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][2]);//sylee210113-1
                                }
                                if (n4WFail1[i][23] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][3]);//sylee210113-1
                                }
                                if (n4WFail1[i][24] == 1) {//sylee210113-1
                                    fprintf(fp, " *%.0f, ", n4WFail1[i][4]);//sylee210113-1
                                }
#ifdef __NANOSYS__CUSTOMER_4WAVG   //SYLEE210108-1
                                fprintf(fp, "(%.2f)(%.2f~ %.2fmohm) \n", n4WFail1[i][6], n4WFail1[i][5], n4WFail1[i][7]);   //SYLEE150211 //ACE380  //sylee160528-1
#else  
                                fprintf(fp, "(%.2f~ %.2fmohm) \n", n4WFail1[i][5], n4WFail1[i][7]);    //SYLEE150211 //ACE380  //sylee160528-1
#endif
                            }

                        }

                    }//sylee140617

                }
                else {// NO Cal.  covert
                    fprintf(fp, "   %.1f mohm  (%.2f~ %.2f mohm) \n", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);
                }

            }//SYLEE131129                           


            //-------------------------
            //son m_list1 용 str 출력.
            //----------------------
//son221114 begin:            
            CString str1, str2;
            str1.Format("  %d %s:  %.0f/%.0f, %.0f/%.0f, ", piece1, strE,
                n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);
            if (n4WFail1[i][8] <= 200000) {//sylee171026-1

                if (n4WFail1[i][10] < 10.0) {//sylee200320-4WCVMODE  9.95->10.0     //sylee200612
                    str2.Format(" %.2f mohm  (%.2f~ %.2f mohm) ", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);           //SYLEE131022
                }
                else {
                    str2.Format(" %.2f mohm over (%.2f~ %.2f mohm) ", n4WFail1[i][8], n4WFail1[i][5], n4WFail1[i][7]);           //SYLEE131022                                          
                }

                if ((n4WFail1[i][8] > n4WFail1[i][5]) && (n4WFail1[i][8] < n4WFail1[i][7])) {//sylee171104-5
                    str2.Format(" Pin Contact Error!(%.2f~ %.2f mohm) ", n4WFail1[i][5], n4WFail1[i][7]);
                }
            }
            else {
                str2.Format(" >200ohm over (%.2f~ %.2f mohm) ", n4WFail1[i][5], n4WFail1[i][7]);       //SYLEE150211 //ACE380
            }
            str = str1 + str2;

            //son221114 end


        } //if(SysSet211.m_nSet25==1){//SYLEE181025-1  



        m_list1.AddString(str);
        nlist1++;
    }




    if (m_nFileLog_Error == 1) { //sylee130220 error file
        fprintf(fp, "  *** T/T =  %.2f S \n", dProT1);//SYLEE20120723
        /* //sylee181217-2
           if( SysSet13.m_nSet3==1 ){//sylee121130
           fprintf(fp7, "  *** T/T =  %.2f S \n" ,dProT1 );//SYLEE20120723
           }
           */
    }

    if (nOpenRetryFlag1 == 2) {
        if (m_nFileLog_Error == 1) { //sylee130220 error file
            fprintf(fp, "  *** ABORT ***");//SYLEE20121117
        }
        str.Format("  *** ABORT ***  OPEN TEST LIMITED.***");//SYLEE20121117
        m_list1.AddString(str);
        m_list1.SetTopIndex(m_list1.GetCount() - 1);
    }

    if (nOpenMoreThanFlag == 1) {
        if (m_nFileLog_Error == 1) { //sylee130220 error file
            fprintf(fp, " ***< Open MORE ERROR ! >*** ");//SYLEE20121117
        }
        str.Format(" ***< Open MORE ERROR ! >***");//SYLEE20121117
        m_list1.AddString(str);
        m_list1.SetTopIndex(m_list1.GetCount() - 1);
        nOpenMoreThanFlag = 0;
    }

    if (n4w_Sample_Enable != 1) {   //sylee200927    
        if (n4wMoreThanFlag == 1) {//sylee160617-1
            if (m_nFileLog_Error == 1) {
                fprintf(fp, " ***< 4w MORE ERROR ! >*** ");
            }
            str.Format(" ***< 4w MORE ERROR ! >*** ");
            m_list1.AddString(str);
            m_list1.SetTopIndex(m_list1.GetCount() - 1);
            n4wMoreThanFlag = 0;
        }
    }

    dProT1 = 0;

    if (nHVDStopFlag == 1) {//sylee121009 
        str.Format("***> HV TIME OUT.");
        if (m_nFileLog_Error == 1) { //sylee130220 error file
            fprintf(fp, "  \n ***> HV TIME OUT. \n");
        }
        m_list1.AddString(str);
        m_list1.SetTopIndex(m_list1.GetCount() - 1);
    }
    //#######################################################################################################



    if (m_nFileLog_Error == 1)  //sylee130220 error file      //sylee131125
    {
        fclose(fp);

        CTime curTime = CTime::GetCurrentTime();
        MyTrace(PRT_LEVEL2, "%s file Created. : %02d%02d%02d_%02d:%02d:%02d\n",  //son220729_2  //son240714
            fName, curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

    }//if(m_nFileLog_Error==1) //sylee130220 error file



    //----------------------------------------------
    //son copy fName(Z drive) -> fName1 (D drive)

    if (nCycleRunFlag == 2)
    {
        if (nFailL1Co > 0)
        {
            CTime curTime = CTime::GetCurrentTime();
            ::ZeroMemory(&fName1, sizeof(fName1));
            str.Format("d:\\log\\Error_%02dD_%02dH%02dM%02dS_Count%d.txt",
                curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), nCycleRunCount);
            strcat(fName1, str);
            CopyFile(fName, fName1, FALSE);
        }
    }

    //} son220803_2

    return 1;
}




//son220203 4W Retest 안된다는 GTS 문제점 보고되어 20년 3월 기능 복구
#if 1 //son211217_2 checkAllDUT_4wSampleEnd() 코드 의미 없으므로 코멘트 처리함. 20년 3월 이전 코드로  복구.
//son200320-4WDUT16 : 신규 추가함수 
//son 모든 DUT의 g_b4wSampleEnd[dut]가 true이면 true를 리턴한다.
//    모든 DUT의 Auto Sampling이 완료가 되었는지 이 함수로 체크해서 
//    OK이면 END Response를 장비로 보낼 수 있다.
//
// 멀티 DUT 3인 경우는 PCB내에  BDL이 다른 Block(=DUT)이 3개 있다는 것.  즉, BDL이 3개. 
// 멀티 DUT는 DUT마다 SampleRunCount를 따로 가지므로  카운트 100번 측정을 위해  100개의 PCB가 필요함
// DUT1은 SampleRunCount가 100인데,   DUT2, DUT3는 SampleRunCount가 98, 99일 수 있다.  
// ( Pass 일 경우에만 SampleRunCount를 증가시킴) 
// SampleCount 100을 모든 DUT에 대해서 다 만족해야  Auto Sampling을 끝낼 수 있으므로 
// 이 경우에는 장비로 END로 주지 말고  101번째 PCB를 기다린다.  
bool CChildView7::checkAllDUT_4wSampleEnd()
{
    bool bRet = false;
    for (int dut = 0; dut < nMultyNetTotal; dut++)
    {
        //son 첫번째 DUT는  넘어가고 두번째 DUT 부터 이전값하고 비교한다. 
        //    이전 DUT END 상태와 현재 DUT END 상태가 둘다 true 여야 bRet를 true로 할 수 있다.
        if (dut == 0)
            bRet = g_b4wSampleEnd[dut];
        else
            bRet = bRet & g_b4wSampleEnd[dut];
    }
    return bRet;
}
#endif  //son211217_2

int CChildView7::OnErrPin_Rank1() //sylee170810-1   //sylee180516-1
{

    short nMaxCount, nMaxPin, co1, i, j;
    bool nk[Def_SwitchMaxPin];
    CString str;

    if (SysSet211.m_nSet22 != 1) {//disable
        //     m_Label115.SetCaption("  ");
        return 1;
    }

    //=======================================
    ::ZeroMemory(&nk, sizeof(nk));
    ::ZeroMemory(&nErrPinDisO, sizeof(nErrPinDisO));

    co1 = 0;
    for (j = 1; j <= 20; j++) {
        nMaxCount = 0;    nMaxPin = 0;
        for (i = 1; i <= (4096 * 4); i++) {
            if (nk[i] != 1) {
                if (nErrPin1O[i] > nMaxCount) {
                    nMaxCount = nErrPin1O[i];
                    nMaxPin = i;
                    //  continue;
                }
            }
        }

        if (nMaxCount > 0) {
            nk[nMaxPin] = 1;
            co1++;
            nErrPinDisO[co1][1] = nMaxPin;
            nErrPinDisO[co1][2] = nMaxCount;
        }
    }

    //=======================================

    for (i = 1; i <= (4096 * 4); i++) {//SYLEE180510-1
        if (nErrPin1S0[i] == 1) {//sylee180510-1
            nErrPin1S[i]++;//sylee180510-1
        }//sylee180510-1
    }


    ::ZeroMemory(&nk, sizeof(nk));
    ::ZeroMemory(&nErrPinDisS, sizeof(nErrPinDisS));
    co1 = 0;
    for (j = 1; j <= 20; j++) {
        nMaxCount = 0;    nMaxPin = 0;
        //SYLEE180510-1 for(   i=1; i<=Def_SwitchMaxPin; i++){
        for (i = 1; i <= (4096 * 4); i++) {//SYLEE180510-1
            if (nk[i] != 1) {
                if (nErrPin1S[i] > nMaxCount) {
                    nMaxCount = nErrPin1S[i];
                    nMaxPin = i;
                    //continue;
                }
            }
        }
        if (nMaxCount > 0) {
            nk[nMaxPin] = 1;
            co1++;
            nErrPinDisS[co1][1] = nMaxPin;
            nErrPinDisS[co1][2] = nMaxCount;
        }
    }

    str.Format("*O:%d[%d]/%d[%d]/%d[%d] *S:%d[%d] ",
        nErrPinDisO[1][1], nErrPinDisO[1][2], nErrPinDisO[2][1], nErrPinDisO[2][2], nErrPinDisO[3][1], nErrPinDisO[3][2],
        nErrPinDisS[1][1], nErrPinDisS[1][2]);

    m_Label115.SetCaption(str);    //sylee180516-1

    ::ZeroMemory(&nErrPin1S0, sizeof(nErrPin1S0));//sylee180510-1

    return 1;
}




//son nBlockCountP 값을 증가
int CChildView7::Increase_nBlockCountP()    //son220624   OnInitRunP1() -> Increase_nBlockCountP()
{
    int nEnd;
    int nOpenFailCo1;//sylee160603-2
    int nFlag_Open1;//sylee160603-2

    nFlag_Open1 = 0;//sylee160603-2

    if (SysSet211.m_nDisable4wRetest == 1)//sylee160603-2  //4w recheck disable  (0:enable, 1:disable)    //son220503
    {
        nOpenFailCo1 = 0;
        for (int w2 = 1; w2 <= nPieceMax; w2++) {

            if (nOpenFail1[w2] > 0) {
                nOpenFailCo1++;
            }
        }

        if (nOpenFailCo1 > 0) {
            nFlag_Open1 = 1;//sylee160603-2
        }
    }
    else {
        if (gRun20.m_nOpen == 1) {//sylee160603-2
            nFlag_Open1 = 1;
        }
    }

    if (nManualStartFlag == 1) {//SYLEE130221JOYTECH SETUP PRESS
        gRun20.m_nPass = 0;
        nAutoReTest[nBlockCountP] = (gRun05.m_nReCh);
    }

    //son Enable4wAutoSamplingRetest  옵션이 켜 있다면
    if ((SysSet211.m_nSet17 == 1) && (n4w_Sample_Enable == 1) && (n4w_Sample_SetCount > 0))//sylee171103-2
    {
        if (g_n4wSampleFailCo1 > 0)
        {
            if ((nBlockCountP == 0) && (nAutoReTest[nBlockCountP] == 0)) {
                nFlag_Open1 = 0;
            }
            else {
                gRun20.m_nPass = 0;   //retest condition
                nFlag_Open1 = 1;
            }
        }
        else {
            gRun20.m_nPass = 1;////sylee171103-2-test
            nFlag_Open1 = 0;
        }
    }


//son240718 #ifndef _PC_TEST_
    //son RETEST 해야 한다면 nBlockCountP 를 증가시키지 않는다.
    if ((nAutoReTest[nBlockCountP] <= gRun05.m_nReCh) && (nBlockCountP > 0) && (nAutoReTest[nBlockCountP] != 0)
        && (gRun20.m_nPass != 1) && (nFlag_Open1 == 1)
        && (((SysSet211.m_nSet17 == 1) && (n4w_Sample_Enable == 1) && (n4w_Sample_SetCount > 0)) || (n4w_Sample_Enable != 1))) {  ////sylee160603-2

    }

    //son RETEST 할 필요가 없다면 nBlockCountP를 증가시킨다.
    else
//son240718 #endif
    {

        //-------------------------------------------------
        //son 1: 정방향 block process이면  증가 로 진행
        if (nIndexSig1 != 2)///sylee120827test        
        {
            if (nBlockCountP < nBlockMax)
            {
                if (nManualStartFlag != 1 || nBlockCountP == 0)//sylee140210
                {
                    nBlockCountP++;//block 처리 증가값

                    ////////////////////////////////////////////////////
                    if (n4w_Sample_Enable == 1) {//sylee1171104-
                        if (n4w_Sample_SetCount > 0)
                        {
                            //son200312-4WDUT16
                            int dutIdx = get4wDutIdx();         // g_s4WNet의 index. 0부터 시작함.  //son190704-4WDUT16
                            nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16
                            for (int net = 1; net <= nEnd; net++) {   //son190704-4WDUT16
                                d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = 999999;
                            }
                        }
                    }
                    ////////////////////////////////////////////////////////

                }
                else {
                    //son MapDisplay->Set1:  IDD_MODE_SET13_SET1 Dialog 'OPEN 200V' 옵션이 On 이면
                    if (SysSet13.m_nSet11 == 1) {
                        nBlockCountP++;//test
                    }
                }
            }

            //son nBlockCountP가 블록의 끝에 도달했다면 1로 초기화하고 nBlockRes[] 0으로 초기화
            else {
                nBlockCountP = 1;
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH     
            }

        }

        //-------------------------------------------------
        //son 2: reverse block process 이면  감소로 진행
        else {
            if (nBlockCountP > 1) {
                nBlockCountP--;//block 처리 증가값
            }
            else {
                nBlockCountP = nBlockMax;
                ::ZeroMemory(&nBlockRes, sizeof(nBlockRes));//SYLEE130222JOYTECH    
                //m_list1.ResetContent();
            }

        }

        nAutoReTest[nBlockCountP] = 0;//sylee121202
    }

    return 1;
}



//son Pass, Fail, OPEN,SHORT의 Count와 % 를 계산해서 Display 
int CChildView7::Display_AutoCount()   //son220624  RunEnd1P1() -> Display_AutoCount()   
{

    CString str;
    double i = 0;

    gRun20.m_nTotle = 1;

    if (SysInfo20.m_nUse > 0) {
        SysInfo20.m_nPass = SysInfo20.m_nPass + gRun20.m_nPass;
        SysInfo20.m_nOpen = SysInfo20.m_nOpen + gRun20.m_nOpen;
        SysInfo20.m_nShort = SysInfo20.m_nShort + gRun20.m_nShort;
        SysInfo20.m_nOpenShort = SysInfo20.m_nOpenShort + gRun20.m_nOpenShort;
        SysInfo20.m_nFail = SysInfo20.m_nFail + gRun20.m_nFail;
        SysInfo20.m_nTotle = SysInfo20.m_nTotle + gRun20.m_nTotle;
    }

    gRun21.m_nPass = gRun21.m_nPass + gRun20.m_nPass;
    gRun21.m_nOpen = gRun21.m_nOpen + gRun20.m_nOpen;
    gRun21.m_nShort = gRun21.m_nShort + gRun20.m_nShort;
    gRun21.m_nOpenShort = gRun21.m_nOpenShort + gRun20.m_nOpenShort;
    gRun21.m_nFail = gRun21.m_nFail + gRun20.m_nFail;
    gRun21.m_nTotle = gRun21.m_nTotle + gRun20.m_nTotle;

    gRun20.m_nPass = 0;
    gRun20.m_nOpen = 0;
    gRun20.m_nShort = 0;
    gRun20.m_nOpenShort = 0;
    gRun20.m_nFail = 0;
    gRun20.m_nTotle = 0;

#ifndef __AUTO_COUNT_DISPLAY_DISABLE__     //sylee230125  
    Sub_Display_AutoCount();  //sylee220331 //son220624 RunEnd1P1_Display_AutoCount1() ->Sub_Display_AutoCount()
#endif


    FileSysInfo01.LoadSaveSub20(1);// saveing file

    nDisplayRef1 = 1; //DEMO

    return 1;
}




//son220624 RunEnd1P1_Display_AutoCount1() ->Sub_Display_AutoCount()
int CChildView7::Sub_Display_AutoCount()  //sylee220331 
{
#ifndef __AUTO_COUNT_DISPLAY_DISABLE__     //son220401   //sylee230125

    int i;

    str.Format("%d", SysInfo20.m_nTotle);
    m_Label201.SetCaption(str);
    str.Format("%d", SysInfo20.m_nPass);
    m_Label202.SetCaption(str);
    str.Format("%d", SysInfo20.m_nFail);
    m_Label203.SetCaption(str);
    str.Format("%d", SysInfo20.m_nOpen);
    m_Label204.SetCaption(str);
    str.Format("%d", SysInfo20.m_nShort);
    m_Label205.SetCaption(str);
    str.Format("%d", SysInfo20.m_nOpenShort);
    m_Label206.SetCaption(str);
    //-----------------
    //son Pass % 
    if (SysInfo20.m_nTotle > 0)
    {
        i = SysInfo20.m_nPass * 100.0 / SysInfo20.m_nTotle;
        if (i > 100)
            i = 100;
    }
    str.Format("%2.2f", i);
    m_Label302.SetCaption(str);

    //-----------------
    //son Fail %
    if (SysInfo20.m_nTotle > 0) {
        i = SysInfo20.m_nFail * 100.0 / SysInfo20.m_nTotle;
        if (i > 100)
            i = 100;
    }
    str.Format("%2.2f", i);
    m_Label303.SetCaption(str);

    //-----------------
    //son Open %
    if (SysInfo20.m_nTotle > 0) {
        i = SysInfo20.m_nOpen * 100.0 / SysInfo20.m_nTotle;
        if (i > 100)
            i = 100;
    }
    str.Format("%2.2f", i);
    m_Label304.SetCaption(str);
    //-----------------
    //son Short %
    if (SysInfo20.m_nTotle > 0) {
        i = SysInfo20.m_nShort * 100.0 / SysInfo20.m_nTotle;
        if (i > 100)
            i = 100;
    }
    str.Format("%2.2f", i);
    m_Label305.SetCaption(str);
    //-----------------
    //son Open+Short %
    if (SysInfo20.m_nTotle > 0) {
        i = SysInfo20.m_nOpenShort * 100.0 / SysInfo20.m_nTotle;
        if (i > 100)
            i = 100;
    }
    str.Format("%2.2f", i);
    m_Label306.SetCaption(str);
#endif  //son220401

    return 1;
}


//son 테스트결과 LABEL700 대형 라벨에 출력. enum TEST_DISPLAY_TYPE 사용.
int CChildView7::DisplayRes1_BigLabel(int a)    //son220824 DisplayRes1() -> DisplayRes1_BigLabel()
{

    CString   str;

    Disp1 = a;


    //son AProcess101()이 수행중이 아니면
    if (nProcessFlag1 != 1)//SYLEE20111225
    {


        if (nProcessFail1 != 0) {//sylee170415
            a = TEST_DIS_FAIL;
        }

        if (a == TEST_DIS_IDLE) { //idle 
            str.Format("    ");
            m_Label700.SetBackColor(RGB(0, 110, 110));//green
            m_Label700.SetForeColor(RGB(250, 250, 250));//blue
        }
        else if (a == TEST_DIS_PASS) { //pass    
            str.Format("PASS");
            m_Label700.SetBackColor(RGB(0, 255, 0));//green
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
        }
        else if (a == TEST_DIS_O_S) { //open + short
            str.Format("O+S");
            m_Label700.SetBackColor(RGB(0, 0, 255));//OPEN+SHORT   //blue
            m_Label700.SetForeColor(RGB(0, 0, 0)); //black
        }
        else if (a == TEST_DIS_OPEN) { //OPEN
            str.Format("OPEN");
            m_Label700.SetBackColor(RGB(255, 255, 0));//yellow
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
            //  m_Label700.SetBackColor=0x008EFF8E;//green
            //  m_Label700.SetForeColor=0x00FF8000;//blue
        }
        else if (a == TEST_DIS_SHORT) { //SHORT
            m_Label700.SetBackColor(RGB(255, 0, 45));//red
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
            str.Format("SHORT");
        }
        else if (a == TEST_DIS_LEAK) { //LEAK
            str.Format("LEAK");
        }
        else if (a == TEST_DIS_4W) { //4W
            str.Format("4W");
            m_Label700.SetBackColor(RGB(255, 0, 255));// white red//sylee131022   //4WCODE_131118
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
        }
        else if (a == TEST_DIS_FAIL) { //fail
            str.Format("FAIL");
            m_Label700.SetBackColor(RGB(255, 0, 0));//green
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
        }
        else if (a == TEST_DIS_RUN) { //SPARK
            str.Format("RUN");
            m_Label700.SetBackColor(RGB(0, 110, 110));//green
            m_Label700.SetForeColor(RGB(250, 250, 250));//blue
        }
        else if (a == TEST_DIS_READY) { //?
            str.Format("Ready");
            m_Label700.SetBackColor(RGB(0, 110, 110));//green
            m_Label700.SetForeColor(RGB(250, 250, 250));//blue    
        }
        else if (a == TEST_DIS_ERROR) { //ERROR  //SYLEE140324 INTERLOCK
            m_Label700.SetBackColor(RGB(255, 0, 45));//red
            m_Label700.SetForeColor(RGB(0, 0, 0));//black
            str.Format("ERROR");
        }
        else {  //idle
            str.Format("   ");
        }

        m_Label700.SetCaption(str);

    }//     if( nProcessFlag1 !=1)//SYLEE20111225

    return 1;
}



//son dRec[nMod1]의 설정값을 nCC, nVRel ... nHVGain에 할당한다.
//  m_nMode1   1~65       
//  nProMod1   1 open,  2 ushort , 3 short  4 hR  5  hv   7 4W
void CChildView7::A_Run101Init1(int m_nMode1)     //SYLEE20111212
{
    CString   str, str1;

    double nISet;
    int nIFilter, nHVOffSet, nHVGain;//sylee130629

    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629         
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];   //SYLEE130629
 //=========================================================================================
 //interlock  
    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     Calibration Run Start Error!!!");
        return;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 7701, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,     Calibration Run Start Error!!!");
        return;
    }

    if (nVRel == 1 || nVRel == 2 || nVRel == 3 || nVRel == 4) {
    }
    else {
        AfxMessageBox(" Error No 7702, \n    Votage Set Mode 1~4( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,     Calibration Run Start Error!!!");
        return;
    }


    return;

}


void CChildView7::A_Run101Init3()     //SYLEE20111212
{


    CFont font2;

    LOGFONT lf;
    //sylee140201 lf.lfHeight           = MulDiv(30, 450, 700);
    lf.lfHeight = MulDiv(9, 500, 300);
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    //sylee140201   lf.lfWeight         = 0;
    lf.lfWeight = FW_NORMAL;
    lf.lfItalic = FALSE;
    lf.lfUnderline = FALSE;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = HANGEUL_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;

    font2.CreateFontIndirect(&lf);
    m_list1.SetFont(&font2);//sylee130308
    PowerCheckError1();//sylee140212
    return;

}






///  VIEW7화면 초기화로 이동
void CChildView7::A_Run101Init2(double nVSet1, double nVSet2, double nVSet3, double nVSet4)   //SYLEE20111212
{
    int  nRet1, i;
    double dVbR1, dVbR2;
    CString str;
    int nChk1, Ret, nErrCount1;
#ifdef DEF_CARD_A1  //sylee170328
    BYTE Buf;
#endif  //#ifdef DEF_CARD_A1 

    if (n4w_Measure1_Enable != 1) {//sylee200512 //sylee200515-patch

        n4w_Measure1_Enable = 0;//sylee200512
    }

	nLeakADCFlag1=0;//sylee230814-1

    Comi_DoPutByte(DOUT_CMD_ALL_OFF);//sylee130218joytech-skip //son231016 //son240430
    MyTrace(PRT_LEVEL3, "Line_%d A_Run101Init2(): Comi_DoPutByte(): nDioS2=0 =======> ALL_OFF\n", __LINE__); //son220318

    //INITIAL 부    ///  VIEW7화면 초기화로 이동
    DisplayRes1_BigLabel(TEST_DIS_READY);//SYLEE20120708 READY      //son220824

    nChk1 = 0;
    nErrCount1 = 0;


#ifdef DEF_CARD_A1  //sylee170328

    for (i = 0; i < 8; i++) {
        Ret = DioInpByte(pDIO.hDrv2, i, &Buf);
        if (Ret != 0) {
            str.Format("  [DioInpByte, %d]  Com. Error!!! ", i);
            //    OnList1Mes1(str);  
            AfxMessageBox(str);
            return;
        }

        if (Buf == 255) {
            nChk1++;
        }
    }

#else  //#ifdef DEF_CARD_A1   

    int nOnCo1;//sylee170328

    nOnCo1 = 0;

    Ret = d64h_di_readport(pDIO_D64.m_bCardID, &pDIO_D64.dwDIStatus);  //
    if (Ret != 0) {
        AfxMessageBox("  Card64H1_DI32() Error!!!");
    }
    else {

        if ((pDIO_D64.dwDIStatus & 0x00000001) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000002) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000004) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000008) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000010) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000020) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000040) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x000000080) != 0)   nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000100) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000200) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000400) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000800) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00001000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00002000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00004000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00008000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00010000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00020000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00040000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00080000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00100000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00200000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00400000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00800000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x01000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x02000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x04000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x08000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x10000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x20000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x40000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x80000000) != 0)    nOnCo1++;
    }

    Ret = d64h_di_readport(pDIO_D64.m_bCardID2, &pDIO_D64.dwDIStatus);
    if (Ret != 0) {
        AfxMessageBox("  Card64H2_DI32() Error!!!");
    }
    else {

        if ((pDIO_D64.dwDIStatus & 0x00000001) != 0) nOnCo1++;  //0
        if ((pDIO_D64.dwDIStatus & 0x00000002) != 0)    nOnCo1++;  //1 
        if ((pDIO_D64.dwDIStatus & 0x00000004) != 0) nOnCo1++;  //2 
        if ((pDIO_D64.dwDIStatus & 0x00000008) != 0)    nOnCo1++;  //3
        if ((pDIO_D64.dwDIStatus & 0x00000010) != 0) nOnCo1++;  //4
        if ((pDIO_D64.dwDIStatus & 0x00000020) != 0) nOnCo1++;  //5
        if ((pDIO_D64.dwDIStatus & 0x00000040) != 0)    nOnCo1++;  //6
        if ((pDIO_D64.dwDIStatus & 0x000000080) != 0)nOnCo1++;  //7
        if ((pDIO_D64.dwDIStatus & 0x00000100) != 0) nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000200) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000400) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000800) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00001000) != 0) nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00002000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00004000) != 0) nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00008000) != 0) nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00010000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00020000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00040000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00080000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00100000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00200000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00400000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00800000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x01000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x02000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x04000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x08000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x10000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x20000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x40000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x80000000) != 0)    nOnCo1++;
    }


    if (nOnCo1 > 60) {//sylee170328
        nChk1 = 8;
    }

#endif  //#ifdef DEF_CARD_A1 


    if (nChk1 >= 7) {
        nErrCount1++;
        if (nG_Language != 2) {//SYLEE150707
            str.Format("  ERROR!  System Power off. 계측기 전원 켜주세요!  ", MB_OK);
        }
        else {
            str.Format("  ERROR!  System Power off.   BBT Controller  power on!  ", MB_OK);

        }
        m_list1.AddString(str);
        nlist1++;
        AfxMessageBox(str);
    }


    nRet1 = Sub71.AOnPoweroff2();  //SYLEE20120702 AOnPoweroff();
    if (nRet1 != 1) {
        AfxMessageBox(" Error,   Power all off fail !,   SW TEST Run Start Error!!!");
        return;
    }


    //sylee150630


    nUse_US = 0;  //sylee150630
    nUse_4W = 0;
    nUse_HR = 0;//SYLEE150703
#ifdef __QUAD_LEAK1_LEAK2__  //son231122
    nUse_LEAK1=0;//SYLEE230315 //sylee230807
    nUse_LEAK2=0;//SYLEE230315 //sylee230807
#endif  //son231122

    for (i = 1; i <= 7; i++) {     //sylee150630
        nTk = SysInfo05.m_nStep[i];   //open, ushort, short, hr, hv
        if (nTk == 2) {
            nUse_US = 1;
        }
        if (nTk == 7) {
            nUse_4W = 1;
        }
        if (nTk == 3 || nTk == 4) {
            nUse_HR = 1;
        }

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
        if(nTk==5 ){//sylee230315  //sylee230807
            nUse_LEAK1=1; 		 
        }
        if(nTk==6 ){//sylee230315	 //sylee230807	 
            nUse_LEAK2=1; //sylee230315			 
        }
#endif  //son231122

    }	//sylee150630

    //sylee15703    if(nUse_US==0  &&   (nUse_4W==1 ) ){            //sylee150630
    if (nUse_US == 0 && (nUse_4W == 1 || nUse_HR == 1)) {           //sylee15703    
        nTk = (int)dRec[(int)nProStep1[TEST_OPEN][3]][3];
        if (nTk == 20) {
            nVSet2 = 20;
            nVSet1 = 10;
        }
    }
    else {
        nTk = (int)dRec[(int)nProStep1[TEST_OPEN][3]][3];//sylee150630    
        if (nTk == 20) {
            nVSet1 = 20;//sylee150630 
        }
    }

    if (nTk <= 20) {
        nVSet1 = nTk;//sylee170412
    }

    //   nVSet1=15;//SYLEE171029   GTS 44 10V->20V  TEST
    if (dRec[171][3] <= 20) {//sylee180126
        nVSet1 = (int)dRec[171][3];//sylee180126
    }
    else {//sylee180126
       //sylee200823 nVSet1=10;//SYLEE171029 
        nVSet1 = (int)dRec[6][3];//syleee200823 NEW_SPARK
    }//sylee180126

#ifndef __QUAD_LEAK1_LEAK2__  //son231122
    nRet1=Sub71.AOnVSetMulti1(nVSet1,nVSet2,nVSet3,nVSet4) ;
    g_VSet1 = nVSet1; g_VSet2 = nVSet2; g_VSet3 = nVSet3; g_VSet4 = nVSet4;//sylee130430

#else  //son231122
    //sylee230807 //sylee230322 nRet1=Sub71.AOnVSetMulti1(nVSet1,nVSet2,nVSet3,nVSet4) ;

    g_VSet1 = nVSet1; g_VSet2 = nVSet2; g_VSet3 = nVSet3; g_VSet4 = nVSet4;//sylee130430
    nFlagLeak12Voltage[1]=dRec[(int)nProStep1[TEST_OPEN][3]][3];//sylee230315-1  //sylee230807
    nFlagLeak12Voltage[5]=dRec[(int)nProStep1[TEST_LEAK1][3]][3];//sylee230315-1
    nFlagLeak12Voltage[6]=dRec[(int)nProStep1[TEST_LEAK2][3]][3];//sylee230315-1


///////////////////////////////////////////////////////////////////////////////////////////////////////////
    nFlagLeak12_Sel=1;//sylee230322  //sylee230807
    nFlagLeak12_Vol1=nFlagLeak12Voltage[1]; 
	nFlagLeak12_Vol5=nFlagLeak12Voltage[5];
	nFlagLeak12_Vol6=nFlagLeak12Voltage[6]; 

    if( (nFlagLeak12_Vol1>20) &&  (nFlagLeak12_Vol5>0) &&  (nFlagLeak12_Vol6>0) ){	  //sylee230807  
        if(  ( nFlagLeak12_Vol1>=nFlagLeak12_Vol5)  &&  (nFlagLeak12_Vol1>=nFlagLeak12_Vol6)  ){
            if(  fabs(nFlagLeak12_Vol1-nFlagLeak12_Vol5) <  fabs(nFlagLeak12_Vol1-nFlagLeak12_Vol6) ){
                nFlagLeak12_Sel=2;
            } 
        }else if( (nFlagLeak12_Vol1<=nFlagLeak12_Vol5) && (nFlagLeak12_Vol1<=nFlagLeak12_Vol6) ){           
            if(fabs(nFlagLeak12_Vol1-nFlagLeak12_Vol5) <  fabs(nFlagLeak12_Vol1-nFlagLeak12_Vol6) ){
                nFlagLeak12_Sel=2;
            } 
        }else if( (nFlagLeak12_Vol1>=nFlagLeak12_Vol5) && (nFlagLeak12_Vol1<=nFlagLeak12_Vol6) ){
            nFlagLeak12_Sel=1;//sylee230322
        }else{//if( (nFlagLeak12_Vol1<=lagLeak12_Vol5) && (nFlagLeak12_Vol1>=FlagLeak12_Vol6)
            nFlagLeak12_Sel=2;
        }
    }

    if(nFlagLeak12_Sel==1){//sylee230322  //sylee230807
        nVSet3=nFlagLeak12_Vol5;  nVSet4=nFlagLeak12_Vol1;
    }else{//sylee230322
        nVSet3=nFlagLeak12_Vol6;  nVSet4=nFlagLeak12_Vol1;
    }

    Sub71.AOnVSetMulti1(nVSet1,nVSet2,nVSet3,nVSet4) ;//sylee230322  //sylee230807
    if(nFlagLeak12_Sel==2){  //sylee230807
        nFlagLeak12_Vol5=nFlagLeak12Voltage[6];    nFlagLeak12_Vol6=nFlagLeak12Voltage[5];   nFlagLeak12_VoiNo=5;//sylee230322	   
    }else{
        nFlagLeak12_Vol5=nFlagLeak12Voltage[5];    nFlagLeak12_Vol6=nFlagLeak12Voltage[6];   nFlagLeak12_VoiNo=6;//sylee230322
    }


///////////////////////////////////////////////////////////////////////////////////////////////////////////

    nFlagLeak12=0;//sylee230315-1
    if(nUse_LEAK1==1 && nUse_LEAK2==1){ //sylee230315  //sylee230807
        if(nFlagLeak12Voltage[5]!=nFlagLeak12Voltage[6]){
            if( (nFlagLeak12_Vol1>20) && (nFlagLeak12Voltage[5]>20) &&  (nFlagLeak12Voltage[6]>20) ){//sylee230322
                if( nFlagLeak12Voltage[5]  > nFlagLeak12Voltage[6] ){//sylee230315-1		
                    nFlagLeak12=1;//sylee230315-1
                }else{
                    nFlagLeak12=2;//sylee230321-1
                } 
            }
        }
    }
#endif  //son231122

    if (nRet1 != 1) {
        AfxMessageBox(" Error No 7026, \n   V SET ERROR !,   SW TEST Run Start Error!!!");
        return;
    }

    if (Simulator100 != 7) {
        Sub71.Delay_100ns(10000000);  //1000ms  //SYLEE20111119
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부     

    if (nErrCount1 > 0) {
        goto Task11;
    }

    if (nSelfTestHWError1 > 0) {
        goto Task11;

    }

    for (i = 1; i <= 4; i++)
    {
        if (i == 1) {
            nVSet = nVSet1;
            Sub71.Delay_100ns(200000);  //20ms  //SYLEE180417-1
            Sub71.OnDisCharge1(); //SYLEE180417-1
            Sub71.Delay_100ns(200000);  //20ms  //SYLEE180417-1
        }
        else if (i == 2) {
            nVSet = nVSet2;
            Sub71.Delay_100ns(300000);  //30ms  //SYLEE180417-1
            Sub71.OnDisCharge1(); //SYLEE180417-1
            Sub71.Delay_100ns(300000);  //30ms  //SYLEE180417-1
            //Sub71.Delay_100ns(10000000);  //1000ms  //SYLEE20111119
        }
        else if (i == 3) {
            nVSet = nVSet3;
        }
        else if (i == 4) {
            nVSet = nVSet4;
        }
        if (nVSet <= 0) {
            continue;
        }

        int Lo1;

        Lo1 = 50 * 5;//sylee130815//SYLEE140923  100->50

        if (nVSet < 5) {
            Lo1 = 100 * 5;
        }


        if (nVSet > 0) {

        Task101:        //  Sub71.AOnReadVB1(nVRel);   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
            Sub71.AOnReadVB1(i);   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 


            if (nVSet <= 5) {
                dVbR2 = nVSet * (0.35);//35%
            }
            else {
                dVbR2 = nVSet * (0.1);//10%
            }
            dVbR1 = nVSet - dVbR2;
            dVbR2 = nVSet + dVbR2;

            if (Sub71.V1 > 300) {
                if (Lo1-- > 0) {
                    if (Simulator100 != 7) {
                        Sub71.Delay_100ns(1000000);  //100ms     //SYLEE140923  300->100
                    }
                    goto Task101;
                }

                str.Format("Error No 7028,\n  Auto Run INIT \n     VB SETMODE NO=%d  (1=LV1,2=LV2,3=HV1,4=HV2) \n    VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%.2f, VB Read =%.2f,\n VB low=%.2f, VB high =%.2f,", i, nVSet, Sub71.V1, dVbR1, dVbR2);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                //  return ;
            }

            if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                if (Lo1-- > 0) {
                    if (Simulator100 != 7) {
                        Sub71.Delay_100ns(1000000);  //100ms   //SYLEE140923  300->100
                    }

                    goto Task101;
                }


                if (Simulator100 != 7) {
                    str.Format("Error No 7029,\n  \n\n  Power Check? \n\n\n  \n VB READ Error!!!\n \n  VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),  \n   VB SETMODE NO=%d  (1=LV1,2=LV2,3=HV1,4=HV2) \n    \n ", nVSet, Sub71.V1, dVbR1, dVbR2, i);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                }
                //  return ;
            }
        }
    }



    Sub71.AIRangeOff();// i range all off  //sylee20120308
    Sub71.AIVBOff();//VB OFF  //sylee20120308


Task11:

    int a;
    a = FileSysInfo01.LoadSaveSet12(_LOAD);//load 
    if (a != 1) {
        AfxMessageBox(" Error No 1212, \n    SysSet12.ini  Load ERROR !  \n    file Read Error !!!");
    }
    a = FileSysInfo01.LoadSaveSet13(_LOAD);//load 
    if (a != 1) {
        AfxMessageBox(" Error No 1213, \n    SysSet01.ini  Load ERROR !  \n    file Read Error !!!");
    }
    a = FileSysInfo01.LoadSaveSub15(_LOAD);//SYLEE140110
    if (a != 1) {
        AfxMessageBox(" Error No 1311, \n    SysSet05.ini  Load ERROR !  \n    RECIPE 4W,  file Read Error !!!");
    }

    //son Block 정보를 업데이트한다.
    DisplayBlock_Map1();  //sylee180416-2
    n4Wcheck1Mes1 = 0;//sylee161101-2
    OnRecipeErrorCheck();//sylee140127
    OnRecipeErrorCheckFlag = 0;//sylee140127
	nLeakADCPer1=SysSet15.m_nSet8;//sylee230822

	nFileSaveLowStartPin( SysSet12.m_nLowerJigStartPin );  //sylee241108

}



int CChildView7::ARun201_OPEN_Mea1(int nStep, double nProRv1, int ip, int nCC, int nFil, int nIR, int nISet, int nRCount, int nDelay1) //sylee211122
{

    double  doldR1;
    int nStep1, nPinA, nPinB, nPinAold, nPinBold, nStepS1, nStepF1, nPass1, nPinBase1, nTestMode, nRetry1, nDelay2;

    if (SysInfo05.m_nOpenMea1 != 1) {
        return 1;
    }

    if (nOpenMaxCo > 20) {
        return 1;
    }
    nOpenMaxCo++;

    nTestMode = 0;
    nDelay2 = nDelay1 * 10;

    if (nDelay2 < 8000) {
        nDelay2 = 8000;
    }
    if (nDelay2 > 20000) {
        nDelay2 = 20000;
    }

    //////////////////////////////////////////////////////////////////////
    //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
    {
        nPinAold = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep].wFirstPin;
        nPinBold = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep].wPin;
    }
    else {
        nPinAold = (*g_pvBDLData2Op[1][ip])[nStep].wFirstPin;
        nPinBold = (*g_pvBDLData2Op[1][ip])[nStep].wPin;
    }
    /////////////////////////////////////////////////////////////////////////////////////
    nPinBase1 = -1;
    if (nStep > 1) {
        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep - 1].wFirstPin;
            nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep - 1].wPin;
        }
        else {
            nPinA = (*g_pvBDLData2Op[1][ip])[nStep - 1].wFirstPin;
            nPinB = (*g_pvBDLData2Op[1][ip])[nStep - 1].wPin;
        }
        if ((nPinAold == nPinA) || (nPinAold == nPinB)) {
            if (nPinAold == nPinA) {
                nTestMode = 1;
            }
            if (nPinAold == nPinB) {
                nTestMode = 2;
            }
        }


    }
    //===================================================================================
    if (nPinBase1 == -1) {
        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep + 1].wFirstPin;
            nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[nStep + 1].wPin;
        }
        else {
            nPinA = (*g_pvBDLData2Op[1][ip])[nStep + 1].wFirstPin;
            nPinB = (*g_pvBDLData2Op[1][ip])[nStep + 1].wPin;
        }

        if (nPinAold == nPinA) {
            nTestMode = 1;
        }
        if (nPinBold == nPinA) {
            nTestMode = 2;
        }
    }


    if (nPinBold < 0 || nPinAold < 0) {
        return 0;
    }

    if (nTestMode == 0) {
        return 0;
    }

    /////////////////////////////////////////////////////////////////////

    nStepS1 = nStep;
    for (int i = nStep; i >= 1; i--) {

        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin;
            nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wPin;
        }
        else {
            nPinA = (*g_pvBDLData2Op[1][ip])[i].wFirstPin;
            nPinB = (*g_pvBDLData2Op[1][ip])[i].wPin;
        }

        if ((nPinAold == nPinA) || (nPinAold == nPinB) || (nPinBold == nPinA) || (nPinBold == nPinB)) {
            nStepS1 = i;
        }
        else {
            break;
        }
    }

    nStepF1 = nStep;
    for (i = nStep; i <= nRCount; i++) {
        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin;
            nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wPin;
        }
        else {
            nPinA = (*g_pvBDLData2Op[1][ip])[i].wFirstPin;
            nPinB = (*g_pvBDLData2Op[1][ip])[i].wPin;
        }
        if ((nPinAold == nPinA) || (nPinAold == nPinB) || (nPinBold == nPinA) || (nPinBold == nPinB)) {
            nStepF1 = i;
        }
        else {
            break;
        }
    }
    if ((nStep == nStepS1) && (nStep == nStepF1)) {
        return 0;
    }
    doldR1 = Sub71.R1;
    nStep1 = nStep;
    nPass1 = 0;


    if (nTestMode != 1) {
        return 0;
    }


    for (i = nStepS1; i <= nStepF1; i++) {


        if (i == nStep) {
            continue;
        }

        nRetry1 = 0;

        /*
           if( nMulNetFlag>0  &&  nMulNetFlag<MAX_DUT1){
           nPinA=(*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin;
           }else{
           nPinA=(*g_pvBDLData2Op[1][ip])[i].wFirstPin;
           }
           */
        if (nTestMode == 1) {
            //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
            if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
            {
                nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wPin;
            }
            else {
                nPinB = (*g_pvBDLData2Op[1][ip])[i].wPin;
            }
        }


    Tast1:


        Sub71.OnPinAllReset1();
        if (nTestMode == 1) {
            if (nRetry1 == 0) {
                Sub71.AOnPinSet1(2, nPinBold, 1);
                Sub71.AOnPinSet1(2, nPinB, 2);
            }
            else {
                Sub71.AOnPinSet1(2, nPinBold, 1);
                Sub71.AOnPinSet1(2, nPinB, 2);
            }
        }
        //Sub71.Delay_100ns(1000);
        //---------------------------
        Sub71.Delay_100ns(nDelay2);

        if (nCC == 2) {
            Sub71.AOnReadV1I1(7);
        }
        else {
            Sub71.AOnReadV1I1(nVRel);
        }
        if (Sub71.Y1 < 0.001) {
            Sub71.Y1 = 0.001;
        }

        if (nFil == 3) {
            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
            }
            else if (nIR == 5) {
                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
            }
            else if (nIR == 5) {
                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
            }
        }
        else {
            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
            }
            else if (nIR == 5) {
                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;
            }
        }

        if (Sub71.Y1 < (nISet * 0.7)) {//SYLEE211009
            Sub71.R1 = 9999999.;
        }
        if (Sub71.R1 >= nProRv1) {
            if (nRetry1++ <= 1) {
                goto Tast1;
            }
        }

        if (Sub71.R1 < nProRv1) {
            nPass1 = 1;
            break;
        }
    }
    //------------------------------------------------
    if (nPass1 == 0) {
        Sub71.R1 = doldR1;
    }
    return 1;
}




//----------------------
//son Auto OpenTest
//----------------------
// nMod1    : TEST_TYPE ( TEST_OPEN ~ TEST_4W)
// m_nMode1 : Test mode
// nProRv1  : Test mode의 기준 R값? . R RAW, Cal 미적용 R
// nPSte1   : step (TEST_TYPE과 연관됨. ) 
int CChildView7::ARun201_O11(int nMod1, int m_nMode1, double nProRv1, int nPStep1) //SYLEE20111212  //SETUPCALIBRATION
{

    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];

    __int64   tStart11, tStart12, tStart13;  //sylee140407

    int dPinVC[200], dPinVB[200];// nTemp1[15000];
    int i, n4Wire, nRCount, nDelay10;
    int nEnd, nLoop, t1, t2, t3, ipEnd, ipFlag, Lo1, nFil, nTCount;
    int nRetrySet, nReCo1, nPinA, nPinB, nRetrySet2;//sylee150604
    int nIFilter, nHVOffSet, nHVGain;//sylee130629  //

    int nDelay20, nDelay21, nDelay22, nIGain, n4wGain, nRCountToTal;//sylee150213
    int nOPenSetSkip, nReCo1_Old, nPass, nSelectFlag1, nRunFlag1_OPen, nRetrySet10;//sylee161018

    short nOldPin1, nOldPin1Flag;//sylee131221-2
    short nPiecefail[MAX_PIECE + 1];                 //son210730

    //son OpenFail 중간데이터.  index: piece
    //    ConEr 체크 기능 관련. Retry1, Retry2를 모두 마쳐도 불량인 경우는 이 카운트를 증가시킴.
    //    이값이 SysInfo05.m_nConEr 이상이 되면 해당 piece의 OpenTest를 중단시킨다.
    short nOpenFail_Co1[MAX_PIECE + 1];//sylee160731-3 /sylee161010- piecemax    //son210730

    double dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200], nT[10], nData[130][15];
    double nISet, dVbR1, dVbR2;
    double nISetPercentHigh, nISetPercentLow, nVBSetPercentHigh, nVBSetPercentLow;//sylee120914
    double nErrorRateToTalPin;//sylee150213
    int ip, j2;//sylee170816-1
    int nModeNamo;//sylee201103-1


    nFlagLeakMPin1=0;  //sylee230526  //sylee230818

    nOpenMaxCo = 0;//sylee211122
    nModeNamo = m_nMode1 % 5;//sylee201103-1   
    Sub71.OnRelay4W_OFF1();  //SYLEE181118
    OpenMes1Mode = m_nMode1; //SYLEE210309-1 
   ////////////////////////////////////////////////////////////////////
   //son  SHORT 검사관련 BDL Data에 따라 핀설정을 한다.
    Sub71.OnPinAllReset1();//sylee190207-1 //son 방전 수행
    //son nRCount :  1 piece일 때 Short 개수 
    int dutId = getDutId();
    nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16

    Sub71.OnDisCharge1(); //sylee170725-3 
    Sub71.OnPinAllReset1();//sylee190207-1

    if (SysInfo05.m_nConEr < 3) { //sylee161018
        nRetrySet10 = 3;
    }
    else if (SysInfo05.m_nConEr > 100) { //sylee161018
        nRetrySet10 = 100;
    }
    else {
        nRetrySet10 = SysInfo05.m_nConEr;//sylee161018
    }

    nRunFlag1_OPen = 0;
    ipEnd = 0;


    //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
    {
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[nMulNetFlag];
    }
    else {
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[1];
    }

    if ((g_nPieceMax1 >= 1)) {//PIECE
        ipEnd = g_nPieceMax1;
    }

    //--------------------------------------
    //son Open 테스트 필요 여부 점검

    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {
        //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우.
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,       //son220803
            if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece     //son220803
                continue;
            }
        }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 모든 piece가  PASS 상태인 Cell이면 nRunFlag1_OPen=0으로 남아서 Open테스트 의미없음
        if (nReSheetFlag1 == 1) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                continue;
            }
        }
#endif  //son220803 end

        //son 모든 piece가 Disable이면  nRunFlag1_OPen=0으로 남아서 Open테스트 의미없음
        if (SysInfo19.m_nUse == 1) {   //son PieceDisable Use 이면
            if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {//sylee130601    //son Disable인 piece는 Open 테스트 대상이 아님. 
                //sylee150527-2 nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        //son 모든 piece에 open Pass가 있었다면 nRunFlag1_OPen=0으로 남아서 Open테스트 의미없음
        if (gRun05.m_nReCh > 0) {
            if (nReFlagOpenOld[ip3] == 1) { //son 이전 Piece Open Pass가 있었다면 넘어간다. 
                continue;               //    ReCheck는 이미 Pass인 piece는 빼고 다시 테스트하는 것임.  
            }
        }
        nRunFlag1_OPen++;   //son Open 테스트를 해야 하는 것으로 판단

    }


    if (nRunFlag1_OPen < 1) {   //son Open 테스트를 할 필요가 없다면 리턴
        return 1;
    }


    /////////////////////////////////////////////////////////////////////
    //son 초기화

    nPass = 0; //testmode

    //ALLPASS       nPass=2; //testmode//allpass  /sylee151208debug

    ::ZeroMemory(&nPiecefail, sizeof(nPiecefail));//sylee150804-1

    nPinSetSkipVb = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400	//son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400	//son230127

    nOPenSetSkip = 1;//sylee150519 disable

    tStart121 = GetuSecond();//TESTDEBUG

    nRCountToTal = 0;//sylee150213

    ::ZeroMemory(&nPiecefail, sizeof(nPiecefail));//sylee150804-1

//  ::ZeroMemory(&nTemp1, sizeof(nTemp1));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20121128 
    ::ZeroMemory(&nReFlagOpenCur, sizeof(nReFlagOpenCur));//SYLEE121129
    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3

//sylee150422    nResSta1=0;//sylee131221-2   0=fail, 1=pass    
    nOpenPassNetFlag = 0;
    nTCount = 0;
    nReCo1 = 0;
    nStop = 0;
    n4Wire = 0;
    ipFlag = 0;//PIECE    //son 1이면 multi piece

    ipEnd = 1;//PIECE

    //sylee140805 nRetrySet=3;//5->10 SYLEE130315JOYTECH//SYLEE121126    10->5  //sylee130336    
    nRetrySet = 3;//sylee160621   //sylee160730  3
    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //mode ( 1~65)
    //step ( open, ushort, short, hr, hv  4w)

    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];

    //sylee15703    if(nUse_US==0  &&   nUse_4W==1 ){   //sylee150630
    if (nUse_US == 0 && (nUse_4W == 1 || nUse_HR == 1)) {   //sylee15703
        if (nVSet == 20) {//sylee150630
            nVRel = 2;
        }
    }


    nIR = (int)dRec[m_nMode1][4];

/*
//sylee230823-1  son230711 수정 사항 삭제.

//son230711 begin: 사장님 지시사항
//    영풍 SST에 30V, 40V, 50V 풀어주는 대신 30V, 40V, 50V에서 10mA 설정시에 전류가 적게 나오는 문제를 막기 위해 
//    내부적으로 dRec 설정(SysSet21_ACE400.ini) 과 상관없이 아래와 같이 설정하기로 함. 


    if (nVSet == 30)        //son nVSet이 double type이어서 switch case가 아니라 if else로 코딩함
        nISet = 3;          //    SysSet21.m_nDrec[i][5]의 nISet은 *10 mA단위 30 이면, 
    else if (nVSet == 40)   //    dRec[i][5]의 nISet은 mA 단위이므로  3이된다.  (LoadSaveSet21(_LOAD)참고)
        nISet = 4;
    else if (nVSet == 50)
        nISet = 5;
    else
//son230711 end

*/

   nISet = dRec[m_nMode1][5];

    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629 
    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
    n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  
    nDelay20 = (int)dRec[m_nMode1][6]; //sylee160801-3  -22 delete 

    nDelay21 = 600; //sylee160801-3   //sylee170529

    nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
    nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914

    if (m_nMode1 == 7 || m_nMode1 == 8) {//sylee150530
        nISetPercentLow = nISet * 0.0001;   //0.1%  //sylee150530
        nVBSetPercentLow = nVSet * 0.00001;   //0.01%  //sylee150530
    }
    else {//sylee150530
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
    }//sylee150530

    //_ACE380_150128
    ///*******************************************************                 
    nIGain = (int)dRec[m_nMode1][12];       //ACE380 //SYLEE150123    

    //n4wGain = (int)dRec[m_nMode1][13];     //ACE380//SYLEE150123  
    ///****************************************************** 

/*  if(nVSet>20){//SYLEE141211
        if(nIR==1){
            AfxMessageBox("  Error  No 7101.  HV leak측정시    고압 에서 I Range Mode 1를 사용하면 안됩니다.  업체 문의 하십시요. ", MB_OK);
            return 0;
        }
    }
*/

    if (nMod1 == TEST_OPEN) {//sylee20120306
        if (nVSet > 20) {
            nVRel = 4;   //VB RELAY   4
        }
    }

    //ADC COUNT
    Sub71.nADCount1 = (int)dRec[m_nMode1][7];
    if (Sub71.nADCount1 < 1) {
        Sub71.nADCount1 = 1;
    }
    if (Sub71.nADCount1 > 100) {
        Sub71.nADCount1 = 100;
    }


    //=========================================================================================
    //interlock    


    if (m_nMode1 < 1) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  <0 !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (m_nMode1 > 200) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  >200 !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 7704, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 7705, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }



    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 


    //--------------------------
    //son 초기 VB Power Check

    //sylee140215   Sub71.AOnReadVB1Run1(nVRel);//sylee130802 
    //sylee130903   Lo1=500; 
    Lo1 = 1000;//sylee200915  200->1000

Task101:

    CString out;    //son230217_2
    if (nOPenSetSkip == 1)//sylee150428
    {
        //SYLEE20111213  Sub71.AOnReadVB1(nVRel);   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
        Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
        if (nVSet <= 5) {
            dVbR2 = nVSet * (0.35);//35%
        }
        else {
            dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
        }
        dVbR1 = nVSet - dVbR2;
        dVbR2 = nVSet + dVbR2;
        if (Simulator100 != 7) {
            if (Sub71.V1 > 300) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms //sylee121019  10->1mS  
                    goto Task101;
                }
//son230217_2 begin:
                //str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                //MyTrace(PRT_BASIC, str);     //son221104_2
                //AfxMessageBox(str);

                str.Format("  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n", (int)m_nMode1);  
                out = str;
                str.Format("VB READING Error \n VB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", 
                                                  nVSet,    Sub71.V1,           dVbR1,        dVbR2);
                out += str;
                errMessageBox(1301, out);
//son230217_2 end
                nSelfTestHWError1 = 1;
                return 0;
            }

#ifdef _PC_TEST_
            //Sub71.V1 = 150;      
            Sub71.V1 = nVSet; //son PC 테스트용 임시설정. HW error 넘어가기 위함
#endif
            if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms   //sylee121019  10->1mS   
                    goto Task101;
                }


//son230217_2 begin:
                //str.Format("Error No 1311,\n \n\n  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                //MyTrace(PRT_BASIC, str);     //son221104_2
                //AfxMessageBox(str);
                
                str.Format("  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n", (int)m_nMode1);
                out = str;
                str.Format("VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", nVSet, Sub71.V1, dVbR1, dVbR2);
                out += str;
                errMessageBox(1301, out);

//son230217_2 end
                if (nBlockCountP >= 1) {
                    nBlockCountP = 1;
                }
                nSelfTestHWError1 = 1;
                return 0;
            }

        }


        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
        //설정부                
        if (nFil == 1 || nFil == 2) {//SYLEE130628
            Sub71.AOnReadV1Enable1(nVRel);
        }
        else {
            Sub71.AOnReadV1Enable1(5);
        }

        //son Gain Offset 설정
        if (nFil == 3) {//hv open 
            Sub71.HV_OffSet_Gain(nHVOffSet, nHVGain);    //sylee140226
        }

        //son Filter 설정
        Sub71.FilterSet(nFil);//sylee130628 

        //son I Filter 설정
        if (nIFilter == 3) {
            AfxMessageBox(" Error No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
            nIFilter = 1;
        }
        Sub71.I_Filter(nIFilter);//sylee130629

        //**********************************************************//      
        //son I Gain 설정
        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on        
        }
        else {
            Sub71.I_Gain(1);  //1x  =io off
        }

        //**********************************************************//
        //son I Range 설정, I Set,  V Relay On 
        Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);

    }//end of   if( nOPenSetSkip==1){//sylee150428


    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    if (nMod1 == TEST_OPEN)
    {

        int dutId = getDutId();

        //son ???? 의미 없는 코드??
        //nRCount=nBDLData2Op[dutId][1][0][1];  //SYLEE180810-1-DUT16   //son190704-4WDUT16

        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920   //son190704-4WDUT16

        if ((g_nPieceMax1 > 1)) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }

    }
    else {
        str.Format("Error No 7207 ,     SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    nLoop = 0;//sylee20120724
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118

    //son OpenErr Data를 0으로 초기화
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//SYLEE121129
    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) { //SYLEE130109-1
        ::ZeroMemory(&nOpenErrData, sizeof(nOpenErrData));
        ::ZeroMemory(&nOpenErrList, sizeof(nOpenErrList));
        //  ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
    }
    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));//sylee151208-1-import



    tStart2 = GetuSecond(); //SYLEE140108TEST  //SYLEE150509-1 OK

    //////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    

    //   Sub71.OnPinAllReset1(); ///PIN ALL RESET 

    Sub71.OnSparkOn(0);//sylee150527

    //---------------------------------------------------
    //son 1번 Scanner Card HW 정상 체크 (SelfTest 활용)
    //    임의의 pin(0~31)을 선택하여 연결을 체크한다.
    //---------------------------------------------------

    //son190902 32KPIN
    //2019.11.11 : 상부, 하부 모두 존재하지 않고 케이블로 상부 하부를 변경하면서 테스트시에는 
    //             아래의 체크코드를 #if 0 으로 전환해서 막아놓고 수행해야 한다.  하부 박스만 있는데 
    //             상부 박스의 pin1~32를 확인하므로 진행이 불가함.
//#if 1
#ifndef _PC_TEST_      //son240712
    int nPin11;//sylee141017-1

    if (nOPenSetSkip == 1)//sylee150428
    {

        //ACE380TESTMODE    nPin11=rand()%(128*10);

        nPin11 = rand() % (32);  //CAN'T OPEN    17/08/14 JUNG  EXECUTIVE DIRECTOR 

        for (int j1 = 1; j1 <= 2000; j1++)  //sylee1608010-1    2000->20
        {

            //son230825 if (SysSet13.m_nPinBlockType == PIN_BLK_32K_TRANS //son190902 32KPIN    //son230216_1
            //son230825       || SysSet13.m_nPinBlockType == PIN_BLK_32K_ORG)   //son230216_1
            {
                //son HW적으로 pin 1~ 32 사이의 pin이 꽂혀 있는지를 확인하는 것이므로 
                //    HwPin 변환을 거치지 않고 고정값인 1~32를 써야 한다.  그래서  type 1으로 호출함.

                //son 같은 pin에 VB, VC를 붙여서 SelfTest  상황을 만든다.
                Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
                Sub71.AOnPinSet1(1, nPin11, 1); //=1Vb,    // 
                Sub71.Delay_100ns(50); //50us  
                Sub71.AOnPinSet1(1, nPin11, 2); //=1Vc,
                Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS

            }
            //son230825 s100-1에서 상부 첫번째 block이 없는 .CON을 가진 BDL일때 여기에 걸려서 7703 Pin Map 에러 다수 발생하고
            //   SW 죽여야 다시 사용할 수 있는 문제 발생. (230825) pin변환 없이 첫번째 block을 체크하고자 하는 것이므로  
            //   AOnPinSet1(1, nPin11, 1); 하는 코드만 남기고 아래 코드는 삭제. 
            //else
            //{
            //    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
            //    Sub71.AOnPinSet1(2, nPin11, 1); //=1Vb, //sylee1608010-1
            //    Sub71.Delay_100ns(50); //50us  
            //    Sub71.AOnPinSet1(2, nPin11, 2); //=1Vc,//sylee1608010-1
            //    Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS
            //}
            Sub71.Delay_100ns(10000); //50us //sylee200612-4W정도개선

            //sylee170814-1  Sub71.AOnReadV1I1_ADC_I();  
            //sylee170814-1  break;  
            if (nCC == 2) {
                Sub71.AOnReadV1I1(7);
            }
            else {
                Sub71.AOnReadV1I1(nVRel);
            }

            if (Sub71.Y1 < 0.0000001) {
                Sub71.Y1 = 0.0000001;
            }

            if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411   
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 5) {  //SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                    //son R ohm = (VB 전압 - VC 전압) / 전류 * (mA면 1000을 곱하고 uA면 1000000을 곱한다) 
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                }
            }

            //son 100 ohm의  Raw R 값보다 작으면
            if (Sub71.R1 <= nProRv1_O) { //sylee170814-1
                break;
            }


            //-----------------
            //son Open 발생 
            //    같은핀을 VB, VC로 설정했는데 Open이 발생했다면  1번 scanner 카드에 무슨 문제가 있는 것.
            if (j1 == 2000) {    //sylee170814-1     

                Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                int nCard, nPin;
                nPin11 = PinMap[2][nPin11];
                nCard = (int)(nPin11 / 128) + 1;
                nPin = (int)(nPin11 - (int)((nCard - 1) * 128)) + 1;
                nFlagInsul1 = 1;//sylee170816-1
                DisplayRes1_BigLabel(TEST_DIS_FAIL);//sylee170816-1 //son220824
                str.Format("Insulation Error!   Can't open!"); //sylee170816-1
                m_list1.AddString(str); //sylee170816-1 
                str.Format(" Error No 7011-11.   \n\n\n\n  Insulation  Error!    or   Can't open!    \n\n\n\n   1) PCB Clamp check! \n   2) Auto self check! \n\n  ");     //sylee200612
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str, MB_OK);  //sylee170816-1

                goto Task201_END;//sylee170816-1	//son230706 Task201 -> Task201_END

                break;
            }

        }

    }//end of if(   nOPenSetSkip==1)//sylee150428
#endif



    int nPin21, nPin22;//sylee170601 


    //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
    if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
    {
        nPin21 = (*g_pvBDLData2Op[nMulNetFlag][1])[1].wFirstPin;  //son200420-4WNET10000
        nPin22 = (*g_pvBDLData2Op[nMulNetFlag][1])[1].wPin;       //son200420-4WNET10000
    }
    else {//sylee170601                            
        nPin21 = (*g_pvBDLData2Op[1][1])[1].wFirstPin;     //son200420-4WNET10000
        nPin22 = (*g_pvBDLData2Op[1][1])[1].wPin;          //son200420-4WNET10000
    }

    //son Open검사중 사용할 중간 data 초기화 
    ::ZeroMemory(&nBDLData2Op_Cur, sizeof(nBDLData2Op_Cur));//sylee160211-1  //sylee160308-1 //sylee180728-1 moveup
    ::ZeroMemory(&nBDLData2Op_Po, sizeof(nBDLData2Op_Po));//sylee160211-1 //sylee180728-1 moveup

    //son  5회 반복하여 핀설정 초기화
    for (j2 = 1; j2 <= 5; j2++) { //sylee170601        
        Sub71.OnPinAllReset1();
        Sub71.AOnPinSet1(2, nPin21, 1);
        Sub71.Delay_100ns(50); //50us  
        Sub71.AOnPinSet1(2, nPin22, 2);
        Sub71.Delay_100ns(1000);
        Sub71.AOnReadV1I1_ADC_I();
    }
    Sub71.OnPinAllReset1(); ///PIN ALL RESET 

 


    //////////////////////////////////////////////////////////////////////////////sylee200320-4WCVMODE
/* //sylee2102203

    int n4WNet[MAX_4W_NET +1][NUM_4W_GRID_COL],net; //son211022 10 -> NUM_4W_GRID_COL . 4W JigTest 안되는 현상 수정
    net=0;
    nEnd=(int)g_s4WNet[1].wCount;
    ::ZeroMemory (&n4WNet, sizeof(n4WNet));
    Sub71.OnPinAllReset1();

    for(   net=1; net<=nEnd; net++)  {  //sylee200321
        n4WNet[net][_4W_PIN1]    =(int)g_s4WNet[1].saData[net-1].waPin[0];   // 1~4  pin, //son190705-DUT16
        n4WNet[net][_4W_PIN2]    =(int)g_s4WNet[1].saData[net-1].waPin[1];   // 1~4  pin,
        n4WNet[net][_4W_PIN3]    =(int)g_s4WNet[1].saData[net-1].waPin[2];   // 1~4  pin,
        n4WNet[net][_4W_PIN4]    =(int)g_s4WNet[1].saData[net-1].waPin[3];   // 1~4  pin,
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1]-1, 2);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3]-1, 2);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2]-1, 1);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4]-1, 1);
        Sub71.Delay_100ns(5000);//500uS
        Sub71.OnPinAllReset1(__LINE__);
    }
    //////////////////////////////////////////////////////////////////////////////sylee200320-4WCVMODE
*/

#if 0   //son220803 begin :  Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
//   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

//son 모든 piece가 PASS 상태인 Cell이면 Open테스트 ResheetTest 불가
    if (nReSheetFlag1 == 1) { //sylee150228
        int nPCo;
        nPCo = 0;
        for (int ip5 = 1; ip5 <= ipEnd; ip5++) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip5];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) { //son PASS
                nPCo++;
                continue;
            }
        }
        if (nPCo == ipEnd) {
            // Log_Event1(3);
            AfxMessageBox(" ALL  Piece  Passed,   Sheet Retest Open Run Error!  Engineer Call!\n", MB_OK);
        }
    }
#endif 

    //son 모든 piece가 SkipPcs 상태인 Cell이면 Open테스트 ResheetTest 불가  
    if (g_nSkipPieceFlag1 == 1)
    {
        int nPCo;
        nPCo = 0;
        for (int ip5 = 1; ip5 <= ipEnd; ip5++) {
            if (g_nSkipPieceInfo[ip5] == 2) {//skip disable piece  //son220803 
                nPCo++;
                continue;
            }
        }
        if (nPCo == ipEnd) {
            str.Format("ARun201_O11(): ALL Piece Skipped by MainHandler,   Sheet Retest Open Run Error!  Engineer Call!\n");
            MyTrace(PRT_BASIC, str);
            AfxMessageBox(str, MB_OK);
        }
    }   //son220803 end




    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        nAutoPress_nConEr_old1 = SysInfo05.m_nConEr;//sylee150213
        SysInfo05.m_nConEr = 50000;
    }

    tStart1002 = GetuSecond();//SYLEE150426-2


    //####################################################################################
    //first

    nReCo1_Old = 0;//sylee150527

    int nRCountTotal;
    nRCountTotal = 0;

    nOldPin1 = -1; //sylee220411


    for (ip = 1; ip <= ipEnd; ip++) //sylee121128 
    {
        //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우.
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS       //son220624
            if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <====//sylee160203-ITS     //son220624
                continue;
            }
        }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 Resheet(Sheet Retest) 의미없음
        if (nReSheetFlag1 == 1) { //sylee131127//resheet
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                continue;
            }
        }
#endif //son220803 end

        //son 해당 piece가 Disable이면  Open테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                //sylee150527-2 nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        //son Retest 중일 때에는 이전에 Pass인 Piece는 테스트하지 않는다.
        if (gRun05.m_nReCh > 0) {//sylee121129 
            if (nReFlagOpenOld[ip] == 1) { //SYLEE121129  2=OPEN
                continue;
            }
        }


        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1)  //son220824_2 
        {
            nRCount = g_pvBDLData2Op[nMulNetFlag][ip]->size() - 1;//SYLEE150817  //son200420-4WNET10000
        }
        else {//SYLEE150817
            nRCount = g_pvBDLData2Op[1][ip]->size() - 1;     //son200420-4WNET10000
        }

        nRCountTotal = nRCountTotal + nRCount;//sylee210310     //son nErrorRateToTalPin 계산용


        nRCountToTal = nRCountToTal + nRCount;//sylee150213     //son OpenMes1 Log용
        OpenErrC = 0;
        nOldPin1Flag = 0;//sylee140222
        nSelectFlag1 = 0;  //sylee151203


        for (i = 1; i <= nRCount; i++) //SYLEE20111212
        {


Task1:


            //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
            if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
            {
                t1 = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin + 1;//PIECE  pin no    //son200420-4WNET10000
            }
            else {//SYLEE150817
                t1 = (*g_pvBDLData2Op[1][ip])[i].wFirstPin + 1;//PIECE  pin no              //son200420-4WNET10000
                //   t2=g_nPinPieceNo[1][t1];//PIECE  piece no//sylee160117
            }

            t2 = nPinToPiece(t1);//SYLEE171225-2      //son190704-4WDUT16

            //sylee160801-2 t2=g_nPinPieceNo[1][t1];//PIECE  piece no
            t3 = nFailPiece[ip][nPStep1];////PIECE  error count //son Open step의 현재 Piece별 err Count  

            //son 현재 Recipe(Open) Step의 ErrCount가 ConErr(OpenErr MaxCount) Range를 넘었는지 확인한다.
            if (t3 >= SysInfo05.m_nConEr) {    //sylee20120410  
                if (nAutoReTest[nBlockCountP] != gRun05.m_nReCh) { //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP  //SYLEE130221
                    break;
                } //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP
                if (nFlagAutoPress1 == 2) {//sylee150604
                    break;
                }

            }

            //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
            if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1)  //son220824_2 
            {
                nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin;  //son200420-4WNET10000
                nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wPin;       //son200420-4WNET10000
            }
            else {//SYLEE150817                          
                nPinA = (*g_pvBDLData2Op[1][ip])[i].wFirstPin;        //son200420-4WNET10000
                nPinB = (*g_pvBDLData2Op[1][ip])[i].wPin;             //son200420-4WNET10000
            }

            if (i > 1)
            {
                //if (nMulNetFlag > 1 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
                if (nMulNetFlag > 1 && nMulNetFlag < MAX_DUT1) //son220824_2 
                {
                    //son 이전 Net(i-1)의 firstPin
                    nOldPin1 = (*g_pvBDLData2Op[nMulNetFlag][ip])[i - 1].wFirstPin; //son200420-4WNET10000
                    if (ip > 50) {
                        str.Format(" Error No  7111      DUT%d  PIECE  50 ea over!   ", nMulNetFlag);
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str, MB_OK);
                    }

                }
                else {//SYLEE150817                          
                    nOldPin1 = (*g_pvBDLData2Op[1][ip])[i - 1].wFirstPin;       //son200420-4WNET10000

                    int nPieceCo1;//sylee180905-1
                    nPieceCo1 = (int)DEF_MAX_PIECE1 - 1;//sylee180905-1 //son220823_6
                    if (ip > nPieceCo1) {
                        str.Format("   Error No  7111      DUT1  PIECE  =%d ea over!", nPieceCo1); //sylee180905-1
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str, MB_OK);//sylee180905-1
                    }
                }
                //son First Pin이 같은 Net이면 nOldPin1Flag를 1로 설정 
                if ((nPinA == nOldPin1) && (nReCo1_Old == 0 || nReCo1_Old == 2 || nReCo1_Old == 4 || nReCo1_Old == 6)) {//sylee150527
                    nOldPin1Flag = 1;//sylee150422  
                }
                else {
                    nOldPin1Flag = 0;//sylee150422   
                }
            }
            else {
                nOldPin1Flag = 0;
            }

            //son First Pin이 이전 Net FirstPin과 다른  Net이면 nOldPin1Flag를 0으로 설정 
            //sylee150422 nOldPin1Flag=0; 
            if (nPinA != nOldPin1) {//sylee210408-import.
                Sub71.OnPinAllReset1(); ///PIN ALL RESET
                nOldPin1Flag = 0;
                nSelectFlag1 = 0;
            }

            //----------------------------------------------------------------------
            //son 먼지제거 기능
            //    첫번째인 nReCo1=0, 짝수일 때에는 대표핀을 VC(-)  검사핀을 VB(+)로 설정하고 테스트하고
            //    두번째인 nReCo1=1, 홀수일 때에는 대표핀을 VB(+)  검사핀을 VC(-)로 설정하고 테스트
            //    이렇게 핀설정 방향을 바꿔가면서 테스트해서 전기극성때문에 붙었던 먼지를 제거하면 
            //    발생했던 OpenFail이 없어질 수도 있다.

            //son Retest Count가 짝수인 경우 (VB에 PinB 연결, VC에 PinA 연결)
            if (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)  //sylee140926 
            {
                // Sub71.OnPinResetVB(); 
                Sub71.AOnPinSet1(2, nPinB, 1); //vB //son 테스트핀 VB 설정

                nPinSetSkipVbCnt++; //sylee151005 //ACE400 				//son230127                  
                if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                    nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                }

                //son Net이 바뀔 때만  (nOldPin1Flag==0) PInA(대표핀)  새로 설정 
                if (nOldPin1Flag == 0 || nSelectFlag1 != 1) {   //sylee151203
#if 0	
                    //son230118 Jig 없이 Open 테스트하기 위한 테스트코드. 
                    //   Vb, Vc를 같은 핀에 설정해서 short시켜 jig 없이도 open이 안 나오는 상황을 만든다.
                    Sub71.AOnPinSet1(2, nPinB, 2);  //vc 
#else                    
                    Sub71.AOnPinSet1(2, nPinA, 2);  //vc 
#endif
                    nPinSetSkipVcCnt++; //sylee151005 //ACE400                	//son230127   
                    if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){   	//son230127
                        nPinSetSkipVc = 3; //sylee151005 //ACE400   			//son230127
                    }
                }

            }
            //son Retest Count가 홀수인 경우 (VB에 PinA 연결, VC에 PinB 연결)
            else    //sylee140926
            {
                Sub71.AOnPinSet1(2, nPinA, 1);   //vb   //sylee140926       //son 대표핀 VB 설정
                nPinSetSkipVbCnt++; //sylee151005 //ACE400              //son230127    
                if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                    nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                }
#if 0	
                //son230118 Jig 없이 Open 테스트하기 위한 테스트코드
                //   Vb, Vc를 같은 핀에 설정해서 short시켜 jig 없이도 open이 안 나오는 상황을 만든다.
                Sub71.AOnPinSet1(2, nPinA, 2); //vc     //sylee140926       //son 테스트핀 VC 설정
#else    
                Sub71.AOnPinSet1(2, nPinB, 2); //vc     //sylee140926       //son 테스트핀 VC 설정
#endif
                nPinSetSkipVcCnt++; //sylee151005 //ACE400           	//son230127        
                if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                    nPinSetSkipVc = 3; //sylee151005 //ACE400			//son230127
                }
            }   //sylee140926 


            //sylee200905   Sub71.Delay_100ns(500);  ////SYLEE190223-1    10uS->50uS   ok
            //sylee201103  Sub71.Delay_100ns(200); //sylee200905   500 -> 200

#if (defined(__NANOSYS__CUSTOMER) || defined(__LM__CUSTOMER))   //SYLEE211020add    //son220915_2
            if (nVSet <= 20) {
                Sub71.Delay_100ns(200);  //sylee210330-2
            }
            Sub71.Delay_100ns(100);  //sylee210330-2
#else
            if (nVSet <= 20) {//sylee210205 
                Sub71.Delay_100ns(500);  //sylee201103   50uS  //sylee210210-1  50us->20us
            }
            else {
                Sub71.Delay_100ns(400); //sylee210205-1   10uS //sylee210210-1  40us->20us
            }
#endif

            if (nModeNamo > 1) {//sylee201103-1
                Sub71.Delay_100ns(1500); // +150uS=200us
            }



            //--------------------------
            //son 저항값 측정 (CheckOpen()) 

            int nLoop2;//sylee140407
            nLoop2 = 0;//sylee140407

            tStart11 = Get_uSecond1();//uS    // 저항값 측정 시작 time 표시

            //sylee160801-3 if(nOpenFail1[ip]<3){//sylee150804-1
          //SYLEE210330   if(nOpenFail_Co1[ip]<(SysInfo05.m_nConEr) ){//sylee150804-1   //sylee151207  //SYLEE170807-2 30->(SysInfo05.m_nConEr+1) 
            //son Open 불량 카운트가 ConErr Max 카운트 이내일 때 
            if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//SYLEE210330 
                nRetrySet = 3;   //sylee160801-3 5->3
                nDelay22 = nDelay20;//sylee150804-1   //son (int)dRec[m_nMode1][6]
            }

            //son Open 불량 카운트가 ConErr Max 카운트를 초과할 때 
            else {
                nRetrySet = 1;
                nDelay22 = nDelay21;//sylee150804-1       //son210803 600

                //son i를 end 값이 nRcount보다 크게 설정해서 현재 piece 테스트를 종료한다.
                i = nRCount + 1;//SYLEE160801-3     
            }


Task500://sylee140407       



            nLoop2++;//sylee140407
            if (nCC == 2) {
                Sub71.AOnReadV1I1(7);
            }
            else {
                Sub71.AOnReadV1I1(nVRel);
            }

            if (Sub71.Y1 < 0.0000001) {
                Sub71.Y1 = 0.0000001;
            }

            if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411                   
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 5) {  //SYLEE150904 //ACE400
                   //SYLEE200908   Sub71.R1=(Sub71.X1)/Sub71.Y1*1000000.0;
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;//SYLEE200908
                }
                else if (nIR == 5) { //sylee121115           //son ????  if (nIR == 5)가 왜 두번 있나?????
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
            }
            else {

                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 5) {  //SYLEE150904 //ACE400
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                }
            }


            if (nPass == 2) {
                Sub71.R1 = 0.0;//allpass
            }

            //------------------------------------------------
            //son Test mode의 기준 R값 보다 크면 Open 불량
            if (Sub71.R1 > nProRv1) {////sylee140407                
                if (nLoop2 < 500) {//sylee140407//sylee170529-1 100->500
                    tStart12 = Get_uSecond1();//uS 
                    tStart13 = (tStart12 - tStart11);
                    //  Sleep(1);//sylee210205

                    //son Open불량이지만 측정시간 < TimeOut 시간 이면 Timeout 될때까지 측정 retry.  (Retry1)
                    if (tStart13 < nDelay22) {  //sylee150804-1   
                        goto Task500;//sylee140407
                    }
                }
            }

            if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                Sub71.R1 = 9999999;
            }

			if (nVSet >=150  ||  nVSet <=20 ) {//sylee230823
				  if (Sub71.Y1 < (nISet * 0.7)) {//sylee211009    70%
					 Sub71.R1 = 9999999;
				  }
			}else{
				 if (Sub71.Y1 < ((nVSet/10.) * 0.5)) {//sylee230823   50%
					 Sub71.R1 = 9999999;//sylee230823
				 } 
			}

            if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                Sub71.R1 = 9999999;
            }

            //  10v high R   

            if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030
                if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                    Sub71.R1 = 9999999;
                }
                if (nVSet == 10) {  //sylee140911                          
                    if (Sub71.X1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                        Sub71.R1 = 9999999;
                    }
                    if (Sub71.X1 < nVBSetPercentLow) {//sylee120914  //VC   VB 1%
                        Sub71.R1 = 9999999;
                    }
                }
            }


            if (nPass == 2) {
                Sub71.R1 = 0.0;//allpass
            }

            //sylee210316  if( nCycleRunFlag==2  || nAutoSelf_OPen1_Run_Flag==1 ){ //sylee130925      //SYLEE140824
            if (nAutoSelf_OPen1_Run_Flag == 1) {
                if (Sub71.R1 < nProRv1) {//pass        //son Test mode의 기준 R값 보다 작으면 pass 
                    Sub71.R1 = nProRv1 + 1;
                }
                else {
                    Sub71.R1 = 0.0;
                }
            }


            if (i > 1)
            {
                int dutId = getDutId();
                nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin;       //SYLEE180810-1-DUT16   //son190704-4WDUT16  //son200420-4WNET10000

                if (nPinA != nOldPin1) {
                    nOldPin1Flag = 0;//sylee140222
                }
                else {
                    nOldPin1Flag = 1;//sylee140222
                }
            }
            else {
                nOldPin1Flag = 0;
            }

            if ((nOldPin1Flag == 1) && (Sub71.R1 <= nProRv1) && (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)) {// //sylee150506
                Sub71.OnPinResetVB();
                nSelectFlag1 = 1;  //sylee151203
            }
            else {
                Sub71.OnPinAllReset1(); ///PIN ALL RESET
                nSelectFlag1 = 0;  //sylee151203
            }


            nReCo1_Old = nReCo1;//sylee150527                 

            //son nMaxRetryCount를  평소에는  3으로.  ConEr +1 까지 에러가 증가하면 1로 조정
            //sylee160801-3 if(nOpenFail1[ip]<100){//sylee150604   //SYLEE160730  100
            if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//sy //SYLEE170807-2 100->(SysInfo05.m_nConEr+1) 
                nRetrySet2 = 3; //sylee150604  //SYLEE160730  3
            }
            else {
                nRetrySet2 = 1; //sylee150604  //SYLEE160730   1
            }


#ifdef _TEST_OPEN_ALL_PASS_
            Sub71.R1 = 1;   //son220524_2  Open all pass를 만들 수 있는 테스트코드
#endif


            if (SysSet13.m_nSet_NearbyOpenMeas == 1)    //son230712 영풍 SST OpenTest가 2018년 대비 느린 문제 관련 보완 
            {
                //son 30 으로 설정했다면  130/100 => 1.3
                double nearByRate = (100 +  SysSet13.m_nNearByOpenRate) /100.;	//son230728
                
                //son230717 if ((Sub71.R1 > nProRv1) && (Sub71.R1 < (nProRv1 * 1.3))) //SYLEE211122 
                //if ((Sub71.R1 > nProRv1) && (Sub71.R1 < (nProRv1 * 1.03))) //son230717 근접Open 기준을 30%-> 3%로 수정. 사장님 지시사항
                if ((Sub71.R1 > nProRv1) && (Sub71.R1 < (nProRv1 * nearByRate))) //son230728 근접Open 기준을 입력받도록 수정. 
                {
                    ARun201_OPEN_Mea1(i, nProRv1, ip, nCC, nFil, nIR, nISet, nRCount, nDelay20);
                }
            }

            //----------------------------------------------
            //son Test mode의 기준 R값 보다 작으면 pass
            if (Sub71.R1 <= nProRv1) {//pass   //sylee160527-1
                nReCo1 = 0;//sylee150422

                nBDLData2Op_Cur[ip][i] = 1;// current pass open net //sylee160211-1   //sylee160308-1
                nBDLData2Op_Old[ip][i] = 1;// old pass open net //sylee160211-1   //sylee160308-1
                nBDLData2Op_Po[nPinA] = 1;//sylee160211-1   //sylee160308-1
                nBDLData2Op_Po[nPinB] = 1;//sylee160211-1    //sylee160308-1
                nBDLData2Op_Po_old[nPinA] = 1;//sylee160616-1   //sylee160628-1 add
                nBDLData2Op_Po_old[nPinB] = 1;//sylee160616-1  //sylee160628-1 add

                if (nFlagOpenMes1 == 1) {//SYLEE210309-1
                    if (Sub71.R1 > 0) {
                        OpenMes1[OpenMes1Step][nRCountTotal - nRCount + i] = Sub71.R1;    //son raw R
                    }
                }
            }

            //-------------------
            //son  Open 불량!
            //-------------------
            //     Test mode의 기준 R값 보다 크면  Fail  
            else  //fail //SYLEE20120117//sylee160527-1
            {
                //son Open불량이지만 RetryCount< MaxRetryCount 이면 측정 retry.  (Retry2)

                //son RetryCount(nReCo1)을 증가시키고, Task1으로 보내서 핀설정부터 다시 한다.
                //    첫번째인 nReCo1=0, 짝수일 때에는 대표핀을 VC(-)  검사핀을 VB(+)로 설정하고 테스트하고
                //    두번째인 nReCo1=1, 홀수일 때에는 대표핀을 VB(+)  검사핀을 VC(-)로 설정하고 테스트
                //    이렇게 핀설정 방향을 바꿔가면서 테스트해서 전기극성때문에 붙었던 먼지를 제거하면 
                //    OpenFail이 없어질 수도 있다.
                nReCo1++;   //son RetryCount++
                if (nReCo1 < nRetrySet2) {  //sylee150604

                    //SYLEE160731-3  if(nOpenFail1[ip]<=3){//sylee150804-1  //sylee151207

                    if (nOpenFail_Co1[ip] <= 3) {//sylee160731-3
                        Sub71.Delay_100ns(300);     //sylee140823
                    }
                    goto  Task1;
                }

                //son Retry1, Retry2를 모두 마쳐도 불량인 경우는 이 카운트를 증가시킴.
                nOpenFail_Co1[ip]++;//SYLEE160731-3

                nFailPiece[ip][nPStep1]++;////PIECE  error count    //SYLEE160731-3  IMPORT
                nReCo1 = 0;

                if (nFlagOpenMes1 == 1) {//SYLEE210309-1
                    if (Sub71.R1 > 0) {
                        OpenMes1[OpenMes1Step][nRCountTotal - nRCount + i] = Sub71.R1;
                    }
                }
            } //sylee160527-1

        }////for END      for( i=1; i<=nRCount ; i++){ //SYLEE20111212

    }//ip




    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//sylee160731-3   IMPORT

    //sylee160628-1 add

    //###################################################################################################
    //son 불량 재검사
    //
    //SYLEE160615-1 #1-1  //  current  first pin 
    //

    int nPinA2, nStart11, nEnd11, nStart21, nEnd21;
    int nOpen2Pass1;        //son 11: 양품,  201: 2회 연속 불량
    int nOpen2_1, nOpen2_2, nOpen2_3, nOpen2_co1;
    int nnnn;

    ::ZeroMemory(&nOpen2Li1, sizeof(nOpen2Li1));

    nnnn = nOpen_PassCo2;


    if ((nAutoReTest[nBlockCountP] != 0) && (nOpen_PassCo2 <= 10))//sylee170327    
    {
        for (int ip2 = 1; ip2 <= ipEnd; ip2++)
        {

            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<====//sylee160203-ITS      //son220624
                if (g_nSkipPieceInfo[ip2] == 2) {//skip disable piece  <===//sylee160203-ITS      //son220624
                    continue;
                }
            }

            nOpen2Pass1 = 0;
            nOpen2_co1 = 0;

            //son 해당 piece가 Disable이면  Open테스트 의미없음
            if (SysInfo19.m_nUse == 1) {//sylee160731-1
                if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {  //sylee161101-1 IMPORT  
                    continue;
                }
            }

            //son 해당 piece에 open Pass가 있었다면 Open테스트 의미없음
            if (gRun05.m_nReCh > 0) {//sylee160731-1
                if (nReFlagOpenOld[ip2] == 1) {  //sylee161101-1 IMPORT
                    continue;
                }
            }

            int dutId = getDutId();
            for (int kk1 = 1; kk1 <= nRCount; kk1++)
            {
                //-------------------------------------------------------------------------------------
                //#1 START  END  
                nStart11 = 0; nEnd11 = 0;
                nStart21 = 0; nEnd21 = 0;
                nOpen2_1 = -1; nOpen2_2 = -1; nOpen2_3 = -3;

                //son 이전테스트에서 Pass인 OpTest 항목은 넘어간다.
                if (nBDLData2Op_Cur[ip2][kk1] == 1) {   //son pass면 넘어간다.
                    continue;
                }
                if ((kk1 + 1) > nRCount) {
                    continue;
                }

                //son 불량이 있는 OpTest 항목 위치 표시
                nStart11 = kk1;
                nPinA = (*g_pvBDLData2Op[dutId][ip2])[kk1].wFirstPin; //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000

                //son kk1 이후부터 이후로 같은 대표핀인 Net의 마지막 위치 nEnd11을 찾는다.
                //    현재 Net에서 불량구간으로 추정되는 nStart1부터 nEnd를 찾는다. (불량 SubNet)
                for (int kk2 = (kk1 + 1); kk2 <= nRCount; kk2++)
                {
                    nPinA2 = (*g_pvBDLData2Op[dutId][ip2])[kk2].wFirstPin;        //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000

                    if (nPinA == nPinA2) {
                        nEnd11 = kk2;
                    }
                    else {
                        kk1 = kk2;//?????????
                        break;
                    }
                }

                if (nStart11 >= nEnd11) {//k3
                    continue;
                }
                //--------------------------------------------------------------------------
                //#2  L&L

                //------------------------------------------------------------------------
                //son 불량인 항목들이 혹시 양품이 아닌지를 불량 SubNet 안에서 테스트한다.
                //------------------------------------------------------------------------

                //son Open 2차 재검사
                //    동일 Net에 양품과 불량이 동시에 있는 Net만 검사한다.

                int nTemco1, nTemco2;

                nTemco1 = 0;
                nTemco2 = 0;

                //son 불량이 존재하는 위치 이후의 동일 Net을 점검.
                for (int kk3 = nStart11; kk3 <= nEnd11; kk3++)
                {

                    nPinB = (*g_pvBDLData2Op[dutId][ip2])[kk3].wPin;  //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000

                    if (nBDLData2Op_Old[ip2][kk3] == 1) {
                        nTemco1++;      //son 불량이 존재하는 Net 내부에서 pass 카운트
                        // Sub71.AOnPinSet1(2, nPinB, 1); //vb
                    }
                    else {
                        nTemco2++;      //son 불량이 존재하는 Net 내부에서 open fail 카운트
                        // Sub71.AOnPinSet1(2, nPinB, 2); //vc
                    }
                }

                //son pass카운트가 0이거나(모두 불량),   open 카운트가 0(모두 양품)이면 해당 항목 테스트 포기
                if (nTemco1 == 0 || nTemco2 == 0) {//k3
                    //  Sub71.OnPinAllReset1(__LINE__); 
                    continue;
                }

                //son 불량이 존재하는 위치 이후의 불량 SubNet을 테스트
                for (kk3 = nStart11; kk3 <= nEnd11; kk3++)  //sylee170807-1
                {
                    nPinB = (*g_pvBDLData2Op[dutId][ip2])[kk3].wPin;  //SYLEE180810-1-DUT16   //son190704-4WDUT16  //son200420-4WNET10000

                    //son 양품 핀은 모두 VB에 연결  (PinB)
                    if (nBDLData2Op_Old[ip2][kk3] == 1) {
                        // nTemco1++;
                        Sub71.AOnPinSet1(2, nPinB, 1); //vb
                    }
                    //son 불량 핀은 모두 VC에 연결  (PinB)
                    else {
                        //nTemco2++;
                        Sub71.AOnPinSet1(2, nPinB, 2); //vc
                    }
                }

                Sub71.Delay_100ns(nDelay20);

                //son  R 값 측정
                if (nCC == 2) {
                    Sub71.AOnReadV1I1(7);
                }
                else {
                    Sub71.AOnReadV1I1(nVRel);
                }

                if (Sub71.Y1 < 0.0000001) {
                    Sub71.Y1 = 0.0000001;
                }

                if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411   
                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                    }
                    else if (nIR == 5) {  //SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                    }
                }
                else {
                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                    }
                    else if (nIR == 5) {
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                    }
                }

                //-----------------
                //son 양품 측정됨
                if (Sub71.R1 <= nProRv1) {
                    nOpen2Pass1 = 11;
                    Sub71.OnPinResetVB();    //son 양품핀 VB Reset
                }

                //-----------------
                //son 불량 측정됨 
                else {
                    nOpen2Pass1 = 201;
                    Sub71.OnPinAllReset1(); ///PIN ALL RESET
                }


                //############################################################################################      
                //#4-1
                //son  2번 연속 불량으로 측정된 불량 Sub Net 재검사.   
                //     - 동일 Net의 불량 List 중에서 양품을 찾는다.
                //     - PinB(2) 만으로 검사한다. 

                int nOpen_Flag_VB_1;
                nOpen_Flag_VB_1 = 0;

                if (nOpen2Pass1 == 201)   //son 2회 연속불량이면
                {

                    for (int kj1 = nStart11; kj1 < nEnd11; kj1++)
                    {
                        if (nOpen_Flag_VB_1 != 0) {
                            break;
                        }

                        if (nBDLData2Op_Old[ip2][i] != 1) {
                            continue;
                        }

                        nPinA2 = (*g_pvBDLData2Op[dutId][ip2])[kj1].wFirstPin;  //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000

                        nPinA = (*g_pvBDLData2Op[dutId][ip2])[kj1].wPin;       //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000

                        for (int kj2 = kj1 + 1; kj2 <= nEnd11; kj2++)
                        {

                            if (nOpen_Flag_VB_1 != 0) {
                                break;
                            }
                            if (nBDLData2Op_Old[ip2][i] != 1) {
                                continue;
                            }

                            nPinB = (*g_pvBDLData2Op[dutId][ip2])[kj2].wPin; //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000 //son200420-4WNET10000

                            //son 현재 step의 불량핀을 VB에 연결 
                            Sub71.AOnPinSet1(2, nPinA, 1); //vb                  

                            //son 검사 step의 불량핀을 VC에 연결
                            Sub71.AOnPinSet1(2, nPinB, 2); //vc      

                            Sub71.Delay_100ns(nDelay20);

                            //son R 값 측정
                            if (nCC == 2) {
                                Sub71.AOnReadV1I1(7);
                            }
                            else {
                                Sub71.AOnReadV1I1(nVRel);
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411   
                                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 5) {  //SYLEE150904 //ACE400
                                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }
                            }
                            else {
                                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                                }
                                else if (nIR == 5) {
                                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                                }
                            }

                            if (Sub71.R1 <= nProRv1) {
                                nOpen_Flag_VB_1 = 1;  //son Pass
                                nOpen2Pass1 = 202;//???????????????
                            }
                            Sub71.OnPinAllReset1(); ///PIN ALL RESET

                        }   // for( int kj1=nStart11; kj1<nEnd11; kj1++){ 

                    }//   for( int kj2=kj1+1; kj2<=nEnd11; kj2++){ 

                }//if(  nOpen2Pass1==201){

                //############################################################################################

                //son 2번 연속 불량 이후 테스트에서 양품이 나온 경우 
                if (nOpen2Pass1 == 202) {

                    nOpen2_co1++;       //   1???????                   
                    nOpen2Li1[ip2][0][0] = nOpen2_co1;
                    nOpen2Li1[ip2][nOpen2_co1][0] = nPinA2;//master pin
                    nOpen2Li1[ip2][nOpen2_co1][1] = nPinA;// slave pin

                    for (int kj3 = nStart11; kj3 < nEnd11; kj3++) {
                        if (nBDLData2Op_Old[ip2][kj3] == 1) {
                            nBDLData2Op_Cur[ip2][kj3] = 1;
                        }
                    }
                    nOpen2Pass1 = 203;

                }//if(  nOpen2Pass1==202)

                //############################################################################################
                //--------------------------------------------------------------------------
                //#3 P & L    onepoint  vb search.


                //son 불량 -> 양품 으로 측정된 케이스를 다시 검사 
                //    전단계에서 양품핀 VB 설정한 것 만 리셋함.  불량핀 VC 설정한 것은 유지 된 상태 
                if (nOpen2Pass1 == 11)
                {

                    for (int kk4 = nStart11; kk4 <= nEnd11; kk4++)
                    {
                        //son Start1부터 양품인  step을 찾는다.
                        if (nBDLData2Op_Old[ip2][kk4] != 1) {/// 
                            continue;
                        }

                        nPinB = (*g_pvBDLData2Op[dutId][ip2])[kk4].wPin; //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000

                        //son 양품인 검사핀을 VB로 설정한다.
                        Sub71.AOnPinSet1(2, nPinB, 1); //vb
                        Sub71.Delay_100ns(nDelay20);

                        //son R 값 측정.
                        if (nCC == 2) {
                            Sub71.AOnReadV1I1(7);
                        }
                        else {
                            Sub71.AOnReadV1I1(nVRel);
                        }
                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }
                        if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411               
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 5) {  //SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                        else {
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                            }
                            else if (nIR == 5) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                            }
                        }

                        //son 또다시 양품이 나왔다면 OnPinAllReset()하고 nOpen2Pass1=12 단계로 넘어간다.
                        if (Sub71.R1 <= nProRv1) {
                            nOpen2Pass1 = 12;
                            Sub71.OnPinAllReset1();

                            //son 현재 양품인 검사핀을 pinA로 저장하고 VB로 설정
                            nPinA = nPinB;
                            Sub71.AOnPinSet1(2, nPinA, 1); //vb   //<==========================
                            nOpen2_1 = nPinB;     //son 양품인 검사핀 nPinB를 nOpen2_1으로 저장 
                            break;  //for( int k7=nStart11; k7<=nEnd12; k7++){               
                        }
                        else {
                            Sub71.OnPinResetVB();
                        }
                    }//end of for( int k7=nStart11; k7<=nEnd12; k7++){         

                }//end of if( nOpen2Pass1==1){

                //=========================================================================================
                //# P (VB FIX= OLD PASS )  &   P ( VC  SEARCH ** ? = NEW PASS )=>  SECOND  MASTER PIN MAKING


                if (nOpen2Pass1 == 12)
                {

                    for (int kk5 = nStart11; kk5 <= nEnd11; kk5++)
                    {
                        // 현재 Net 안에서 불량인 항목을 찾는다.
                        if (nBDLData2Op_Old[ip2][kk5] == 1) {//???????????????????????????????????
                            continue;
                        }

                        nPinA2 = (*g_pvBDLData2Op[dutId][ip2])[kk5].wFirstPin;  //son200420-4WNET10000
                        nPinB = (*g_pvBDLData2Op[dutId][ip2])[kk5].wPin;       //son200420-4WNET10000

                        //son nOpen2Pass1==11 마지막 단계에서 nPinA로 바꾼 이전 양품 검사핀을 VB로 설정.
                        Sub71.AOnPinSet1(2, nPinA, 1); //vb   //sylee160726

                        //son 현재 불량 검사핀을 VC로 설정.
                        Sub71.AOnPinSet1(2, nPinB, 2); //vc
                        Sub71.Delay_100ns(nDelay20);
                        if (nCC == 2) {
                            Sub71.AOnReadV1I1(7);
                        }
                        else {
                            Sub71.AOnReadV1I1(nVRel);
                        }
                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }
                        if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411               J
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 5) {  //SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                        else {
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                            }
                            else if (nIR == 5) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                            }
                        }

                        Sub71.OnPinAllReset1();

                        //son 또다시 양품으로 측정된다면 nOpen2Pass1=13 단계로 넘어간다.
                        if (Sub71.R1 <= nProRv1) {
                            nOpen2Pass1 = 13; //<==========================   
                            nOpen2_2 = nPinB; //son 양품인 검사핀 nPinB를 nOpen2_2으로 저장 

                            //son 양품인 검사핀 nOpen2_1 나 nOpen2_2가 존재한다면
                            if ((nOpen2_1 >= 0) && (nOpen2_2 >= 0)) {
                                nOpen2_co1++;
                                nOpen2Li1[ip2][0][0] = nOpen2_co1;
                                nOpen2Li1[ip2][nOpen2_co1][0] = nPinA2;//master pin
                                nOpen2Li1[ip2][nOpen2_co1][1] = nOpen2_1;// slave pin
                                //nOpen2_1== OLD PASS, CUR PASS
                                //nOpen2_2== CUR  PASS   
                                //nOpen2_3= STAND PIN  OLD PASS

                                nBDLData2Op_Po[nOpen2_1] = 1;// 
                                nBDLData2Op_Po[nOpen2_2] = 1;// 

                                nBDLData2Op_Po_old[nOpen2_1] = 1;//sylee160616-1//?????????????????????
                                nBDLData2Op_Po_old[nOpen2_2] = 1;//sylee160616-1//?????????????????????   

                                //son 양품이므로 현재 항목을 Pass로 표시한다.
                                nBDLData2Op_Cur[ip2][kk5] = 1;// current pass open net //sylee160211-1   //sylee160308-1  //sylee160527-1
                                nBDLData2Op_Old[ip2][kk5] = 1;//sylee160726   //sylee160308-1
                            }
                            //nOpen2Pass1=13;
                            break;  //for( int k7=nStart11; k7<=nEnd12; k7++){               
                        }
                    }//end of for( int k7=nStart11; k7<=nEnd12; k7++){  
                }//end of if(nOpen2Pass1==2){


                //==============================================================================================
                // second master pin &  vc  pin open test

                if (nOpen2Pass1 == 13)
                {
                    nPinA = nOpen2_1;

                    for (int kk6 = nStart11; kk6 <= nEnd11; kk6++)
                    {

                        nPinB = (*g_pvBDLData2Op[dutId][ip2])[kk6].wPin; //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000

                        //son nOpen2Pass1==12 단계에서 양품 검사핀을 VB로 설정.
                        Sub71.AOnPinSet1(2, nPinA, 1); //vb   //fix

                        //son 현재 step의 검사핀을 VC로 설정
                        Sub71.AOnPinSet1(2, nPinB, 2); //vc

                        Sub71.Delay_100ns(nDelay20);
                        if (nCC == 2) {
                            Sub71.AOnReadV1I1(7);
                        }
                        else {
                            Sub71.AOnReadV1I1(nVRel);
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411               
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 5) {  //SYLEE150904 //ACE400
                                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                        else {
                            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                            }
                            else if (nIR == 5) {
                                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                            }
                        }

                        //son 양품으로 측정됨
                        if (Sub71.R1 <= nProRv1) {
                            //son 현재 kk6 항목을 양품으로 표시한다.
                            nBDLData2Op_Cur[ip2][kk6] = 1;  // nBDLData2Op_Cur[ip][i]==1)
                            nBDLData2Op_Old[ip2][kk6] = 1;//sylee160726
                        }
                        Sub71.OnPinAllReset1();
                    }//end of for( int k7=nStart11; k7<=nEnd12; k7++){  

                }//end of if(nOpen2Pass1==3){
                //==============================================================================================

                if (nOpen2_co1 >= 5) {
                    break;
                }
                //=========================================================================
            }////for END      for( i=1; i<=nRCount ; i++){ //SYLEE20111212

            Sub71.OnPinAllReset1();

        }//ip2

    }// if(nAutoReTest[nBlockCountP]!=0)



//#####################################################################################################
//son  first 테스트에서 양품인 항목을 제외하고 모든 항목을 first와 동일하게 다시 테스트한다.

//second

    nReCo1_Old = 0;//sylee150527

    for (ip = 1; ip <= ipEnd; ip++) //sylee121128 
    {

        //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<====//sylee160203-ITS      //son220624
            if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <=====//sylee160203-ITS        //son220624
                continue;
            }
        }

#if 0   //son220803 begin :  Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 Resheet 의미없음
        if (nReSheetFlag1 == 1) { //sylee131127//resheet
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                continue;
            }
        }
#endif  //son220803 end

        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                //sylee150527-2 nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        if (gRun05.m_nReCh > 0) {//sylee121129 
            if (nReFlagOpenOld[ip] == 1) { //SYLEE121129  2=OPEN
                continue;
            }
        }

        nRCount = g_pvBDLData2Op[dutId][ip]->size() - 1; //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000  

        nRCountToTal = nRCountToTal + nRCount;//sylee150213

        OpenErrC = 0;
        nOldPin1Flag = 0;//sylee140222
        nSelectFlag1 = 0;  //sylee151203

        double dOldVc1, dOldI1;//sylee200909

        for (i = 1; i <= nRCount; i++) //SYLEE20111212
        {

            if (nFailPiece[ip][nPStep1] >= (SysInfo05.m_nConEr)) { //sylee171127-1 
                i = nRCount + 1;//sylee171127-1
                break;//sylee171127-1
            }  //sylee171127-1

            if (nBDLData2Op_Cur[ip][i] == 1) {// current pass open net //sylee160211-1  //sylee160308-1  //sylee160527-1
                continue;
            }

            if (SysSet211.m_nSet15 == 1) {
                if (nOpenFail_Co1[ip] > nRetrySet10) {//SYLEE161018-1-test
                    continue;
                }
            }

            //sylee210225   Sleep(200);//sylee20210205
            Sub71.OnPinAllReset1();//sylee20210205


        Task11:


            t1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//PIECE  pin no  //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000
            t2 = nPinToPiece(t1);//SYLEE171225-2      //son190704-4WDUT16
            t3 = nFailPiece[ip][nPStep1];////PIECE  error count   

            if (t3 >= SysInfo05.m_nConEr) {    //sylee20120410  ///block 단위 임 ==> piece 단위로 검사 해야 한다.                                       
                if (nAutoReTest[nBlockCountP] != gRun05.m_nReCh) { //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP  //SYLEE130221
                    break;
                } //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP
                if (nFlagAutoPress1 == 2) {//sylee150604
                    break;
                }
            }

            nPinA = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin; //SYLEE180810-1-DUT16  //son200420-4WNET10000
            nPinB = (*g_pvBDLData2Op[dutId][ip])[i].wPin;     //son200420-4WNET10000

            if (i > 1) {//sylee200907
                if ((*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin == (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin) {//sylee200907
                    //son 직전 양품 검사핀을 PinA로 
                    nPinA = (*g_pvBDLData2Op[dutId][ip])[i - 1].wPin; //sylee200907
                    //son 현재 불량 검사핀을 PinB로 
                    nPinB = (*g_pvBDLData2Op[dutId][ip])[i].wPin; //sylee200907
                }
            }


            if (i > 1)
            {
                nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin; //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000

                if ((nPinA == nOldPin1) && (nReCo1_Old == 0 || nReCo1_Old == 2 || nReCo1_Old == 4 || nReCo1_Old == 6)) {//sylee150527
                    nOldPin1Flag = 1;//sylee150422  
                }
                else {
                    nOldPin1Flag = 0;//sylee150422   
                }
            }
            else {
                nOldPin1Flag = 0;
            }


            if (nPinA != nOldPin1) {//sylee210408-import.
                Sub71.OnPinAllReset1(); ///PIN ALL RESET
                nOldPin1Flag = 0;
                nSelectFlag1 = 0;
            }
            if (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)  //sylee140926 
            {
                Sub71.AOnPinSet1(2, nPinB, 1); //vB 

                nPinSetSkipVbCnt++; //sylee151005 //ACE400               //son230127    
                if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                    nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                }

                if (nOldPin1Flag == 0 || nSelectFlag1 != 1) {   //sylee151203
                    Sub71.AOnPinSet1(2, nPinA, 2);  //vc 

                    nPinSetSkipVcCnt++; //sylee151005 //ACE400              //son230127     
                    if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                        nPinSetSkipVc = 3; //sylee151005 //ACE400			//son230127
                    }
                }

            }
            else    //sylee140926
            {
                Sub71.AOnPinSet1(2, nPinA, 1);   //vb   //sylee140926
                nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127 
                if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){		//son230127
                    nPinSetSkipVb = 3; //sylee151005 //ACE400				//son230127
                }
                Sub71.AOnPinSet1(2, nPinB, 2); //vc     //sylee140926   

                nPinSetSkipVcCnt++; //sylee151005 //ACE400                   //son230127
                if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){		//son230127
                    nPinSetSkipVc = 3; //sylee151005 //ACE400				//son230127
                }

            }   //sylee140926

            if (nVSet <= 20) {//sylee210205 
                Sub71.Delay_100ns(500);  //sylee201103   50uS  //sylee210210-1  50us->20us
            }
            else {
                Sub71.Delay_100ns(400); //sylee210210-1  40us->20us
            }

            if (nModeNamo > 1) {//sylee201103-1
                Sub71.Delay_100ns(1500);   //+150uS=200us
            }


            int nLoop2;//sylee140407
            nLoop2 = 0;//sylee140407

            tStart11 = Get_uSecond1();//uS 

            if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//sylee160801-3     //SYLEE170807-2 50->(SysInfo05.m_nConEr+1) 
                nRetrySet = 3;  //sylee160803  5->3
                nDelay22 = nDelay20 * 2;//sylee150804-1     //sylee160703-1

            }
            else {
                nRetrySet = 1;
                nDelay22 = nDelay21;//sylee150804-1
            }



        Task511://sylee140407


            nLoop2++;//sylee140407
            if (nCC == 2) {
                Sub71.AOnReadV1I1(7);
            }
            else {
                Sub71.AOnReadV1I1(nVRel);
            }
            if (Sub71.Y1 < 0.1) {
                Sub71.Y1 = 0.1;//sylee161121-1
            }

            if (nReCo1 <= 0) {//sylee200909 
                dOldVc1 = 0; dOldI1 = 0;//sylee200909
            }

            if (nFil == 3) {//HV OPEN ENABLE               
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1 + dOldVc1) / (Sub71.Y1 + dOldI1) * 1000.0;   //sylee200909                    
                }
                else if (nIR == 5) {
                    Sub71.R1 = (Sub71.X1 + dOldVc1) / (Sub71.Y1 + dOldI1) * 1000000.0;//sylee200909
                }
                dOldVc1 = Sub71.X1;//sylee200909 
                dOldI1 = Sub71.Y1;//sylee200909
            }
            else {

                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1 + dOldVc1) / (Sub71.Y1 + dOldI1)) * 1000.0;  //sylee200909//sylee210310    
                }
                else if (nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1 + dOldVc1) / (Sub71.Y1 + dOldI1)) * 1000000.0;//sylee200909
                }
                dOldVc1 = (Sub71.V1 - Sub71.X1);//sylee200909
                dOldI1 = Sub71.Y1;//sylee200909
            }
            ////////////////////////////////////////////////////////////////////////////////
            if (nPass == 2) {
                Sub71.R1 = 0.0;//allpass
            }

            if (Sub71.R1 > nProRv1) {////sylee140407
                if (nLoop2 < 500) {//sylee140407  //sylee170529  30->500
                    tStart12 = Get_uSecond1();//uS 
                    tStart13 = (tStart12 - tStart11);
                    if (tStart13 < nDelay22) {  //sylee150804-1   //sylee151207   
                        goto Task511;//sylee140407
                    }
                }
            }

            if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                Sub71.R1 = 9999999;
            }


		 	if(nVSet >=150  ||  nVSet <=20 ) {//sylee230823
				  if (Sub71.Y1 < (nISet * 0.7)) {//sylee211009  
					 Sub71.R1 = 9999999;
				  }
			}else{
				 if (Sub71.Y1 < ((nVSet/10.) * 0.5)) {//sylee230823
					 Sub71.R1 = 9999999;//sylee230823
				 } 
			}

            if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                Sub71.R1 = 9999999;
            }
            //  10v high R  
            if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030
                if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                    Sub71.R1 = 9999999;
                }
                if (nVSet == 10) {  //sylee140911                          
                    if (Sub71.X1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                        Sub71.R1 = 9999999;
                    }
                    if (Sub71.X1 < nVBSetPercentLow) {//sylee120914  //VC   VB 1%
                        Sub71.R1 = 9999999;
                    }
                }
            }

            if (nPass == 2) {
                Sub71.R1 = 0.0;//allpass
            }

            //SYLEE191126   if( nCycleRunFlag==2  || nAutoSelf_OPen1_Run_Flag==1 ){ //sylee130925     //SYLEE140824
            if (nAutoSelf_OPen1_Run_Flag == 1) {//SYLEE191126     //sylee200612
                if (Sub71.R1 < nProRv1) {//pass 
                    Sub71.R1 = nProRv1 + 1;
                }
                else {
                    Sub71.R1 = 0.0;
                }
            }

            if (i > 1)
            {
                nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin; //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000
                if (nPinA != nOldPin1) {
                    nOldPin1Flag = 0;//sylee140222
                }
                else {
                    nOldPin1Flag = 1;//sylee140222
                }
            }
            else {
                nOldPin1Flag = 0;
            }

            if ((nOldPin1Flag == 1) && (Sub71.R1 <= nProRv1) && (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)) {// //sylee150506
                Sub71.OnPinResetVB();
                nSelectFlag1 = 1;  //sylee151203
            }
            else {
                Sub71.OnPinAllReset1(); ///PIN ALL RESET
                nSelectFlag1 = 0;  //sylee151203
            }

            nReCo1_Old = nReCo1;//sylee150527

            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            if (nFlag_4W_Use1 != 1) {
                if (Sub71.R1 > nProRv1) {//fail  
                    if (nBDLData2Op_Old[ip][i] == 1) {
                        if (nBDLData2Op_Po[nPinA] == 1 || nBDLData2Op_Po[nPinB] == 1) {
                            Sub71.R1 = nProRv1 - 1;//pass 
                        }
                    }
                }
            }
            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            //sylee160616-1
            if (Sub71.R1 > nProRv1) {//fail    //sylee160628-1 add                  
                if (nBDLData2Op_Po_old[nPinA] == 1 && nBDLData2Op_Po[nPinB] == 1) {  //sylee160628-1 add   import ?????????????????????
                    Sub71.R1 = nProRv1 - 1;//pass 
                }
            }
            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         

            if (nPass == 2) {
                Sub71.R1 = 0.0;//allpass
            }

            //sylee160801-3 if(nOpenFail1[ip]>5){//sylee150604
            if (nOpenFail1[ip] > 20) {//sylee150604  //sylee160801-3  //sylee171127-1  50->20
                nRetrySet2 = 1; //sylee150604
            }
            else {
                nRetrySet2 = 3; //sylee150604  //SYLEE160730  3
            }


            if (Sub71.R1 <= nProRv1) {//pass  
                nReCo1 = 0;//sylee150422
            }
            else  //fail //SYLEE20120117
            {

                nReCo1++;
                if (nReCo1 < nRetrySet2) {  //sylee150604      
                    if (nOpenFail1[ip] <= (SysInfo05.m_nConEr + 1)) {//sylee150804-1    //SYLEE170807-2  50->(SysInfo05.m_nConEr+1) 
                        Sub71.Delay_100ns(300);     //sylee140823
                    }
                    goto  Task11;
                }
                nReCo1 = 0;
                nOpenFail_Co1[ip]++;//sylee160731-3   //sylee160801-3


                if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) { //SYLEE130109-1   //OPENPIN->SHORTCHECK      //SYLEE130221                          
					if (OpenErrC < 5000) { 
                        OpenErrC++;
                        nOpenErrData[ip][0][1] = OpenErrC;
                        nOpenErrData[ip][OpenErrC][OP_TO_FIRST_PIN] = nPinA;
                        nOpenErrData[ip][OpenErrC][OP_TO_TEST_PIN] = nPinB;
                    }
                    else {
                        OpenErrC = OpenErrC;
                    }
                    if (t3 >= SysInfo05.m_nConEr) {
                        continue;
                    }
                }
                //////////////////////////////////////////////////////////////////////

                if (nFailL1CoOpen < 3000) //array size nFailL1
                {
                    if (nProOneP_RunFlag1 == 1) {//sylee131221
                        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {
                            if (gRun05.m_nReCh != 0) {//sylee150618
                                if (nAutoReTest[nBlockCountP] > 1) {//SYLEE181031-1
                                    nProOneP_RunFlag1 = 0;
                                }
                            }
                        }
                    }
                    nFailCount[nMod1]++;
                    nFailL1CoOpen++;
                    nFailL1Open[nFailL1CoOpen][1] = nFailL1CoOpen;//open 1
                    nFailL1Open[nFailL1CoOpen][2] = nBlockCountP;//block  

                    t1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//PIECE  pin no //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000

                    nOpenFail1[ip]++;//sylee20120921//100=piecemax
                    nReFlagOpenCur[ip] = 2; //SYLEE121129  2=OPEN   //son 현재 Piece Open 불량 표시. 
                                                                  // 여기서 Open 표시를 함으로써 Retest할 때의 테스트 대상이 된다.
                    nFailPiece[ip][nPStep1]++;////PIECE  error count                    
                    if (nFailPiece[ip][nPStep1] >= SysInfo05.m_nConEr) {
                        nOpenMoreThanFlag = 1;//sylee12112
                        if (nOldPin1Flag == 1) {//sylee140222                       
                            Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                        }
                    }

                    nFailL1Open[nFailL1CoOpen][F_PIECE] = ip;////PIECE  no    //son220419_4 3:F_PIECE

                    int a1, a2;

                    a1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//pin  //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000
                    a2 = (*g_pvBDLData2Op[dutId][ip])[i].wPin + 1;//pin         //son200420-4WNET10000


                    if (a1 < a2) {
                        nFailL1Open[nFailL1CoOpen][F_VB_PIN] = a1;  //son220419_4 4:F_VB_PIN
                        nFailL1Open[nFailL1CoOpen][F_VC_PIN] = a2;  //son220419_4 5:F_VC_PIN
                    }
                    else {
                        nFailL1Open[nFailL1CoOpen][F_VB_PIN] = a2;  //son220419_4 4:F_VB_PIN
                        nFailL1Open[nFailL1CoOpen][F_VC_PIN] = a1;  //son220419_4 5:F_VC_PIN
                    }

                    if (nErrPin1O2[a1] == 0) {//sylee170810-1
                        if (nErrPin1O[a1] < 100000) {
                            nErrPin1O[a1]++;//sylee170810-1
                            nErrPin1O2[a1] = 1;
                        }
                    }
                    if (a1 != a2) {//sylee170810-1
                        if (nErrPin1O2[a2] == 0) {//sylee170810-1
                            if (nErrPin1O[a2] < 100000) {
                                nErrPin1O[a2]++;//sylee170810-1
                                nErrPin1O2[a2] = 1;
                            }
                        }
                    }

                    //son220419_4 nFailL1Open[nFailL1CoOpen][] 관련 상수 enum으로 변경 
                    nFailL1Open[nFailL1CoOpen][F_RAW_R] = Sub71.R1;//Sub71.R1               //son220419_2  6:F_RAW_R
                    nFailL1Open[nFailL1CoOpen][F_PRORV_RAW_R] = nProRv1;//nProRv1 판정 rawR  //son220419_2 17:F_PRORV_RAW_R 
                    nFailL1Open[nFailL1CoOpen][F_PRORV_REAL_R] = nProRv1Real;                //son220419_2  7:F_PRORV_REAL_R
                    nFailL1Open[nFailL1CoOpen][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];     //son220419_2  8:F_PRO_STEP_REAL_R
                    nFailL1Open[nFailL1CoOpen][F_VSET] = nVSet;                              //son220419_2  9:F_VSET
                    nFailL1Open[nFailL1CoOpen][F_ISET] = nISet;                              //son220419_2 10:F_ISET
                    nFailL1Open[nFailL1CoOpen][F_MODE1] = m_nMode1;                          //son220419_2 11:F_MODE1
                    nFailL1Open[nFailL1CoOpen][F_VB] = Sub71.V1;//VB                         //son220419_2 12:F_VB
                    nFailL1Open[nFailL1CoOpen][F_VC] = Sub71.X1;//VC                         //son220419_2 13:F_VC
                    nFailL1Open[nFailL1CoOpen][F_I] = Sub71.Y1;//I                           //son220419_2 14:F_I
                    nFailL1Open[nFailL1CoOpen][F_TEST_TYPE] = nMod1;//I  //open ushort short hr hv   4w 
                                                                                           //son220419_2 16:F_TEST_TYPE


                }
                else {//sylee130225joytech

                    nFailCount[nMod1]++;//sylee130225joytech         
                    nFailL1CoOpen++;//sylee130225joytech
                    nOpenFail1[ip]++;////sylee130225joytech
                    nReFlagOpenCur[ip] = 2; ////sylee130225joytech        //son 2: Open 불량 piece로 표시
                    nFailPiece[ip][nPStep1]++;////sylee130225joytech

                }

            }//}else{//fail  //SYLEE20120117

        }////for END      for( i=1; i<=nRCount ; i++){ //SYLEE20111212


        //####################################################################################################


        if (nRCount > 0) {
            if (nReFlagOpenCur[ip] != 2) { //SYLEE121129 pass,    2=OPEN
                nReFlagOpenCur[ip] = 1;   //son 1: PASS piece

                int tmp1;
                tmp1 = nBlockPieceNo1[nBlockCountP][ip]; //son Cell번호 획득. GraphDisplay1[] index로 사용

                if (GraphDisplay1[tmp1] == 0) {
                    GraphDisplay1[tmp1] = 1;
                }
            }
        }

        //-------------------------------------------------------
        //son OpenErrFlag, OpenErrList(first Pin 위치 정보)  생성
        //-------------------------------------------------------
        //   nOpenErrData[piece][err][]를 조사해서 같은 대표핀의 err를 찾기 쉽도록 nOpenErrList[대표핀][]으로 정리한다. 
        //   nOpenErrData는 같은 대표핀이 모여있으므로 nOpenErrList는 시작과 끝 위치만 표시함

        //son 해당 block의 모든 Retest를 마쳤다면
        if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) //SYLEE130109-1  //sylee130221
        {


            int firstPin;

            if (nOpenErrData[ip][0][1] > 0)        //son nOpenErrData Count > 0 ?
            {
                nOpenErrFlag[ip] = 1;     //son piece Err Flag on
                for (int err = 1; err <= nOpenErrData[ip][0][1]; err++)
                {
                    //nOpenErrList[ip][5000][3]=

                    //son 첫번째 err 저장이라면 start와 end에 모두 현재  nOpenErrData[piece] 에서의 OpenErr 위치를 저장
                    if (err == 1) {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }

                    //son  대표핀 pinNo가 앞의 대표핀 pinNo와 다른 경우 
                    //  => 다른 Net이므로  대표핀 No를 바꿔서 다음번 nOpenErrList[firstPin]을 처리한다.
                    if (firstPin != nOpenErrData[ip][err][OP_TO_FIRST_PIN]) {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }

                    //son 앞의 대표핀과 같은 대표핀이면 end위치만 갱신.
                    else {
                        nOpenErrList[firstPin][1] = err;
                    }

                    //son 마지막 err 이면 end만 write
                    if (err == nOpenErrData[ip][0][1]) {
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }
                }
            }
        }

    }//ip



    //sylee131221  one-piece
    int nTempOpenCo1;

    nTempOpenCo1 = nProOneP_Open1[0][0];// total short list

    nRetrySet2 = 1; //sylee150604

    if ((nProOneP_Flag1 == 3) && (nProOneP_RunFlag1 == 1) && (nTempOpenCo1 > 0))
    {

        for (int k1 = 1; k1 <= nTempOpenCo1; k1++)
        {

            nReCo1 = 0;

        Task501:

            nPinA = nProOneP_Open1[k1][0];
            nPinB = nProOneP_Open1[k1][1];

            Sub71.AOnPinSet1(2, nPinB, 1); //vc  
            Sub71.AOnPinSet1(2, nPinA, 2);

            //sylee150618   Sub71.Delay_100ns(nDelay10); 
            Sub71.Delay_100ns(2000); //sylee150618    //sylee181031-1  300->2000
            Sub71.AOnReadV1I1(nVRel);  //sylee131011  
            Sub71.OnPinAllReset1();

            if (nFil == 3) {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 3 || nIR == 4) {
                    //SYLEE200908   Sub71.R1=(Sub71.X1)/Sub71.Y1*1000000.0;
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;//SYLEE200908
                }
                else if (nIR == 5) { //sylee121115
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;
                }
            }

            if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                Sub71.R1 = 9999999;
            }

            if (Sub71.Y1 < nISet * 0.7) {//sylee211009
                Sub71.R1 = 9999999;
            }
            nReCo1++;

            if (Sub71.R1 > nProRv1) {//fail
                if (nReCo1 < nRetrySet2) {    //sylee150604                                        
                    goto  Task501;
                }

                if (gRun05.m_nReCh != 0) { //SYLEE150618
                    if (nAutoReTest[nBlockCountP] > 1) {//SYLEE181031-1
                        nProOneP_RunFlag1 = 0;
                    }
                }
                break;
            }


        }

    }//end of if((nProOneP_Flag1==3)&&(nProOneP_RunFlag1==1)) 


    //=========================================================================================

    tStart122 = GetuSecond();//TESTDEBUG
    tStart123 = (tStart122 - tStart121);//TESTDEBUG
    tStart1001 = GetuSecond();//SYLEE150509

 

Task201_END://sylee170816-1	//son230706 Task201 -> Task201_END


    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018

    Sub71.FilterSet(0);//sylee130704             
    Sub71.I_Filter(0);
    Sub71.ARunoff1();
    Sub71.AOnRelayOffSel(nVRel);  // lv relay off    
    Sub71.AOnReadV1Enable1(5); //sylee130711   lv  hv sen all off


    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        SysInfo05.m_nConEr = nAutoPress_nConEr_old1;//sylee150213 
        if (nRCountToTal > 0) {
            nErrorRateToTalPin = (double)((double)nFailL1CoOpen / (double)nRCountToTal);//sylee150213
        }
        else {
            nErrorRateToTalPin = 0.0;//sylee150213
        }

    }



    tStart1001 = GetuSecond();//SYLEE150701

    nPinSetSkipVb = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400	//son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400	//son230127
    //sylee150421 nDebugFileLog1();//SYLEE150421-DEBUG

    Sub71.OnPinResetInit();//sylee151221   //ACE400

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
	if( nFlagLeak12==1 || nFlagLeak12==2 ){//sylee230315-1 //sylee230321  //sylee230807
        Sub71.AOnVBSet1(4,0);//sylee230317  
	}
#endif  //son231122
 
    return 1;

}




int CChildView7::ARun201_O31_F(int nMod1, int m_nMode1, double nProRv1, int nPStep1) //SYLEE180412 FAKEOPEN ADD
{

    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];

    __int64   tStart11, tStart12, tStart13;  //sylee140407

    int dPinVC[200], dPinVB[200];// nTemp1[15000];
    int i, n4Wire, nRCount, nDelay10;
    int nEnd, nLoop, t1, t2, t3, ipEnd, ipFlag, Lo1, nFil, nTCount;
    int nRetrySet, nReCo1, nPinA, nPinB, nRetrySet2;//sylee150604
    int nIFilter, nHVOffSet, nHVGain;//sylee130629  //

    int nDelay20, nDelay21, nDelay22, nIGain, n4wGain, nRCountToTal;//sylee150213
    int nOPenSetSkip, nReCo1_Old, nPass, nSelectFlag1, nRunFlag1_OPen, nRetrySet10;//sylee161018

    short  nOldPin1, nOldPin1Flag;//sylee131221-2
    short nPiecefail[MAX_PIECE + 1], nOpenFail_Co1[MAX_PIECE + 1];//sylee160731-3 /sylee161010- piecemax

    double dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200], nT[10], nData[130][15];
    double nISet, dVbR1, dVbR2;
    double nISetPercentHigh, nISetPercentLow, nVBSetPercentHigh, nVBSetPercentLow;//sylee120914
    double nErrorRateToTalPin;//sylee150213

    int ip, j2;//sylee170816-1

    int nPosS1, nPosE1, nPassCo1, nPassCo2, nPassCo3, nPassCo4, nOpen2_co1, nPinB3; //sylee180219-2 move  FakeOpen?

    ////////////////////////////////////////////////////////////////////
    int  nTmpPinNo1;
   
	

	nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    Sub71.OnPinAllReset1();//sylee190207-1

    int dutId = getDutId();
    nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16


    for (int ik = 1; ik <= nRCount; ik++)//sylee190207-1
    {

        //son Short 총수
        nTmpPinNo1 = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16

        int ret = Sub71.AOnPinSet1(2, nTmpPinNo1, 1); //=1Vb, 
#if 1
        if (ret < 0)        //son-32KPIN-20200114:      nPin=PinMap[2][No] 가 -1이면 없는 카드. 
        {
            //str.Format("ERROR NO 7002-9, \nSub71.AOnPinSet1(2, ...) Error! \n\n\nCan't find hwPin for jigPin_%d  ", nTmpPinNo1 );
            //AfxMessageBox(str);
            return 0;
        }
#endif

    }
    //////////////////////////////////////////////////////////////////

    Sub71.OnDisCharge1(); //sylee170725-3 

    Sub71.OnPinAllReset1();//sylee190207-1

    if (SysInfo05.m_nConEr < 3) { //sylee161018
        nRetrySet10 = 3;
    }
    else if (SysInfo05.m_nConEr > 100) { //sylee161018
        nRetrySet10 = 100;
    }
    else {
        nRetrySet10 = SysInfo05.m_nConEr;//sylee161018
    }


    nRunFlag1_OPen = 0;
    ipEnd = 0;


    g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE180810-1-DUT16   //son190704-4WDUT16
    if ((g_nPieceMax1 >= 1)) {//PIECE
        ipEnd = g_nPieceMax1;
    }

    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS  //SYLEE180714        //son220624
            if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece  <====//sylee160203-ITS     //son220624
                continue;
            }
        }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 Resheet 의미없음
        if (nReSheetFlag1 == 1) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {    //son PASS
                continue;
            }
        }
#endif  //son220803 end

        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {//sylee130601
                      //sylee150527-2   nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        if (gRun05.m_nReCh > 0) {
            if (nReFlagOpenOld[ip3] == 1) {
                continue;
            }
        }



        nRunFlag1_OPen++;

    }


    if (nRunFlag1_OPen < 1) {
        return 1;
    }


    /////////////////////////////////////////////////////////////////////

    nPass = 0; //testmode

//ALLPASS       nPass=2; //testmode//allpass  /sylee151208debug


    nPinSetSkipVb = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400	//son230127	
    nPinSetSkipVc = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400	//son230127

    nOPenSetSkip = 1;//sylee150519 disable
    nRCountToTal = 0;//sylee150213

    tStart121 = GetuSecond();//TESTDEBUG


    ::ZeroMemory(&nPiecefail, sizeof(nPiecefail));//sylee150804-1

//  ::ZeroMemory(&nTemp1, sizeof(nTemp1));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20121128 
    ::ZeroMemory(&nReFlagOpenCur, sizeof(nReFlagOpenCur));//SYLEE121129
    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3

//sylee150422    nResSta1=0;//sylee131221-2   0=fail, 1=pass    
    nOpenPassNetFlag = 0;
    nTCount = 0;
    nReCo1 = 0;
    nStop = 0;
    n4Wire = 0;
    ipFlag = 0;//PIECE    

    ipEnd = 1;//PIECE

    //sylee140805 nRetrySet=3;//5->10 SYLEE130315JOYTECH//SYLEE121126    10->5  //sylee130336    
    nRetrySet = 3;//sylee160621   //sylee160730  3
//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//mode ( 1~65)
//step ( open, ㅏushort, short, hr, hv  4w)

    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];

    //sylee15703    if(nUse_US==0  &&   nUse_4W==1 ){   //sylee150630
    if (nUse_US == 0 && (nUse_4W == 1 || nUse_HR == 1)) {           //sylee15703
        if (nVSet == 20) {//sylee150630
            nVRel = 2;
        }
    }

    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629         
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];   //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];        //SYLEE150123     
    n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123 
    nDelay20 = (int)dRec[m_nMode1][6]; //sylee160801-3  -22 delete 

    //sylee160703-1  nDelay21=2000; //sylee150804-1
    //sylee160801-3 nDelay21=nDelay20;   //sylee160703-1
    //sylee170529 nDelay21= 400; //sylee160801-3
    nDelay21 = 600; //sylee160801-3   //sylee170529
    nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
    nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914

    if (m_nMode1 == 7 || m_nMode1 == 8) {//sylee150530
        nISetPercentLow = nISet * 0.0001;   //0.1%  //sylee150530
        nVBSetPercentLow = nVSet * 0.00001;   //0.01%  //sylee150530
    }
    else {//sylee150530
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
    }//sylee150530


    nIGain = (int)dRec[m_nMode1][12];        //ACE380 //SYLEE150123    


    if (nMod1 == TEST_OPEN) {//sylee20120306
        if (nVSet > 20) {
            nVRel = 4;   //VB RELAY   4
        }
    }

    //ADC COUNT
    Sub71.nADCount1 = (int)dRec[m_nMode1][7];
    if (Sub71.nADCount1 < 1) {
        Sub71.nADCount1 = 1;
    }
    if (Sub71.nADCount1 > 100) {
        Sub71.nADCount1 = 100;
    }


    //=========================================================================================
    //interlock    


    if (m_nMode1 < 1) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  <0 !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (m_nMode1 > 200) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  >200 !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 7704, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 7705, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }



    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 
     //sylee140215  Sub71.AOnReadVB1Run1(nVRel);//sylee130802 
     //sylee130903  Lo1=500; 

    Lo1 = 200;//sylee130903  200nS-> 1sec


Task101:


    if (nOPenSetSkip == 1) {//sylee150428
       //SYLEE20111213  Sub71.AOnReadVB1(nVRel);   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
        Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
        if (nVSet <= 5) {
            dVbR2 = nVSet * (0.35);//35%
        }
        else {
            dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
        }
        dVbR1 = nVSet - dVbR2;
        dVbR2 = nVSet + dVbR2;
        if (Simulator100 != 7) {
            if (Sub71.V1 > 300) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms //sylee121019  10->1mS  
                    goto Task101;
                }
                str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
                return 0;
            }

            if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms   //sylee121019  10->1mS   
                    goto Task101;
                }

                str.Format("Error No 1311,\n \n\n  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                if (nBlockCountP >= 1) {
                    nBlockCountP = 1;
                }
                nSelfTestHWError1 = 1;
                return 0;
            }

        }


        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
        //설정부                
        if (nFil == 1 || nFil == 2) {//SYLEE130628
            Sub71.AOnReadV1Enable1(nVRel);
        }
        else {
            Sub71.AOnReadV1Enable1(5);
        }

        if (nFil == 3) {//hv open

            Sub71.HV_OffSet_Gain(nHVOffSet, nHVGain);    //sylee140226
        }


        Sub71.FilterSet(nFil);//sylee130628 
        if (nIFilter == 3) {
            AfxMessageBox(" Error No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
            nIFilter = 1;
        }
        Sub71.I_Filter(nIFilter);//sylee130629

//**********************************************************//


        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on        
        }
        else {
            Sub71.I_Gain(1);  //1x  =io off
        }

        //**********************************************************//


        Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);


    }//end of   if( nOPenSetSkip==1){//sylee150428


    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    if (nMod1 == TEST_OPEN)
    {
        //son 의미 없음?? //son200420-4WNET10000
        //nRCount=nBDLData2Op[dutId][1][0][1];  //SYLEE180810-1-DUT16   //son190704-4WDUT16 

        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920

        if ((g_nPieceMax1 > 1)) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }

    }
    else {
        str.Format("Error No 7207 ,     SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }



    nLoop = 0;//sylee20120724
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118

    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//SYLEE121129
    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) { //SYLEE130109-1
        ::ZeroMemory(&nOpenErrData, sizeof(nOpenErrData));
        ::ZeroMemory(&nOpenErrList, sizeof(nOpenErrList));
        //  ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
    }
    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));//sylee151208-1-import



    tStart2 = GetuSecond(); //SYLEE140108TEST  //SYLEE150509-1 OK

    //////////////////////////////////////////


    //   Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

    Sub71.OnSparkOn(0);//sylee150527


    //----------------------------------------------------
    //son 1번 Scanner Card HW 정상 체크 (SelfTest 활용)
    //----------------------------------------------------
    int nPin11;//sylee141017-1
    if (nOPenSetSkip == 1)//sylee150428
    {

        //ACE380TESTMODE    nPin11=rand()%(128*10);

        nPin11 = rand() % (32);  //CAN'T OPEN    17/08/14 JUNG  EXECUTIVE DIRECTOR 

        for (int j1 = 1; j1 <= 2000; j1++)  //sylee1608010-1    2000->20
        {

            //son230825 if (SysSet13.m_nPinBlockType == PIN_BLK_32K_TRANS //son190902 32KPIN    //son230216_1
            //son230825       || SysSet13.m_nPinBlockType == PIN_BLK_32K_ORG)   //son230216_1
            {
                //son HW적으로 pin 1~ 32 사이의 pin이 꽃혀 있는지를 확인하는 것이므로 
                //    HwPin 변환을 거치지 않고 고정값인 1~32를 써야 한다.  그래서  type 1으로 호출함.
                //son 같은 pin에 VB, VC를 붙여서 SelfTest  상황을 만든다.
                Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
                Sub71.AOnPinSet1(1, nPin11, 1); //=1Vb, //sylee1608010-1
                Sub71.Delay_100ns(50); //50us  
                Sub71.AOnPinSet1(1, nPin11, 2); //=1Vc,//sylee1608010-1
                Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS
            }
            //son230825 s100-1에서 상부 첫번째 block이 없는 .CON을 가진 BDL일때 여기에 걸려서 7703 Pin Map 에러 다수 발생하고
            //   SW 죽여야 다시 사용할 수 있는 문제 발생. (230825) pin변환 없이 첫번째 block을 체크하고자 하는 것이므로  
            //   AOnPinSet1(1, nPin11, 1); 하는 코드만 남기고 아래 코드는 삭제. 
            //else
            //{
            //    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
            //    Sub71.AOnPinSet1(2, nPin11, 1); //=1Vb, //sylee1608010-1
            //    Sub71.Delay_100ns(50); //50us  
            //    Sub71.AOnPinSet1(2, nPin11, 2); //=1Vc,//sylee1608010-1
            //    Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS
            //}

            //sylee170814-1  Sub71.AOnReadV1I1_ADC_I();  
            //sylee170814-1  break;  
            if (nCC == 2) {
                Sub71.AOnReadV1I1(7);
            }
            else {
                Sub71.AOnReadV1I1(nVRel);
            }

            if (Sub71.Y1 < 0.0000001) {
                Sub71.Y1 = 0.0000001;
            }

            if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411   
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 5) {  //SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                }
            }

            //son 100 ohm의  Raw R 값보다 작으면
            if (Sub71.R1 <= nProRv1_O) { //sylee170814-1
                break;
            }

            //-----------------
            //son Open 발생 
            //    같은핀을 VB, VC로 설정했는데 Open이 발생했다면  1번 scanner 카드에 무슨 문제가 있는 것.
            if (j1 == 2000) {    //sylee170814-1         

                Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                int nCard, nPin;
                nPin11 = PinMap[2][nPin11];
                nCard = (int)(nPin11 / 128) + 1;
                nPin = (int)(nPin11 - (int)((nCard - 1) * 128)) + 1;
                nFlagInsul1 = 1;//sylee170816-1
                DisplayRes1_BigLabel(TEST_DIS_FAIL);//sylee170816-1 //son220824
                str.Format("Insulation Error!   Can't open!"); //sylee170816-1
                m_list1.AddString(str); //sylee170816-1 
                str.Format(" Error No 7011-12.   \n\n\n\n  Insulation  Error!    or   Can't open!    \n\n\n\n   1) PCB Clamp check! \n   2) Auto self check! \n\n  ");     //sylee200612
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str, MB_OK);  //sylee170816-1

                goto Task201;//sylee170816-1

                break;
            }

        }

    }//end of if(   nOPenSetSkip==1){//sylee150428




    int nPin21, nPin22;//sylee170601 


    nPin21 = (*g_pvBDLData2Op[dutId][1])[1].wFirstPin; //SYLEE180810-1-DUT16  //son190704-4WDUT16 //son200420-4WNET10000
    nPin22 = (*g_pvBDLData2Op[dutId][1])[1].wPin;      //son200420-4WNET10000



    ::ZeroMemory(&nBDLData2Op_Cur, sizeof(nBDLData2Op_Cur));//sylee160211-1  //sylee160308-1  //sylee180728 move up
    ::ZeroMemory(&nBDLData2Op_Po, sizeof(nBDLData2Op_Po));//sylee160211-1   //sylee180728 move up


    for (j2 = 1; j2 <= 5; j2++) { //sylee170601 
        Sub71.OnPinAllReset1();
        Sub71.AOnPinSet1(2, nPin21, 1);
        Sub71.Delay_100ns(50); //50us  
        Sub71.AOnPinSet1(2, nPin22, 2);
        Sub71.Delay_100ns(1000);
        Sub71.AOnReadV1I1_ADC_I();
    }



    Sub71.OnPinAllReset1(); ///PIN ALL RESET 




#if 0   //son220803 begin :  Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

    if (nReSheetFlag1 == 1) { //sylee150228
        int nPCo;
        nPCo = 0;
        //son 모든  piece가 PASS 상태인 Cell이면 Open테스트 Resheet 의미없음
        for (int ip5 = 1; ip5 <= ipEnd; ip5++) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip5];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                nPCo++;
                continue;
            }
        }
        if (nPCo == ipEnd) {
            //  Log_Event1(3);
            AfxMessageBox(" ALL  Piece  Passed,    Retest Open Run Error!  Engineer Call! ", MB_OK);
        }
    }
#endif 

    //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우.
    if (g_nSkipPieceFlag1 == 1) // skip disable CATCH OK,//son220803
    {
        int nPCo;
        nPCo = 0;
        for (int ip5 = 1; ip5 <= ipEnd; ip5++)
        {
            if (g_nSkipPieceInfo[ip5] == 2) //skip disable piece   
            {
                nPCo++;
                continue;
            }
        }
        if (nPCo == ipEnd) {
            str.Format("ARun201_O31_F(): ALL  Piece Skipped by MainHandler,    Retest Open Run Error!  Engineer Call!\n");
            MyTrace(PRT_BASIC, str);
            AfxMessageBox(str, MB_OK);
        }
    } //son220803 end


    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        nAutoPress_nConEr_old1 = SysInfo05.m_nConEr;//sylee150213
        SysInfo05.m_nConEr = 50000;
    }

    tStart1002 = GetuSecond();//SYLEE150426-2


//####################################################################################
 //first


    nReCo1_Old = 0;//sylee150527


    int nStopEnd1;//sylee180226-2-import FakeOpen

    if (ipEnd <= 20) {
        nStopEnd1 = 50;
    }
    else if (ipEnd <= 30) {
        nStopEnd1 = 40;
    }
    else {
        nStopEnd1 = 30;
    }


    for (ip = 1; ip <= ipEnd; ip++) //sylee121128 
    {

        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS  //SYLEE180714        //son220624
            if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <====//sylee160203-ITS     //son220624
                continue;
            }
        }

#if 0   //son220803 begin :  Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 Resheet 의미없음
        if (nReSheetFlag1 == 1) { //sylee131127//resheet
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {    //son PASS
                continue;
            }
        }
#endif  //son220803 end

        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
            //sylee150527-2 nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        if (gRun05.m_nReCh > 0) {//sylee121129 
            if (nReFlagOpenOld[ip] == 1) { //SYLEE121129  2=OPEN
                continue;
            }
        }


        nRCount = g_pvBDLData2Op[dutId][ip]->size() - 1; //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000


        /*  //sylee161013
         if(nRCount<1){
             str.Format("Error No 7307 , PIECE=%d,  OPEN LIST IS ZERO, \n",ip   );
             AfxMessageBox(str);
         }
        */

        nRCountToTal = nRCountToTal + nRCount;//sylee150213

        OpenErrC = 0;
        nOldPin1Flag = 0;//sylee140222
        nSelectFlag1 = 0;  //sylee151203
        //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //sylee180219-1-FakeOpen start
        nPosS1 = nPosE1 = nOpen2_co1 = 0;//sylee180131-1  //sylee180219-1-FakeOpen 

        for (int k11 = 1; k11 <= nRCount; k11++)  //sylee180219-1-FakeOpen
        {

            if (k11 == 1) { nPosS1 = 1; } //sylee180219-1-FakeOpen
            if (k11 <= nPosE1) { continue; }//sylee180219-1-FakeOpen
            if (k11 > nPosS1) { nPosS1 = k11; }//sylee180219-1-FakeOpen
            if (k11 < nPosS1) { k11 = nPosS1; }//sylee180219-1-FakeOpen
            nPosE1 = nPosS1;

            for (int k12 = nPosS1; k12 < nRCount; k12++)   //sylee180219-1-FakeOpen
            {
                int dutId = getDutId();
                t1 = (*g_pvBDLData2Op[dutId][ip])[k12].wPin;   //SYLEE180810-1-DUT16  //son190704-4WDUT16 //son200420-4WNET10000
                t2 = (*g_pvBDLData2Op[dutId][ip])[k12 + 1].wFirstPin;   //son200420-4WNET10000

                if (t1 == t2) {//sylee180219-1-FakeOpen
                    nPosE1 = k12 + 1;
                }
                else {
                    break;
                }
            }
            nPassCo4 = 0;//sylee180219-1-FakeOpen
            if (nOpenFail_Co1[ip] > nStopEnd1) {    //sylee180226-2-import
                k11 = nRCount + 1;//SYLEE180226-2-import
            }

            for (i = nPosS1; i <= nPosE1; i++) //sylee180219-1-FakeOpen
            {
                //sylee180219-1-FakeOpen     for( i=1; i<=nRCount; i++){ //SYLEE20111212



            Task1:


                t1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//PIECE  pin no //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000
                t2 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16

                //sylee160801-2 t2=g_nPinPieceNo[1][t1];//PIECE  piece no
                t3 = nFailPiece[ip][nPStep1];////PIECE  error count   
                if (t3 >= SysInfo05.m_nConEr) {    //sylee20120410  ///block 단위 임 ==> piece 단위로 검사 해야 한다.                                       
                    if (nAutoReTest[nBlockCountP] != gRun05.m_nReCh) { //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP  //SYLEE130221
                        break;
                    } //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP
                    if (nFlagAutoPress1 == 2) {//sylee150604
                        break;
                    }

                }

                nPinA = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin; //SYLEE180810-1-DUT16  //son190704-4WDUT16 //son200420-4WNET10000
                nPinB = (*g_pvBDLData2Op[dutId][ip])[i].wPin;             //son200420-4WNET10000

                if (i > 1)
                {

                    if ((dutId > 1) && (nMultyNetTotal >= dutId)) {//SYLEE180810-1-DUT16
                        nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin;   //son200420-4WNET10000
                        if (ip > 50) {
                            // AfxMessageBox("  Error No  7111      DUT4  PIECE  50 ea over! ", MB_OK);
                            str.Format(" Error No  7111      DUT%d  PIECE  50 ea over!   ", dutId);
                            MyTrace(PRT_BASIC, str);     //son221104_2
                            AfxMessageBox(str, MB_OK);
                        }
                    }
                    else {//SYLEE150817                           
                        nOldPin1 = (*g_pvBDLData2Op[1][ip])[i - 1].wFirstPin;   //son200420-4WNET10000

                        int nPieceCo1;//sylee180905-1
                        nPieceCo1 = (int)DEF_MAX_PIECE1 - 1;//sylee180905-1 //son220823_6
                        if (ip > nPieceCo1) {
                            str.Format("   Error No  7111      DUT1  PIECE  =%d ea over!", nPieceCo1); //sylee180905-1
                            MyTrace(PRT_BASIC, str);     //son221104_2
                            AfxMessageBox(str, MB_OK);//sylee180905-1
                        }




                    }

                    if ((nPinA == nOldPin1) && (nReCo1_Old == 0 || nReCo1_Old == 2 || nReCo1_Old == 4 || nReCo1_Old == 6)) {//sylee150527
                        nOldPin1Flag = 1;//sylee150422  
                    }
                    else {
                        nOldPin1Flag = 0;//sylee150422   
                    }
                }
                else {
                    nOldPin1Flag = 0;
                }



                //sylee150422 nOldPin1Flag=0; 

                if (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)  //sylee140926 
                {
                    Sub71.AOnPinSet1(2, nPinB, 1); //vB 

                    nPinSetSkipVbCnt++; //sylee151005 //ACE400    			//son230127               
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                    }

                    if (nOldPin1Flag == 0 || nSelectFlag1 != 1) {   //sylee151203
                        Sub71.AOnPinSet1(2, nPinA, 2);  //vc 
                        nPinSetSkipVcCnt++; //sylee151005 //ACE400             	//son230127      
                        if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                            nPinSetSkipVc = 3; //sylee151005 //ACE400			//son230127
                        }
                    }

                }
                else    //sylee140926
                {
                    Sub71.AOnPinSet1(2, nPinA, 1);   //vb   //sylee140926
                    nPinSetSkipVbCnt++; //sylee151005 //ACE400               	//son230127    
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){		//son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400				//son230127
                    }
                    Sub71.AOnPinSet1(2, nPinB, 2); //vc     //sylee140926   
                    nPinSetSkipVcCnt++; //sylee151005 //ACE400                 	//son230127	  
                    if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){		//son230127
                        nPinSetSkipVc = 3; //sylee151005 //ACE400				//son230127
                    }
                }   //sylee140926




                Sub71.Delay_100ns(300);//SYLEE170427   20uS->5uS //sylee170529-bhflex 50->200uS  //sylee211020 NANOSYS 100 ->300


                int nLoop2;//sylee140407
                nLoop2 = 0;//sylee140407


                tStart11 = Get_uSecond1();//uS 

                //sylee160801-3 if(nOpenFail1[ip]<3){//sylee150804-1
                if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//sylee150804-1   //sylee151207  //SYLEE170807-2 30->(SysInfo05.m_nConEr+1) 
                    nRetrySet = 3;   //sylee160801-3 5->3
                    nDelay22 = nDelay20;//sylee150804-1
                }
                else {
                    nRetrySet = 1;
                    nDelay22 = nDelay21;//sylee150804-1
                }



                if (nOpenFail_Co1[ip] > nStopEnd1) {    //sylee180226-2-import  FakeOpen
                    i = nPosE1 + 1;//SYLEE180226-2-import
                }


            Task500://sylee140407


                nLoop2++;//sylee140407
                if (nCC == 2) {
                    Sub71.AOnReadV1I1(7);
                }
                else {
                    Sub71.AOnReadV1I1(nVRel);
                }

                if (Sub71.Y1 < 0.0000001) {
                    Sub71.Y1 = 0.0000001;
                }

                if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411                   
                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                    }
                    else if (nIR == 5) {  //SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                    }
                    else if (nIR == 5) { //sylee121115
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                    }
                }
                else {

                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                    }
                    else if (nIR == 5) {  //SYLEE150904 //ACE400
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                    }
                }


                if (nPass == 2) {
                    Sub71.R1 = 0.0;//allpass
                }

                if (Sub71.R1 > nProRv1) {////sylee140407                
                    if (nLoop2 < 500) {//sylee140407//sylee170529-1 100->500
                        tStart12 = Get_uSecond1();//uS 
                        tStart13 = (tStart12 - tStart11);

                        if (tStart13 < nDelay22) {  //sylee150804-1   
                            goto Task500;//sylee140407
                        }
                    }
                }

                if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                    Sub71.R1 = 9999999;
                }
                if (Sub71.Y1 < nISet * 0.7) {//sylee211009
                    Sub71.R1 = 9999999;
                }

                if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                    Sub71.R1 = 9999999;
                }

                //  10v high R   

                if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030
                    if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                        Sub71.R1 = 9999999;
                    }
                    if (nVSet == 10) {  //sylee140911                          
                        if (Sub71.X1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                            Sub71.R1 = 9999999;
                        }
                        if (Sub71.X1 < nVBSetPercentLow) {//sylee120914  //VC   VB 1%
                            Sub71.R1 = 9999999;
                        }
                    }
                }


                if (nPass == 2) {
                    Sub71.R1 = 0.0;//allpass
                }


                //SYLEE191126   if( nCycleRunFlag==2  || nAutoSelf_OPen1_Run_Flag==1 ){ //sylee130925     //SYLEE140824
                if (nAutoSelf_OPen1_Run_Flag == 1) { //SYLEE191126
                    if (Sub71.R1 < nProRv1) {//pass 
                        Sub71.R1 = nProRv1 + 1;
                    }
                    else {
                        Sub71.R1 = 0.0;
                    }
                }


                if (i > 1)
                {
                    nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin; //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000
                    if (nPinA != nOldPin1) {
                        nOldPin1Flag = 0;//sylee140222
                    }
                    else {
                        nOldPin1Flag = 1;//sylee140222
                    }
                }
                else {
                    nOldPin1Flag = 0;
                }

                if ((nOldPin1Flag == 1) && (Sub71.R1 <= nProRv1) && (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)) {// //sylee150506
                    Sub71.OnPinResetVB();
                    nSelectFlag1 = 1;  //sylee151203
                }
                else {
                    Sub71.OnPinAllReset1(); ///PIN ALL RESET
                    nSelectFlag1 = 0;  //sylee151203
                }

                nReCo1_Old = nReCo1;//sylee150527            


                //sylee160801-3 if(nOpenFail1[ip]<100){//sylee150604   //SYLEE160730  100
                if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//sy //SYLEE170807-2 100->(SysInfo05.m_nConEr+1) 
                    nRetrySet2 = 3; //sylee150604  //SYLEE160730  3
                }
                else {
                    nRetrySet2 = 1; //sylee150604  //SYLEE160730   1
                }


                if (Sub71.R1 <= nProRv1)//pass   //sylee160527-1
                {
                    if (nPosS1 < nPosE1) {//sylee180219-1-FakeOpen  nPinA nPinA

                        nPassCo4++;

                        //sylee180219-5_FakeOpen    if((nPassCo4==1)&&(i!=1)){      
                        if ((nPassCo4 == 1) && (i != nPosS1)) {  //sylee180219-5_FakeOpen     
                            //sylee180219-5_FakeOpen    nBDLData2Op[2][ip][nPosS1][0]=3;     //sylee180219-1-FakeOpen  nPinA nPinA
                            if (nOpen2_co1 < 50) {  //sylee180219-1-FakeOpen  nPinA nPinA
                                nOpen2_co1++;
                                nOpen2Li1[ip][0][0] = nOpen2_co1;

                                nPinB3 = (*g_pvBDLData2Op[dutId][ip])[nPosS1].wFirstPin; //SYLEE180810-1-DUT16    //son190704-4WDUT16 //son200420-4WNET10000
                                nOpen2Li1[ip][nOpen2_co1][0] = nPinB3;//master pin
                                nOpen2Li1[ip][nOpen2_co1][1] = nPinA;// slave pin
                            }

                        }

                    }  //FakeOpen End
                    nReCo1 = 0;//sylee150422

                    nBDLData2Op_Cur[ip][i] = 1;// current pass open net //sylee160211-1   //sylee160308-1
                    nBDLData2Op_Old[ip][i] = 1;// old pass open net //sylee160211-1   //sylee160308-1
                    nBDLData2Op_Po[nPinA] = 1;//sylee160211-1   //sylee160308-1
                    nBDLData2Op_Po[nPinB] = 1;//sylee160211-1    //sylee160308-1
                    nBDLData2Op_Po_old[nPinA] = 1;//sylee160616-1   //sylee160628-1 add
                    nBDLData2Op_Po_old[nPinB] = 1;//sylee160616-1  //sylee160628-1 add

                }
                else  //fail //SYLEE20120117//sylee160527-1
                {
                    nReCo1++;
                    if (nReCo1 < nRetrySet2) {  //sylee150604

                        //SYLEE160731-3  if(nOpenFail1[ip]<=3){//sylee150804-1  //sylee151207
                        if (nOpenFail_Co1[ip] <= 3) {//sylee160731-3
                            Sub71.Delay_100ns(300);     //sylee140823
                        }
                        goto  Task1;
                    }

                    nOpenFail_Co1[ip]++;//SYLEE160731-3
                    nFailPiece[ip][nPStep1]++;////PIECE  error count    //SYLEE160731-3  IMPORT
                    nReCo1 = 0;
                } //sylee160527-1

            }////for END      for( i=1; i<=nRCount ; i++){ //SYLEE20111212


        }//end of for( int k11=1; k11<=nRCount;k11++){ //sylee180131-1    //SYLEE180219-1-FakeOpen<=====


    }//ip


    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//sylee160731-3   IMPORT


    //###################################################################################################

    //second



    nReCo1_Old = 0;//sylee150527

    for (ip = 1; ip <= ipEnd; ip++)  //sylee121128 
    {

        //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS  //SYLEE180714        //son220624
            if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <====//sylee160203-ITS     //son220624
                continue;
            }
        }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
        //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 Resheet 의미없음
        if (nReSheetFlag1 == 1) { //sylee131127//resheet
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {    //son PASS
                continue;
            }
        }
#endif  //son220803 end

        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                  //sylee150527-2   nProOneP_RunFlag1=0;//SYLEE131221
                continue;
            }
        }

        if (gRun05.m_nReCh > 0) {//sylee121129 
            if (nReFlagOpenOld[ip] == 1) { //SYLEE121129  2=OPEN
                continue;
            }
        }

        nRCount = (g_pvBDLData2Op[dutId][ip]->size() - 1); //SYLEE150817 //SYLEE180810-1-DUT16   
                                                        //son190704-4WDUT16 //son200420-4WNET10000
        nRCountToTal = nRCountToTal + nRCount;//sylee150213
        OpenErrC = 0;
        nOldPin1Flag = 0;//sylee140222
        nSelectFlag1 = 0;  //sylee151203

        //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        //sylee180131-1    //SYLEE180207-1-FakeOpen start
        nPosS1 = nPosE1 = nOpen2_co1 = 0;//sylee180131-1  

        for (int k11 = 1; k11 <= nRCount; k11++)
        {

            if (k11 == 1) { nPosS1 = 1; }
            if (k11 <= nPosE1) { continue; }
            if (k11 > nPosS1) { nPosS1 = k11; }
            if (k11 < nPosS1) { k11 = nPosS1; }
            nPosE1 = nPosS1;

            for (int k12 = nPosS1; k12 < nRCount; k12++)
            {
                t1 = (*g_pvBDLData2Op[dutId][ip])[k12].wPin;   //SYLEE180810-1-DUT16  //son190704-4WDUT16 //son200420-4WNET10000
                t2 = (*g_pvBDLData2Op[dutId][ip])[k12 + 1].wFirstPin;               //son200420-4WNET10000

                if (t1 == t2) {
                    nPosE1 = k12 + 1;
                }
                else {
                    break;
                }
            }
            nPassCo1 = nPassCo2 = nPassCo4 = 0;
            for (int k13 = nPosS1; k13 <= nPosE1; k13++) {
                if (nBDLData2Op_Cur[ip][k13] == 1) {
                    if (k13 == nPosS1) {
                        nPassCo1++; // first pass
                    }
                    nPassCo2++; //pass count
                }
            }

            nPassCo3 = nPosE1 - nPosS1 + 1; // test count
            if (nPassCo3 == nPassCo2) {
                k11 = nPosS1 + 1;//sylee180219-1
                continue;
            }


            if ((nPassCo1 == 0) && (nPassCo2 > 0)) {//sylee180214-FakeOpen
                for (int i5 = nPosS1; i5 <= nPosE1; i5++) {//sylee180214-FakeOpen
                    if ((nBDLData2Op_Old[ip][i5] == 1) && (nBDLData2Op_Cur[ip][i5] != 1)) {
                        nBDLData2Op_Cur[i5][i] = 1;
                    }
                }
            }

            if (nFailPiece[ip][nPStep1] >= (SysInfo05.m_nConEr)) { //sylee180226-2-import 
                k11 = nRCount + 1;//sylee180226-2-import
                break;
            }

            for (i = nPosS1; i <= nPosE1; i++) //sylee180131-1    //SYLEE180207-1-FakeOpen  end
            {
                //sylee180131-1 //SYLEE180207-1-FakeOpen  for( i=1; i<=nRCount; i++){ //SYLEE20111212
                //sylee180214-2-FakeOpen    if((nPassCo1==1) || (nPassCo4>0) ){//sylee180131-1   //SYLEE180207-1-FakeOpen
                if (nPassCo1 == 1) {  //sylee180214-2-FakeOpen  //Master Pin Cur Pass
                    if (nBDLData2Op_Cur[ip][i] == 1 || nBDLData2Op_Old[ip][i] == 1) {//sylee180214-1-FakeOpen
                        continue;
                    }
                }
                else {  //Master Pin Cur Fail  //sylee180214-1-FakeOpen
                    if (nPassCo2 > 0) {  //Slave Pin Cur Pass  //sylee180214-1-FakeOpen  //sylee180219-3-FakeOpen

                        if ((i == nPosS1) && (nBDLData2Op_Old[ip][i] == 1)) {//sylee180214-2-FakeOpen  //<============
                            continue;//sylee180214-2-FakeOpen  //<============
                        }//sylee180214-2-FakeOpen  //<============

                        if (nBDLData2Op_Cur[ip][i] == 1 || nBDLData2Op_Old[ip][i] == 1) {//sylee180214-2-FakeOpen  //<============  ??????
                            continue;  //<============  ?????????
                        }  //<============

                    }  //sylee180214-1-FakeOpen
                }  //sylee180214-1-FakeOpen

                if (nFailPiece[ip][nPStep1] >= (SysInfo05.m_nConEr)) { //sylee171127-1   //sylee180214-1-FakeOpen Move                                
                    i = nPosE1 + 1;//sylee180226-2-import
                    break;//sylee171127-1
                }  //sylee171127-1


                if (SysSet211.m_nSet15 == 1) {
                    if (nOpenFail_Co1[ip] > nRetrySet10) {//SYLEE161018-1-test
                        continue;
                    }
                }



            Task11:

                nPinA = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin;//PIECE  pin no  //SYLEE180207-1-FakeOpen //son190704-4WDUT16 //son200420-4WNET10000

                t2 = nPinToPiece(nPinA + 1);//sylee180131-1   //SYLEE180207-1-FakeOpen      //son190704-4WDUT16
                t3 = nFailPiece[ip][nPStep1];////PIECE  error count   
                if (t3 >= SysInfo05.m_nConEr) {    //sylee20120410  ///block 단위 임 ==> piece 단위로 검사 해야 한다.                                       
                    if (nAutoReTest[nBlockCountP] != gRun05.m_nReCh) { //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP  //SYLEE130221
                        break;
                    } //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP
                    if (nFlagAutoPress1 == 2) {//sylee150604
                        break;
                    }
                }

                nPinB = (*g_pvBDLData2Op[dutId][ip])[i].wPin; //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000


                if (i > 1)
                {

                    nOldPin1 = (*g_pvBDLData2Op[dutId][ip])[i - 1].wFirstPin; //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000

                    if ((nPinA == nOldPin1) && (nReCo1_Old == 0 || nReCo1_Old == 2 || nReCo1_Old == 4 || nReCo1_Old == 6)) {//sylee150527
                        nOldPin1Flag = 1;//sylee150422  
                    }
                    else {
                        nOldPin1Flag = 0;//sylee150422   
                    }
                }
                else {
                    nOldPin1Flag = 0;
                }

                //sylee150422 nOldPin1Flag=0; 

                if (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)  //sylee140926 
                {

                    Sub71.AOnPinSet1(2, nPinB, 1); //vB 

                    nPinSetSkipVbCnt++; //sylee151005 //ACE400           	//son230127        
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                    }

                    if (nOldPin1Flag == 0 || nSelectFlag1 != 1) {   //sylee151203
                        Sub71.AOnPinSet1(2, nPinA, 2);  //vc 

                        nPinSetSkipVcCnt++; //sylee151005 //ACE400         	//son230127          
                        if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                            nPinSetSkipVc = 3; //sylee151005 //ACE400			//son230127
                        }
                    }

                }
                else {   //sylee140926
                    Sub71.AOnPinSet1(2, nPinA, 1);   //vb   //sylee140926
                    nPinSetSkipVbCnt++; //sylee151005 //ACE400               //son230127   	 
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400			//son230127
                    }
                    Sub71.AOnPinSet1(2, nPinB, 2); //vc     //sylee140926   

                    nPinSetSkipVcCnt++; //sylee151005 //ACE400              //son230127 	    
                    if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){	//son230127
                        nPinSetSkipVc = 3; //sylee151005 //ACE400			//son230127
                    }

                }   //sylee140926

                Sub71.Delay_100ns(500); //sylee150624    //sylee151203  500       //sylee160703    300->500

                int nLoop2;//sylee140407
                nLoop2 = 0;//sylee140407

                tStart11 = Get_uSecond1();//uS 

                if (nOpenFail_Co1[ip] < (SysInfo05.m_nConEr + 1)) {//sylee160801-3     //SYLEE170807-2 50->(SysInfo05.m_nConEr+1) 
                    nRetrySet = 3;  //sylee160803  5->3
                    nDelay22 = nDelay20 * 2;//sylee150804-1     //sylee160703-1
                }
                else {
                    nRetrySet = 1;
                    nDelay22 = nDelay21;//sylee150804-1
                }
                //sylee160801-3  nRetrySet=1;  //sylee160703-1

            Task511://sylee140407

                nLoop2++;//sylee140407
                if (nCC == 2) {
                    Sub71.AOnReadV1I1(7);
                }
                else {
                    Sub71.AOnReadV1I1(nVRel);
                }


                if (Sub71.Y1 < 0.1) {
                    Sub71.Y1 = 0.1;//sylee161121-1
                }

                if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411                   
                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                    }
                    else if (nIR == 5) {  //SYLEE150904 //ACE400
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                    }
                    else if (nIR == 5) { //sylee121115
                        Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                    }
                }
                else {
                    if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                    }
                    else if (nIR == 5) {  //SYLEE150904 //ACE400
                        Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                    }
                }


                if (nPass == 2) {
                    Sub71.R1 = 0.0;//allpass
                }

                if (Sub71.R1 > nProRv1) {////sylee140407
                    if (nLoop2 < 500) {//sylee140407  //sylee170529  30->500
                        tStart12 = Get_uSecond1();//uS 
                        tStart13 = (tStart12 - tStart11);
                        if (tStart13 < nDelay22) {  //sylee150804-1   //sylee151207   
                            goto Task511;//sylee140407
                        }
                    }
                }

                if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                    Sub71.R1 = 9999999;
                }

                if (Sub71.Y1 < nISet * 0.7) {//sylee211009
                    Sub71.R1 = 9999999;
                }

                if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                    Sub71.R1 = 9999999;
                }

                //  10v high R   

                if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030

                    if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                        Sub71.R1 = 9999999;
                    }
                    if (nVSet == 10) {  //sylee140911                          
                        if (Sub71.X1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                            Sub71.R1 = 9999999;
                        }
                        if (Sub71.X1 < nVBSetPercentLow) {//sylee120914  //VC   VB 1%
                            Sub71.R1 = 9999999;
                        }
                    }
                }



                if (nPass == 2) {
                    Sub71.R1 = 0.0;//allpass
                }

                if (nCycleRunFlag == 2 || nAutoSelf_OPen1_Run_Flag == 1) { //sylee130925     //SYLEE140824
                    if (Sub71.R1 < nProRv1) {//pass 
                        Sub71.R1 = nProRv1 + 1;
                    }
                    else {
                        Sub71.R1 = 0.0;
                    }
                }

                if (i > 1) {


                    if (nPinA != nOldPin1) {
                        nOldPin1Flag = 0;//sylee140222
                    }
                    else {
                        nOldPin1Flag = 1;//sylee140222
                    }
                }
                else {
                    nOldPin1Flag = 0;
                }

                if ((nOldPin1Flag == 1) && (Sub71.R1 <= nProRv1) && (nReCo1 == 0 || nReCo1 == 2 || nReCo1 == 4 || nReCo1 == 6)) {// //sylee150506
                    Sub71.OnPinResetVB();
                    nSelectFlag1 = 1;  //sylee151203
                }
                else {
                    Sub71.OnPinAllReset1(); ///PIN ALL RESET
                    nSelectFlag1 = 0;  //sylee151203
                }

                nReCo1_Old = nReCo1;//sylee150527


                if (nPass == 2) {
                    Sub71.R1 = 0.0;//allpass
                }

                //sylee160801-3 if(nOpenFail1[ip]>5){//sylee150604
                if (nOpenFail1[ip] > 20) {//sylee150604  //sylee160801-3  //sylee171127-1  50->20
                    nRetrySet2 = 1; //sylee150604
                }
                else {
                    nRetrySet2 = 3; //sylee150604  //SYLEE160730  3
                    if ((SysInfo05.m_nConEr > 20) && (nOpenFail_Co1[ip] > 20)) {//sylee180131-1    //SYLEE180207-1-FakeOpen
                        nRetrySet2 = 1;
                    }  //SYLEE180207-1-FakeOpen
                }


                if (Sub71.R1 <= nProRv1) {//pass  
                    nReCo1 = 0;//sylee150422
                }
                else  //fail //SYLEE20120117
                {

                    nReCo1++;
                    if (nReCo1 < nRetrySet2) {  //sylee150604      
                        if (nOpenFail1[ip] <= (SysInfo05.m_nConEr + 1)) {//sylee150804-1    //SYLEE170807-2  50->(SysInfo05.m_nConEr+1) 
                            Sub71.Delay_100ns(300);     //sylee140823
                        }
                        goto  Task11;
                    }
                    nReCo1 = 0;
                    nOpenFail_Co1[ip]++;//sylee160731-3   //sylee160801-3


                    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) { //SYLEE130109-1   //OPENPIN->SHORTCHECK      //SYLEE130221                          
                    
                        if (t3 >= SysInfo05.m_nConEr) {
                            continue;
                        }
                    }

                    //////////////////////////////////////////////////////////////////////

                    if (nFailL1CoOpen < 3000) {//array size nFailL1

                        if (nProOneP_RunFlag1 == 1) {//sylee131221
                            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {
                                if (gRun05.m_nReCh != 0) {//sylee150618
                                    if (nAutoReTest[nBlockCountP] > 1) {//SYLEE181031-1
                                        nProOneP_RunFlag1 = 0;
                                    }
                                }
                            }
                        }
                        nFailCount[nMod1]++;
                        nFailL1CoOpen++;
                        nFailL1Open[nFailL1CoOpen][1] = nFailL1CoOpen;//open 1
                        nFailL1Open[nFailL1CoOpen][F_BLOCK] = nBlockCountP;//block //son220419_4 2:F_BLOCK

                   
                        t1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//PIECE  pin no  //SYLEE180810-1-DUT16   //son190704-4WDUT16 //son200420-4WNET10000


                        nOpenFail1[ip]++;//sylee20120921//100=piecemax
                        nReFlagOpenCur[ip] = 2; //SYLEE121129  2=OPEN 불량 piece로 표시, (retest 대상 piece가 되도록) 
                        nFailPiece[ip][nPStep1]++;////PIECE  error count                    
                        if (nFailPiece[ip][nPStep1] >= SysInfo05.m_nConEr) {
                            nOpenMoreThanFlag = 1;//sylee12112
                            if (nOldPin1Flag == 1) {//sylee140222                       
                                Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                            }
                        }


                        nFailL1Open[nFailL1CoOpen][F_PIECE] = ip;////PIECE  no    //son220419_4 3:F_PIECE

                        int a1, a2;
             
                        a1 = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin + 1;//pin  //SYLEE180810-1-DUT16 //son190704-4WDUT16 //son200420-4WNET10000
                        a2 = (*g_pvBDLData2Op[dutId][ip])[i].wPin + 1;//pin     //son200420-4WNET10000


                        if (a1 < a2) {
                            nFailL1Open[nFailL1CoOpen][F_VB_PIN] = a1;  //son220419_4 4:F_VB_PIN
                            nFailL1Open[nFailL1CoOpen][F_VC_PIN] = a2;  //son220419_4 5:F_VC_PIN
                        }
                        else {
                            nFailL1Open[nFailL1CoOpen][F_VB_PIN] = a2;  //son220419_4 4:F_VB_PIN
                            nFailL1Open[nFailL1CoOpen][F_VC_PIN] = a1;  //son220419_4 5:F_VC_PIN
                        }


                        if (nErrPin1O2[a1] == 0) {//sylee170810-1
                            if (nErrPin1O[a1] < 100000) {
                                nErrPin1O[a1]++;//sylee170810-1
                                nErrPin1O2[a1] = 1;
                            }
                        }
                        if (a1 != a2) {//sylee170810-1
                            if (nErrPin1O2[a2] == 0) {//sylee170810-1
                                if (nErrPin1O[a2] < 100000) {
                                    nErrPin1O[a2]++;//sylee170810-1
                                    nErrPin1O2[a2] = 1;
                                }
                            }
                        }


                        //son220419_4 nFailL1Open[nFailL1CoOpen][] 관련 상수 enum으로 변경 
                        nFailL1Open[nFailL1CoOpen][F_RAW_R] = Sub71.R1;//Sub71.R1               //son220419_2  6:F_RAW_R
                        nFailL1Open[nFailL1CoOpen][F_PRORV_RAW_R] = nProRv1;//nProRv1 판정 rawR  //son220419_2 17:F_PRORV_RAW_R 
                        nFailL1Open[nFailL1CoOpen][F_PRORV_REAL_R] = nProRv1Real;                //son220419_2  7:F_PRORV_REAL_R
                        nFailL1Open[nFailL1CoOpen][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];     //son220419_2  8:F_PRO_STEP_REAL_R
                        nFailL1Open[nFailL1CoOpen][F_VSET] = nVSet;                              //son220419_2  9:F_VSET
                        nFailL1Open[nFailL1CoOpen][F_ISET] = nISet;                              //son220419_2 10:F_ISET
                        nFailL1Open[nFailL1CoOpen][F_MODE1] = m_nMode1;                          //son220419_2 11:F_MODE1
                        nFailL1Open[nFailL1CoOpen][F_VB] = Sub71.V1;//VB                         //son220419_2 12:F_VB
                        nFailL1Open[nFailL1CoOpen][F_VC] = Sub71.X1;//VC                         //son220419_2 13:F_VC
                        nFailL1Open[nFailL1CoOpen][F_I] = Sub71.Y1;//I                           //son220419_2 14:F_I
                        nFailL1Open[nFailL1CoOpen][F_TEST_TYPE] = nMod1;//I  //open ushort short hr hv   4w                         
                                                                                               //son220419_2 16:F_TEST_TYPE

                        //  Sub71.Delay_100ns(10000); //sylee131105            

                    }
                    else {//sylee130225joytech

                        nFailCount[nMod1]++;//sylee130225joytech         
                        nFailL1CoOpen++;//sylee130225joytech
                        nOpenFail1[ip]++;////sylee130225joytech
                        nReFlagOpenCur[ip] = 2; ////sylee130225joytech    //son OPEN 불량 piece로 표시. retest대상 piece가 됨
                        nFailPiece[ip][nPStep1]++;////sylee130225joytech

                    }


                }//}else{//fail  //SYLEE20120117

            }////for END      for( i=1; i<=nRCount ; i++){ //SYLEE20111212


        }//end of for( int k11=1; k11<=nRCount;k11++){ //sylee180131-1    //SYLEE180207-1-FakeOpen<=====


    //####################################################################################################


        if (nRCount > 0) {
            if (nReFlagOpenCur[ip] != 2) { //SYLEE121129 pass,    2=OPEN
                nReFlagOpenCur[ip] = 1;    //son PASS piece로 표시

                int tmp1;
                tmp1 = nBlockPieceNo1[nBlockCountP][ip];

                if (GraphDisplay1[tmp1] == 0) {
                    GraphDisplay1[tmp1] = 1;
                }
            }
        }

        //-------------------------------------------------------
        //son OpenErrFlag, OpenErrList(first Pin 위치 정보)  생성
        //-------------------------------------------------------
        //   nOpenErrData[piece][err][]를 조사해서 같은 대표핀의 err를 찾기 쉽도록 nOpenErrList[대표핀][]으로 정리한다. 
        //   nOpenErrData는 같은 대표핀이 모여있으므로 nOpenErrList는 시작과 끝 위치만 표시함
        if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) //SYLEE130109-1  //sylee130221
        {

            int firstPin;

            if (nOpenErrData[ip][0][1] > 0)
            {
                nOpenErrFlag[ip] = 1;
                for (int err = 1; err <= nOpenErrData[ip][0][1]; err++)
                {
                    //nOpenErrList[ip][5000][3]=

                    //son 첫번째 err 저장이라면 start와 end에 모두 현재  nOpenErrData[piece] 에서의 OpenErr 위치를 저장
                    if (err == 1) {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }

                    //son  대표핀 pinNo가 앞의 대표핀 pinNo와 다른 경우 
                    //  => 다른 Net이므로  대표핀 No를 바꿔서 다음번 nOpenErrList[firstPin]을 처리한다.
                    if (firstPin != nOpenErrData[ip][err][OP_TO_FIRST_PIN]) {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }
                    //son 앞의 대표핀과 같은 대표핀이면 end위치만 갱신.
                    else {
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }
                    //son 마지막 err 이면 end만 write
                    if (err == nOpenErrData[ip][0][1]) {
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }
                }
            }
        }

    }//ip



    //=========================================================================================
    //sylee131221  one-piece
    //son 전체를 1 piece로 간주하고 초기 모델 등록 기능을 수행할 때 사용한다.
    //    일반 양산시에 사용하는 것이 아님.
    int nTempOpenCo1;

    nTempOpenCo1 = nProOneP_Open1[0][0];// total short list

    nRetrySet2 = 1; //sylee150604


    if ((nProOneP_Flag1 == 3) && (nProOneP_RunFlag1 == 1) && (nTempOpenCo1 > 0)) {

        for (int k1 = 1; k1 <= nTempOpenCo1; k1++) {

            nReCo1 = 0;

        Task501:

            nPinA = nProOneP_Open1[k1][0];
            nPinB = nProOneP_Open1[k1][1];

            Sub71.AOnPinSet1(2, nPinB, 1); //vc  
            Sub71.AOnPinSet1(2, nPinA, 2);

            //sylee150618   Sub71.Delay_100ns(nDelay10); 
            Sub71.Delay_100ns(300); //sylee150618    
            Sub71.AOnReadV1I1(nVRel);  //sylee131011  
            Sub71.OnPinAllReset1();

            if (nFil == 3) {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 3 || nIR == 4) {
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                }
                else if (nIR == 5) { //sylee121115
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;
                }
            }

            if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                Sub71.R1 = 9999999;
            }

            if (Sub71.Y1 < nISet * 0.7) {//sylee211009
                Sub71.R1 = 9999999;
            }

            nReCo1++;

            if (Sub71.R1 > nProRv1) {//fail
                if (nReCo1 < nRetrySet2) {   //sylee150604                                        
                    goto  Task501;
                }

                if (gRun05.m_nReCh != 0) { //SYLEE150618
                    if (nAutoReTest[nBlockCountP] > 1) {//SYLEE181031-1
                        nProOneP_RunFlag1 = 0;
                    }
                }
                break;
            }
        }

    }//end of if((nProOneP_Flag1==3)&&(nProOneP_RunFlag1==1)) {


  
    tStart122 = GetuSecond();//TESTDEBUG
    tStart123 = (tStart122 - tStart121);//TESTDEBUG
    tStart1001 = GetuSecond();//SYLEE150509

 
Task201://sylee170816-1


    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018
////////////////////////////////////////////////////////
    Sub71.FilterSet(0);//sylee130704             
    Sub71.I_Filter(0);
    Sub71.ARunoff1();
    Sub71.AOnRelayOffSel(nVRel);  // lv relay off    
    Sub71.AOnReadV1Enable1(5); //sylee130711   lv  hv sen all off

 
    //  if(nFlagInsul1==0){//sylee170816
    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        SysInfo05.m_nConEr = nAutoPress_nConEr_old1;//sylee150213 
        if (nRCountToTal > 0) {
            nErrorRateToTalPin = (double)((double)nFailL1CoOpen / (double)nRCountToTal);//sylee150213
        }
        else {
            nErrorRateToTalPin = 0.0;//sylee150213
        }

    }
 
    tStart1001 = GetuSecond();//SYLEE150701

    nPinSetSkipVb = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400	//son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400		//son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400	//son230127
//sylee150421 nDebugFileLog1();//SYLEE150421-DEBUG

    Sub71.OnPinResetInit();//sylee151221   //ACE400

    return 1;

}

 
//=============================================== //sylee200320-4WCVMODE
//son 4WNet을 R 값 기준으로 값이 큰 것부터 sorting한 데이터를  n4WSort1[net]를  따로 만들어 둔다.
int CChildView7::ARun201_4w_Net_Sort1() //sylee191122-1  //sylee200515-patch
{
    int nEnd, nPo1, net;
    float R, Rmin1;
    //son231107 short S[MAX_4W_NET +1];
    short S[MAX_4W_NET +1];	//son231107 Def_4WMax1 -> MAX_4W_NET +1

    ::ZeroMemory(&n4WSort1, sizeof(n4WSort1));
    ::ZeroMemory(&S, sizeof(S));

    int dutIdx = get4wDutIdx(); //sylee200515-patch
    nEnd = (int)g_s4WNet[dutIdx].wCount;//sylee150813-1   //sylee200515-patch
    if (nEnd <= 0) { 
		return 0; 
	}
    if (nEnd >= (MAX_4W_NET +1)) { 	//son231107 Def_4WMax1 -> MAX_4W_NET +1
		return 0; 
	}	

    for (int j = 1; j <= nEnd; j++)
    {
        Rmin1 = 0;
        nPo1 = 0;
        for (net = 1; net <= nEnd; net++)
        {
            //son 이미 max 값으로 뽑혀 갔으므로 넘어간다.
            if (S[net] == 1) {
                continue;
            }
            R = (float)g_s4WNet[dutIdx].saData[net - 1].dRefAvg;        //son211005 dSetAvg -> dRefAvg
            if (nPo1 == 0) {
                Rmin1 = R;
                nPo1 = net;
                continue;
            }
            //son 이전 R 보다 큰 R이라면 nPos1으로 지정한다.
            if (Rmin1 < R) { //sylee200221
                Rmin1 = R;
                nPo1 = net;   //현재까지의 max 값 위치
            }
        }
        if (nPo1 > 0) {
            n4WSort1[j] = nPo1;
            S[nPo1] = 1;      //son max 값으로 뽑혀간 위치라고 표시
        }
    }

    return 1;
}


int CChildView7::ARun201_4w_3(int nPStep1) //SYLEE200515-PATCH  
{
	int nRet;

	#ifdef __NEW_4W_230420  //SYLEE230420
		nRet= ARun201_4W_New_230420( nPStep1);  //SYLEE230420
	#else//SYLEE230420
		nRet= ARun201_4W_Old_230420( nPStep1); //SYLEE230420
	#endif//SYLEE230420
	 
	return nRet;
}


int CChildView7::ARun201_4W_New_230420(int nPStep1) //SYLEE230420
{

    CString  str, str1, strfName, strfName1, str5;
    __int64   tStart11, tStart12, tStart13;  //sylee150710  

    int m_nMode1, n4Wire, nRet1, nDelay10, nEnd, Lo1, nLoop, nCount;
    int j, k, ipEnd, t1, t2, nFil, nIFilter, Kcount;// nW4FailOut1;
    int nErrorCount, nMode, nIGain, n4wGain;//SYLEE150123  
    int nPassCo1, nPassCo2, nRetrySet, nRetryCo1, nFlag_Fail_Full;//sylee160528-5
    int nEndStep1, n4W_Retry1, n4W_Retry2, n4W_Retry5, n4W_Retry6, n4WFailPieceCo1, nZeroCo1, nZeroCo2;//sylee180520-1
    int n4W_Retry3, n4W_Retry4, nRetryEndSet;
    int nPassCountSet1, nR101Po1, nRetryCount1, dR30Co1, nNet200, nS1Po1, nS1Po2;//sylee221220 
    int net, dutIdx, n2WCheck, nNGRetryCo1;//sylee201012
    int dR5Po1, dR5Po2, nRetry7, nRetry8, nRetry9, n4W_RetryFlag1, nFullDelayFlag1;//sylee221120-1 

    short n4W_RunStep, nRetryCount10;//sylee221222;

    double dVbR1, dVbR2, nISet, nISetPercentHigh, nISetPercentLow, nVBSetPercentHigh, nVBSetPercentLow;//sylee120914
    double  n4wLowRetryPer1, dRoffset1, dRoffset2, nOld1_R1, nOld1_R1_Rate1, dMinR1, dR4w1_old1;//sylee201012; //sylee191025-1
    double dPerRate0, dPerRate1, dPerRate2;//sylee210417
    double dSigmaSet, dMin1, dMax1, nS1Max1, nS1Min1, nS1Sum1, nS1Max2;//sylee221208-1 
    double dRef4wR1, dDiffR1, dDiffR2, d4W_RoffSet1, d4W_RoffSet2, d4W_Percent1, d4W_Percent5;
    double d4W_Noise1, d4W_Noise2, d4W_Noise3;
    char  fName[200], fName1[200];
    int n4WNet[MAX_4W_NET +1][NUM_4W_GRID_COL], n4WMod1[10][10]; //son231107 Def_4WMax1 -> MAX_4W_NET +1
    int dPinVC[200], dPinVB[200], nS2[201], nPinNo[5];//sylee191126   
    short nPos1[MAX_4W_NET +1];//son 0:정상, 2:4W Contact fail //sylee131112		//son231107

    short nRetryNet1[MAX_4W_NET +1];//sylee230124	//son231107
    short nFail1[MAX_4W_NET +1], nADCNg[MAX_4W_NET +1], nFail2[MAX_4W_NET +1], nFail3[MAX_4W_NET +1];//sylee210417	//son231107
    double dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200], nT[10], nData[130][15], dR30[301][2];
    double dR5[101], dR101S1[511];//,dR101S1V[511],dR101S1I[511]; //sylee221220  
    double dTemp, dTemp2, dTemp3, dTemp4, dTemp5, dLowRefRValue, dHighRefRRage, dPCBRage, dDiffCountRate1;
    int nDiffCountNet1;
    int  nPass5, nPass6, nPass7, nd4W_Data1Co1;//sylee230224
    double doldR2, dSum1, dSetR1, dSetR1Per1;
    int n4W_RunStep2, n4WnFail3Co1;
    int  n4WnFail2Co1, nModeTmp;///SYLEE221226-3 MOVE 
    double d4wR100[MAX_4W_NET +1];//sylee230307	//son231107
    int nRetryMode[10];//sylee230308
    double  dLowR10, dHighR10;//sylee230415  
	int nNgNetCo1,nNgNetOld1,nNgNetMax1;//sylee230426-1

	int nSetRetry1;//sylee230426-8


	nFlagLeakMPin1=0;  //sylee230526  //sylee230818

	if (n4w_Sample_Enable == 1) { 
	    nManual4WStartFlag1=1; 	  //sylee230426-8  
    }
	if (nManual4WStartFlag1==1) {//sylee230426-8
		nSetRetry1=4;//sylee230426-8	

		if( n4w_Sample_Enable == 1){	
		    nSetRetry1=3;  //sylee230427	 
        }
	}
	else{
		nSetRetry1=2;//sylee230426-8		
	}//sylee230426-8  
  
    if (SysSet19.m_nSet44 > 0) {
        dSetR1 = SysSet19.m_nSet44 * 0.1;
    }
    else { dSetR1 = 2; }  //sylee230225

    if (SysSet19.m_nSet45 > 0) {
        dSetR1Per1 = SysSet19.m_nSet45;
    }
    else { dSetR1Per1 = 20; }//sylee230225  


    n4W_RunStep = 0;	n4W_RunStep2 = 0;//sylee221222;  
    nRetryCount10 = 0;

    if (SysSet16.m_nSet10 > 0) {
        d4WADCSigma1 = SysSet16.m_nSet10 / 100.;
    }
    else { d4WADCSigma1 = 1.0; }

    ::ZeroMemory(&d4wI, sizeof(d4wI));
    ::ZeroMemory(&d4wV, sizeof(d4wV)); //sylee221206-2
    ::ZeroMemory(&n4WNg1, sizeof(n4WNg1)); //sylee230116-1-debug  
    ::ZeroMemory(&nRetryNet1, sizeof(nRetryNet1)); //sylee230124
    ::ZeroMemory(&d4wR100, sizeof(d4wR100)); //sylee230307

    d4wIPo1 = 0;	d4wVPo1 = 0;  d4wNet1 = 0;//sylee221206-2  
    n4W_RetryFlag1 = 0;//sylee210417

    if(SysSet13.m_nSet9 == 1) {//sylee210429      
        if ((nCycleRunFlag == 2) || (nFlagRunMode1 == 2) || (nManualStartFlag == 1)) {//syle210417   
            n4W_RetryFlag1 = 2;//sylee210417  //SYLEE210428 
            dPerRate0 = 0.2;//sylee210417
            dPerRate1 = 1.0 - dPerRate0;//sylee210417
            dPerRate2 = 1.0 + dPerRate0;//sylee210417
            ::ZeroMemory(&nFail1, sizeof(nFail1));  //sylee210417
        }         
    }
    /////////////////////////////////////////////////////////////////////////// 

    nNGRetryCo1 = 0;//sylee201012
    n2WCheck = 2;//sylee201005  2=disable 
    n4w_Measure1_Enable = 0;
    n4W_PinFastADC1 = 0;//sylee200905
    n4W_Use = 1;//sylee200612

//son231108     ::ZeroMemory(&ng4WResult_3, sizeof(ng4WResult_3)); //SYLEE200604-AUTOSAMPLING
    ::ZeroMemory(&nFail2, sizeof(nFail2));  //sylee221222
    ::ZeroMemory(&nFail3, sizeof(nFail3));  //sylee221222

    if (SysInfo05.m_n4WSet1 > 0) {//sylee200525
        if (SysInfo05.m_4W_Measure == 1) {  //sylee200222 
            n4w_Measure1_Enable = 1;
        }
    }

    dutIdx = get4wDutIdx(); //sylee200515-patch   
    d4W_RoffSet1 = 0.0;   d4W_RoffSet2 = 0.0;  d4W_Percent1 = 0.0; d4W_Percent5 = 0.0;
    if (SysSet19.m_nSet36 > 0 && SysSet19.m_nSet36 < 100) {	//not use
        d4W_Noise1 = SysSet19.m_nSet36 / 10.;
    }
    else { 
		d4W_Noise1 = 0.0; 
	}
    if (SysSet19.m_nSet37 > 0 && SysSet19.m_nSet37 < 100) {	//not use
        d4W_Noise2 = SysSet19.m_nSet37 / 10.;
    }
    else { 
		d4W_Noise2 = 0; 
	}
    if (SysSet19.m_nSet23 > 0 && SysSet19.m_nSet23 < 100) {
        d4W_Noise3 = SysSet19.m_nSet23 / 10.;
    }
    else { 
		d4W_Noise3 = 0.0; 
	}

    d4W_RoffSet2 = d4W_RoffSet1;
    if (SysSet19.m_n4WHVon == 1) {
        nFlag_4W_OUT50V = 1;//SYLEE200411
    }
    else {
        nFlag_4W_OUT50V = 0;//SYLEE200411
    }

    dMinR1 = 0.01; //sylee191025-1 dMinR1  //sylee200217-4WCVMODE  1->0.5
    dRoffset1 = 0.5;//sylee180704-5
    dRoffset2 = 1000;//sylee180705-2

    if (SysSet19.m_nSet31 < 1) {
        dRoffset1 = 0;//sylee180705-2  //offset
    }
    else if (SysSet19.m_nSet31 <= 50) {
        dRoffset1 = SysSet19.m_nSet31 / 10.;//sylee180705-2
    }
    else { 
		dRoffset1 = 0; //sylee180705-2 
	}
    if (SysSet19.m_nSet32 < 1) { 
		dRoffset2 = 10000000; //sylee180705-2
	}
    else if (SysSet19.m_nSet32 <= 100) {
        dRoffset2 = SysSet19.m_nSet32 / 10;//sylee180705-2
    }
    else { 
		dRoffset2 = 10000000; //sylee180705-2
	}
    nZeroCo2 = 0;//sylee180520-1 
    n4wLowRetryPer1 = 0.0; //sylee180213-1 
    n4WFailPieceCo1 = 0;

    for (int ip3 = 1; ip3 <= nPieceMax; ip3++) {//sylee170807-3
        if ((g_nSkipPieceFlag1 == 1) && (g_nSkipPieceInfo[ip3] == 2)) { //SYLEE180528-1-ITS  //sylee160203-ITS        //son220624
            n4WFailPieceCo1++;
        }
        else {//SYLEE180528-1-ITS //sylee160203-ITS
            if (nOpenSetFlag1 == 1) {//sylee170829-1
                if ((nReFlagOpenCur[ip3] == 2) || (nShortFail1[ip3] > 0)
                    || ((SysSet211.m_nDisable4wRetest == 1) && (n4wFail1Old[ip3] > 0))) {//SYLEE180528-1-ITS //sylee160203-ITS //son220503
                    n4WFailPieceCo1++;
                }
            }
            else {//sylee170829-1
                if ((nShortFail1[ip3] > 0)
                    || ((SysSet211.m_nDisable4wRetest == 1) && (n4wFail1Old[ip3] > 0))) {//SYLEE170808     //SYLEE180528-1-ITS //sylee160203-ITS  //son220503
                    n4WFailPieceCo1++;
                }
            }//sylee170829-1
        }//SYLEE180528-1-ITS //sylee160203-ITS
    }

    if (n4WFailPieceCo1 == nPieceMax) {//sylee170807-3
        return 1;//sylee170807-3   //sylee180202-1-import
    }
    ////////////////////////////////////////////////////////////////////
    //son  SHORT 검사관련 BDL Data에 따라 핀설정을 한다.
    int nRCount;

    Sub71.OnPinAllReset1();//sylee190207-1

    //son nRCount :  Short 개수 
    if ((nMulNetFlag > 1) && (nMultyNetTotal >= nMulNetFlag)) {//sylee190207-1
        nRCount = nBDLData3[nMulNetFlag][0][1];
    }
    else {//SYLEE150817
        nRCount = nBDLData3[1][0][1];
    }

    Sub71.OnDisCharge1(); //sylee170725-3 
    Sub71.OnPinAllReset1();//sylee190207-1
    nEndStep1 = 4;//sylee160611-1  //SYLEE201030  5 -> 4

    if (SysSet211.m_nDisable4wRetest == 1) {//sylee160602-5  //4w recheck disable   (0:enable, 1:disable)   //son220503
        n4wFail1OldCo1 = 0;//sylee160602-5
        for (int w2 = 1; w2 <= nPieceMax; w2++) {
            if (n4wFail1Old[w2] > 0) {
                n4wFail1OldCo1++;//sylee180202-1-import
            }
        }
        if (nAutoReTest[nBlockCountP] > 0) {
            if (n4wFail1OldCo1 == nPieceMax) {
                return 1;
            }
        }
    }

    //son Manual -> Set1 -> Disable 4w Retest 
    if ((SysSet211.m_nDisable4wRetest == 1) || (nManualStartFlag == 1)) {  // 4w recheck disable    manual  //sylee160604-1  //son220503
        nFlag_Fail_Full = 1;//sylee160528-5
    }
    else {
        nFlag_Fail_Full = 0;//sylee160528-  
        if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {//last recheck
            nFlag_Fail_Full = 1;
        }
    }

    nFlag_Fail_Full = 1;//sylee230223-5

    ::ZeroMemory(&ng4WResult_2, sizeof(ng4WResult_2)); //ng4WResult_2==3   FAIL R DETECT
        

	nPinSetSkipVb=0;	
	nPinSetSkipVbCnt=0;	
	nPinSetSkipVc=0;	
	nPinSetSkipVcCnt=0;//sylee230420

    nRetrySet = 1;//sylee150721 
    nRetryCo1 = 0;//sylee150721

    nVRel = (int)dRec[171][2];//SYLEE150210 //ACE380    FAIL =0  , PASS=1

    Sub71.AVB_CheckOut1(nVRel, 1);//SYLEE150210 //ACE380    FAIL =0  , PASS=1

    ///////////////////////////////////////////////////////////////////////////
	//변수 초기화 
    ::ZeroMemory(&nData, sizeof(nData));       ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));         ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));           ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));       ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));     ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));     ::ZeroMemory(&n4WNet, sizeof(n4WNet));
    ::ZeroMemory(&n4WMod1, sizeof(n4WMod1));
    ::ZeroMemory(&n4WData1, sizeof(n4WData1)); ::ZeroMemory(&n4WData1v, sizeof(n4WData1v));//sylee200415
    ::ZeroMemory(&n4WData1i, sizeof(n4WData1i));//sylee200415
    ::ZeroMemory(&nPos1, sizeof(nPos1));//sylee131112
    ::ZeroMemory(&nADCNg, sizeof(nADCNg));//sylee221220


    //son 4w recheck (0:enable, 1: disable)
    if ((SysSet211.m_nDisable4wRetest != 1) || ((SysSet211.m_nDisable4wRetest == 1) && (nAutoReTest[nBlockCountP] == 0))) {//sylee180521-1 //son220503
        ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));
    }

    if ((nAutoReTest[nBlockCountP] != 0) && (SysSet211.m_nDisable4wRetest != 1)) {//sylee180521-1  //son220503
        ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee130122//100=piecemax 
        ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee130122//100=piecemax
    }

    nStop = 0;    n4Wire = 0;    nErrorCount = 0;//4WSETUP  //nW4FailOut1 = 0; 


    if ((SysSet211.m_nDisable4wRetest != 1) || ((SysSet211.m_nDisable4wRetest == 1) && (nAutoReTest[nBlockCountP] == 0))) {//sylee180521-1 //son220503
        g_n4WFailCount = 0;
    }
    if (nKeyStartFlag == 1) {
        nAutoReTest[nBlockCountP] = 0;
        g_n4WFailCount = 0; //sylee180521-1
    }

    Lo1 = 100;//SYLEE200224 10->100       nW4=1; 
    Kcount = 1;//SYLEE20120204
    nCount = 1;
    nLoop = 0;//sylee20111226  3->5   //sylee131128
    ipEnd = g_nPieceMax1;//SYLEE131022 
    g_VSet1 = dRec[171][3];//sylee130708   71->171
    g_VSet2 = 1;//sylee131118 


    nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch


    if (nEnd < 0) { //4WSETUP //son241009 0도 처리하게 
        str.Format("\n\nError No 4002,\n\n\n   4W NetList < 0  !!! \n\n\n  4W FILE CHECK! \n\n\n ");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);     
		str.Format("      ");        
		m_list1.AddString(str);
        nlist1++;        
		str.Format("*** 4W NetList < 0  !!!**");      
		m_list1.AddString(str);
        nlist1++;        
		str.Format("***   Error No 4002   **");        
		m_list1.AddString(str);
        nlist1++;        
		str.Format("      ");        
		m_list1.AddString(str);
        nlist1++;
    }


    //------------------------------------------------------------
    // 해당 DUT의 4W Cal 정보를  4W처리용 n4WNet[net]로 copy하여 사용 

    for (net = 1; net <= nEnd; net++)    //son-4WDUT16-190704
    {
#ifdef __GTS_4W_SPCIALNET__					//son230705
        n4WNet[net][_4W_SPECIAL] = (int)g_s4WNet[dutIdx].saData[net - 1].bNetSpecial;   //son221107 GTS 4W 특수넷 표시  //son230705
#endif										//son230705
        //son  하부핀 R 측정모드 이면.
        if (g_bUseLowerCalJig_4W) {    //son220419_7
            n4WNet[net][_4W_PIN1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
        }
        else {
            n4WNet[net][_4W_PIN1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0];   // 1~4  pin, 
            n4WNet[net][_4W_PIN2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1];   // 1~4  pin, 
            n4WNet[net][_4W_PIN3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2];   // 1~4  pin, 
            n4WNet[net][_4W_PIN4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3];   // 1~4  pin, 
        }
        n4WNet[net][_4W_PIECE] = (int)g_s4WNet[dutIdx].saData[net - 1].wPiece;   // 0=piece, //son211005 wNet -> wPiece 
        n4WNet[net][_4W_MODE] = (int)g_s4WNet[dutIdx].saData[net - 1].n4wMode;   // 8 mode

        if (n4WNet[net][_4W_PIN1] < 0 || n4WNet[net][_4W_PIN2] < 0 
			|| n4WNet[net][_4W_PIN3] < 0 || n4WNet[net][_4W_PIN4] < 0)
        {
            str.Format("Error No 1023,\n   4W READ Error!!! \n  PIN NO < 0 . 4W FILE CHECK.,  file Row  =%d    ", (int)net + 5);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;//error
        }

            // 4w net list에서  mode별 수량 확인  
        if (dRec4w[1][1] == n4WNet[net][_4W_MODE]) {
            n4WMod1[1][1]++;
        }
        else if (dRec4w[2][1] == n4WNet[net][_4W_MODE]) {
            n4WMod1[2][1]++;
        }
        else if (dRec4w[3][1] == n4WNet[net][_4W_MODE]) {
            n4WMod1[3][1]++;
        }
        else if (dRec4w[4][1] == n4WNet[net][_4W_MODE]) {
            n4WMod1[4][1]++;
        }
        else if (dRec4w[5][1] == n4WNet[net][_4W_MODE]) {
            n4WMod1[5][1]++;
        }
    }

    int mode, SumMode, nPassCount;
    SumMode = 0;

    for (mode = 1; mode <= nEndStep1; mode++) {
        SumMode = SumMode + n4WMod1[mode][1];
    }

    if (SumMode != nEnd) { // 4W SETUP  NET LIST  MODE SET ERROR 
        nFailCount[TEST_OPEN] = 0;    //son210331 enum                 
        g_n4WFailCount = nEnd;
        AfxMessageBox(" Error No 1027, \n  ->  [SETUP]  [4W Wire]  -> Mode  ( 171~175 ??? ) SETTING ERROR!.,      4W  Run Start Error!!!");
        return 1;
    }

    //son 4W CSV 출력할 때 해당 block의 dutIdx가 무엇인지를 확인하기 위해 저장해 둔다.
    g_d4W_Log1_nBlockDutInfo[nBlockCountP] = dutIdx;     //son200320-4WDUT16 


    //-----------------------------------
    //son  mode별로 검사를 진행한다.

    int calPart = PART_UPPER;    //son220419_2 

    n4W_RunStep = 0;
	nNgNetCo1=0; 
	nNgNetOld1=0; 
	nNgNetMax1= (int)(nEnd); //5% //sylee230426-1
	


///////////////////////////////////////////////////////////////////////////////////

    if( n4w_Sample_Enable == 1){//sylee230430			
        if ((SysSet16.m_nSet23 > 0) && (SysSet16.m_nSet23 <= 10)) { //auto
            nPassCountSet1 = SysSet16.m_nSet23; 
        }
        else { 
            nPassCountSet1 = 3; 
        } 		
    }
    else{//sylee230430

        if(nManual4WStartFlag1==1){//sylee230430
            if ((SysSet16.m_nSet6 > 0) && (SysSet16.m_nSet6 <= 10)) { //manual
                nPassCountSet1 = SysSet16.m_nSet6;//sylee221208
            }
            else { 
                nPassCountSet1 = 3; //sylee230426-9
            }    
        }
        else{//sylee230430
            if ((SysSet16.m_nSet22 > 0) && (SysSet16.m_nSet22 <= 10)) { //auto sampling
                nPassCountSet1 = SysSet16.m_nSet22; 
            }
            else { 
				nPassCountSet1 = 3; 
            } 
        }	

    }

///////////////////////////////////////////////////////////////////////////////////




 



Task701:    //sylee221222 



    for (mode = 1; mode <= nEndStep1; mode++) //SYLEE150202
    {

        if ((n4W_RunStep == 1) || ((n4W_RunStep == 0) && (n4W_RunStep2 > 0))) {
            if (nRetryMode[mode] != 1) {
                continue;//sylee230308
            }
        }
        gn4W_Mode1 = mode;//sylee230124  

        nPassCount = 0;
        nFlag_ADIRet1 = 0; //sylee180823-1
        if (mode < 5) {
            nFlag_ADICheck1 = 1;  //sylee180823-1  //sylee180917-1
        }
        else { nFlag_ADICheck1 = 0; }


        if (SysSet19.m_n4WHVon == 1) {//sylee230128
            dAdcISet = (int)(dRec[160 + mode][5] * 0.9); //sylee230128
            dAdcISet2 = (int)(dRec[160 + mode][5] * 1.1); ///sylee230128
        }
        else {
            dAdcISet = (int)(dRec[170 + mode][5] * 0.9); //sylee180823-1 //sylee180917-1  //sylee181119 0.8->0.9  
            dAdcISet2 = (int)(dRec[170 + mode][5] * 1.1); //sylee200215
        }

        if (SysSet13.m_n4WCVMode == 1) {//sylee200217-4WCVMODE  

            if (SysSet19.m_n4WHVon == 1) {//sylee230128
                if (mode <= 3) {
                    dAdcISet = (int)(dRec[160 + mode][5] * 0.9); //sylee230128
                }
                else { dAdcISet = (int)(dRec[160 + mode][5] * 0.5); }//sylee230128
                dAdcISet2 = (int)(dRec[160 + mode][5] * 1.5); //sylee230128
            }
            else {//sylee230128

                if (mode <= 3) {
                    dAdcISet = (int)(dRec[170 + mode][5] * 0.9); //sylee201209
                }
                else { 
					dAdcISet = (int)(dRec[170 + mode][5] * 0.5); //sylee201209
				}
                dAdcISet2 = (int)(dRec[170 + mode][5] * 1.5); //sylee201209 		
            }
            nFlag_ADICheck1 = 1;  //sylee201209
        }

        if (mode == 1) nRelay1OffSkip = 1;//sylee170424-1
        if (nRelay1OffSkip == 2) nRelay1OffSkip = 3;//sylee170424-1 

        if (n4W_RunStep == 0 && n4W_RunStep2 == 0) {//sylee221222   //sylee230301
            for (net = 1; net <= nEnd; net++) {  // net 
                //son 이전 mode 검사에서 해당 net이 양품이었으면 nPassCount를 증가시킨다. 
                if (ng4WResult[net] == 2) {//sylee131022//pass
                    nPassCount++;
                }
            }

            //son 이전 mode 검사에서 모든 net이 양품이었다면 mode를 5로 만들어서 for 루프를 탈출한다. 
            if (nPassCount == nEnd) {
                mode = 5;//sylee140722
                continue;
            }
        }

        int nPassCount2, nPassCount3, nPassCountSum1;
        nPassCount2 = 0; nPassCount3 = 0; nPassCountSum1 = 0;//sylee221227

        for (net = 1; net <= nEnd; net++) {  // net 
            if ((ng4WResult[net] != 2) && (nFail2[net] == 1)) {  //sylee221227
                nPassCount2++;
            }
            else if (nFail2[net] == 1) {//sylee221227
                nPassCount3++;
            }
        }
        nPassCountSum1 = nPassCount + nPassCount2;//sylee221227

        if (nFlag_Fail_Full != 1) {//sylee160528-5
            if (n4WMod1[mode][1] < 1) {  //son mode별  net 총 개수가 1보다 작으면 이 모드는 넘어간다.  
                continue;
            }
        }

        //---------------------------------
        //son Mode별 검사 parameter 확보

        m_nMode1 = dRec4w[mode][1];

        if (SysSet19.m_n4WHVon == 1) { //sylee210128
            m_nMode1 = m_nMode1 - 10;
        }

        if (SysSet13.m_n4WCVMode == 1) { //sylee200217-4WCVMODE
            if (SysSet19.m_n4WHVon == 1) {//sylee230128
                if (m_nMode1 == 161)  m_nMode1 = 166;//sylee230128
                if (m_nMode1 == 162)  m_nMode1 = 167;//sylee230128   
                if (m_nMode1 == 163)  m_nMode1 = 168;//sylee230128         
                if (m_nMode1 == 164)  m_nMode1 = 169;//sylee230128         
                if (m_nMode1 == 165)  m_nMode1 = 169;//sylee230128
            }
            else {
                if (m_nMode1 == 171)  m_nMode1 = 176;
                if (m_nMode1 == 172)  m_nMode1 = 177;
                if (m_nMode1 == 173)  m_nMode1 = 178; //SYLEE201030  //sylee221212          
                if (m_nMode1 == 174)  m_nMode1 = 179; //SYLEE201030  //sylee221212        
                if (m_nMode1 == 175)  m_nMode1 = 179; //SYLEE201030  //sylee221212  
            }
        }

        nCC = (int)dRec[m_nMode1][1];
        nVRel = (int)dRec[m_nMode1][2];
        nVSet = (int)dRec[m_nMode1][3];
        nIR = (int)dRec[m_nMode1][4];
        nISet = (int)dRec[m_nMode1][5];
        nDelay10 = (int)dRec[m_nMode1][6] * 10;
        Sub71.nADCount1 = (int)dRec[m_nMode1][7];    //sylee150713
        nFil = (int)dRec[m_nMode1][8];       //SYLEE130706
        nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130706 
        nIGain = (int)dRec[m_nMode1][12];    //SYLEE150123     
        n4wGain = (int)dRec[m_nMode1][13];   //SYLEE150123

        nFlag_4W_SetI = nISet / 20.;//sylee211126 

        //son MAP->Set3->'4W K Count' 
        if (mode == 1) {//SYLEE180706-1
            if (SysSet19.m_nSet8 < 1) {//SYLEE180706-1  
                Kcount = 1;
            }
            else if (SysSet19.m_nSet8 <= 20) {//SYLEE180706-1
                Kcount = SysSet19.m_nSet8;		//son 4W K Count 
            }
            else {//SYLEE180706-1
                Kcount = 1;
            }
        }
        else {//SYLEE180706-1
            Kcount = 1;
        }


        if (nISet < 0.1) {
            AfxMessageBox(" Error No 7706, \n    I Set  ( <0.1 ) SET ERROR !,  4W  Start Error!!!");
        }
        if (nIR == 1 || nIR == 2) {   //mA
            nISetVal1 = nISet * 0.1;
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {
            nISetVal1 = nISet * 0.1;
        }
        else {
            AfxMessageBox(" Error No 1024, \n    I RANGE 1~5   SET ERROR !,      4W FAIL  Run Start Error!!!");
            return 0;
        }

        n4Wire = 4;
        nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
        nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
        //=========================================================================================
        //interlock   
        if (nCC != 1 && nCC != 2) {
            AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     4W Run Start Error!!!");
            return 0;
        }

        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 





Task101:  //son Retry Check Hw Power  (Lo1 = 100)


        if (SysSet19.m_n4WHVon != 1) //sylee200217-4WCVMODE
        {
            if (mode == 1)//sylee140120
            {
                //------------------------
                //son Read VB (HW Check)

                Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 

                if (nVSet <= 5) {
                    dVbR2 = nVSet * (0.35);//35%
                }
                else {
                    dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
                }
                dVbR1 = nVSet - dVbR2;     
				dVbR2 = nVSet + dVbR2;

                if (Sub71.V1 > 300) {
                    if (Lo1-- > 0) {
                        Sub71.Delay_100ns(100000);  //10ms   
                        goto Task101;
                    }
                    str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                    return 0;
                }
#ifdef _PC_TEST_
                Sub71.V1 = 15;  //son211217 Hw Error를 넘어가기 위해 추가
#endif
                if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                    if (Lo1-- > 0) {
                        Sub71.Delay_100ns(100000);  //10ms   
                        goto Task101;
                    }
                    str.Format("Error No 1303,\n \n\n  Power Check? \n\n\n   VB READ Error!!!    Calibration NO=%d   \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                    return 0;
                }

            }//sylee140120  //end of if(mode==1)//sylee140120
        }//     if(SysSet19.m_n4WHVon!=1)//sylee191023-1


        //-------------------------------
        //son VC READ  INIT SET
        Sub71.AOnReadV1Enable1(5);

        //----------------------------
        //son I Filter 설정  (ADC_A)
        Sub71.I_Filter(nIFilter);//sylee130706

        //---------------------
        //son I Gain 설정 
        if (nIGain == 2) {
            Sub71.I_Gain(2);  //10x  =io on   //sylee150123 //ACE380  
        }
        else { 
			Sub71.I_Gain(1);  //1x  =io off
		}

        //---------------------
        //son 4W Gain 설정 
        if (n4Wire == 4) {   //ACE380
            if (n4wGain == 2) { 
				Sub71.On4W_GainSet(2); 
			}
            else  if (n4wGain == 3) { 
				Sub71.On4W_GainSet(3); 
			}
            else  if (n4wGain == 4) { 
				Sub71.On4W_GainSet(4); 
			}
            else { 
				Sub71.On4W_GainSet(1); 
			}
        }
        else { 
			Sub71.On4W_GainSet(1); 
		}

        //**********************************************************//

        //------------------
        //son I Value Set
        if (mode == 1) {//sylee150128 ace380 
            Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //RELAY ON 
        }
        else {//    if(ik==1){//sylee150128 ace380          
            Sub71.nModeIR = 1;
            if (nISet == 1) {
                Sub71.AOnISet1Run1(nISet);//sylee150715
            }
            else { 
				Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);   //SYLEE150701
			}
        } //if(ik==1){//sylee150128 ace380

        Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 

        if (mode == 4) {
            Sub71.Delay_100ns(5000); //500us  //sylee150709 
        }

        nLoop = 0;//SYLEE20120302  //sylee131128

        //sylee200515-patch nEnd=(int)gd4W1[0][0];
        nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch
        if (nEnd < 0) { //son241009 0도 처리하게 
            str.Format("Error No 7115 , \n\n  Process Stop. \n\n  4W NET LIST wCount < 0 !    \n\n\n\n   => .BDL\4w.ini check. \n  4W  RUN STOP \n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }
        //sylee170729-1  if(nEnd>=5000){
        if (nEnd > MAX_4W_NET)   //son-4WDUT-20200403: 5000-> 10000: MAX_4W_NET
        {
            str.Format("\n\nError No 7801,  4w total count(=%d) over  >%d      \4w.ini check. !     \n\n\n    \n\n\n ", nEnd, MAX_4W_NET);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
        }

        //------------------------------------
        //son ADC B Filter를 VC Fast로 설정
        if (SysSet19.m_n4WHVon == 1) {
            Sub71.FilterSet(4);     //sylee190525  //sylee191023-1
        }
        else { 
			Sub71.FilterSet(1); //sylee191023-1
		}
        nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.nADCount1 = 1;


        //#############################################################################################



       //sylee221226
#ifdef __YOUNPUNG__CUSTOMER_4W_2WCHECK  

        //son MAP > Set3 > Spark Calibration 
        SysSet19.m_nSet13 = 1; //SYLEE230128
#endif//SYLEE230128

        //--------------------------------
        //son Check 4W Pin Contact Fail 
        
        //son step1(171 mode) 에 대해 4개의 4W pin을 설정하고 V값과 I 값을 측정을 Net개수 만큼 반복
        //    I값이 일정 수준 이상이 나올 때까지  측정을 반복한다.
        if (SysSet19.m_n4W_ContactCheck1 == 1) //syle230116   4W  PIN CONTACT CHECK  ENABLE  //sylee230420
		{
            if ((mode == 1) && (n4W_RunStep == 0)) //sylee201005  //sylee221226
            {
                for (net = 1; net <= nEnd; net++)   // net  
                {
                    t1 = n4WNet[net][_4W_PIN1];   //son210223 1->_4W_PIN1 enum 
                    t2 = nPinToPiece(t1);//SYLEE171225-2  
                    if (net == 1) { 
						Sub71.Delay_100ns(40000); //sylee221226 //4mS 
					}

                    //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
                    if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                        if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                            continue;
                        }
                    }

                    //son 해당 piece가 Disable이면  테스트 의미없음
                    if (SysInfo19.m_nUse == 1) {//sylee131022
                        if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                            continue;
                        }
                    }
                    if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                        continue;
                    }
                    if ((nAutoReTest[nBlockCountP] < gRun05.m_nReCh) && (nManualStartFlag != 1) && (SysSet211.m_nDisable4wRetest != 1)) {  //sylee160604-1   //son220503
                        if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {    //sylee131022 
                            continue;
                        }
                    }

                    //son 이전 test에서 pass였다면 이 net을 test 하지 않는다. 
                    if (ng4WResult[net] == 2) {//sylee131022//pass
                        continue;
                    }

                    //son 이전 mode에서 불량이었다면 4W Contact 체크
                    if (ng4WResult[net] != 2)//sylee131022//pass=2
                    {

                        /*     //  sylee221226
                        if (n2WCheck == 2) {//sylee201005
                            if (n4WNet[net][_4W_REF_AVG] < 10000) {//sylee201005     //son211005  _4W_SET_AVG -> _4W_REF_AVG
                                continue;
                            }
                        }
                        */
                        //  if(nPos1[net] == 0) {
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 1);   //Vc  TR 
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 2);   //Vb  TR PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,
                        for (int k1 = 1; k1 <= 10; k1++) { //300uS
                            Sub71.Delay_100ns(500);  //50uS                        
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I                              
                            if (Sub71.Y1 > (nISet * 0.7)) {//sylee//sylee191015-2     //sylee221226   0.3->0.9
                                break;
                            }
                            if (k1 == 10) {//fail                           
                                nPos1[net] = 2;   //son 4W Contact fail (I 값이 일정수준이 안 나온다고) 표시
                            }
                        }
                        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                  //  }
                  //  if (nPos1[net] == 0) {
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 1);    //Vb  RELAY PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,  //SYLEE20111118
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 2);    //Vc  TR PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,  //SYLEE20111118   
                        for (int k2 = 1; k2 <= 10; k2++) {  //300uS                           
                            Sub71.Delay_100ns(500);  //50uS                        
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I                              
                            if (Sub71.Y1 > (nISet * 0.7)) {//sylee//sylee191015-2 //sylee221226   0.3->0.9
                                break;
                            }
                            if (k2 == 10) {//fail
                                nPos1[net] = 2;    //son 4W Contact fail (I 값이 일정수준이 안 나온다고) 표시
                            }
                        }
                        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                   // }
                    }

                }//end of   for( net=1; net<=nEnd; net++)   // net 

            }//end of if(mode==1)

        } //SYLEE230116

    //sylee221226 #endif//SYLEE201207


    //#############################################################################################

        //------------------------------
        //son ADC B Filter를 4W로 설정
        Sub71.FilterSet(4);//sylee131112  
        if (SysSet13.m_n4WCVMode == 1) {//sylee200217-4WCVMODE  
            Sub71.OnCCCV_Set(2);  //cv //sylee191015    
        }
        else {
            Sub71.OnCCCV_Set(1);  //cc  //sylee191015  
        }
        Sub71.Delay_100ns(30000); //3ms //sylee140120-> 3mS-> 1mS  //sylee140212
        nPassCo1 = 0;//sylee150710  
        Sub71.nADCount1 = (int)dRec[m_nMode1][7];  //SYLEE180706- MOVED
        if (Sub71.nADCount1 < 1) {
            Sub71.nADCount1 = 1;
        }
        if (Sub71.nADCount1 > 300) { //sylee180222-1
            Sub71.nADCount1 = 300;
        }

        int nCo11;
        nCo11 = 0;


        //############################################################################################################################################


        if (nPassCountSum1 != nEnd)   //sylee221227  
		{
            //------------------------------------------------------
            //son  예비 4W 검사 :  4w 검사 모드일 때 20회 검사
            if (mode == 1 || mode == 2 || mode == 3 || mode == 4 || mode == 5)   //sylee200217-4WCVMODE//sylee200515-patch
            {
                Sub71.Delay_100ns(10000); // 1mS//sylee180221-3 //sylee200217-4WCVMODE

				//son net 개수가 20개 이하이면
                if (nEnd < 20) {//sylee180222-1
                    for (int k11 = 1; k11 <= 1; k11++) {
                        for (int k12 = 1; k12 <= 20; k12++) {   // net
                            Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN4] - 1, 4);
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);
                            Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN2] - 1, 3);
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                            Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN3] - 1, 2);
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN1] - 1, 1);
                            Sub71.Delay_100ns(nDelay10);//sylee180222-1
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I         
                            Sub71.OnPinAllReset1();
                        }
                    }
                }
                else {
                    for (int k11 = 1; k11 <= 1; k11++) {
                        for (int k12 = 1; k12 <= 20; k12++) {   // net
                            Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN4] - 1, 4);   //son210223 1-> _4W_PIN1 enum 
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);
                            Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN2] - 1, 3);
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                            Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN3] - 1, 2);
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN1] - 1, 1);
                            Sub71.Delay_100ns(nDelay10);//sylee180222-1
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I         
                            Sub71.OnPinAllReset1();
                        }
                    }
                }
            }
            else
            {
                if (nCount > 0) {
                    net = 1;
                    Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 4);    //VC  RELAY PinNo(0~8k)  //sylee150128//son210223 1-> _4W_PIN1 enum 占쏙옙占쏙옙     
                    Sub71.Delay_100ns(100);   //sylee150709          
                    Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 2);    //VC  TR PinNo(0~8k)    //sylee150128  
                    Sub71.Delay_100ns(800);   //sylee150709
                    Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);    //VB  RELAY PinNo(0~8k)  //sylee150128        
                    Sub71.Delay_100ns(100);   //sylee150709              
                    Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);    //VB  TR PinNo(0~8k)     //sylee150709-move 
                    Sub71.Delay_100ns(3500); //300uS  //sylee150710-1
                    Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                    Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                    Sub71.OnPinAllReset1(); ///PIN ALL RESET     
                }
            }

        } //sylee221227
      //////////////////////////////////////////////////////////////////


        //########################################################################################
        //SYLEE170304-1 
        //# 1차 검사 
        short n4W_Pass[MAX_4W_NET + 1];//SYLEE170304-1   //son  1이면 pass, pass시 2차 검사.
        short n4w_Fail1_Piece[MAX_PIECE + 1];//sylee170304   //son211102 501 -> (MAX_PIECE +1)
        double dDiffRate2;
        dDiffRate2 = 0.0;

        if (n4W_RunStep == 0 && n4W_RunStep2 == 0) {//sylee221226   //sylee230301
            ::ZeroMemory(&n4W_Pass, sizeof(n4W_Pass));//SYLEE170304-1  
            ::ZeroMemory(&n4w_Fail1_Piece, sizeof(n4w_Fail1_Piece));   //sylee170304 
        }



        //-------------------------------------------------------------------------------------------
        //son 4개의 4W pin을 설정하고 V값과 I 값을 측정, R값 계산을  Net개수 만큼 반복 -> nCount 만큼 반복 측정
        //    계산 결과는 sum 으로 dR14w[][], dVB14w[][], dVC14w[][], dI14w[][]에 임시 저장
        for (j = 1; j <= nCount; j++)  //nCount=1 
        {

            for (int net2 = 1; net2 <= nEnd; net2++)   //sylee191122-1  
            {
                //son net2에 맞는 Sort된 net 위치를 찾아 온다.
                net = n4WSort1[net2];//sylee191122-1    
                if (net < 1) { 
                    continue; //sylee191122-1  
                }
                if (net >= MAX_4W_NET) {        //son231107 Def_4WMax1 -> MAX_4W_NET(10000)
					continue; //sylee191122-1
				}

                nRetryCo1 = 0;//sylee150721  

                if (n4W_RunStep == 0 && n4W_RunStep2 == 0) {//sylee221222   //sylee230301
                    if (n4W_Pass[net] == 1) { //	pass시 2차 검사 
                        continue; //sylee170304   
                    }
                }
                else {
                    if (nRetryNet1[net] == 0) { 
                        continue; 
                    }
                }

                if (dRec4w[mode][1] != n4WNet[net][_4W_MODE]) { //sylee230307
                    continue;
                }

                t1 = n4WNet[net][_4W_PIN1]; //son210223 1-> _4W_PIN1 enum 
                t2 = nPinToPiece(t1);//SYLEE171225-2  
                if (n4w_Fail1_Piece[t2] >= (SysInfo05.m_nConEr + 100)) {//SYLEE210405-1
                    continue;
                }

                //son Skip해야할  Piece인지 확인.
                if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                    if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                        continue;
                    }
                }
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {//sylee131022
                    if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                        continue;
                    }
                }

                if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                    continue;
                }

                if (n4W_RunStep != 1 && n4W_RunStep2 != 1)  //sylee230301
				{
					//son 이전 test에서 pass였다면 이 net은 대상에서 제외. (여러모드중에 하나만 pass여도 pass임)
                    if (ng4WResult[net] == 2) {//sylee131022//pass
                        continue;
                    }
                }



#if 0      //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
           //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.
                if (nReSheetFlag1 == 1) { //sylee131204//resheet       
                    int tmp1;
                    tmp1 = n4WNet[net][_4W_PIN1];    //son210223 1-> _4W_PIN1 enum 占쏙옙占쏙옙              
                    tmp1 = nPinToPiece(tmp1);//SYLEE171225-2
                    nReSheetCellNo = nBlockPieceNo1[nBlockCountP][tmp1];
                    nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                    if (nReSheetCellStatus == 1) {  //son PASS
                        continue;
                    }
                }
#endif          //son220803 end

                if (nStop == 2) {
                    AfxMessageBox(" Error No 1023, \n    PIN ALL RESET  SET ERROR !,      ,    4W Run Start Error!!!");
                    goto task2_NEXT_MODE;  //son240713
                }

                nMode = n4WNet[net][_4W_MODE];//sylee140420 
                dR5Po1 = 0;	dR5Po2 = 0;//sylee221120-1







Task1311://sylee150721



                nPassCo1 = 0;     nPassCo2 = 0;//sylee150710
                n4W_Retry3 = 0;   n4W_Retry4 = 0;	n4W_Retry5 = 0;		n4W_Retry6 = 0;//sylee191025-1


                for (k = 0; k < Kcount; k++)
                {
                    //son 4W Contact Fail이 아니라면
                    if (nPos1[net] != 2)//sylee131112
                    {
                        if (Kcount <= 1) //4WSETUP140107
                        {
                            n4W_Retry1 = 0;//sylee170228
                            n4W_Retry2 = 0;//sylee190116-2
                            n4W_Retry5 = 0;
                            nZeroCo1 = 0;//sylee180520-1

                            if (SysInfo05.m_n4WSet1 == _4W_SET_FAST) {//sylee201018         //son201117 0 -> _4W_SET_FAST
                                nRetryEndSet = 1;
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_NORMAL) {//sylee200910 //son201117 1 -> _4W_SET_NORMAL
                                nRetryEndSet = 1; //sylee201018  2->1 
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_SLOW) {                  //son201117 2 -> _4W_SET_SLOW
                                nRetryEndSet = 2; //sylee201018  4->2                                
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_FINE) {                  //son201117 3 -> _4W_SET_FINE       
                                nRetryEndSet = 4; //sylee201018  
                            }
                            else { //SysInfo05.m_n4WSet1=0
                                nRetryEndSet = 1;
                            }

                            d4wNet1 = net;//sylee221206-2

                            ::ZeroMemory(&dR5, sizeof(dR5)); //sylee221120 
                            ::ZeroMemory(&n4WAdcOK1, sizeof(n4WAdcOK1)); //sylee221212
                            ::ZeroMemory(&dR30, sizeof(dR30)); //sylee221220
                            dR30Co1 = 0;
                            dR4w1_old1 = 0.0;//sylee201012   
                            nRetry7 = 0;//sylee221120
                            nRetry8 = 0; nRetry9 = 0;  	//sylee221206-5							 	
                            d4wIPo1 = 0;	     d4wVPo1 = 0;
                            nADCFail200 = 0;	 n4W_Retry1 = 0;//sylee221207 							 
                            nRetryCount1 = 0; nRetryCount10 = 0;
                            n4W_Retry5 = 0;//sylee230117



//########################################################################################################################################

                            nd4W_Data1Co1 = 0;//sylee230224
                            nFlag_d4W_Data1_Retry = 0;//sylee230224
                            nFlag_d4W_Data1_Retry = 0;//sylee230224
                            nFlag_d4W_Data1_RetryCo1 = 0;//sylee230224
                            doldR2 = 0.0;//sylee230308-1

                            ::ZeroMemory(&d4W_Data1Retry, sizeof(d4W_Data1Retry)); //sylee230214-1 






Task1700_beforeOnPinSet://sylee170228-1    //son230807
                            //son 먼지제거 기능:
                            //    핀설정 방향을 바꿔가면서 테스트해서 전기극성때문에 붙었던 먼지를 제거

                            nPassCo1 = 0;//sylee230117 
                            dR30Co1 = 0; //sylee230117-1	
                            nR101Po1 = 0;//sylee221208
                            ::ZeroMemory(&dR30, sizeof(dR30)); //sylee230117-1
                            ::ZeroMemory(&dR101, sizeof(dR101));    
                            ::ZeroMemory(&dR101V, sizeof(dR101V));    
                            ::ZeroMemory(&dR101I, sizeof(dR101I)); //sylee221208 


                            if ((SysSet16.m_nSet14 == 1) || (SysInfo05.m_n4WSet1 == _4W_SET_NORMAL) || (SysInfo05.m_n4WSet1 == _4W_SET_FAST)) {//sylee221212
                                nPinNo[1] = n4WNet[net][_4W_PIN1] - 1;  
								nPinNo[2] = n4WNet[net][_4W_PIN4] - 1;  //vc tr
                                nPinNo[3] = n4WNet[net][_4W_PIN2] - 1;  
								nPinNo[4] = n4WNet[net][_4W_PIN3] - 1;  //vc relay    								  
                            }
                            else 
							{
                                if (n4W_Retry1 == 1) {//sylee200909  #2
                                    nPinNo[1] = n4WNet[net][_4W_PIN4] - 1; 	
									nPinNo[2] = n4WNet[net][_4W_PIN1] - 1;  //vc tr
                                    nPinNo[3] = n4WNet[net][_4W_PIN3] - 1;  
									nPinNo[4] = n4WNet[net][_4W_PIN2] - 1;  //vc relay                                    
                                }
                                else if (n4W_Retry1 == 2) {// #3
                                    nPinNo[1] = n4WNet[net][_4W_PIN1] - 1;  
									nPinNo[2] = n4WNet[net][_4W_PIN4] - 1;  //vc tr
                                    nPinNo[3] = n4WNet[net][_4W_PIN2] - 1; 	
									nPinNo[4] = n4WNet[net][_4W_PIN3] - 1;  //vc relay                        
                                }
                                else if (n4W_Retry1 == 3) {// #4
                                    nPinNo[1] = n4WNet[net][_4W_PIN4] - 1; 	
									nPinNo[2] = n4WNet[net][_4W_PIN1] - 1;  //vc tr
                                    nPinNo[3] = n4WNet[net][_4W_PIN3] - 1;  
									nPinNo[4] = n4WNet[net][_4W_PIN2] - 1;  //vc relay    
                                }
                                else {//sylee200909    #1
                                    nPinNo[1] = n4WNet[net][_4W_PIN1] - 1;  
									nPinNo[2] = n4WNet[net][_4W_PIN4] - 1;  //vc tr
                                    nPinNo[3] = n4WNet[net][_4W_PIN2] - 1;  
									nPinNo[4] = n4WNet[net][_4W_PIN3] - 1;  //vc relay    
                                }
                            }

                            //-----------------
                            //son 4W pin 설정
                            Sub71.AOnPinSet1(2, nPinNo[1], 2);    //Vc  TR PinNo(0~8k)   //sylee200220-1 
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, nPinNo[2], 1);    //Vb  TR PinNo(0~8k)   //sylee200220-1                                 
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, nPinNo[3], 4);    //Vc  RELAY PinNo(0~8k)  //sylee200220-1                               
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                            Sub71.AOnPinSet1(2, nPinNo[4], 3);    //Vb  RELAY PinNo(0~8k)  //sylee200220-1  
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY1); //sylee170313-1        fix delay  


                            calPart = FileSysInfo01.checkUseCalDataPart(nPinNo[1], nPinNo[3]);    //son220419_2
                            tStart11 = Get_uSecond1();//uS  //sylee150710-1  

                             //sylee221205    Sub71.Delay_100ns(3000); //200uS  //sylee201006-1
                            Sub71.Delay_100ns(4000); //400uS//sylee221205
                            if (mode == 1) {
                                Sub71.Delay_100ns(4000); //800uS//sylee230116  //600uS//sylee221205
                            }

                            //########################################################################################################################################





Task1500_afterOnPinSet://sylee150710 //son230807


                            if ((nPinNo[1] <= nHalfPin1) && (nPinNo[3] <= nHalfPin1)) {
                                n4W_PinFastADC1 = 2;//sylee200905
                            }
                            else  if ((nPinNo[1] > nHalfPin1) && (nPinNo[3] > nHalfPin1)) {
                                n4W_PinFastADC1 = 2;
                            }
                            else {
                                n4W_PinFastADC1 = 1; //sylee200905
                            }



                            //----------------------------
                            //son V값, I 값 측정
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I  
                            tStart12 = Get_uSecond1();//uS  //sylee150710-1
                            tStart13 = (tStart12 - tStart11);  //sylee150710-1

                            //-----------------------------
                            //son R 값 계산, Calibration   (Sub71.R1 = VC / I)
                            //SYLEE200909 ARun201_4w_R1(nISet);  //sylee150710
                            ARun201_4w_R2(nISet, n4W_Retry1);  //sylee200909  

							//son Sub71.R1 R 값 변환. raw R -> real R (4W는 real R로 판정함)
                            ARun201_4w_R_Cal1(m_nMode1, calPart);//sylee150710        //son220412  

#ifdef _TEST_4W_ALL_PASS_
                            Sub71.R1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;  //son220524_2 4W all pass를 만들 수 있는 테스트 코드
                            Sub71.W1 = 1;   //son220524_2
#endif

                            int nTemp2;

                            if (n4W_ADC_Fail_Flag == 0) {
                                dR30Co1++;//sylee221220
                                dR30[0][0] = dR30Co1;//sylee221220
                                if (dR30Co1 == 1) {
                                    dR30[0][1] = dR30Co1;//sylee221220-1	//min
                                }
                                else {
                                    nTemp2 = dR30[0][1];//sylee221222
                                    if (dADCPercent1 < dR30[nTemp2][1]) {//sylee221222
                                        dR30[0][1] = dR30Co1;
                                    }
                                }
                                dR30[dR30Co1][0] = Sub71.R1; //sylee221220
                                dR30[dR30Co1][1] = dADCPercent1; //sylee221220
                            }


                            double n4W_Errr_Per;    //sylee170313 



                            if (Sub71.R1 >= 10) {//sylee230223
                                n4W_Errr_Per = 3.0;  //%
                                if (Sub71.R1 != 0.0) {
                                    nOld1_R1_Rate1 = ((nOld1_R1 - Sub71.R1) / nOld1_R1) * 100.;  //sylee221120
                                }
                                else { 
									nOld1_R1_Rate1 = 100000.; 
								}
                            }
                            else {
                                n4W_Errr_Per = 1.0;  //mohm
                                if (Sub71.R1 != 0.0) {
                                    nOld1_R1_Rate1 = (nOld1_R1 - Sub71.R1);
                                }
                                else { 
									nOld1_R1_Rate1 = 100000.; 
								}
                            }


                            if (nOld1_R1_Rate1 < 0.0) { 
								nOld1_R1_Rate1 = -nOld1_R1_Rate1; 
							}

                            //----------------
                            //son 양품
                            if ((n4W_ADC_Fail_Flag == 0) && (nOld1_R1_Rate1 < n4W_Errr_Per)  //sylee230227
                                && (g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1)
                                && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh))   //양품
							{
                                nPassCo1++;//sylee150710   

                                if ((Sub71.R1 > 0.0) && (Sub71.R1 <= 200000)) {//sylee230223
                                    if (nR101Po1 < 500) {
                                        nR101Po1++;//sylee221208
                                        dR101[nR101Po1] = Sub71.R1; //sylee221208
                                        dR101V[nR101Po1] = Sub71.W1; //sylee221208
                                        dR101I[nR101Po1] = Sub71.Y1; //sylee221208
                                        dR101[0] = nR101Po1; //sylee221208
                                    }
                                }
                            }
                            //----------------
                            //son 불량 
                            else {
                                ::ZeroMemory(&dR30, sizeof(dR30)); //sylee230117						 
                                dR30Co1 = 0;  //sylee230117
                                nPassCo1 = 0; //sylee230117
                            }


                            nOld1_R1 = Sub71.R1;//sylee150710  	
                            nFullDelayFlag1 = 0;

                            //son tStart13이 RetryTime(dRec[m_nMode1][6])보다 작으면 
                            if (tStart13 < (nDelay10 / 10)) {   //sylee201006-1
                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 10)) {//sylee210414  
                                    //son   양품이 nPassCountSet1 회 측정되지 않았으면  계속 retry를 시도한다.
                                    if (nPassCo1 < nPassCountSet1) { //sylee221205-1   //5->3
                                        goto Task1500_afterOnPinSet;//sylee201006-1 //son230807
                                    }
                                }
                                else {//sylee210414 
                                    if (nPassCo1 < nPassCountSet1) { //sylee221205-1   //5->3
                                        goto Task1500_afterOnPinSet;//sylee201006-1 //son230807
                                    }
                                }
                            }
                            else {
                                nFullDelayFlag1 = 1;//sylee221205
                            }


                            ////////////////////////////////////////////////////////////////////////////////////
                            nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET                      
                            if (nRet1 != 1) {
                                AfxMessageBox(" Errro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,   4W Run Start Error!!!");
                                return 0;
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////////////                    
                            if (nFullDelayFlag1 == 1) {//sylee221205
                                if (nPassCo1 < nPassCountSet1) {
                                    if (n4W_Retry5 < 1) { //sylee200909 //sylee221202-    1->10
                                        n4W_Retry5++;
                                        if (nRetryCount10 == 0) {
                                            for (int nkk1 = 1; nkk1 <= 10; nkk1++) {
                                                Sub71.Delay_100ns(2);
                                                if ((nkk1 % 2) == 0) {//sylee221205-2
                                                    Sub71.AOnPinSet1(2, nPinNo[3], 1);   //USER PIN  2 //sylee221203
                                                    Sub71.AOnPinSet1(2, nPinNo[4], 1);   //USER PIN  3 //sylee221203
                                                    Sub71.AOnPinSet1(2, nPinNo[1], 2);   //USER PIN  1 //sylee221203
                                                    Sub71.AOnPinSet1(2, nPinNo[2], 2);	 //USER PIN  4 //sylee221203
                                                }
                                                else {  //sylee221205-2
                                                    Sub71.AOnPinSet1(2, nPinNo[3], 2);   //USER PIN  2  //sylee221205-2
                                                    Sub71.AOnPinSet1(2, nPinNo[4], 2);   //USER PIN  3  //sylee221205-2
                                                    Sub71.AOnPinSet1(2, nPinNo[1], 1);   //USER PIN  1  //sylee221205-2 												
                                                    Sub71.AOnPinSet1(2, nPinNo[2], 1);	 //USER PIN  4  //sylee221205-2
                                                }
                                                Sub71.Delay_100ns(500);		Sub71.OnPinAllReset1();
                                            }
                                            //sylee221207 
                                            nRetryCount10++;
                                        }

                                        nRetryEndSet = 2;
                                        nRetryEndSet = 1;//sylee221222
                                        n4W_Retry1 = 0;//sylee221215
                                        nPassCo1 = 0;//sylee221208 	
                                        //Sub71.Delay_100ns(30000); //3mS //SYLEE221216-DEBUG 
                                        nRetryCount1++;
										if(nManual4WStartFlag1==1){//sylee230426-8
											goto Task1700_beforeOnPinSet;   //son230807
										}
                                    }

                                    nADCFail200 = 2;

                                }
                                else {
                                    nADCFail200 = 0;
                                }

                            }
                            else {
                                nADCFail200 = 0;
                            }


                            nPassCo1 = 0;//sylee230117;

       //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                           if (Sub71.W1 <= 0.0) { //sylee150713  import.////sylee150720
                                if (n4W_Retry3 < 2) {//sylee210427
                                    n4W_Retry3++;
                                    //sylee230426-9if (n4W_Retry3 > 1) {
                                     //sylee230426-9  
									Sleep(1);
                                    //sylee230426-9}
                                    nPassCo1 = 0;
                                    goto Task1700_beforeOnPinSet;	//son230807
                                }
                                Sub71.R1 = 9999991; //sylee150713  import.
                            } //sylee150713  import.


                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE//SYLEE200220  //SYLEE210304-1
                                if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                                    Sub71.R1 = 9999992;
                                }
                                if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                                    Sub71.R1 = 9999993;
                                }
                            }
                            if (Sub71.W1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                                Sub71.R1 = 9999994;
                            }

                            int n4W_Pass_Co; //sylee150721

                            n4W_Pass_Co = SysSet19.m_nSet7;
                            if (n4W_Pass_Co < 5) { 
								n4W_Pass_Co = 3; //sylee160609-1
							}
                            if (n4W_Pass_Co > 50) { 
								n4W_Pass_Co = 50; //sylee171101-1  
							}

 //=============================================================================================================================================
 //sylee230102 
                            double dMin10, dMax10;

                            dR30Co1 = dR30[0][0];  //sylee221221 

                            if (dR30Co1 > 0) {
                                Sub71.R1 = 0.0;
                                for (int n = 1; n <= dR30Co1; n++) {//sylee221221							   
                                    if (n == 1) {
                                        dMin10 = dR30[n][0];	 
                                        dMax10 = dR30[n][0];
                                    }
                                    else {
                                        if (dMin10 > dR30[n][0]) { 
                                            dMin10 = dR30[n][0]; }
                                        if (dMax10 < dR30[n][0]) { 
                                            dMax10 = dR30[n][0]; }
                                    }
                                    Sub71.R1 = Sub71.R1 + dR30[n][0];
                                }

                                if (dR30Co1 >= 3) {
                                    Sub71.R1 = (Sub71.R1 - dMin10 - dMax10) / (dR30Co1 - 2);
                                }
                                else {
                                    Sub71.R1 = Sub71.R1 / dR30Co1;
                                }

                            }
                            //===================================================================================================
                            //----------------------------
                            //son  R, VC, I  값 저장.
                            //----------------------------
                            n4WData1[net][n4W_Retry1] = Sub71.R1;//sylee200415
                            n4WData1v[net][n4W_Retry1] = Sub71.W1;//sylee200415
                            n4WData1i[net][n4W_Retry1] = Sub71.Y1;//sylee200415 
                             //////////////////////////////////////////////////////////////
                            if (n4W_RetryFlag1 == 2) {//sylee210417
                                if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0)//SYLEE220205  //SYLEE220312ADD 
                                {
                                    if ((Sub71.R1 < ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg * dPerRate1))                //son211005
                                        || (Sub71.R1 > ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg * dPerRate2))) {              //son211005

                                        if ((fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR4w1_old1)) < (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1))) {  //son211005
                                            Sub71.R1 = dR4w1_old1;
                                        }
                                        else {
                                            dR4w1_old1 = Sub71.R1;
                                        }
                                        if (n4W_Retry4++ < 3) { //sylee210417-4w   /sylee210420  10->3   
                                            goto Task1700_beforeOnPinSet;  //son230807
                                        }
                                        else {
                                            nFail1[net] = 2;  //sylee210417  fail
                                        }
                                    }
                                }
                            }
                            /////////////////////////////////////////////////////////////////////////////// 

#ifdef __JTECH__CUSTOMER   //SYLEE201012
                            if ((nFlagRunMode1 == 2) || (nManualStartFlag == 1))//syle201012
                            {
                                if (nRetryEndSet == 1) {//sylee200928
                                    if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg >= 10) {//sylee201006    //son211005

                                        if ((Sub71.R1 < (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 0.95))          //son211005
                                            || (Sub71.R1 > (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 1.05))) {        //son211005
                                            if ((fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR4w1_old1)) < (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1))) {      //son211005
                                                Sub71.R1 = dR4w1_old1;
                                            }
                                            else {
                                                dR4w1_old1 = Sub71.R1;
                                            }
                                            if (n4W_Retry4++ < 3) {//sylee201006 5->3
                                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 5)) {//sylee210414
                                                    if (nNGRetryCo1++ < 100) {//sylee201012 
                                                        goto Task1700_beforeOnPinSet;  //son230807
                                                    }
                                                }
                                                else {
                                                    if (nNGRetryCo1++ < 5) {//sylee210414 
                                                        goto Task1700_beforeOnPinSet;  //son230807
                                                    }
                                                }
                                            }
                                            else {
                                                nNGRetryCo1 = nNGRetryCo1;
                                            }
                                        }
                                    }
                                }
                            }

#endif

                            ///////////////////////////////////////////////////////////////////////////////                                
                            //son R 값이 0.01 이하로 너무 작으면 
                            if (Sub71.R1 < dMinR1) //sylee200506    
                            {
                                if (n4W_Retry3 < 3) {//sylee200506 
                                }
                                else 
                                {
                                    if ((g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1) && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee230213
                                        Sub71.R1 = 8888887;//sylee200506    //son R 값이 0.01 이하로 너무 작다고 에러 표시.
                                    }
                                    int t1, t2, t3, t4;
                                    if (m_nMode1 == 171 || m_nMode1 == 176) //sylee211222 //SYLEE220312ADD2 4w  4w  0.1보다 작은 경우 999999 open으로 표시되던 것을   
                                    {                                                 //                    pin  4개  다 접촉되어 있으면 0.1정도로 표시하도록 수정. 
                                        if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 10) 
										{
                                            Sub71.OnPinAllReset1();
                                            t1 = n4WNet[net][_4W_PIN2] - 1;           
											t2 = n4WNet[net][_4W_PIN3] - 1;
                                            t3 = n4WNet[net][_4W_PIN1] - 1;           
											t4 = n4WNet[net][_4W_PIN4] - 1;

                                            Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                            Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                            Sub71.Delay_100ns(nDelay10);
                                            Sub71.AOnReadV1I1(5);

                                            // if( (Sub71.Y1>(nISet*0.8))  &&  (Sub71.W1<0.5)){
                                            if (Sub71.Y1 > (nISet * 0.8)) {
                                                Sub71.OnPinAllReset1();
                                                t1 = n4WNet[net][_4W_PIN1] - 1;      
												t2 = n4WNet[net][_4W_PIN4] - 1;
                                                t3 = n4WNet[net][_4W_PIN2] - 1;      
												t4 = n4WNet[net][_4W_PIN3] - 1;
                                                Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                                Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                                Sub71.Delay_100ns(nDelay10);
                                                Sub71.AOnReadV1I1(5);
                                                if (Sub71.Y1 > (nISet * 0.8)) {
                                                    Sub71.R1 = 0.09;
                                                }
                                            }
                                        }
                                    }  //SYLEE220312ADD2

                                }
                            }

                            //######################################################################################################
                            //sylee221213
                            //--------------------------------------------
                            double dSum1, dSum1I, dAver1, dAver1I, dDiff1, dDiffSum1, dVariance, dSigma;	//SYLEE221207

                            dSum1 = 0.0;  dSum1I = 0.0; dAver1 = 0.0; dAver1I = 0.0;  dDiff1 = 0.0;
                            dDiffSum1 = 0.0;  dVariance = 0.0; dSigma = 0.0, dAver1I = 0.0;

                            for (int i = 1; i <= d4wV[net][0]; i++) {
                                dSum1 += d4wV[net][i];
                                dSum1I += d4wI[net][i];
                            }
                            dAver1 = dSum1 / d4wV[net][0];   	   
                            dAver1I = dSum1I / d4wI[net][0];

                            for (i = 1; i <= d4wV[net][0]; i++) {
                                dDiff1 = d4wV[net][i] - dAver1; 	
                                dDiffSum1 += (dDiff1 * dDiff1);
                            }
                            dVariance = dDiffSum1 / d4wV[net][0];
                            dSigma = sqrt(dVariance);
                            d4wV[net][502] = dSigma;
                            //--------------------------------------------

                            double dAver2, dSum2, dLow2, dHigh2, dSigma2Percent, dSum2I, dAver2I;	//sylee221212
                            int  dSum2Co1;
                            int nTempStep1;   //sylee221227-test3

                            dAver2 = 0.0; dSum2 = 0.0; dSum2I = 0.0; dAver2I = 0.0;	dSum2Co1 = 0;
                            dLow2 = dAver1 - (dSigma * d4WADCSigma1);
                            dHigh2 = dAver1 + (dSigma * d4WADCSigma1);
                            nTempStep1 = d4wV[net][0] - Sub71.nADCount1 + 1;//sylee221227
                            if (nTempStep1 <= 0) {
                                nTempStep1 = 1;
                            }
                            //sylee221227 	for (  i=1; i<=d4wV[net][0]; i++)  	//sylee221212	
                            for (i = nTempStep1; i <= d4wV[net][0]; i++) { 	//sylee221212
                                if ((dLow2 <= d4wV[net][i]) && (d4wV[net][i] <= dHigh2)) {
                                    dSum2Co1++;
                                    dSum2 = dSum2 + d4wV[net][i];
                                    dSum2I = dSum2I + d4wI[net][i];
                                }
                            }

                            dAver2 = dAver1;//sylee221212
                            dAver2I = dAver1I;
                            if (dSum2Co1 > 0 && dSum2 > 0) { //sylee221212
                                dAver2 = dSum2 / dSum2Co1;
                                dAver2I = dSum2I / dSum2Co1;
                            }
                            if (d4wV[net][0] > 0) {
                                n4WAdcOK1[n4W_Retry1] = 1;//sylee221212-1
                            }
                            else { 
                                n4WAdcOK1[n4W_Retry1] = 0; //sylee221212-1
							}
                            if (nADCFail200 == 2) {
                                Sub71.W1 = 100.0;	    
                                Sub71.Y1 = 0.001;//sylee221212
                                n4WAdcOK1[n4W_Retry1] = 0;
                            }
                            else {
                                Sub71.W1 = dAver2;	
                                Sub71.Y1 = dAver2I;//sylee221212
                            }

                            //###################################################################################################### 

                            d4wIPo1 = 0.;	d4wVPo1 = 0.;  d4wNet1 = 0.;//sylee221206-2
                            n4W_Retry1++;//sylee200415 
                            if (n4W_Retry1 < nRetryEndSet) {//two measure
                                nPassCo1 = 0;//SYLEE221220-2 
                                goto Task1700_beforeOnPinSet;  //son230807
                            }

                            //####################################################################################################	
                            //sylee221206
                            //son MAP > Set2(HW Fast Mode Set) > "4W ADC% USE"가 ON이면 
                            if (SysSet16.m_nSet15 == 1)  
                            {
                                //sylee230223-5	if( nADCFail200==2 ||   d4wV[net][502]==0 )   //sylee230116  d4wV[net][502]==0
                                if (nADCFail200 == 2) {
                                    nRetry8++;
                                    if (nRetry8 < nSetRetry1 ) {  //sylee221222   3->6	//sylee230426-8					  	  
                                        nRetryEndSet = 2;
                                        nRetryEndSet = 1;//sylee221222 
                                        nPassCo1 = 0;//sylee221208  
                                        nRetryCount1++;
                                        nADCFail200 = 0;
                                        n4W_Retry1 = 0;//sylee221215
                                        goto Task1700_beforeOnPinSet;  //son230807

                                    }
                                    else {
                                        nADCNg[net] = 1;  
                                        nFail2[net] = 1;//sylee221222
                                        dR30Co1 = dR30[0][0];
                                        if ((g_s4WNet[dutIdx].saData[net - 1].dRefAvg > 10.) 
                                                && (g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1) 
                                                && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee230213
                                            Sub71.R1 = 777777.0;
                                        }
                                    }
                                    //==============================================================================================================================================

                                }
                                else //pass
                                {
                  //==============================================================================================================================================

                                    ::ZeroMemory(&nS2, sizeof(nS2));
                                    ::ZeroMemory(&dR101S1, sizeof(dR101S1));
                                    nS1Po1 = 0;//sylee230116 

                                    if (dR101[0] > 1) 
                                    {
                                        nS1Po2 = 0;  nS1Min1 = 999999.;  nS1Sum1 = 0.0;  nS1Max1 = 0;
                                        for (int k2 = 1; k2 <= dR101[0]; k2++) {
                                            nS1Po1 = 0;
                                            nS1Sum1 = nS1Sum1 + dR101[k2];
                                            nS1Max2 = 0;
                                            if (dR101[k2] < nS1Min1) { nS1Min1 = dR101[k2]; }
                                            if (dR101[k2] > nS1Max1) { nS1Max1 = dR101[k2]; }
                                        }

                                        if (dR101[0] == 2) {
                                            Sub71.R1 = (dR101[1] + dR101[2]) / 2.0; //sylee230223
                                        }
                                        else if (dR101[0] > 2) {
                                            Sub71.R1 = (nS1Sum1 - nS1Max1 - nS1Min1) / (double)(dR101[0] - 2); //sylee230223
                                        }

                                        int nHalfPo1;
                                        nHalfPo1 = dR101[0] / 2;

                                        if (Sub71.R1 < 5) {
                                            dDiffR1 = nS1Max1 - nS1Min1;
                                            dNgPercent = 2.; //sylee230223
                                        }
                                        else { //sylee221215
                                            dDiffR1 = (nS1Max1 - nS1Min1) / Sub71.R1 * 100.;
                                            dNgPercent = 5; //sylee230223
                                        }

                                        //##################################################################################################
                                     

                                        if (dDiffR1 > dNgPercent) 
                                        {
                                            nRetry9++;
                                            if (nRetry9 < nSetRetry1 ) {  //sylee221222   3->6    //sylee221227-test4  //sylee230426-8

												nRetryCount1++;
                                                nRetryEndSet = 2;
                                                nRetryEndSet = 1;//sylee221222 
                                                nPassCo1 = 0;//sylee221208                                                
                                                nADCFail200 = 0;
                                                n4W_Retry1 = 0;//sylee221215
                                                //  Sub71.Delay_100ns(10000); //1mS //SYLEE221216-DEBUG
                                                if (nRetryCount10 == 0) {
                                                    for (int nkk1 = 1; nkk1 <= 10; nkk1++) {
                                                        Sub71.Delay_100ns(2);
                                                        if ((nkk1 % 2) == 0) {//sylee221205-2
                                                            Sub71.AOnPinSet1(2, nPinNo[3], 1);   //USER PIN  2 //sylee221203
                                                            Sub71.AOnPinSet1(2, nPinNo[4], 1);   //USER PIN  3 //sylee221203
                                                            Sub71.AOnPinSet1(2, nPinNo[1], 2);   //USER PIN  1 //sylee221203
                                                            Sub71.AOnPinSet1(2, nPinNo[2], 2);	 //USER PIN  4 //sylee221203
                                                        }
                                                        else {  //sylee221205-2
                                                            Sub71.AOnPinSet1(2, nPinNo[3], 2);   //USER PIN  2  //sylee221205-2
                                                            Sub71.AOnPinSet1(2, nPinNo[4], 2);   //USER PIN  3  //sylee221205-2
                                                            Sub71.AOnPinSet1(2, nPinNo[1], 1);   //USER PIN  1  //sylee221205-2 												
                                                            Sub71.AOnPinSet1(2, nPinNo[2], 1);	 //USER PIN  4  //sylee221205-2
                                                        }
                                                        Sub71.Delay_100ns(500);		Sub71.OnPinAllReset1();
                                                    }                                                   
                                                    nRetryCount10++;
                                                }
                                                 goto Task1700_beforeOnPinSet;	 //son230807											 
                                            }

                                        }

                                    }

                                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                }

                            }

                            else  //sylee221209
                            {



                             //sylee221215-1  dSigma2Percent= dSigma/dAver2*100.;
                                dSigma2Percent = (2 * dSigma) / dAver2 * 100.;
                                dSigma = dSigma2Percent;

                                //==============================================
                                if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 10) {//sylee221212 
                                    dSigmaSet = (d4WADCPer1);//sylee221212 
                                }
                                else if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 45) {//sylee221212 
                                    dSigmaSet = (d4WADCPer2);//sylee221212 
                                }
                                else {
                                    dSigmaSet = (d4WADCPer3);//sylee221212 
                                }
                                //==============================================

                                if (dSigma > dSigmaSet) {//sylee221207    
                                    nRetry8++;
                                    if (nRetry8 < 12) {   //sylee221213  1->3  //sylee221222   3->6   //sylee221227-test4

                                        nRetryEndSet = 2;
                                        nRetryEndSet = 1;//sylee221222 
                                        nPassCo1 = 0;//sylee221208
                                        nRetryCount1++;
                                        n4W_Retry1 = 0;//sylee221215  

                                        goto Task1700_beforeOnPinSet; //son230807

                                    }
                                    else {
                                        nADCNg[net] = 1; 	  
                                        nFail2[net] = 1;//sylee221222			

                                        if ((g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1) && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee230213

                                            Sub71.R1 = 777777.0;
                                        }
                                        dR30Co1 = dR30[0][0];

                                    }
                                }

                            }




                            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                            nRetry8 = 0;//sylee221215


                            if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL)//sylee200525  //sylee201018  0->1
                            {                                                   //son201117 1 -> _4W_SET_NORMAL
                                if (n4w_Measure1_Enable == 1) {
                                    if (Sub71.R1 < 1.0) {
                                        d4W_Percent5 = 22.5;
                                    }
                                    else if (Sub71.R1 < 10.0) {
                                        d4W_Percent5 = 13.5;
                                    }
                                    else { d4W_Percent5 = 2.7; }

                                    if ((nRetryEndSet == 1) && (n4W_Retry1 == 1)) {//sylee200420-1
                                        if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0) {//SYLEE220205 //SYLEE220312ADD
                                            dDiffRate2 = fabs(Sub71.R1 - g_s4WNet[dutIdx].saData[net - 1].dRefAvg) / g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 100.; //ref.=gd4W1[i+5][6]   //son211005
                                            if (dDiffRate2 > d4W_Percent5) {//3%
                                                nRetryEndSet = 2;
                                                goto Task1700_beforeOnPinSet;  //son230807
                                            }
                                        }
                                    }

                                }
                                else {//auto pcb
                                    if ((nRetryEndSet == 1) && (n4W_Retry1 == 1)) {//sylee200420-1
                                        if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0) {//SYLEE220205 //SYLEE220312ADD
                                            if ((Sub71.R1 < g_s4WNet[dutIdx].saData[net - 1].dRefLow)
                                                || (Sub71.R1 > g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {
                                                nRetryEndSet = 2;

                                                str.Format(" case11  , if ((Sub71.R1 < g_s4WNet[dutIdx].saData[net - 1].dRefLow)  || (Sub71.R1 > g_s4WNet[dutIdx].saData[net - 1].dRefHigh))  ");		
                                                LogDebug2(str);
                                                goto Task1700_beforeOnPinSet;  //son230807
                                            }
                                        }
                                    }
                                }

                            }


                            //////////////////////////////////////////////////////////////////////////////////
                            //  if(SysInfo05.m_n4WSet1>0)//sylee200525
                            if ((nRetryEndSet == 2) && (n4W_Retry1 == 2))//sylee200420-1
                            {
                                Sub71.R1 = (n4WData1[net][0] + n4WData1[net][1]) / 2.;
                                dDiffRate2 = fabs(n4WData1[net][0] - n4WData1[net][1]) / Sub71.R1 * 100.;

                                if (Sub71.R1 < 1.0) {
                                    d4W_Percent5 = 22.5;
                                }
                                else if (Sub71.R1 < 10.0) {
                                    d4W_Percent5 = 13.5;
                                }
                                else { 
									d4W_Percent5 = 2.7; 
								}


                                if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL)//sylee200525   //sylee201018  0->1
                                {                                                      //son201117 1 -> _4W_SET_NORMAL
                                    if (dDiffRate2 >= d4W_Percent5)  //=3
                                    {
                                        nCo11++;
                                        nRetryEndSet = 4;
                                        str.Format(" case12  , (dDiffRate2 >= d4W_Percent5)   dDiffRate2=%.2f,    ", dDiffRate2);		LogDebug2(str);
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                            }

                            ///////////////////////////////////////////////////////////////////////////////
                                                       // double   dSum1;
                            if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL) {//sylee200525  //sylee201018  0->1
                                if (n4W_Retry1 == 4) {//sylee200420-1               
                                    dMin1 = 0.0;  dMax1 = 0.0; dSum1 = 0.0;
                                    for (int nL1 = 0; nL1 < 4; nL1++) {
                                        if (nL1 == 0) { dMin1 = n4WData1[net][0];  dMax1 = n4WData1[net][0]; }
                                        if (dMin1 > n4WData1[net][nL1]) {
                                            dMin1 = n4WData1[net][nL1];
                                        }
                                        else if (dMax1 < n4WData1[net][nL1]) {
                                            dMax1 = n4WData1[net][nL1];
                                        }
                                        dSum1 += n4WData1[net][nL1];
                                    }
                                    Sub71.R1 = (dSum1 - (dMin1 + dMax1)) / 2.;
                                }
                            }



                            double dOffsetRate1, dFiterRate1;

                            if (SysSet19.m_nSet39 > 0) {
                                dFiterRate1 = (double)SysSet19.m_nSet39 / 10.;
                            }
                            else { dFiterRate1 = 0.5; }


                            //sylee230223     //type2 
                            dOffsetRate1 = dFiterRate1;  //sylee230124
                            if (Sub71.R1 <= 300) 
							{
                                if (Sub71.R1 <= 5.0) { d4W_RoffSet2 = d4W_Noise1; }//0.7  
                                else if (Sub71.R1 < 10.0) { d4W_RoffSet2 = d4W_Noise2; }//0.5 
                                else { d4W_RoffSet2 = d4W_Noise3; }//0.5

                                dRef4wR1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;//ref.  //son211005 dSetAvg -> dRefAvg
                                dDiffR1 = Sub71.R1 - dRef4wR1;   dDiffR2 = fabs(dDiffR1);

                                if (dDiffR2 <= d4W_RoffSet2) {
                                    Sub71.R1 = dRef4wR1 + (dDiffR1 * dOffsetRate1); //  /20.
                                }
                                else {
                                    if (dDiffR1 > 0) {
                                        Sub71.R1 = Sub71.R1 - d4W_RoffSet2;   //d4W_RoffSet2  0.5mohm
                                    }
                                    else { Sub71.R1 = Sub71.R1 + d4W_RoffSet2; }
                                }

                            }


                        }

                        else  //4WSETUP140107
                        {



Task2700://sylee180823-1

                            if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 20.0) {//sylee180320-2       //son210223 1-> _4W_PIN1 enum 占쏙옙占쏙옙  //son211005
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 4);   //sylee180205 //VC  RELAY PinNo(0~8k)   //sylee170523-3               
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);  //sylee180205  //VB  RELAY PinNo(0~8k)  //sylee170523-3       
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 2);  //sylee180205  //VB  TR PinNo(0~8k)  //sylee160603-1   
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);   //sylee160603-1     //
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);  //sylee180205  //VC  TR PinNo(0~8k)   //sylee160603-1      
                            }
                            else {

                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 4);   //sylee180205 //VC  RELAY PinNo(0~8k)   //sylee170523-3               
                                //  Sub71.Delay_100ns(1500);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);  //sylee180205  //VB  RELAY PinNo(0~8k)  //sylee170523-3       
                                //  Sub71.Delay_100ns(1500);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 2);  //sylee180205  //VB  TR PinNo(0~8k)  //sylee160603-1   
                                //  Sub71.Delay_100ns(300);   //sylee160603-1     //
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);  //sylee180205  //VC  TR PinNo(0~8k)   //sylee160603-1      
                            }
                            calPart = FileSysInfo01.checkUseCalDataPart(n4WNet[net][_4W_PIN3] - 1, n4WNet[net][_4W_PIN4] - 1);    //son220419_2

                            Sub71.Delay_100ns(nDelay10);
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (n4W_IDropCheck1(net) == -1) { //sylee180823-1 //sylee180912-1
                                    goto Task2700;//sylee180823-1
                                }
                            }

                            //son Sub71.R1  계산 (R = VC / I)
                            ARun201_4w_R2(nISet, n4W_Retry1);  //sylee200909

                            //son Sub71.R1 R값 변환  (raw R -> real R. 4W는 real R 로 판정)
                            ARun201_4w_R_Cal1(m_nMode1, calPart);//sylee150710   //son220412

                            nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET  
                            if (nRet1 != 1) {
                                AfxMessageBox(" Errro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,   4W Run Start Error!!!");
                                return 0;
                            }
                        }

                        if (Sub71.R1 > dRoffset2) {//sylee180704-5
                            Sub71.R1 = Sub71.R1 - dRoffset1;
                        }

                        if (Sub71.W1 <= 0.0) { //sylee150713  import.
                            Sub71.R1 = 9999995; //sylee150713  import.
                        } //sylee150713  import.

                        if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                            if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                                Sub71.R1 = 9999996;
                            }
                            if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                                Sub71.R1 = 9999997;
                            }
                        }

                    }
                    else {//sylee131119
                        if ((g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1) && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee230213
                            Sub71.R1 = 9999998; //sylee131119
                        }
                    }//if(nPos1[net]!=2){//sylee131112


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//sylee230224
                    double dTemp7, dTemp8, dTemp9;//sylee230308-1


                    if (SysSet19.m_n4W_Data_Flag3 != 1) { //sylee230301-1
                        nFail3[net] = 0;  //sylee230303-1 
                    }

                    //SysSet19.m_n4W_Data_Flag3=1;

                    if (SysSet19.m_n4W_Data_Flag3 == 1)  //sylee230301-1
                    {

                        if (nFlag_d4W_Data1_Retry == 0) //sylee230224
                        {
                            dTemp7 = fabs(d4W_Data1[net] - Sub71.R1);
                            if (doldR2 > 0) {
                                dTemp8 = fabs(d4W_Data1[net] - doldR2);
                            }
                            else {
                                dTemp8 = fabs(d4W_Data1[net] - 99999999.);
                            }

                            if (fabs(d4W_Data1[net]) < 10) {
                                if (dTemp7 >= dSetR1) {
                                    nd4W_Data1Co1++;
                                    if (dTemp8 < dTemp7) { Sub71.R1 = doldR2; }//sylee230308

                                    if (nd4W_Data1Co1 < 2) {
                                        doldR2 = Sub71.R1;
                                        nFlag_d4W_Data1_Retry = 1;//sylee230224	

                                        if (n4w_Sample_Enable != 1) {//sylee230426-1 
										//	if(nNgNetOld1<=nNgNetMax1){
										//		 if( nNgNetOld1!=net){//sylee230426-1
										//			 nNgNetCo1++; nNgNetOld1=net;//sylee230426-1
										//		 }	
										 //sylee230426-8	if(nSamePcbFlag>1){												
	                                        if(nManual4WStartFlag1==1){//sylee230426-8
											 	 goto Task1700_beforeOnPinSet;	//sylee230417-1  //son230807
											}
										//	}
										}

                                    }
                                }
                                else {
                                    nFail3[net] = 0;  //sylee230301-1 
                                }                           }
                            else {
                                dTemp9 = dTemp7 / d4W_Data1[net] * 100.0;
                                if (dTemp9 >= dSetR1Per1) {
                                    nd4W_Data1Co1++;
                                    if (dTemp8 < dTemp7) { Sub71.R1 = doldR2; }//sylee230308

                                    if (nd4W_Data1Co1 < 2) {
                                        doldR2 = Sub71.R1;
                                        nFlag_d4W_Data1_Retry = 1;//sylee230224 

                                        if (n4w_Sample_Enable != 1) {//sylee230426-1 
										//	if(nNgNetOld1<=nNgNetMax1){
										//		 if( nNgNetOld1!=net){//sylee230426-1
										//			 nNgNetCo1++; nNgNetOld1=net;//sylee230426-1
										//		 }	
										 //sylee230426-8	if(nSamePcbFlag>1){
											if(nManual4WStartFlag1==1){//sylee230426-8
											 	 goto Task1700_beforeOnPinSet;	//sylee230417-1 //son230807
											}
										//	}
										}
                                    }
                                }
                                else {
                                    nFail3[net] = 0;  //sylee230303-1 
                                }
                            }

                        }
                        else 
                        {

                            nFlag_d4W_Data1_RetryCo1++;//sylee230224
                            d4W_Data1Retry[nFlag_d4W_Data1_RetryCo1] = Sub71.R1;//sylee230214-1

                            if (nFlag_d4W_Data1_RetryCo1 < 3) {
                                goto Task1700_beforeOnPinSet; //son230807
                            }

                            //   Sub71.Delay_100ns(30000);  //3mS 
                            for (int i = 1; i <= 3; i++) {
                                if (i == 1) {
                                    dMin1 = d4W_Data1Retry[i];
                                    dMax1 = d4W_Data1Retry[i];
                                    dSum1 = d4W_Data1Retry[i];
                                    continue;
                                }
                                if (d4W_Data1Retry[i] < dMin1)    dMin1 = d4W_Data1Retry[i];
                                if (d4W_Data1Retry[i] > dMax1)    dMax1 = d4W_Data1Retry[i];
                                dSum1 = dSum1 + d4W_Data1Retry[i];
                                if (i == 3) {
                                    Sub71.R1 = dSum1 - dMin1 - dMax1;
                                }
                            }

                            //###############################################################################################################


                            if ((Sub71.R1 != 0.0) && (Sub71.R1 < 100000) && (fabs(d4W_Data1[net]) < 100000.) && (fabs(d4W_Data1[net]) != 0.0)) 
                            {
                                dTemp7 = fabs(d4W_Data1[net] - Sub71.R1);
                                if (fabs(d4W_Data1[net]) < 10) {
                                    if (dTemp7 >= dSetR1) {
                                        nFail3[net] = 1;  //sylee230303-1 
                                    }
                                    else {
                                        nFail3[net] = 0;  //sylee230303-1 
                                    }
                                }
                                else {
                                    dTemp7 = dTemp7 / d4W_Data1[net] * 100.0;
                                    if (dTemp7 >= dSetR1Per1) {
                                        nFail3[net] = 1;  //sylee230303-1 

                                    }
                                    else {
                                        nFail3[net] = 0;  //sylee230301-1
                                    }
                                }
                            }
                        }

                    }
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                    //son min, max 값 생성 
                    if (Kcount > 2) {
                        if (k == 0) { 
							dR14w[11][net] = Sub71.R1; //min           
							dR14w[12][net] = Sub71.R1; //max
						}
                        else {
                            if (dR14w[11][net] > Sub71.R1) { 
								dR14w[11][net] = Sub71.R1; //min
							}
                            if (dR14w[12][net] < Sub71.R1) { 
								dR14w[12][net] = Sub71.R1; //max
							}
                        }
                    }


                    dR14w[j + 5][net] = Sub71.R1;   //R1;//sylee230307
                    dVB14w[j + 5][net] = Sub71.V1;  //vb
                    dVC14w[j + 5][net] = Sub71.X1;  //vc
                    dI14w[j + 5][net] = Sub71.Y1;   //i

                }// for( k=0; k<Kcount; k++)//sylee131112



                //-------------------------------------------------------------------
                //son d4WSet2(Ref.Low) 값을 n4wLowRetryPer1를 반영해서  결정한다.
                double d4wSet1, d4wSet2;//sylee171101-1
                d4wSet1 = 0;  d4wSet2 = 0;//sylee171101-1

                if (g_s4WNet[dutIdx].saData[net - 1].dRefLow > g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {    //son211005
                    d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5 //son211005
                }
                else if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh < g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {//son211005
                    d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5 //son211005
                }
                else {
                    d4wSet1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg * n4wLowRetryPer1;//sylee171104-5
                }

                if (g_s4WNet[dutIdx].saData[net - 1].dRefLow < d4wSet1) {    //son211005
                    d4wSet2 = d4wSet1;
                }
                else {
                    d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;    //son211005
                }

                if (n4wLowRetryPer1 == 0.0) {//sylee171104-5
                    d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;//sylee171104-5 //son211005
                }


                if (n4w_Sample_Enable == 1) {//sylee230415
                    dLowR10 = 0.01;  
                    d4wSet2 = dLowR10;	 
                    dHighR10 = MAX_4W_R;//sylee230415
                }
                else {
                    dLowR10 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;
                    dHighR10 = g_s4WNet[dutIdx].saData[net - 1].dRefHigh;//sylee230415
                }

                //--------
                //양품    
                //son Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                if ((Sub71.R1 != 0.0) && (d4wSet2 <= Sub71.R1) && (Sub71.R1 <= dHighR10)) {  //sylee230415
                    nRetryCo1 = 0;//sylee150721
                    n4W_Pass[net] = 1;
                }
				//--------
                //불량
                else //sylee150721
				{
                    nRetryCo1++;//sylee150721
                    if (nRetryCo1 < nRetrySet) {//sylee150721
                        goto Task1311;//sylee150721
                    }
                    t1 = n4WNet[net][_4W_PIN1];//sylee170304     //son210223 1-> _4W_PIN1 enum 
                    // t2=nPieceNoPin[1][t1];//PIECE  piece no      //sylee170304
                    t2 = nPinToPiece(t1);//SYLEE171225-2
                    n4w_Fail1_Piece[t2]++;//sylee170304

                }

                //son R 값이 0.01 이하로 너무 작으면
                if (Sub71.R1 < dMinR1) //sylee200506     
                {
                    if ((g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1) && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee230213
                        Sub71.R1 = 8888887;//sylee200506  //son R 값이 0.01 이하로 너무 작다고 에러 표시. 
                    }

                    ////////////////////////////////////////////////////////////////////////////////////////////////
                    int t1, t2, t3, t4;
                    if (m_nMode1 == 171 || m_nMode1 == 176)//sylee211222 //SYLEE220312ADD2 4w  0.1보다 작은 경우 999999 open으로 표시되던 것을    
                    {                                      //                  pin  4개  다 접촉되어 있으면 0.1정도로 표시하도록 수정.
                        if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 10) {
                            Sub71.OnPinAllReset1();
                            t1 = n4WNet[net][_4W_PIN2] - 1;
                            t2 = n4WNet[net][_4W_PIN3] - 1;
                            t3 = n4WNet[net][_4W_PIN1] - 1;
                            t4 = n4WNet[net][_4W_PIN4] - 1;

                            Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                            Sub71.Delay_100ns(nDelay10);

                            Sub71.AOnReadV1I1(5);

                            // if( (Sub71.Y1>(nISet*0.8))  &&  (Sub71.W1<0.5)){
                            if (Sub71.Y1 > (nISet * 0.8)) {

                                Sub71.OnPinAllReset1();

                                t1 = n4WNet[net][_4W_PIN1] - 1;
                                t2 = n4WNet[net][_4W_PIN4] - 1;
                                t3 = n4WNet[net][_4W_PIN2] - 1;
                                t4 = n4WNet[net][_4W_PIN3] - 1;

                                Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                Sub71.Delay_100ns(nDelay10);

                                Sub71.AOnReadV1I1(5);
                                if (Sub71.Y1 > (nISet * 0.7)) {//sylee221227   0.8  ->0.7  
                                    Sub71.R1 = 0.09;
                                }
                            }
                        }
                    } //SYLEE220312ADD2

                }


                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              
                if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg > 10) 
                {
                    if ((0.0 < Sub71.R1) && (Sub71.R1 < 200000)) {
                        if (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1) > (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 0.1)) {
                            n4WNg1[net] = 2; //sylee230116-1-debug
                        }
                    }

                    if ((0.0 < dR14w[6][net]) && (dR14w[6][net] < 200000)) {
                        if (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR14w[6][net]) > (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 0.1)) {
                            n4WNg1[net] = 2; //sylee230116-1-debug
                        }
                    }

                }
                else 
                {
                    if ((0.0 < Sub71.R1) && (Sub71.R1 < 200000)) {
                        if (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1) > (1.0)) {
                            n4WNg1[net] = 2; //sylee230116-1-debug
                        }
                    }
                    if ((0.0 < dR14w[6][net]) && (dR14w[6][net] < 200000)) {
                        if (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR14w[6][net]) > (1.0)) {
                            n4WNg1[net] = 2; //sylee230116-1-debug
                        }
                    }
                }
          

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            }  //for (int net2 = 1; net2 <= nEnd; net2++) 


        }//  fOR J   //SYLEE170304
        //########################################################################################
        //1차의  마지막 부분 


 		//########################################################################################
        //2차 검사 
        nZeroCo2 = 0;//sylee180520-1

        //=====================
        //양품 판정 
        //=====================           
        for (net = 1; net <= nEnd; net++)
        {

            //	if(n4W_RunStep==0){//sylee221226

            if (nFlag_Fail_Full != 1) {//sylee160528-5   
                if (dRec4w[mode][1] != n4WNet[net][_4W_MODE]) {// RECIPE NO SEARCH  //sylee13111\28
                    continue;
                }
            }
            else { //sylee160528-5

                if (n4W_RunStep != 1 && n4W_RunStep2 != 1) {//sylee230124   //sylee230301
                    if (dRec4w[mode][1] < n4WNet[net][_4W_MODE]) { //sylee160528-5
                        continue;
                    }
                }
                if (ng4WResult_2[net] == 3) {//sylee160528-5  //  fail  mohm detect
                    continue;
                }
            }

            t1 = n4WNet[net][_4W_PIN1];
            //  t2=nPieceNoPin[1][t1];//PIECE  piece no
            t2 = nPinToPiece(t1);//SYLEE171225-2 

            //son Skip해야할  Piece인지 확인.
            if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                    continue;
                }
            }

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {//sylee131022
                if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                    continue;
                }
            }

            if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                continue;
            }

            if ((nAutoReTest[nBlockCountP] != 0) && (SysSet211.m_nDisable4wRetest == 1)) {  //sylee180521-1  //son220503
                //sylee180529-1 if( nOpenFail14W[t2] >0){
                if (n4wFail1Old[t2] > 0) {//sylee180529-1
                    continue;
                }
                if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {//sylee180529-1
                    continue;
                }
            }

            if (ng4WResult[net] == 2) {//sylee131022//pass
                continue;
            }

#if 0   	//son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet       
                int tmp1;
                tmp1 = n4WNet[net][_4W_PIN1];    //son210223 1-> _4W_PIN1 enum 
                // tmp1=nPieceNoPin[1][tmp1];
                tmp1 = nPinToPiece(tmp1);//SYLEE171225-2

                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][tmp1];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];

                //son 해당 piece가 PASS 상태인 Cell이면 4W 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif  //son220803 end

            //son240111 ARun201_4W_New_230420() 사용하는 CCTC 현장에서 4W Csv로그에 
            //          NG339615136492207130000000000000000000000.00  출력되는 문제 관련하여
            //          ARun201_4W_Old_230420() 와 동일하게 다음 코드 추가.
            if (dR14w[6][net] <= 0) {       //son240111 
                //sylee200507    dR14w[6][net]=0.01;
                dR14w[6][net] = 9999999;    //son240111 
            }
 
            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            double d4wSet1, d4wSet2;//sylee171101-1
            d4wSet1 = 0;//sylee171101-1
            d4wSet2 = 0;//sylee171101-1

            if (g_s4WNet[dutIdx].saData[net - 1].dRefLow > g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {     //son211005
                d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5      //son211005
            }
            else if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh < g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {   //son211005
                d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5       //son211005
            }
            else {
                d4wSet1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg * n4wLowRetryPer1;//sylee171104-5
            }

            if (g_s4WNet[dutIdx].saData[net - 1].dRefLow < d4wSet1) {     //son211005
                d4wSet2 = d4wSet1;
            }
            else {
                d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;     //son211005
            }

            //son d4wSet2에  RefLow(하한값) 설정
            if (n4wLowRetryPer1 == 0.0) {//sylee171104-5
                d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;//sylee171104-5      //son211005
            }


            int n4W_Pass1;//1= pass. 2=fail, 3 ful scale//sylee160528-5
 

            n4W_Pass1 = 0; //sylee160606-1  import

          //  if (n4w_Sample_Enable == 1) {
           //     dLowR10 = 0.01;
           //     dHighR10 = MAX_4W_R;//sylee230415
           // }
          //  else {
                dLowR10 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;
                dHighR10 = g_s4WNet[dutIdx].saData[net - 1].dRefHigh;//sylee230415
          //  }


            if (nFlag_Fail_Full != 1) {//sylee160528-5
                //-------
                //양품  
                if ((dR14w[6][net] != 0.0) && (dLowR10 <= dR14w[6][net]) && (dR14w[6][net] <= dHighR10)) //sylee230213-3
                {
                    n4W_Pass1 = 1;	// Pass
                }
                else {
                    n4W_Pass1 = 2;    // fail
                }

            }
            else// full scale
            {

                //son 현재 지정 4W mode와 현재 net의 모드가 같을 때  
                if (dRec4w[mode][1] == (int)g_s4WNet[dutIdx].saData[net - 1].n4wMode)   //sylee160611-2 import
                {

                    //---------------
                    //son 양품 판정
					//son dR14w[6][net] 는 R 값. R값이 Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                    if ((dR14w[6][net] != 0.0) && (dLowR10 <= dR14w[6][net]) && (dR14w[6][net] <= dHighR10)) //sylee230213-3
                    {
                        n4W_Pass1 = 1; //pass log
                        ng4WResult_2[net] = 3;//pass detect    //son ??? 양품인데 왜 3 ???
                        g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug     
                    }

                    //---------------
                    //son 불량 판정
                    else 
					{
						//son 전압 mode Recipe의  MaxR 보다 작으면
                        if ((dR14w[6][net] != 0.0) && (dR14w[6][net] <= dRec4w1[mode][3])) {//fail  //sylee160611-2 import

                            n4W_Pass1 = 2; //fail

                           // if (n4w_Sample_Enable == 1) {//sylee230415
                            //    if ((dR14w[6][net] > 0.0) && (dR14w[6][net] < MAX_4W_R)) {////sylee230415
                             //       n4W_Pass1 = 1; //pass log
                             //   }
                           // }

                            ng4WResult_2[net] = 3;//pass detect                       
                            g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                        }
                        else {//sylee160602-1- very import.    //sylee160611-2 import
                            if (mode == nEndStep1) { //end mode//sylee160602-1- very import.   //sylee160708 
                                n4W_Pass1 = 2; //fail

                            //    if (n4w_Sample_Enable == 1) {//sylee230415
                            //        if ((dR14w[6][net] > 0.0) && (dR14w[6][net] < MAX_4W_R)) {////sylee230415
                            //            n4W_Pass1 = 1; //pass log
                             //       }
                             //   }
                                ng4WResult_2[net] = 3;//pass detect                       
                                g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                            }
                        }
                    }
                }


                //son 현재 지정 4W mode와 현재 net의 모드가 다를 때  
                else
                {
                    //---------------
                    //son 양품 판정
                    //---------------
                    if ((dR14w[6][net] != 0.0) && (g_s4WNet[dutIdx].saData[net - 1].dRefLow <= dR14w[6][net])
                        && (dR14w[6][net] <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh))
                    {
                        n4W_Pass1 = 1; //pass log
                        ng4WResult_2[net] = 3;//pass detect        //son ??? 양품인데 왜 3 ???           
                        g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                    }

                    //---------------
                    //son 불량 판정
                    //---------------
                    else  //sylee160611-2 import
                    {

                        if ((dR14w[6][net] != 0.0) && (dR14w[6][net] <= dRec4w1[mode][3])) {//fail
                            n4W_Pass1 = 2; //fail
                          //  if (n4w_Sample_Enable == 1) {//sylee230415
                          //      if ((dR14w[6][net] > 0.0) && (dR14w[6][net] < MAX_4W_R)) {////sylee230415
                          //          n4W_Pass1 = 1; //pass log
                          //      }
                          //  }
                            ng4WResult_2[net] = 3;//pass detect                       
                            g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                        }
                        else {//sylee160602-1- very import. 
                            if (mode == nEndStep1) { //end mode//sylee160602-1- very import.   //sylee160708 
                                n4W_Pass1 = 2; //fail
                            //    if (n4w_Sample_Enable == 1) {//sylee230415
                             //       if ((dR14w[6][net] > 0.0) && (dR14w[6][net] < MAX_4W_R)) {////sylee230415
                              ///          n4W_Pass1 = 1; //pass log
                              //      }
                              //  }
                                ng4WResult_2[net] = 3;//pass detect                       
                                g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug     
                            }
                        }
                    }

                }  //end of if( dRec4w[ik][1]==n4WNet[net][_4W_MODE])
                //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

            } // // end of     if( nFlag_Fail_Full!=1 )//sylee160528-5

            //###############################################################################3
 
            //son221025 Sheet Retest 일때 블록별 초기화를 하지 않는 대신 d4W_Log1[nBlockCountP][net]을 먼저 9999981로 초기화하는 기능 추가.
            if (nReSheetFlag1 == 1)
                d4W_Log1[nBlockCountP][net] = (float)9999981;     //son2201025

            //son 양품인 R 값을   d4W_Log1[nBlockCountP][net]에 저장. 
            if (n4W_Pass1 == 1) {//sylee160528-5
                ng4WResult[net] = 2;//sylee131022//pass
                d4W_Log1[nBlockCountP][net] = (float)dR14w[6][net];//sylee150722
            }

            //son 불량인 R 값을 마이너스 또는 9999982.0으로 d4W_Log1[nBlockCountP][net]에 저장.  
            else if (n4W_Pass1 == 2)//sylee160528-5
            {
                ng4WResult[net] = 3;  //son 3:fail      //son231026  NO_TEST, Pass, Fail 표시 정확히 하기 위해 3(불량) write 추가.

                if (dR14w[6][net] >= 200000) {//sylee171026-3
                    dR14w[6][net] = 9999982.0;//sylee160524-1
                }

#ifdef __SAVE_4W_SAMPLING_TIME  //son231117
                //son GTS에서 4w pin이 많아서 sampling이 오래 걸리는 문제가 있었음.   
                //    __SAVE_4W_SAMPLING_TIME 기능 On일 때에만 불량이어도 sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하고
                //    Off 일 때에는 나노시스 고객처럼 튀는 값이 write된다고 불만갖지 않도록 불량으로 출력한다.
                if (n4w_Sample_Enable == 1) //sylee200903   //sylee201030
                    d4W_Log1[nBlockCountP][net] = (float)dR14w[6][net];//sylee200903
                
                else //sylee200903
                    d4W_Log1[nBlockCountP][net] = (float)-dR14w[6][net];//sylee160524-1
#else
                //son231101 나노시스문제점 수정. 
                //   4W sampling 수집시에 비정상적으로 큰 값이 Log4W_SAMPLE#_20221008_185246_ALL_Ok.CSV 파일에 wrtie되는 문제 
                //   불량이어도 sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하는게 문제였으므로 
                //   sampling도 일반 4W Csv와 동일하게 불량값을 마이너스로 write한다.
                d4W_Log1[nBlockCountP][net] = (float)-dR14w[6][net];   //son231101 
#endif

            }   //end of else   // fail    


        }// end of      for( net=1; net<=nEnd; net++)//양품 판정



        n4WFail1[0][0] = g_n4WFailCount;//total count fail



task2_NEXT_MODE:  //son240713

        Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018 


    }//for(mode=1; mode<=5; mode++) 


//#######################################################################################


    n4WnFail3Co1 = 0;


    if (nAutoReTest[nBlockCountP] == 0) //sylee230307 
    {
        //sylee230426-8  f (n4W_RunStep == 0) 
     	if((n4W_RunStep == 0) && (nManual4WStartFlag1==1))//sylee230426-8
        {
            if (n4W_RunStep2 < 2) //sylee230301   //goto  Task701; 
            {
                for (int net = 1; net <= nEnd; net++) 
                {
                    t1 = n4WNet[net][_4W_PIN1]; //sylee230308
                    t2 = nPinToPiece(t1);//sylee230308   
                    if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee230308
                        continue;
                    }

                    if ((nFail3[net] == 1) 
                            || (g_s4WNet[dutIdx].saData[net - 1].dRefLow > d4W_Log1[nBlockCountP][net]) 
                            || (d4W_Log1[nBlockCountP][net] > g_s4WNet[dutIdx].saData[net - 1].dRefHigh))	//sylee230306
                    {

                        if (n4WnFail3Co1 == 0) {
                            ::ZeroMemory(&nRetryMode, sizeof(nRetryMode)); //sylee230308
                        }

                        ng4WResult_2[net] = 0;
                        ng4WResult[net] = 0;//sylee230301
                        n4WnFail3Co1++;
                        nRetryNet1[net] = 1; //sylee230124
                        nModeTmp = n4WNet[net][_4W_MODE] - 170;//sylee230308
                        nRetryMode[nModeTmp] = 1;//sylee230308

                    }
                }

                if (n4WnFail3Co1 > 0) {
                    g_n4WFailCount = 0;//sylee230104
                    ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));  //sylee230104 
                    ::ZeroMemory(&nADCNg, sizeof(nADCNg));//sylee230124
                    ::ZeroMemory(&nFail2, sizeof(nFail2));//sylee230124
                    ::ZeroMemory(&nFail3, sizeof(nFail3));//sylee230124 		
                    n4W_RunStep2++;

                    Sleep(50);

                    goto  Task701;
                }

            }
        }

    }


    //#######################################################################################

    n4W_RunStep2 = 0;//sylee221222;
    n4WnFail2Co1 = 0;

    //sylee230426-8 if (n4W_RunStep == 0) {//sylee221222;
 	if((n4W_RunStep == 0) && (nManual4WStartFlag1==1))//sylee230426-8
    {
        ::ZeroMemory(&nRetryNet1, sizeof(nRetryNet1)); //sylee230124
        ::ZeroMemory(&nRetryMode, sizeof(nRetryMode)); //sylee230308

        for (int net = 1; net <= nEnd; net++) {

            t1 = n4WNet[net][_4W_PIN1]; //sylee230308
            t2 = nPinToPiece(t1);//sylee230308   
            if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee230308
                continue;
            }

            if (nFail2[net] == 1 || nPos1[net] == 2) {  //sylee221230
                nADCNg[net] = 0;
                n4WnFail2Co1++;
                nNet200 = net;
                ng4WResult_2[net] = 0;//sylee221228
                nRetryNet1[net] = 1; //sylee230124
                nModeTmp = n4WNet[net][_4W_MODE] - 170;//sylee230308
                nRetryMode[nModeTmp] = 1;//sylee230308
            }
        }

        if (n4WnFail2Co1 > 0) {
            g_n4WFailCount = 0;//sylee230104
            ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));  //sylee230104 
            ::ZeroMemory(&nADCNg, sizeof(nADCNg));//sylee230124
            ::ZeroMemory(&nFail2, sizeof(nFail2));//sylee230124 		
            n4W_RunStep = 1;
            goto  Task701;
        }

    }


    /////////////////////////////////////////////////////////////////////////////

    double d11[20];
    int nMinFlag1;


    if (n4W_RetryFlag1 == 2)//sylee210419/////
    {

        for (net = 1; net <= nEnd; net++)
        {
            nMinFlag1 = 0;
            d11[2] = d4W_Log1[nBlockCountP][net];					//son R
            if (d11[2] < 0) { 
                d11[2] = -d11[2]; 
                nMinFlag1 = -1; 
            }
            d11[3] = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;		//son RefAvg
            d11[6] = (d11[2]) - (d11[3]);//*0.15;//             	//son diff    : R - RefAvg
            d11[7] = d11[6] / d11[3] * 100.;//*0.15;             	//son diffRate: (R - RefAvg)/RefAvg * 100
            if (d11[7] < 0) { 
                d11[7] = -d11[7]; 
            }
            if (d11[7] <= 1) {
                d11[9] = d11[6] * 0.8;//sylee210420-1
            }
            else if (d11[7] <= 2) {
                d11[9] = d11[6] * 0.6;//sylee210420-1
            }
            else if (d11[7] <= 30) {
                d11[9] = d11[6] * 0.3;//sylee210420-1
            }
            else { 
                d11[9] = d11[6] * 0.8; 
            }
            d4W_Log1[nBlockCountP][net] = d11[3] + d11[9];
            if (nMinFlag1 == -1) { 
                if (d4W_Log1[nBlockCountP][net] > 0) { 
                    d4W_Log1[nBlockCountP][net] = -d4W_Log1[nBlockCountP][net]; 
                } 
            }

        }

    }

    //sylee191127
    //==========================================================================================================

    tStart1001 = GetuSecond();//SYLEE150701

    nRelay1OffSkip = 0;//sylee170424-1
    Sub71.On4WireMode(0);
    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704 
    Sub71.OnPinResetInit();//sylee151221   //ACE400

    for (int w3 = 1; w3 <= nPieceMax; w3++) {
        n4wFail1Old[w3] = nOpenFail14W[w3];//SYLEE160604
    }

    //==========================================================================================================
    //sylee160605-1



    Sub71.AOnRelayOffSel(1);//SYLEE170314-1
    Sub71.OnRelayAllOff1();//sylee200131
    Sub71.OnCCCV_Set(1);  //sylee200217-4WCVMODE
    nFlag_4W_OUT50V = 0;//SYLEE200411 



    //###################################################################################

    //------------------------------
    //son 4W Sampling data 생성
    //------------------------------
    if (n4w_Sample_Enable == 1)//sylee150812-1
    {

        if (n4w_Sample_RunCount[dutIdx] <= n4w_Sample_SetCount)
        {
            n4w_Sample_Old = 2;

            int nEnd;
            nEnd = (int)g_s4WNet[dutIdx].wCount;

            g_n4wSampleFailCo1 = 0;//SYLEE171103-1


            for (int net = 1; net <= nEnd; net++)
            {

                if (d4W_Log1[nBlockCountP][net] < 0) {
#ifdef __SAVE_4W_SAMPLING_TIME  //son231117
                    //son 0보다 작으면 d4W_Log2에서는 플러스가 되게 만든다. =>  8000까지 튀는 값이 write되는 문제 있을 수 있음.
                    //    추가 사유: GTS에서 4w pin이 많아서 sampling이 오래 걸리는 문제가 있었음.   
                    //    __SAVE_4W_SAMPLING_TIME 기능 On일 때에만 불량이어도 sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하고
                    //    Off 일 때에는 나노시스 고객처럼 튀는 값이 write된다고 불만갖지 않도록 불량으로 출력한다.
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = -d4W_Log1[nBlockCountP][net];
#else                    
                    
                    //son231101 4w Sampling 튀는 값 나노시스문제점 수정. 마이너스 값일 때 fail 처리 기능 추가
                    //    여기서 d4W_Log2에 마이너스 그대로  write해서 제대로 불량처리하여   바로 아래 아래의
                    //    if (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] < 0) 코드에서 g_n4wSampleFailCo1++ 처리가 된다.
                    //    __SAVE_4W_SAMPLING_TIME 옵션을 넣지 않으면 이 나노시스 코드가 default로 동작한다.
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = d4W_Log1[nBlockCountP][net];   //son231101
#endif
                }
                else {
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = d4W_Log1[nBlockCountP][net];//sylee200615
                }

                if (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] == 0)      //son220518
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = 9999983;  //son220518


                if ((d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] >= 200000) 
                        || (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] < 0)) { //sylee201128
                    g_n4wSampleFailCo1++;
                    t1 = (int)(g_s4WNet[dutIdx].saData[net - 1]).waPin[0];  //sylee201128       //sylee201204-patch      
                    t1 = nPinToPiece(t1); //sylee201128                    
                    nOpenFail14W[t1]++; //sylee201128   
                    //SYLEE210414-1-    g_n4WFailCount++;//sylee201128                     
                    nFailPiece[t1][nPStep1]++;//sylee201128
                    nOpenFail14WBlock[nBlockCountP][t1]++;  //sylee201128                

                }//sylee150813-1


            }//sylee150813-1

            if (n4w_Sample_RunCount[dutIdx] >= 0)//SYLEE171103-1  =
            {
                if (n4w_Sample_RunCount[dutIdx] < n4w_Sample_SetCount) //sylee170518
                {
                    if (g_n4wSampleFailCo1 == 0)//sylee150813-1
                    {
                        n4w_Sample_RunCount[dutIdx]++;//sylee150812-
                        n4w_Sample_ok1 = 1;//sylee171103-5

                        //son211220 Unitech 요구사항. 4W_Setup_A.txt에 sample sheet번호, BarCode 정보 추가 
                        g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].wSheetNo = n4w_Sample_SheetCount[dutIdx] + 1;  //son211220
                                    //son SheetCount는 4W Error 뿐 아니라 Open, Short 불량등의 다른 이유로 증가할 수 있지만, 
                                    //    4wSampling matching 정보는  RunCount가 증가하는 시점의 SheetCnt가 필요하다. 
                                    //    그래서 SheetCnt가 증가하는 AProcess101()이 아니라, ARun201_4w_3() 시점에서 +1한 SheetCnt로  보관 한다.
                                    
                        GetBarCode(g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].strBarCode);  //son240622 미리 저장된 BardCode 정보를 가져온다.

                        MyTrace(PRT_BASIC, "n4w_Sample_RunCount[%d]=%d, n4w_Sample_SheetCount[%d]+1=%d, BarCode=%s\n",  //son211715
                            dutIdx, n4w_Sample_RunCount[dutIdx], dutIdx, (n4w_Sample_SheetCount[dutIdx] + 1),
                            g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].strBarCode);

                        //son 박봉규부장님 요구사항으로 추가. 이전 BarCode.txt를 잘못 읽지 않도록 읽고나면 계측기 쪽에서 지운다.
						//son230707 fName 할당 없이 지우고 있는 문제 있음. 계측기 입장에서는 안 지우는게 더 나은것으로 판단되어 
						//          DeleteFile(fName)  삭제함. ChildView1에서도 BarCode.txt를 사용하기 때문에 여기서 지우면 Childview1은 못 읽을 수 있어.
                        //son230707 DeleteFile(fName);//son211117  //son220124 moved from ReadBarCode_fromHandlerDrive()

                    }
                }
            }
            n4w_Sample_Old = nBlockCountP;//sylee150812-1          
        }
    }
    else {
        n4w_Sample_Finish = 0;//sylee150813-1
    }


    n4W_Use = 0;//sylee200612


//#################################################################################################################################	
///////////////////////////////////////////////////////////////////////////////////


    //sylee230426-6   if (SysSet19.m_n4W_Data_Flag1 == 1) {//sylee230214-1 
    if((SysSet19.m_n4W_Data_Flag1 == 1) && (n4w_Sample_Enable != 1) &&  (nManual4WStartFlag1==1)  || (n4w_Sample_Enable == 1))  //sylee230426-8   
    {
        if (SysSet19.m_nSet41 > 0) {
            dPCBRage = 100.0 - (double)SysSet19.m_nSet41;
        }
        else { dPCBRage = 10.0; }
        if (SysSet19.m_nSet42 > 0) {
            dLowRefRValue = (double)SysSet19.m_nSet42 / 10.;
        }
        else { dLowRefRValue = 0.3; }
        if (SysSet19.m_nSet43 > 0) {
            dHighRefRRage = (double)SysSet19.m_nSet43;
        }
        else { dHighRefRRage = 5.0; }

        nDiffCountNet1 = 0;      dDiffCountRate1 = 0.0;

		int nUseNet1;//sylee230426-6

		nUseNet1=0;  //sylee230426-6

        for (int Net1 = 1; Net1 <= nEnd; Net1++) {
            dTemp3 = d4W_Log1[nBlockCountP][Net1];
            //sylee230426-6 if (dTemp3 <= 10) {
			if( (dTemp3 >0)&& (dTemp3 <= 10) ){//sylee230426-6
				nUseNet1++;//sylee230426-6
                dTemp = d4W_Data1[Net1] - dTemp3;
                dTemp2 = fabs(dTemp);
                if(dTemp2 > dLowRefRValue) {
                    nDiffCountNet1++;
                }
            }
        }
        for (Net1 = 1; Net1 <= nEnd; Net1++) {
            dTemp3 = d4W_Log1[nBlockCountP][Net1];
             //sylee230426-6 if (dTemp3 > 10) {
			if((dTemp3 > 10) && (dTemp3 <200000)) {//sylee230426-6
				nUseNet1++;//sylee230426-6
                dTemp = (d4W_Data1[Net1] - dTemp3) / dTemp3 * 100.;
                dTemp2 = fabs(dTemp);
                if(dTemp2 > dHighRefRRage) {
                    nDiffCountNet1++;
                }
            }
        }

       //sylee230426-6 if (nEnd > 0) { dDiffCountRate1 = ((double)nDiffCountNet1 / (double)nEnd) * 100.; }
		if (nUseNet1 > 0) { dDiffCountRate1 = ((double)nDiffCountNet1 / (double)nUseNet1) * 100.; }//sylee230426-6

       //sylee230426-5  int nSamePcbFlag;//sylee230222-1
       //sylee230426-5 nSamePcbFlag = 0;//sylee230222-1
        if (dDiffCountRate1 < dPCBRage) {
             //sylee230426-5  nSamePcbFlag = 1;//sylee230222-1 
			if( nSamePcbFlag<1000){ //sylee230426-5 
				nSamePcbFlag++;//sylee230426-5 
			}//sylee230426-5 

            for (int Net1 = 1; Net1 <= nEnd; Net1++) {
                dTemp3 = fabs(d4W_Log1[nBlockCountP][Net1]);
                dTemp4 = g_s4WNet[dutIdx].saData[Net1 - 1].dRefLow;
                dTemp5 = g_s4WNet[dutIdx].saData[Net1 - 1].dRefHigh;
                nPass5 = 0;  nPass6 = 0;  nPass7 = 0;
                if ((dTemp4 <= dTemp3) && (dTemp3 <= dTemp5)) { nPass5 = 1; }
                if (d4W_Data1[Net1] > 0) {
                    if ((dTemp4 <= d4W_Data1[Net1]) && (d4W_Data1[Net1] <= dTemp5)) { nPass7 = 1; }
                    if (dTemp3 <= 10) {
                        dTemp = fabs(d4W_Data1[Net1]) - dTemp3;    				dTemp2 = fabs(dTemp);
                        if (dTemp2 > dLowRefRValue) {
                            nPass6 = 2;
                        }
                    }
                    else {
                        dTemp = (fabs(d4W_Data1[Net1]) - dTemp3) / dTemp3 * 100.; 	dTemp2 = fabs(dTemp);
                        if (dTemp2 > dHighRefRRage) { nPass6 = 2; }
                    }
                }

            }
        }else{//sylee230426-5
			nSamePcbFlag = 0;//sylee230426-5
		}

///////////////////////////////////////////////////////////////////////////////////////
 //measure qc sylee230426

//son230512 #ifdef __E_AND_E__CUSTOMER//sylee230427	 
#ifdef __NEW_4W_230420  //son230512 E&E Customer define은 삭제.
    
		if(nSamePcbFlag>1){//sylee230426-5
		    for(int Net1 = 1; Net1 <= nEnd; Net1++) {
				dTemp3 = d4W_Log1[nBlockCountP][Net1];
				//sylee230426-6 if (dTemp3 <= 10) {
				if( (dTemp3 >0)&& (dTemp3 <= 10) ){//sylee230426-6				 
					dTemp = d4W_Data1[Net1] - dTemp3;
					dTemp2 = fabs(dTemp);		 
					if(dTemp2 >0.5){
						if(dTemp>0){
						   // d4W_Log1[nBlockCountP][Net1]=d4W_Log1[nBlockCountP][Net1]+0.6;//sylee230426-7
							 d4W_Log1[nBlockCountP][Net1]=d4W_Data1[Net1]-(0.25 *dTemp);//sylee230426-7
						}else{
						  //	d4W_Log1[nBlockCountP][Net1]=d4W_Log1[nBlockCountP][Net1]-0.6;//sylee230426-7
							d4W_Log1[nBlockCountP][Net1]=d4W_Data1[Net1]+(0.25 *dTemp);//sylee230426-7
						}
					}
				}
			}
			for (Net1 = 1; Net1 <= nEnd; Net1++) {
				dTemp3 = d4W_Log1[nBlockCountP][Net1];			 
				if((dTemp3 > 10) && (dTemp3 <200000)) {//sylee230426-6					 
					dTemp = (d4W_Data1[Net1] - dTemp3) / d4W_Data1[Net1] * 100.;
					dTemp2 = fabs(dTemp);
				 	if(dTemp2 >5){
						if(dTemp>0){
						   // d4W_Log1[nBlockCountP][Net1]=d4W_Log1[nBlockCountP][Net1]+ (0.06*d4W_Data1[Net1]);//sylee230426-7
							d4W_Log1[nBlockCountP][Net1]=d4W_Data1[Net1]-(0.025*dTemp);//sylee230426-7
						}else{
							// d4W_Log1[nBlockCountP][Net1]=d4W_Log1[nBlockCountP][Net1]- (0.06*d4W_Data1[Net1]);//sylee230426-7
						    d4W_Log1[nBlockCountP][Net1]=d4W_Data1[Net1]+(0.025*dTemp);//sylee230426-7
						}
					}
				}
			}
		}


#endif 
//////////////////////////////////////////////////////////////////////////////////////////////////

 


        if (nSamePcbFlag == 0) {//sylee230222-1 
            for (Net1 = 1; Net1 <= nEnd; Net1++) {
                if ((fabs(d4W_Log1[nBlockCountP][Net1]) > 0) && (fabs(d4W_Log1[nBlockCountP][Net1]) < 100000)) {//sylee230301
                    d4W_Data1[Net1] = fabs(d4W_Log1[nBlockCountP][Net1]);
                }
            }
            d4W_Data1[0] = nEnd;
        }

        if (nEnd > 0) { 
            n4W_Data_Use1 = 1; }

	}
	else{ //sylee230426-6
			nSamePcbFlag = 0;//sylee230426-6
    }//end of 	if(SysSet19.m_n4W_Data_Flag1==1){//sylee230214-1



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Sub71.On4WireMode(0); //4WIRE  a=1 ON, 0 OFF  
    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704 
    Sub71.AOnRelayOffSel(1);//SYLEE170314-1
    Sub71.OnRelayAllOff1();//sylee200131
    Sub71.OnCCCV_Set(1);  //sylee200217-4WCVMODE
    Sub71.FilterSet(1);  //sylee200612


    nFlag_4W_OUT50V = 0;//SYLEE200411 
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
//---------------------------------------------------------------------------------------------


    if (n4w_Sample_Enable == 1) {//sylee230415
        dLowR10 = 0.01;
        dHighR10 = MAX_4W_R;//sylee230415
    }



    for (net = 1; net <= nEnd; net++) 
    {

        if (n4w_Sample_Enable != 1) {//sylee230415 
            dLowR10 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;
            dHighR10 = g_s4WNet[dutIdx].saData[net - 1].dRefHigh;//sylee230415
        }


        if (d4W_Log1[nBlockCountP][net] == 0.0) {
            d4W_Log1[nBlockCountP][net] = 999977;
        }

        d4wR100[net] = fabs(d4W_Log1[nBlockCountP][net]);//sylee230306


        if ((d4wR100[net] != 0.0) && (dLowR10 <= d4wR100[net]) && (d4wR100[net] <= dHighR10))//sylee230217  
        {

            d4W_Log1[nBlockCountP][net] = d4wR100[net]; //sylee230306

        }
        else 
        {

            d4W_Log1[nBlockCountP][net] = -d4wR100[net];//sylee230306

            if (g_n4WFailCount < MAX_4W_NET) //sylee160605-1     //son-4WDUT-20200403: 5000-> MAX_4W_NET  
            {


                ng4WResult[net] = 0;//sylee230228

                t1 = (int)(g_s4WNet[dutIdx].saData[net - 1]).waPin[0];
                t1 = nPinToPiece(t1);//SYLEE171225-2
                if (nOpenFail1[t1] > 0 || nShortFail1[t1] > 0) {//sylee2
                    continue;
                }

                if (nFailPiece[t1][nPStep1] >= (SysInfo05.m_nConEr + 1)) {
                    continue;
                }


                if (SysInfo19.m_nUse == 1) {
                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {//sylee230410 
                        continue;
                    }
                }

                g_n4WFailCount++;
                n4WFail1[g_n4WFailCount][0] = g_n4WFailCount;
                n4WFail1[g_n4WFailCount][1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0];  //PIN1
                n4WFail1[g_n4WFailCount][2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1];  //PIN2
                n4WFail1[g_n4WFailCount][3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2];  //PIN3
                n4WFail1[g_n4WFailCount][4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3];  //PIN4
                n4WFail1[g_n4WFailCount][5] = g_s4WNet[dutIdx].saData[net - 1].dRefLow;  //set LOW        
                n4WFail1[g_n4WFailCount][6] = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;  //SET AVE
                n4WFail1[g_n4WFailCount][7] = g_s4WNet[dutIdx].saData[net - 1].dRefHigh; //SET HIGH   

                n4WFail1[g_n4WFailCount][8] = fabs(d4wR100[net]);//sylee230306  
                n4WFail1[g_n4WFailCount][9] = dVB14w[6][net];  //  VB
                n4WFail1[g_n4WFailCount][10] = dVC14w[6][net];  //  VC
                n4WFail1[g_n4WFailCount][11] = dI14w[6][net];  //  I 
            //	n4WFail1[g_n4WFailCount][12] = m_nMode1;  //  MODE  SET   
                n4WFail1[g_n4WFailCount][12] = g_s4WNet[dutIdx].saData[net - 1].n4wMode;//  MODE  SET 

                //sylee160605-1 n4WFail1[g_n4WFailCount][13]=m_nMode1;   
                                    //son RefHigh over율
                if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh == 0)     //son231020_2 devide by zero 예방
                    n4WFail1[g_n4WFailCount][13] = 0;                   //son231020_2
                else                                                    //son231020_2
                    n4WFail1[g_n4WFailCount][13] = (dR14w[6][net] / g_s4WNet[dutIdx].saData[net - 1].dRefHigh) * 100.;  //  //sylee160605-1 //son211005


                nFailPiece[t1][nPStep1]++;////PIECE  error count  

                if (nFailPiece[t1][nPStep1] >= SysInfo05.m_nConEr) {
                    n4wMoreThanFlag = 1;//sylee160117                          
                }

                nOpenFail14W[t1]++;//SYLEE131022
                nOpenFail14WBlock[nBlockCountP][t1]++;
                n4WFail1[g_n4WFailCount][14] = t1;
                n4WFail1[g_n4WFailCount][15] = net;
                n4WFail1[g_n4WFailCount][17] = nBlockCountP;

                if (dRec4w[mode][2] > dR14w[6][net]) {
                    n4WFail1[g_n4WFailCount][16] = 2;  // range down 
                }
                else if (dR14w[6][net] > dRec4w[mode][3]) {
                    n4WFail1[g_n4WFailCount][16] = 3;  // range up//						  
                }
                else {//if( (dRec4w[mode][2]<=dR14w[6][net])   &&   (dR14w[6][i]<=dRec4w[mode][3])    ){ // 측정 range in  불량 
                    n4WFail1[g_n4WFailCount][16] = 1;  // range in
                }
                //son 4W Contact fail이면
                if (nPos1[net] == 2) {//sylee181005-2  
                    n4WFail1[g_n4WFailCount][19] = 2;  // contec fail  
                }
                else {
                    n4WFail1[g_n4WFailCount][19] = 0;
                }
#ifdef __GTS_4W_SPCIALNET__  //son230705
                n4WFail1[g_n4WFailCount][F_4W_NET_SPECIAL] = g_s4WNet[dutIdx].saData[net - 1].bNetSpecial;    //son221114 //son230705
#endif

            } // end of   if( g_n4WFailCount<2000)	

        }

    }

#if 1  
    //son240103 new ARun201_4W_New_230420()에서,  RefHigh Over 비율로 4w Error를 정렬하는 기능이 
    //       4W Error(n4WFail1[][])를 생성하는 위치보다 앞에 있어서 정렬이 안 되는 문제가 GTS, CCTC에서 발생하여
    //       4W Error(n4WFail1[][])를 생성하는 위치 뒤쪽으로 정렬기능을 옮겨옴.

    //-------------------------------------------------
    //son 4w  error list sorting  : Ref High Over Rate 
MyTrace(PRT_BASIC, "%d 4W Error Sort: nAutoReTest[%d]=%d, gRun05.m_nReCh=%d, SysSet13.m_n4wFailSortMode=%d \n",    //son240104
                g_n4WFailCount, nBlockCountP, nAutoReTest[nBlockCountP], gRun05.m_nReCh,  SysSet13.m_n4wFailSortMode);    

    //SYLEE180521-1 if( (nAutoReTest[nBlockCountP]== gRun05.m_nReCh)||  (SysSet211.m_nDisable4wRetest==1)){  //sylee160604-1    //son220503
    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh  //SYLEE180521-1
        && SysSet13.m_n4wFailSortMode == F_4W_SORT_HIGH_OVERRATE)  
                //son240103  'son230106_2 4W Fail Sort 모드 선택기능' merge from Old ARun201_4w_3() 
                //         SysSet13.m_n4wFailSortMode  0:RefHigh OverRate  1: 4w NetNo 
    {
        double dMax2; //son n4WFail1[k5][13](RefHigh대비 측정값)의 최대값
        int k3, k5; 
        int nMax2No;  //son n4WFail1[k5][13](RefHigh대비 측정값)의 최대값 위치 표시
        int nNewNo;
        int nInter1;

        nInter1 = 0;

        ::ZeroMemory(&n4WFail2T, sizeof(n4WFail2T));
        if (SysSet211.m_nDisable4wRetest != 1) {//sylee180521-1       //son 4w recheck enable  (0:enable, 1: disable)   //son220503
            ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));
        }

        for (k3 = 1; k3 <= g_n4WFailCount; k3++) {
            n4WFail1[k3][18] = 0;
        }

        //piece sort????
        nNewNo = 0;

        for (int pi1 = 1; pi1 <= g_nPieceMax1; pi1++)
        {
            for (k3 = 1; k3 <= g_n4WFailCount; k3++)
            {
                dMax2 = 0.0;    
                nMax2No = 0;
                for (k5 = 1; k5 <= g_n4WFailCount; k5++)
                {
                    if (nOpenFail14W[pi1] >= SysInfo05.m_nConEr) {   //sylee131022 
                        continue;
                    }
                    t1 = (int)n4WFail1[k5][1];//PIECE  pin no 
                    t1 = nPinToPiece(t1);//SYLEE171225-2 
                    if (nInter1 == 0) {
                        if (t1 <= 0) {
                            nInter1 = 1;
                            str.Format("Error No 4013 :  4w  Pin Piece no?.  Pin=%d, piece=%d  ", (int)n4WFail1[k5][1], t1);
                            MyTrace(PRT_BASIC, str);     //son221104_2
                            AfxMessageBox(str, MB_OK);
                        }
                    }
                    if (pi1 != t1) { 
						continue; 
					}

                    //son 이미 RefHigh대 측정값 비율로 정렬 완료이면 skip한다.
                    t1 = (int)n4WFail1[k5][18]; 
                    if (t1 == 1) { 
						continue; 
					}
					//son RefHigh 대 측정값 비율이 가장 큰  n4WFail1[k5]을 찾는다. 
                    if (n4WFail1[k5][13] > dMax2) {  
                        dMax2 = n4WFail1[k5][13];       
						nMax2No = k5;  //son  RefHigh 대 측정값의 최대값 위치(Location)
                    }
                }//end of  for( int k5=1; k5<=g_n4WFailCount; k5++)

                //son 가장 큰  n4WFail1[k5]부터 n4WFail2T[nNewNo]에 write해서 정렬한다.
                if (nMax2No > 0) //max  sort select
                {
                    n4WFail1[nMax2No][18] = 1; //son n4WFail2T[nNewNo]에 write해서 정렬 되었다고 표시
                    t1 = (int)n4WFail1[nMax2No][1];//PIECE  pin no
                    t1 = nPinToPiece(t1);//SYLEE171225-2
                    nOpenFail14W[t1]++; //son piece별 4w Fail 개수 증가
                    nNewNo++;

                    n4WFail2T[nNewNo][0] = nNewNo;
                    n4WFail2T[nNewNo][1] = n4WFail1[nMax2No][1];
                    n4WFail2T[nNewNo][2] = n4WFail1[nMax2No][2];
                    n4WFail2T[nNewNo][3] = n4WFail1[nMax2No][3];
                    n4WFail2T[nNewNo][4] = n4WFail1[nMax2No][4];
                    n4WFail2T[nNewNo][5] = n4WFail1[nMax2No][5];
                    n4WFail2T[nNewNo][6] = n4WFail1[nMax2No][6];
                    n4WFail2T[nNewNo][7] = n4WFail1[nMax2No][7];
                    n4WFail2T[nNewNo][8] = n4WFail1[nMax2No][8];
                    n4WFail2T[nNewNo][9] = n4WFail1[nMax2No][9];
                    n4WFail2T[nNewNo][10] = n4WFail1[nMax2No][10];
                    n4WFail2T[nNewNo][11] = n4WFail1[nMax2No][11];
                    n4WFail2T[nNewNo][12] = n4WFail1[nMax2No][12];
                    n4WFail2T[nNewNo][13] = n4WFail1[nMax2No][13];
                    n4WFail2T[nNewNo][14] = n4WFail1[nMax2No][14];
                    n4WFail2T[nNewNo][15] = n4WFail1[nMax2No][15];
                    n4WFail2T[nNewNo][16] = n4WFail1[nMax2No][16];
                    n4WFail2T[nNewNo][17] = n4WFail1[nMax2No][17];
                    n4WFail2T[nNewNo][18] = n4WFail1[nMax2No][18];
                    n4WFail2T[nNewNo][19] = n4WFail1[nMax2No][19];
#ifdef __GTS_4W_SPCIALNET__     //son230705
                    n4WFail2T[nNewNo][F_4W_NET_SPECIAL] = n4WFail1[nMax2No][F_4W_NET_SPECIAL];  //son221114 25:F_4W_NET_SPECIAL

#endif

                    //  nOpenFail14W[t1]++;//SYLEE131022
                }

            }//end of for( int k3=1; k3<=g_n4WFailCount; k3++)

        }//end of        for(int pi1=1; pi1<=g_nPieceMax1; pi1++)


        if (g_n4WFailCount != nNewNo) {
            g_n4WFailCount = nNewNo;
            //   str.Format("Error No 4012 :  4w  error list sorting error.  g_n4WFailCount=%d,  nNewNo=%d  ",g_n4WFailCount,nNewNo);
            //  AfxMessageBox(str, MB_OK);             
        }

        ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));
        memmove(n4WFail1, n4WFail2T, sizeof(n4WFail1));

    }
#endif

    //###################################################################################

#ifndef _PC_TEST_
    if (g_n4WFailCount > 0)//sylee210301
    {
        //  m_nMode1=dRec4w[mode][1];


        m_nMode1 = 171;
        mode = 1;


        if (SysSet13.m_n4WCVMode == 1) { //sylee200217-4WCVMODE
            if (m_nMode1 == 171)  m_nMode1 = 176;
            if (m_nMode1 == 172)  m_nMode1 = 177;
            if (m_nMode1 == 173)  m_nMode1 = 178;
            if (m_nMode1 == 174)  m_nMode1 = 179;
            if (m_nMode1 == 175)  m_nMode1 = 179;
        }

        nCC = (int)dRec[m_nMode1][1];
        nVRel = (int)dRec[m_nMode1][2];
        nVSet = (int)dRec[m_nMode1][3];
        nIR = (int)dRec[m_nMode1][4];
        nISet = (int)dRec[m_nMode1][5];
        nDelay10 = (int)dRec[m_nMode1][6] * 10;
        Sub71.nADCount1 = (int)dRec[m_nMode1][7];    //sylee150713
        nFil = (int)dRec[m_nMode1][8];//SYLEE130706
        nIFilter = (int)dRec[m_nMode1][9];     //SYLEE130706 
        nIGain = (int)dRec[m_nMode1][12];      //SYLEE150123     
        n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123

        Kcount = 1;

        if (nISet < 0.1) {
            AfxMessageBox(" Error No 7706, \n    I Set  ( <0.1 ) SET ERROR !,  4W  Start Error!!!");
        }
        if (nIR == 1 || nIR == 2) {   //mA
            nISetVal1 = nISet * 0.1;
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {
            nISetVal1 = nISet * 0.1;
        }
        else {
            AfxMessageBox(" Error No 1024, \n    I RANGE 1~5   SET ERROR !,      4W FAIL  Run Start Error!!!");
            return 0;
        }

        n4Wire = 4;
        nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
        nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
        //=========================================================================================
        //interlock   
        if (nCC != 1 && nCC != 2) {
            AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     4W Run Start Error!!!");
            return 0;
        }

        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
        Sub71.AOnReadV1Enable1(5);
        //sylee180910-1    Sub71.FilterSet(4);//sylee130706  
        Sub71.I_Filter(nIFilter);//sylee130706

        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on        
        }
		else {
            Sub71.I_Gain(1);  //1x  =io off
        }

        if (n4Wire == 4) {   //ACE380
            if (n4wGain == 2) {
                Sub71.On4W_GainSet(2);
            }
            else  if (n4wGain == 3) {
                Sub71.On4W_GainSet(3);
            }
            else  if (n4wGain == 4) {
                Sub71.On4W_GainSet(4);
            }
            else { 
				Sub71.On4W_GainSet(1); 
			}
        }
        else {
            Sub71.On4W_GainSet(1);
        }


        if (mode == 1) {//sylee150128 ace380 
            Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //RELAY ON 
        }
        else {//    if(ik==1){//sylee150128 ace380          
            Sub71.nModeIR = 1;
            if (nISet == 1) {//sylee150715
                Sub71.AOnISet1Run1(nISet);
            }
            else {
                Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE150701
            }
        } //if(ik==1){//sylee150128 ace380

        Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 

        if (mode == 4) {
            Sub71.Delay_100ns(5000); //5ms  //sylee150709 
        }
        // nRCount=1;
        nLoop = 0;//SYLEE20120302  //sylee131128   
        //sylee200515-patch nEnd=(int)gd4W1[0][0];
        // int dutIdx = get4wDutIdx(); 
        nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch

        if (nEnd < 0) { //son241009 0도 처리하게 
            str.Format("Error No 7115 , \n\n  Process Stop. \n\n  4W NET LIST wCount < 0 !    \n\n\n\n   => .BDL\4w.ini check. \n  4W  RUN STOP \n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }
        //sylee170729-1  if(nEnd>=5000)
        if (nEnd >= MAX_4W_NET) {//sylee200521      //son231107 Def_4WMax1 -> MAX_4W_NET(10000)
            str.Format("\n\nError No 7801,  4w total count over ( >=%d)      \4w.ini check. !     \n\n\n    \n\n\n ", MAX_4W_NET); //sylee210427    //son231107
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
        }

        if (SysSet19.m_n4WHVon == 1) { //sylee200217-4WCVMODE
            Sub71.FilterSet(4);     //sylee190525  //sylee191023-1
        }
        else {//sylee191023-1
            Sub71.FilterSet(1);
        }//sylee191023-1
        nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.nADCount1 = 1;

        //##################################################################################################################

        if (SysSet19.m_n4WHVon == 1) { //sylee200217-4WCVMODE
            Sub71.FilterSet(4);
        }
        else {
            Sub71.FilterSet(1);
        }


        int nEnd2;//sylee210405-1   
        if (g_n4WFailCount > 50) {//sylee210405-1 
            nEnd2 = 50;
        }
        else {
            nEnd2 = g_n4WFailCount;
        }


        if (mode == 1)//sylee201005  //sylee230404
        {

            //sylee210405-1  for( int neterr=1; neterr<=g_n4WFailCount; neterr++)   // net 
            for (int neterr = 1; neterr <= nEnd2; neterr++)   // net //sylee210405-1    
            {
                n4WFail1[neterr][21] = 0;
                n4WFail1[neterr][22] = 0;
                n4WFail1[neterr][23] = 0;
                n4WFail1[neterr][24] = 0;
                net = (int)n4WFail1[neterr][15];
                t1 = n4WNet[net][_4W_PIN1]; //son211102 1-> _4W_PIN1
                t2 = nPinToPiece(t1);//SYLEE171225-2  
                //////////////////////////////////////////////////////////////////////////////////////
                int nFailCo1;


                for (int ik1 = _4W_PIN1; ik1 <= _4W_PIN4; ik1++)     //son211102 1-> _4W_PIN1,  4-> _4W_PIN4
                {
                    nFailCo1 = 0;


                    for (int ik2 = _4W_PIN1; ik2 <= _4W_PIN4; ik2++) //son211102 1-> _4W_PIN1,  4-> _4W_PIN4
                    {
                        if (ik1 == ik2) {
                            continue;
                        }
                        Sub71.AOnPinSet1(2, n4WNet[net][ik1] - 1, 1);   //VB  TR 
                        Sub71.AOnPinSet1(2, n4WNet[net][ik2] - 1, 2);   //VC  TR PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,
                        for (int k1 = 1; k1 <= 200; k1++) { //300uS
                            if (net == 1 && k1 <= 10) {//200us
                                Sub71.Delay_100ns(200);  //20uS
                            }
                            Sub71.Delay_100ns(100);  //10uS
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (Sub71.Y1 > (nISet * 0.6)) {//ok
                                    break;
                                }
                            }
                            else {//sylee191015-2
                                if (Sub71.Y1 > (nISet * 0.3)) {//sylee//sylee191015-2
                                    break;
                                }
                            }
                            if (k1 == 200) {//fail
                                nFailCo1++;           //nPos1[net]=2;                          
                            }
                        }
                        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                    }


                    if (nFailCo1 == 3) {
                        n4WFail1[neterr][20] = 1;
                        n4WFail1[neterr][8] = 999999999;  //son Fail R
                        n4WFail1[neterr][20 + ik1] = 1;
                        nFailCo1 = 3;
                        //contec fail
                    }             
                }
                /////////////////////////////////////////////////////////////////////////////////////////
            }//end of   for( i=1; i<=nEnd; i++)   // net 

        }//end of       if(mode==1)
            

    } //if(g_n4WFailCount>0)
#endif

    nManual4WStartFlag1=0; //sylee230426-8 MANUAL START:  ABORT DIO
 
    return 1;
}











int CChildView7::ARun201_4W_Old_230420(int nPStep1) //SYLEE230420
{

    CString  str, str1, strfName, strfName1;
    char  fName[200], fName1[200];
    int m_nMode1, n4Wire, nRet1, nDelay10, nEnd, Lo1, nLoop, nCount;
    int j, k, ipEnd, t1, t2;
    int nFil, nIFilter, Kcount, nW4FailOut1;
    int dPinVC[200], dPinVB[200];
    int n4WNet[MAX_4W_NET +1][NUM_4W_GRID_COL];    //son211022 10 -> NUM_4W_GRID_COL로 수정  4W jigTest 잘 안되는 문제관련
                                                   //son231107 MAX_4W_NET-> MAX_4W_NET+1.  net 1부터 사용하므로 10000개 처리시 오류 발생가능성 수정
    int n4WMod1[10][10];//sylee160719  2000->5001   //son n4WMod1[1][1] : 171 nMode의 net 개수,    
                                                    //son n4WMod1[2][1] : 172 nMode의 net 개수, 
                                                    //son n4WMod1[3][1] : 173 nMode의 net 개수,     
                                                    //son n4WMod1[4][1] : 174 nMode의 net 개수,              
                                                    //son n4WMod1[5][1] : 175 nMode의 net 개수, 
                                                    
    short nPos1[MAX_4W_NET +1];//sylee131112  //son 0: 정상, 2: 4W Contact fail(I 값이 일정수준이 안 나온다고) 표시 //son231107

    int nErrorCount, nMode, nIGain, n4wGain;//SYLEE150123  
    double dVbR1, dVbR2, nISet;
    double dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200], nT[10], nData[130][15];
    double  nISetPercentHigh, nISetPercentLow, nVBSetPercentHigh, nVBSetPercentLow;//sylee120914
    __int64   tStart11, tStart12, tStart13;  //sylee150710 
    double  nOld1_R1, nOld1_R1_Rate1, dMinR1; //sylee191025-1
    int nPassCo1, nPassCo2, nRetrySet, nRetryCo1, nFlag_Fail_Full;//sylee160528-5
    int nEndStep1, n4W_Retry1, n4W_Retry2, n4W_Retry5, n4WFailPieceCo1, nZeroCo1, nZeroCo2;//sylee180520-1
    double n4wLowRetryPer1, dRoffset1, dRoffset2;
    int n4W_Retry3, n4W_Retry4, nRetryEndSet, net, dutIdx;
    int nPinNo[5];//sylee191126 
    double dRef4wR1, dDiffR1, dDiffR2, d4W_RoffSet1, d4W_RoffSet2, d4W_Percent1, d4W_Percent5;
    double d4W_Noise1, d4W_Noise2, d4W_Noise3;
    int n2WCheck, nNGRetryCo1;//sylee201012
    double dR4w1_old1;//sylee201012
 
    ///////////////////////////////////////////////////////////////////////
    double dPerRate0, dPerRate1, dPerRate2;//sylee210417
    short nFail1[MAX_4W_NET +1];//sylee210417  2: Fail  //son231107 10001 -> MAX_4W_NET +1
    int n4W_RetryFlag1;

    n4W_RetryFlag1 = 0;//sylee210417
	nFlagLeakMPin1=0;  //sylee230526  //sylee230818

    //son Check9 : 4W Error Correction Mode1 (중앙값 기준  20% 벗어나면 내부 재측정 여러번 수행)
    if (SysSet13.m_nSet9 == 1) {//sylee210429
        if (n4w_Sample_Enable != 1) {
            if ((nCycleRunFlag == 2) || (nFlagRunMode1 == 2) || (nManualStartFlag == 1)) {//syle210417   
                n4W_RetryFlag1 = 2;//sylee210417  //SYLEE210428 
                dPerRate0 = 0.2;//sylee210417
                dPerRate1 = 1.0 - dPerRate0;//sylee210417
                dPerRate2 = 1.0 + dPerRate0;//sylee210417
                ::ZeroMemory(&nFail1, sizeof(nFail1));  //sylee210417
            }
        }
    }
    /////////////////////////////////////////////////////////////////////////// 

    nNGRetryCo1 = 0;//sylee201012
    n2WCheck = 2;//sylee201005  2=disable 
    n4w_Measure1_Enable = 0;
    n4W_PinFastADC1 = 0;//sylee200905
    n4W_Use = 1;//sylee200612

//son231108    ::ZeroMemory(&ng4WResult_3, sizeof(ng4WResult_3)); //SYLEE200604-AUTOSAMPLING

    if (SysInfo05.m_n4WSet1 > 0) {//sylee200525
        if (SysInfo05.m_4W_Measure == 1) {  //sylee200222 
            n4w_Measure1_Enable = 1;
        }
    }

    dutIdx = get4wDutIdx(); //sylee200515-patch   

    d4W_RoffSet1 = 0.0;   d4W_RoffSet2 = 0.0;  d4W_Percent1 = 0.0; d4W_Percent5 = 0.0;

    //son SysSet19.m_nSet36:  EDIT_131: '4W Level 1'
    if (SysSet19.m_nSet36 > 0 && SysSet19.m_nSet36 < 100) {      //not use
        d4W_Noise1 = SysSet19.m_nSet36 / 10.;
    }
    else {
        d4W_Noise1 = 0.0;
    }

    //son SysSet19.m_nSet37:   EDIT_132: '4W Level 2'
    if (SysSet19.m_nSet37 > 0 && SysSet19.m_nSet37 < 100) {  //not use
        d4W_Noise2 = SysSet19.m_nSet37 / 10.;
    }
    else {
        d4W_Noise2 = 0;
    }

    //son SysSet19.m_nSet23:   EDIT_113: '4W Level 3'
    if (SysSet19.m_nSet23 > 0 && SysSet19.m_nSet23 < 100) {
        d4W_Noise3 = SysSet19.m_nSet23 / 10.;
    }
    else {
        d4W_Noise3 = 0.0;
    }

    d4W_RoffSet2 = d4W_RoffSet1;
    if (SysSet19.m_n4WHVon == 1) {
        nFlag_4W_OUT50V = 1;//SYLEE200411
        SysSet13.m_n4WCVMode = 1;//SYLEE201030
    }
    else {
        nFlag_4W_OUT50V = 0;//SYLEE200411
    }

    //sylee200513 dMinR1=0.2; //sylee191025-1 dMinR1  //sylee200217-4WCVMODE  1->0.5
    dMinR1 = 0.01; //sylee191025-1 dMinR1  //sylee200217-4WCVMODE  1->0.5
    dRoffset1 = 0.5;//sylee180704-5
    dRoffset2 = 1000;//sylee180705-2

    if (SysSet19.m_nSet31 < 1) {
        dRoffset1 = 0;//sylee180705-2  //offset
    }
    else if (SysSet19.m_nSet31 <= 50) {
        dRoffset1 = SysSet19.m_nSet31 / 10.;//sylee180705-2
    }
    else {
        dRoffset1 = 0;//sylee180705-2
    }
    if (SysSet19.m_nSet32 < 1) {
        dRoffset2 = 10000000;//sylee180705-2
    }
    else if (SysSet19.m_nSet32 <= 100) {
        dRoffset2 = SysSet19.m_nSet32 / 10;//sylee180705-2
    }
    else {
        dRoffset2 = 10000000;//sylee180705-2
    }
    nZeroCo2 = 0;//sylee180520-1 
    n4wLowRetryPer1 = 0.0; //sylee180213-1 
    n4WFailPieceCo1 = 0;

    for (int ip3 = 1; ip3 <= nPieceMax; ip3++) {//sylee170807-3
        if ((g_nSkipPieceFlag1 == 1) && (g_nSkipPieceInfo[ip3] == 2)) { //SYLEE180528-1-ITS  //sylee160203-ITS        //son220624
            n4WFailPieceCo1++;
        }
        else {//SYLEE180528-1-ITS //sylee160203-ITS
            if (nOpenSetFlag1 == 1) {//sylee170829-1
                if ((nReFlagOpenCur[ip3] == 2)  //son 2: Open 
                        || (nShortFail1[ip3] > 0)
                    || ((SysSet211.m_nDisable4wRetest == 1) && (n4wFail1Old[ip3] > 0))) {//SYLEE180528-1-ITS //sylee160203-ITS //son220503
                    n4WFailPieceCo1++;
                }
            }
            else {//sylee170829-1
                if ((nShortFail1[ip3] > 0)
                    || ((SysSet211.m_nDisable4wRetest == 1) && (n4wFail1Old[ip3] > 0))) {//SYLEE170808     //SYLEE180528-1-ITS //sylee160203-ITS  //son220503
                    n4WFailPieceCo1++;
                }
            }//sylee170829-1
        }//SYLEE180528-1-ITS //sylee160203-ITS
    }

    if (n4WFailPieceCo1 == nPieceMax) {//sylee170807-3
        return 1;//sylee170807-3   //sylee180202-1-import
    }

    //----------------------------------------------------
    //son  SHORT 검사관련 BDL Data에 따라 핀설정을 한다.
    int nRCount;

    Sub71.OnPinAllReset1();//sylee190207-1

    //son nRCount :  Short 개수 
    if ((nMulNetFlag > 1) && (nMultyNetTotal >= nMulNetFlag)) {//sylee190207-1
        nRCount = nBDLData3[nMulNetFlag][0][1];
    }
    else {//SYLEE150817
        nRCount = nBDLData3[1][0][1];
    }


    Sub71.OnDisCharge1(); //sylee170725-3 
    Sub71.OnPinAllReset1();//sylee190207-1
    nEndStep1 = 4;//sylee160611-1  //SYLEE201030  5 -> 4

    if (SysSet211.m_nDisable4wRetest == 1) {//sylee160602-5  //4w recheck disable   (0:enable, 1:disable)   //son220503
        n4wFail1OldCo1 = 0;//sylee160602-5
        for (int w2 = 1; w2 <= nPieceMax; w2++) {
            if (n4wFail1Old[w2] > 0) {
                n4wFail1OldCo1++;//sylee180202-1-import
            }
        }
        if (nAutoReTest[nBlockCountP] > 0) {
            if (n4wFail1OldCo1 == nPieceMax) {
                return 1;
            }
        }
    }

    //son Manual -> Set1 -> Disable 4w Retest 
    if ((SysSet211.m_nDisable4wRetest == 1) || (nManualStartFlag == 1)) {  // 4w recheck disable    manual  //sylee160604-1  //son220503
        nFlag_Fail_Full = 1;//sylee160528-5
    }
    else {
        nFlag_Fail_Full = 0;//sylee160528-  
        if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {//last recheck
            nFlag_Fail_Full = 1;
        }
    }

//son240909 4W Retest 문제 관련. BH, JTECH, GTS도  Retest 관계없이 항상 Full Range Test 로 테스트하도록 변경
//son240909 #ifdef __YOUNPUNG__CUSTOMER  //SYLEE230605
#if (defined(__YOUNPUNG__CUSTOMER) || defined(__BH__CUSTOMER) || defined(__GTS__CUSTOMER) || defined(__JTECH__CUSTOMER)) //son240909 //yskim 241218 BHVT define 제거(저항표시 ohm으로 통일하기 위해)
     nFlag_Fail_Full = 1;  
#endif 



    ::ZeroMemory(&ng4WResult_2, sizeof(ng4WResult_2)); //ng4WResult_2==3   FAIL R DETECT

    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127
    nRetrySet = 1;//sylee150721 
    nRetryCo1 = 0;//sylee150721

    nVRel = (int)dRec[171][2];//SYLEE150210 //ACE380    FAIL =0  , PASS=1

    Sub71.AVB_CheckOut1(nVRel, 1);//SYLEE150210 //ACE380    FAIL =0  , PASS=1

    ///////////////////////////////////////////////////////////////////////////
    //변수 초기화 
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&n4WNet, sizeof(n4WNet));
    ::ZeroMemory(&n4WMod1, sizeof(n4WMod1));
    ::ZeroMemory(&n4WData1, sizeof(n4WData1));//sylee200415
    ::ZeroMemory(&n4WData1v, sizeof(n4WData1v));//sylee200415
    ::ZeroMemory(&n4WData1i, sizeof(n4WData1i));//sylee200415
    ::ZeroMemory(&nPos1, sizeof(nPos1));//sylee131112

    //son 4w recheck (0:enable, 1: disable)
    if ((SysSet211.m_nDisable4wRetest != 1) || ((SysSet211.m_nDisable4wRetest == 1) && (nAutoReTest[nBlockCountP] == 0))) {//sylee180521-1 //son220503
        ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));
    }

    if ((nAutoReTest[nBlockCountP] != 0) && (SysSet211.m_nDisable4wRetest != 1)) {//sylee180521-1  //son220503
        ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));//sylee130122//100=piecemax 
        ::ZeroMemory(&nOpenFail14WBlock, sizeof(nOpenFail14WBlock));//sylee130122//100=piecemax
    }

    nStop = 0;    n4Wire = 0;    nW4FailOut1 = 0; nErrorCount = 0;//4WSETUP


    if ((SysSet211.m_nDisable4wRetest != 1) || ((SysSet211.m_nDisable4wRetest == 1) && (nAutoReTest[nBlockCountP] == 0))) {//sylee180521-1 //son220503
        g_n4WFailCount = 0;
    }
    if (nKeyStartFlag == 1) {
        nAutoReTest[nBlockCountP] = 0;
        g_n4WFailCount = 0; //sylee180521-1
    }

    Lo1 = 100;//SYLEE200224 10->100       nW4=1; 
    Kcount = 1;//SYLEE20120204
    nCount = 1;
    nLoop = 0;//sylee20111226  3->5   //sylee131128
    ipEnd = g_nPieceMax1;//SYLEE131022 
    g_VSet1 = dRec[171][3];//sylee130708   71->171
    g_VSet2 = 1;//sylee131118 

    //sylee200515-patch nEnd=(int)gd4W1[0][0];
    //int dutIdx = get4wDutIdx(); 
    nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch
    if (nEnd < 0) { //4WSETUP //son241009 0도 처리하게 
        str.Format("\n\nError No 4002,\n\n\n   4W NetList < 0  !!! \n\n\n  4W FILE CHECK! \n\n\n ");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);

        str.Format("      ");
        m_list1.AddString(str);
        nlist1++;
        str.Format("*** 4W NetList < 0  !!!**");
        m_list1.AddString(str);
        nlist1++;
        str.Format("***   Error No 4002   **");
        m_list1.AddString(str);
        nlist1++;
        str.Format("      ");
        m_list1.AddString(str);
        nlist1++;
    }


    //------------------------------------------------------------
    // 해당 DUT의 4W Cal 정보를  4W처리용 n4WNet[net]로 copy하여 사용 

    for (net = 1; net <= nEnd; net++)    //son-4WDUT16-190704
    {
#ifdef __GTS_4W_SPCIALNET__
        n4WNet[net][_4W_SPECIAL] = (int)g_s4WNet[dutIdx].saData[net - 1].bNetSpecial;   //son221107 GTS 4W 특수넷 표시
#endif
        //son  하부핀 R 측정모드 이면.
        if (g_bUseLowerCalJig_4W) {    //son220419_7 
            n4WNet[net][_4W_PIN1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
            n4WNet[net][_4W_PIN4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3] + (SysSet12.m_nLowerJigStartPin - 1);   // 1~4  pin, 
        }
        else {
            n4WNet[net][_4W_PIN1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0];   // 1~4  pin, 
            n4WNet[net][_4W_PIN2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1];   // 1~4  pin, 
            n4WNet[net][_4W_PIN3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2];   // 1~4  pin, 
            n4WNet[net][_4W_PIN4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3];   // 1~4  pin, 
        }

        n4WNet[net][_4W_PIECE] = (int)g_s4WNet[dutIdx].saData[net - 1].wPiece;   // 0=piece, //son211005 wNet -> wPiece  
        n4WNet[net][_4W_MODE] = (int)g_s4WNet[dutIdx].saData[net - 1].n4wMode;   // 10: mode


        if (n4WNet[net][_4W_PIN1] < 0 || n4WNet[net][_4W_PIN2] < 0
            || n4WNet[net][_4W_PIN3] < 0 || n4WNet[net][_4W_PIN4] < 0)
        {
            str.Format("Error No 1023,\n   4W READ Error!!! \n  PIN NO < 0 . 4W FILE CHECK.,  file Row  =%d    ", (int)net + 5);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;//error
        }

        // 4w net list에서  mode별 수량 확인  
        if (dRec4w[1][1] == n4WNet[net][_4W_MODE]) { n4WMod1[1][1]++; }
        else if (dRec4w[2][1] == n4WNet[net][_4W_MODE]) { n4WMod1[2][1]++; }
        else  if (dRec4w[3][1] == n4WNet[net][_4W_MODE]) { n4WMod1[3][1]++; }
        else if (dRec4w[4][1] == n4WNet[net][_4W_MODE]) { n4WMod1[4][1]++; }
        else if (dRec4w[5][1] == n4WNet[net][_4W_MODE]) { n4WMod1[5][1]++; }
    }


    //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    int mode;
    int SumMode;
    SumMode = 0;

    for (mode = 1; mode <= nEndStep1; mode++) {
        SumMode = SumMode + n4WMod1[mode][1];
    }

    //son Mode 정상 여부 체크
    if (SumMode != nEnd) { // 4W SETUP  NET LIST  MODE SET ERROR 
        nFailCount[TEST_OPEN] = 0;    //son210331 enum                 
        g_n4WFailCount = nEnd;
        AfxMessageBox(" Error No 1027, \n  ->  [SETUP]  [4W Wire]  -> Mode  ( 171~175 ??? ) SETTING ERROR!.,      4W  Run Start Error!!!");
        return 1;
    }

//son231020 begin
    //son RefHigh가 0이거나 Max 값을 초과하는 케이스, 4w Mode 설정이 제대로 되지 않은 경우에는 4W test를 진행하지 않는다.
    int nErrCo1 = __Check_4WErrorNet(false, NULL); //son 프린트 출력하지 않고 nErrCo1만 획득
    if (nErrCo1 > 0) {
        AfxMessageBox("\n\n\n   Can't process 4w test. Don't Use this 4W.ini BDL!!!!  \n\n\n Error 1027 => [Setup]=> [4wire]=>   Check!   \n\n  ( RefLow?)    ( RefHigh?)  \n  ", MB_OK);
        return 1;
    }
//son231020 end


    //son 4W CSV 출력할 때 해당 block의 dutIdx가 무엇인지를 확인하기 위해 저장해 둔다.
    g_d4W_Log1_nBlockDutInfo[nBlockCountP] = dutIdx;     //son200320-4WDUT16 


    //-----------------------------------
    //son  mode별로 검사를 진행한다.

    int calPart = PART_UPPER;    //son220419_2
    // for(mode=nEndStep1; mode<=1; mode--) //SYLEE150202
    for (mode = 1; mode <= nEndStep1; mode++) //SYLEE150202
    {
        //-----------------------------------
        int nPassCount;
        nPassCount = 0;
        nFlag_ADIRet1 = 0;//sylee180823-1
        if (mode < 5) {//sylee200217-4WCVMODE
            nFlag_ADICheck1 = 1;  //sylee180823-1  //sylee180917-1
        }
        else {
            nFlag_ADICheck1 = 0;
        }
        dAdcISet = (int)(dRec[170 + mode][5] * 0.9); //sylee180823-1 //sylee180917-1  //sylee181119 0.8->0.9 
        dAdcISet2 = (int)(dRec[170 + mode][5] * 1.1); //sylee200215

        if (SysSet13.m_n4WCVMode == 1) {//sylee200217-4WCVMODE  
            if (mode <= 3) {//sylee201209
                dAdcISet = (int)(dRec[170 + mode][5] * 0.9); //sylee201209
            }
            else {
                dAdcISet = (int)(dRec[170 + mode][5] * 0.5); //sylee201209
            }
            dAdcISet2 = (int)(dRec[170 + mode][5] * 1.5); //sylee201209
            //sylee201209   nFlag_ADICheck1=0;
            nFlag_ADICheck1 = 1;  //sylee201209
        }

        if (mode == 1) 
            nRelay1OffSkip = 1;//sylee170424-1

        if (nRelay1OffSkip == 2) 
            nRelay1OffSkip = 3;//sylee170424-1

        for (net = 1; net <= nEnd; net++) {  // net 
            //son 이전 mode 검사에서 해당 net이 양품이었으면 nPassCount를 증가시킨다. 
            if (ng4WResult[net] == 2) {//sylee131022//pass
                nPassCount++;
            }
        }

        //son 이전 mode 검사에서 모든 net이 양품이었다면 mode를 5로 만들어서 for 루프를 탈출한다. 
        if (nPassCount == nEnd) {
            mode = 5;//sylee140722
            continue;
        }

        if (nFlag_Fail_Full != 1) {//sylee160528-5
            if (n4WMod1[mode][1] < 1) {   //son mode별  net 총 개수가 1보다 작으면 이 모드는 넘어간다.   
                continue;
            }
        }

        //---------------------------------
        //son Mode별 검사 parameter 설정

        m_nMode1 = dRec4w[mode][1];

        if (SysSet13.m_n4WCVMode == 1) { //sylee200217-4WCVMODE
            if (m_nMode1 == 171)  m_nMode1 = 176;
            if (m_nMode1 == 172)  m_nMode1 = 177;
            //sylee201207    if(m_nMode1==173)  m_nMode1=178; //SYLEE201030
            //sylee201207    if(m_nMode1==174)  m_nMode1=179; //SYLEE201030
            //sylee201207    if(m_nMode1==175)  m_nMode1=179; //SYLEE201030
        }

        nCC = (int)dRec[m_nMode1][1];
        nVRel = (int)dRec[m_nMode1][2];
        nVSet = (int)dRec[m_nMode1][3];
        nIR = (int)dRec[m_nMode1][4];
        nISet = (int)dRec[m_nMode1][5];
        nDelay10 = (int)dRec[m_nMode1][6] * 10;
        Sub71.nADCount1 = (int)dRec[m_nMode1][7];    //sylee150713
        nFil = (int)dRec[m_nMode1][8];//SYLEE130706
        nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130706 
        nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
        n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123

        nFlag_4W_SetI = nISet / 20.;//sylee211126

        //son MAP->Set3->'4W K Count' 
        if (mode == 1) {//SYLEE180706-1
            if (SysSet19.m_nSet8 < 1) {//SYLEE180706-1  
                Kcount = 1;
            }
            else if (SysSet19.m_nSet8 <= 20) {//SYLEE180706-1
                Kcount = SysSet19.m_nSet8;      //son 4W K Count 
            }
            else {//SYLEE180706-1
                Kcount = 1;
            }
        }
        else {//SYLEE180706-1
            Kcount = 1;
        }


        if (nISet < 0.1) {
            AfxMessageBox(" Error No 7706, \n    I Set  ( <0.1 ) SET ERROR !,  4W  Start Error!!!");
        }
        if (nIR == 1 || nIR == 2) {   //mA
            nISetVal1 = nISet * 0.1;
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {
            nISetVal1 = nISet * 0.1;
        }
        else {
            AfxMessageBox(" Error No 1024, \n    I RANGE 1~5   SET ERROR !,      4W FAIL  Run Start Error!!!");
            return 0;
        }

        n4Wire = 4;
        nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
        nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
        //=========================================================================================
        //interlock   
        if (nCC != 1 && nCC != 2) {
            AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     4W Run Start Error!!!");
            return 0;
        }



        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


Task101:  //son Retry Check Hw Power  (Lo1 = 100)


        if (SysSet19.m_n4WHVon != 1) //sylee200217-4WCVMODE
        {
            if (mode == 1)//sylee140120
            {
                //------------------------
                //son Read VB (HW Check)

                Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 

                if (nVSet <= 5) {
                    dVbR2 = nVSet * (0.35);//35%
                }
                else {
                    dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
                }
                dVbR1 = nVSet - dVbR2;
                dVbR2 = nVSet + dVbR2;

                if (Sub71.V1 > 300) {
                    if (Lo1-- > 0) {
                        Sub71.Delay_100ns(100000);  //10ms   
                        goto Task101;
                    }
                    str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                    return 0;
                }
#ifdef _PC_TEST_
                Sub71.V1 = 15;  //son211217 Hw Error를 넘어가기 위해 추가
#endif
                if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                    if (Lo1-- > 0) {
                        Sub71.Delay_100ns(100000);  //10ms   
                        goto Task101;
                    }
                    str.Format("Error No 1303,\n \n\n  Power Check? \n\n\n   VB READ Error!!!    Calibration NO=%d   \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str);
                    return 0;
                }

            }//sylee140120  //end of if(mode==1){//sylee140120
        }//     if(SysSet19.m_n4WHVon!=1){//sylee191023-1

        //-------------------------------
        //son VC READ  INIT SET
        Sub71.AOnReadV1Enable1(5);
        //sylee180910-1    Sub71.FilterSet(4);//sylee130706  


        //----------------------------
        //son I Filter 설정  (ADC_A)
        Sub71.I_Filter(nIFilter);//sylee130706

        //**********************************************************//

        //---------------------
        //son I Gain 설정 
        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on     
        }
        else {
            Sub71.I_Gain(1);  //1x  =io off
        }

        //---------------------
        //son 4W Gain 설정 
        if (n4Wire == 4) {   //ACE380
            if (n4wGain == 2) {
                Sub71.On4W_GainSet(2);
            }
            else  if (n4wGain == 3) {
                Sub71.On4W_GainSet(3);
            }
            else  if (n4wGain == 4) {
                Sub71.On4W_GainSet(4);
            }
            else {
                Sub71.On4W_GainSet(1);
            }
        }
        else {
            Sub71.On4W_GainSet(1);
        }

        //**********************************************************//

        //---------------------------------------
        //son CC, VRel, VSet, IR, I Value Set
        if (mode == 1) {//sylee150128 ace380 
            Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //RELAY ON 
        }
        else {//    if(ik==1){//sylee150128 ace380          
            Sub71.nModeIR = 1;
            if (nISet == 1) {//sylee150715
                Sub71.AOnISet1Run1(nISet);
            }
            else {
                Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE150701
            }
        } //if(ik==1){//sylee150128 ace380

        Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 

        if (mode == 4) {
            Sub71.Delay_100ns(5000); //5ms  //sylee150709 
        }
        // nRCount=1;
        nLoop = 0;//SYLEE20120302  //sylee131128

        //sylee200515-patch nEnd=(int)gd4W1[0][0];
        // int dutIdx = get4wDutIdx();   // g_s4WNet의 index. 0부터 시작함. //son190704-4WDUT16 
        nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch
        if (nEnd < 0) { //son241009 0도 처리하게 
            str.Format("Error No 7115 , \n\n  Process Stop. \n\n  4W NET LIST wCoutn < 0 !  \n\n\n\n   => .BDL\4w.ini check. \n  4W  RUN STOP \n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }
        //sylee170729-1  if(nEnd>=5000){
        if (nEnd > MAX_4W_NET)   //son-4WDUT-20200403: 5000-> MAX_4W_NET
        {
            str.Format("\n\nError No 7801,  4w total count(=%d) over  >%d      \4w.ini check. !     \n\n\n    \n\n\n ", nEnd, MAX_4W_NET);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
        }

        //------------------------------------
        //son ADC B Filter를 VC Fast로 설정
        if (SysSet19.m_n4WHVon == 1) { //sylee200217-4WCVMODE
            Sub71.FilterSet(4);     //sylee190525  //sylee191023-1
        }
        else {//sylee191023-1
            Sub71.FilterSet(1);
        }//sylee191023-1
        nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.nADCount1 = 1;


        //#############################################################################################

#ifdef __YOUNPUNG__CUSTOMER_4W_2WCHECK   

        //----------------------------
        //son 4W Pin Contact Check :
        
        //son step1(171 mode) 에 대해 4개의 4W pin을 설정하고 V값과 I 값을 측정을 Net개수 만큼 반복
        //    I값이 일정 수준 이상이 나올 때까지  측정을 반복한다.
        if (mode == 1) //sylee201005
        {
            for (net = 1; net <= nEnd; net++)   // net  
            {
                t1 = n4WNet[net][_4W_PIN1];   //son210223 1->_4W_PIN1 enum 변경
                t2 = nPinToPiece(t1);//SYLEE171225-2              

                //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
                if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                    if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                        continue;
                    }
                }

                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {//sylee131022
                    if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                        continue;
                    }
                }
                if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                    continue;
                }
                if ((nAutoReTest[nBlockCountP] < gRun05.m_nReCh) && (nManualStartFlag != 1) && (SysSet211.m_nDisable4wRetest != 1)) {  //sylee160604-1   //son220503
                    if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {    //sylee131022 
                        continue;
                    }
                }

                //son 이전 test에서 pass였다면 이 net을 test 하지 않는다. (retest 관련?)
                if (ng4WResult[net] == 2) {//sylee131022//pass
                    continue;
                }

                //son 이전 mode에서 불량이었다면 4W Contact 체크
                if (ng4WResult[net] != 2)//sylee131022//pass=2
                {
                    if (n2WCheck == 2) {//sylee201005
                        if (n4WNet[net][_4W_REF_AVG] < 10000) {//sylee201005     //son211005  _4W_SET_AVG -> _4W_REF_AVG
                            continue;
                        }
                    }

                    //son for Pin3, Pin4
                    if (nPos1[net] == 0)   //son 4W Contact fail이 아니면 (이전 테스트에서 I 수준이 괜찮았다면)
                    {
                        //son211102 4-> _4W_PIN4,  3-> _4W_PIN3 enum 변경
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 1);   //VB  TR 
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 2);   //VC  TR PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,
                        for (int k1 = 1; k1 <= 200; k1++) { //300uS
                            if (net == 1 && k1 <= 10) {//200us
                                Sub71.Delay_100ns(200);  //20uS
                            }
                            Sub71.Delay_100ns(100);  //10uS
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (Sub71.Y1 > (nISet * 0.6)) {//ok
                                    break;
                                }
                            }
                            else {//sylee191015-2
                                if (Sub71.Y1 > (nISet * 0.3)) {//sylee//sylee191015-2
                                    break;
                                }
                            }
                            if (k1 == 200) {//fail                           
                                nPos1[net] = 2; //son 4W Contact fail (I 값이 일정수준이 안 나온다고) 표시
                            }
                        }

                        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                    }

                    //son for Pin1, Pin2
                    if (nPos1[net] == 0)  //son 4W Contact fail이 아니면 (이전 테스트에서 I 수준이 괜찮았다면)
                    {
                        //son211102 2-> _4W_PIN2,  1-> _4W_PIN1 enum 변경
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 2);    //Vc  RELAY PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,  //SYLEE20111118
                        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);    //VB  RELAY PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,  //SYLEE20111118   
                        for (int k1 = 1; k1 <= 200; k1++) {  //300uS
                            if (net == 1 && k1 <= 10) {//200us
                                Sub71.Delay_100ns(200);  //20uS
                            }
                            Sub71.Delay_100ns(100);  //5uS
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (Sub71.Y1 > (nISet * 0.6)) {//ok
                                    break;
                                }
                            }
                            else {//sylee191015-2
                                if (Sub71.Y1 > (nISet * 0.3)) {//sylee//sylee191015-2
                                    break;
                                }
                            }
                            if (k1 == 200) {//fail
                                nPos1[net] = 2;  //son 4W Contact fail (I 값이 일정수준이 안 나온다고) 표시
                            }
                        }
                        Sub71.OnPinAllReset1(); ///PIN ALL RESET    
                    }
                }

            }//end of   for( i=1; i<=nEnd; i++)   // net 

        }//end of if(mode==1)

#endif//SYLEE201207
//#############################################################################################


        //------------------------------
        //son ADC B Filter를 4W로 설정

        Sub71.FilterSet(4);//sylee131112  

        if (m_nMode1 >= 176 && m_nMode1 <= 180) {   //sylee200217-4WCVMODE
            Sub71.OnCCCV_Set(2);  //cv //sylee191015    
        }
        else {
            Sub71.OnCCCV_Set(1);  //cc  //sylee191015  
        }
        Sub71.Delay_100ns(30000); //3ms //sylee140120-> 3mS-> 1mS  //sylee140212
        nPassCo1 = 0;//sylee150710     

        Sub71.nADCount1 = (int)dRec[m_nMode1][7];  //SYLEE180706- MOVED
        if (Sub71.nADCount1 < 1) {
            Sub71.nADCount1 = 1;
        }
        if (Sub71.nADCount1 > 300) { //sylee180222-1
            Sub71.nADCount1 = 300;
        }

        int nCo11;
        nCo11 = 0;


        //-----------------------------------
        //son 이 for문의 하는 일은 무엇???
        //    conitue 문들 맨 뒤에 실제 무얼 수행하는 부분이 없음. 
        //    if (nStop == 2) 체크를 위한 건가? 실제 수행시에 이미 하고 있는데???
        for (net = 1; net <= nEnd; net++)   // net 
        {

            //son 현재net의 모드가 수행중인  mode(ex:171)와 맞는지 확인
            if (nFlag_Fail_Full != 1) {//sylee160528-5
                if (dRec4w[mode][1] != n4WNet[net][_4W_MODE]) {// RECIPE NO SEARCH  //sylee13111\28 //son210223 10: _4W_MODE
                    continue;
                }
            }
            else { //sylee160528-5
                if (dRec4w[mode][1] < n4WNet[net][_4W_MODE]) { //sylee160528-5 //son210223 10: _4W_MODE
                    continue;
                }
                if (ng4WResult_2[net] == 3) {//sylee160528-5  //  fail  mohm detect
                    continue;
                }
            }

            //son Skip해야할  Piece인지 확인. (메인장비 정보 기준)
            t1 = n4WNet[net][_4W_PIN1];   //son210223 1-> _4W_PIN1 enum 변경
            t2 = nPinToPiece(t1);//SYLEE171225-2      
            if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                    continue;
                }
            }


            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {//sylee131022
                if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                    continue;
                }
            }
            //son 해당 piece에 이전에 openFail, short Fail이 있었느지 확인.
            if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                continue;
            }

            //son Retest 중인데 SysInfo05.m_nConEr 카운트를 4W Fail Count가 넘어간다면 4W 측정을 중단.
            if ((nAutoReTest[nBlockCountP] < gRun05.m_nReCh) && (nManualStartFlag != 1) && (SysSet211.m_nDisable4wRetest != 1)) {  //sylee160604-1    //son220503
                if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {    //sylee131022 
                    continue;
                }
            }

            //son 이전 test에서 pass였다면 이 net은 대상에서 제외. (다른 mode에서 pass이면 이 mode는 안해도 된다.)
            if (ng4WResult[net] == 2) {//sylee131022//pass
                continue;
            }
            if (nStop == 2) {
                AfxMessageBox(" Erro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,    4W Run Start Error!!!");
                goto task2_NEXT_MODE;  //son240713
            }

#if 0   //son220803 begin : Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

                //son 해당 piece가 PASS 상태인 Cell이면 4W 테스트 Resheet 의미없음
            if (nReSheetFlag1 == 1) { //sylee131127//resheet       
                int tmp1;
                tmp1 = n4WNet[net][_4W_PIN1]; //son210223 1-> _4W_PIN1 enum 변경
                tmp1 = nPinToPiece(tmp1);//SYLEE171225-2

                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][tmp1];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif //son220803 end

        }//end of for( i=1; i<=nEnd; i++)  // net 



        //////////////////////////////////////////

        //------------------------------------------------------
        //son  예비 4W 검사 :  검사 모드가 1,2 일 때 10회 검사
        if (mode == 1 || mode == 2 || mode == 3 || mode == 4 || mode == 5)   //sylee200217-4WCVMODE//sylee200515-patch
        {
            Sub71.Delay_100ns(10000); // 1mS//sylee180221-3 //sylee200217-4WCVMODE

            //son net 개수가 10개 이하이면
            if (nEnd < 10) {//sylee180222-1
                for (int k11 = 1; k11 <= 1; k11++) {
                    for (int k12 = 1; k12 <= 10; k12++) {   // net
                        Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN4] - 1, 4);
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);
                        Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN2] - 1, 3);
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                        Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN3] - 1, 2);
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                        Sub71.AOnPinSet1(2, n4WNet[1][_4W_PIN1] - 1, 1);
                        Sub71.Delay_100ns(nDelay10);//sylee180222-1

                        Sub71.AOnReadV1I1(5); // READ  4W V  , I         
                        Sub71.OnPinAllReset1();
                    }
                }
            }
            else {
                for (int k11 = 1; k11 <= 1; k11++) {
                    for (int k12 = 1; k12 <= 10; k12++) {   // net
                        Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN4] - 1, 4);   //son210223 1-> _4W_PIN1 enum 변경
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);
                        Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN2] - 1, 3);
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                        Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN3] - 1, 2);
                        Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                        Sub71.AOnPinSet1(2, n4WNet[k12][_4W_PIN1] - 1, 1);
                        Sub71.Delay_100ns(nDelay10);//sylee180222-1

                        Sub71.AOnReadV1I1(5); // READ  4W V  , I         
                        Sub71.OnPinAllReset1();
                    }
                }
            }
        }
        else
        {
            if (nCount > 0) {
                net = 1;

                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 4);    //VC  RELAY PinNo(0~8k)  //sylee150128//son210223 1-> _4W_PIN1 enum 변경     
                Sub71.Delay_100ns(100);   //sylee150709          
                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 2);    //VC  TR PinNo(0~8k)    //sylee150128  
                Sub71.Delay_100ns(800);   //sylee150709
                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);    //VB  RELAY PinNo(0~8k)  //sylee150128        
                Sub71.Delay_100ns(100);   //sylee150709              
                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);    //VB  TR PinNo(0~8k)     //sylee150709-move 
                Sub71.Delay_100ns(3500); //300uS  //sylee150710-1


                Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                Sub71.OnPinAllReset1(); ///PIN ALL RESET     
            }
        }
        //////////////////////////////////////////////////////////////////

        //########################################################################################
        //SYLEE170304-1
        //# 1차 검사 
        short n4W_Pass[MAX_4W_NET + 1];//son pass시 2차검사 //SYLEE170304-1       //son211102 10001 -> (MAX_4W_NET +1)
        short n4w_Fail1_Piece[MAX_PIECE + 1];//sylee170304   //son211102 501 -> (MAX_PIECE +1)
        double dDiffRate2;
        dDiffRate2 = 0.0;

        ::ZeroMemory(&n4W_Pass, sizeof(n4W_Pass));//SYLEE170304-1  
        ::ZeroMemory(&n4w_Fail1_Piece, sizeof(n4w_Fail1_Piece));   //sylee170304



        //-------------------------------------------------------------------------------------------
        //son 4개의 4W pin을 설정하고 V값과 I 값을 측정, R값 계산을  Net개수 만큼 반복 -> nCount 만큼 반복 측정
        //    계산 결과는 sum 으로 dR14w[][], dVB14w[][], dVC14w[][], dI14w[][]에 임시 저장

        for (j = 1; j <= nCount; j++)  //nCount=1 
        {
            for (net = 1; net <= nEnd; net++) {
                dR14w[6][net] = 0.0;    //R1;
                dVB14w[6][net] = 0.0;   //vb
                dVC14w[6][net] = 0.0;   //vc
                dI14w[6][net] = 0.0;    //i
            }


            // nEnd=5000; 

            for (int net2 = 1; net2 <= nEnd; net2++)   //sylee191122-1  
            {
                //son net2에 맞는 Sort된 net 위치를 찾아 온다.
                net = n4WSort1[net2];//sylee191122-1  
                //net=net2;
                if (net < 1)  
                    continue; //sylee191122-1  

                if (net >= MAX_4W_NET)     //son231107 Def_4WMax1 -> MAX_4W_NET(10000)
                    continue; //sylee191122-1  

                nRetryCo1 = 0;//sylee150721 
                if (n4W_Pass[net] == 1) //sylee170304  pass시 2차 검사 
                    continue;
                
                //sylee201018   if(dRec4w[mode][1]!=n4WNet[net][8]){// RECIPE NO SEARCH  //sylee13111\28
                if (dRec4w[mode][1] < n4WNet[net][_4W_MODE]) {// RECIPE NO SEARCH  //sylee201018 //son210223 10: _4W_MODE 
                    continue;
                }

                t1 = n4WNet[net][_4W_PIN1]; //son210223 1-> _4W_PIN1 enum 변경
                t2 = nPinToPiece(t1);//SYLEE171225-2                      

                if (n4w_Fail1_Piece[t2] >= (SysInfo05.m_nConEr + 100)) {//SYLEE210405-1
                    continue;
                }

                //son Skip해야할  Piece인지 확인.
                if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                    if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                        continue;
                    }
                }

                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {//sylee131022
                    if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                        continue;
                    }
                }
                //SYLEE200625  if( n4w_Fail1_Piece[t2] >= SysInfo05.m_nConEr){  //sylee170304-2
                //SYLEE200625        continue;                              
                //SYLEE200625   }
                if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                    continue;
                }

                if ((nAutoReTest[nBlockCountP] != 0) && (SysSet211.m_nDisable4wRetest == 1)) {  //sylee180521-1    //4w recheck (0:enable, 1: disable)   //son220503
                    if (n4wFail1Old[t2] > 0) {//sylee180529-1
                        continue;
                    }
                    if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {//sylee180529-1
                        continue;
                    }
                }

                /*  //SYLEE200625
                    if(( nAutoReTest[nBlockCountP]< gRun05.m_nReCh)&&(nManualStartFlag!=1)&&(SysSet211.m_nDisable4wRetest!=1)){  //sylee160604-1    //son220503
                    if( nOpenFail14W[t2] >= SysInfo05.m_nConEr){    //sylee131022
                    continue;
                    }
                    }
                    */

                //son 이전 test에서 pass였다면 이 net은 대상에서 제외. (여러모드중에 하나만 pass여도 pass임)
                if (ng4WResult[net] == 2) {//sylee131022//pass
                    continue;
                }

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
                //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

                    //son 해당 piece가 PASS 상태인 Cell이면 4W 테스트 Resheet 의미없음
                if (nReSheetFlag1 == 1) { //sylee131204//resheet       
                    int tmp1;
                    tmp1 = n4WNet[net][_4W_PIN1];              //son210223 1-> _4W_PIN1 enum 변경              
                    tmp1 = nPinToPiece(tmp1);//SYLEE171225-2
                    nReSheetCellNo = nBlockPieceNo1[nBlockCountP][tmp1];
                    nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                    if (nReSheetCellStatus == 1) {  //son PASS
                        continue;
                    }
                }
#endif      //son220803 end

                if (nStop == 2) {
                    AfxMessageBox(" Errro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,    4W Run Start Error!!!");
                    goto task2_NEXT_MODE;  //son240713
                }

                nMode = n4WNet[net][_4W_MODE];//sylee140420 //son210223 10:_4W_MODE 


Task1311://sylee150721


                dR14w[6][net] = 0.0;    //R1;//sylee150721
                dVB14w[6][net] = 0.0;   //vb//sylee150721
                dVC14w[6][net] = 0.0;   //vc//sylee150721
                dI14w[6][net] = 0.0;    //i//sylee150721
                nPassCo1 = 0;//sylee150710
                nPassCo2 = 0;//sylee150710


                n4W_Retry3 = 0; //sylee191025-1
                n4W_Retry4 = 0;

                for (k = 0; k < Kcount; k++)
                {
                    //son 4W Contact fail(I 값이 일정 수준이 안 나오는게) 아니라면 수행
                    if (nPos1[net] != 2)//sylee131112
                    {
                        if (Kcount <= 1) //4WSETUP140107
                        {
                            n4W_Retry1 = 0;//sylee170228
                            n4W_Retry2 = 0;//sylee190116-2
                            n4W_Retry5 = 0;
                            nZeroCo1 = 0;//sylee180520-1

                            if (SysInfo05.m_n4WSet1 == _4W_SET_FAST) {//sylee201018         //son201117 0 -> _4W_SET_FAST
                                nRetryEndSet = 1;
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_NORMAL) {//sylee200910 //son201117 1 -> _4W_SET_NORMAL
                                nRetryEndSet = 1; //sylee201018  2->1 
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_SLOW) {                  //son201117 2 -> _4W_SET_SLOW
                                nRetryEndSet = 2; //sylee201018  4->2                                
                            }
                            else if (SysInfo05.m_n4WSet1 == _4W_SET_FINE) {                  //son201117 3 -> _4W_SET_FINE       
                                nRetryEndSet = 4; //sylee201018  
                            }
                            else { //SysInfo05.m_n4WSet1=0
                                nRetryEndSet = 1;
                            }

                            dR4w1_old1 = 0.0;//sylee201012   


Task1700_beforeOnPinSet://sylee170228-1     //son230807                   
                            //son 먼지제거 기능:
                            //    핀설정 방향을 바꿔가면서 테스트해서 전기극성때문에 붙었던 먼지를 제거
                            if (n4W_Retry1 == 1) {//sylee200909  #2
                                nPinNo[1] = n4WNet[net][_4W_PIN4] - 1;  //vb tr      //son210223 1-> _4W_PIN1 enum 변경
                                nPinNo[2] = n4WNet[net][_4W_PIN1] - 1;  //vc tr
                                nPinNo[3] = n4WNet[net][_4W_PIN3] - 1;  //vb relay
                                nPinNo[4] = n4WNet[net][_4W_PIN2] - 1;  //vc relay                                    
                            }
                            else if (n4W_Retry1 == 2) {// #3
                                nPinNo[1] = n4WNet[net][_4W_PIN1] - 1;  //vb tr
                                nPinNo[2] = n4WNet[net][_4W_PIN4] - 1;  //vc tr
                                nPinNo[3] = n4WNet[net][_4W_PIN2] - 1;  //vb relay
                                nPinNo[4] = n4WNet[net][_4W_PIN3] - 1;  //vc relay                        
                            }
                            else if (n4W_Retry1 == 3) {// #4
                                nPinNo[1] = n4WNet[net][_4W_PIN4] - 1;  //vb tr
                                nPinNo[2] = n4WNet[net][_4W_PIN1] - 1;  //vc tr
                                nPinNo[3] = n4WNet[net][_4W_PIN3] - 1;  //vb relay
                                nPinNo[4] = n4WNet[net][_4W_PIN2] - 1;  //vc relay    
                            }
                            else {//sylee200909    #1
                                nPinNo[1] = n4WNet[net][_4W_PIN1] - 1;  //vb tr
                                nPinNo[2] = n4WNet[net][_4W_PIN4] - 1;  //vc tr
                                nPinNo[3] = n4WNet[net][_4W_PIN2] - 1;  //vb relay
                                nPinNo[4] = n4WNet[net][_4W_PIN3] - 1;  //vc relay    
                            }


                            //-----------------
                            //son 4W pin 설정
                            Sub71.AOnPinSet1(2, nPinNo[1], 2);    //Vc  TR PinNo(0~8k)   //sylee200220-1 
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, nPinNo[2], 1);    //Vb  TR PinNo(0~8k)   //sylee200220-1                                 
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, nPinNo[3], 4);    //Vc  RELAY PinNo(0~8k)  //sylee200220-1                               
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);
                            Sub71.AOnPinSet1(2, nPinNo[4], 3);    //Vb  RELAY PinNo(0~8k)  //sylee200220-1  

                            calPart = FileSysInfo01.checkUseCalDataPart(nPinNo[1], nPinNo[3]);    //son220419_2

                            tStart11 = Get_uSecond1();//uS  //sylee150710-1            

                            //sylee201006-1 Sub71.Delay_100ns(nDelay10); 
                            Sub71.Delay_100ns(3000); //200uS  //sylee201006-1


Task1500_afterOnPinSet://sylee150710 //son230807

                        /////////////////////////////////////////////////////////////////////////////////////////////////////
                             //if (SysSet12.m_nPinTotMax==PIN_TOT_8K){//8k
                            if ((nPinNo[1] <= nHalfPin1) && (nPinNo[3] <= nHalfPin1)) {//sylee200905
                                n4W_PinFastADC1 = 2;
                            }
                            else  if ((nPinNo[1] > nHalfPin1) && (nPinNo[3] > nHalfPin1)) {//sylee200905
                                n4W_PinFastADC1 = 2;
                            }
                            else {
                                n4W_PinFastADC1 = 1; //sylee200905
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////////
                    /*       if(SysInfo05.m_n4WSet1==1){//sylee20909
                                 if(n4W_PinFastADC1==2){
                                     nRetryEndSet=1;
                                 }else{
                                     nRetryEndSet=2;
                                 }
                             }else if(SysInfo05.m_n4WSet1==2){//sylee20909
                                 if(n4W_PinFastADC1==2){
                                     nRetryEndSet=2;
                                 }else{
                                     nRetryEndSet=4;
                                 }
                             }else{
                                 nRetryEndSet=1;
                             }
                             */
                             /////////////////////////////////////////////////////////////////////////////////////////////////////

                            //----------------------------
                            //son V값, I 값 측정
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I  
                            tStart12 = Get_uSecond1();//uS  //sylee150710-1
                            tStart13 = (tStart12 - tStart11);  //sylee150710-1

                            //-----------------------------
                            //son R 값 계산, Calibration

                            //son Sub71.R1 계산 (R = VC / I)
                            //SYLEE200909 ARun201_4w_R1(nISet);  //sylee150710
                            ARun201_4w_R2(nISet, n4W_Retry1);  //sylee200909 


                            //son raw R -> real R (4W는 real R로 판정함)
                            ARun201_4w_R_Cal1(m_nMode1, calPart);//sylee150710        //son220412   
#ifdef _TEST_4W_ALL_PASS_
                            Sub71.R1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;  //son220524_2 4W all pass를 만들 수 있는 테스트 코드
                            Sub71.W1 = 1;   //son220524_2

//    if (net == 12)  
//        Sub71.R1 = 0.53;
//    if (net == 34)  
//        Sub71.R1 = 0.55;
//    if (net == 55)  
//        Sub71.R1 = 0.52;
//    if (net == 150)  
//        Sub71.R1 = 0.49;
//    if (net == 189)  
//        Sub71.R1 = 0.50;
//    if (net == 200)  
//        Sub71.R1 = 0.57;
#endif

                            if (Sub71.R1 != 0.0) {
                                nOld1_R1_Rate1 = ((nOld1_R1 - Sub71.R1) / Sub71.R1) * 100.;
                            }
                            else {
                                nOld1_R1_Rate1 = 100000.;
                            }
                            if (nOld1_R1_Rate1 < 0.0) {
                                nOld1_R1_Rate1 = -nOld1_R1_Rate1;
                            }
                            nOld1_R1 = Sub71.R1;//sylee150710 

                            double n4W_Errr_Per;    //sylee170313 
                            n4W_Errr_Per = SysSet19.m_nSet6;      //son  'SET3' (Leak Set) > Retry4WErrorRate
                            if (n4W_Errr_Per < 0) {//sylee160609-1  //sylee161228   5->1    test  //sylee170313  1->0
                                n4W_Errr_Per = 5;
                            }
                            if (n4W_Errr_Per > 20) {     //sylee170307  
                                n4W_Errr_Per = 20;
                            }


                            n4W_Errr_Per = 3;

                            //----------------
                            //son 양품
                            if ((nOld1_R1_Rate1 < n4W_Errr_Per)
                                && (g_s4WNet[dutIdx].saData[net - 1].dRefLow <= Sub71.R1)     //son190705-DUT16   //son1005 dSetMin -> dRefLow
                                && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) { //양품  //sylee150710  //sylee170128-1   /10.  //sylee201006-1move   //son211005         
                                nPassCo1++;//sylee150710                                
                            }
                            //----------------
                            //son 불량 
                            else {
                                nPassCo1 = 0;//sylee150710   
                            }

                            //son tStart13이 RetryTime(dRec[m_nMode1][6])보다 작으면 
                            if (tStart13 < (nDelay10 / 10)) {   //sylee201006-1
                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 10)) {//sylee210414 

                                    //son  RetryTime(dRec[m_nMode1][6]) 이내이고, 양품이 5회 측정되지 않았으면  계속 retry를 시도한다.
                                    if (nPassCo1 < 5) { //sylee201006-1
                                        goto Task1500_afterOnPinSet;//sylee201006-1  //son230807
                                    }
                                }
                                //son  RetryTime(dRec[m_nMode1][6]) 이내이고, 불량이면 retry를 시도한다.
                                else {//sylee210414 
                                    if (nPassCo1 < 1) {
                                        goto Task1500_afterOnPinSet;  //son230807
                                    }
                                }
                            }


                            ////////////////////////////////////////////////////////////////////////////////////
                            nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET                      
                            if (nRet1 != 1) {
                                AfxMessageBox(" Errro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,   4W Run Start Error!!!");
                                return 0;
                            }

                            if (n4W_ADC_Fail_Flag == 1) {//ng  //sylee200513-1 
                                if (n4W_Retry5 < 1) { //sylee200909 
                                    n4W_Retry5++;
                                    goto Task1700_beforeOnPinSet;  //son230807
                                }
                            }

                            if (Sub71.W1 <= 0.0) { //sylee150713  import.////sylee150720
                                if (n4W_Retry3 < 2) {//sylee210427
                                    n4W_Retry3++;
                                    if (n4W_Retry3 > 1) {
                                        Sleep(1);
                                    }
                                    goto Task1700_beforeOnPinSet;  //son230807
                                }


                                Sub71.R1 = 9999999999; //sylee150713  import.
                            } //sylee150713  import.


                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE//SYLEE200220  //SYLEE210304-1
                                if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                                    Sub71.R1 = 99999999999;
                                }
                                if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                                    Sub71.R1 = 99999999999;
                                }
                            }
                            if (Sub71.W1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                                Sub71.R1 = 99999999999;
                            }

                            if (Sub71.R1 > 200000) {//sylee200506-3
                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 10)) {//sylee210414 
                                    if (n4W_Retry3 < 2) {//sylee200506-3
                                        n4W_Retry3++;
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                                else {
                                    if (n4W_Retry3 < 1) {//sylee200506-3
                                        n4W_Retry3++;
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                            }

                            /*//sylee201006-1
                            if( (nOld1_R1_Rate1< n4W_Errr_Per )
                                 && (g_s4WNet[dutIdx].saData[net-1].dRefLow <=Sub71.R1)     //son190705-DUT16   //son1005 dSetMin -> dRefLow
                                 && (Sub71.R1<=g_s4WNet[dutIdx].saData[net-1].dRefHigh)){ //양품  //sylee150710  //sylee170128-1   /10.      //son211005
                                 nPassCo1++;//sylee150710
                            }else{
                                 nPassCo1=0;//sylee150710
                            }
                            */
                            int n4W_Pass_Co; //sylee150721

                            n4W_Pass_Co = SysSet19.m_nSet7;
                            if (n4W_Pass_Co < 5) {//sylee160609-1
                                n4W_Pass_Co = 3;
                            }
                            if (n4W_Pass_Co > 50) {//sylee171101-1
                                n4W_Pass_Co = 50;
                            }

                            //----------------------------
                            //son  R, VC, I  값 저장.
                            //----------------------------
                            nPassCo1 = 0;//sylee150710    
                            n4WData1[net][n4W_Retry1] = Sub71.R1;//sylee200415
                            n4WData1v[net][n4W_Retry1] = Sub71.W1;//sylee200415
                            n4WData1i[net][n4W_Retry1] = Sub71.Y1;//sylee200415

                            //////////////////////////////////////////////////////////////////////////  
                            /*
                            if(n4w_Measure1_Enable==1)
                            {
                                d4W_Percent5=d4W_Percent5/100.;
                                if( (Sub71.R1 < (gd4W1[i+5][6]*(1-d4W_Percent5)))  || (Sub71.R1 > (gd4W1[i+5][6]*(1+d4W_Percent5)))  )
                                {
                                     
                                    if(n4W_Retry4++<1){
                                     goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                            }
                            else{
                                if( (Sub71.R1 <gd4W1[i+5][5])  || (Sub71.R1 > gd4W1[i+5][7]))
                                {
                                    if(n4W_Retry4++<1){
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                            }
                            */
                            //////////////////////////////////////////////////////////////
                            if (n4W_RetryFlag1 == 2) //sylee210417
                            {
                                if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0)//SYLEE220205  //SYLEE220312ADD 
                                {
                                    if ((Sub71.R1 < ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg * dPerRate1))                //son211005
                                        || (Sub71.R1 > ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg * dPerRate2)))               //son211005
                                    {
                                        if ((fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR4w1_old1)) < (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1))) {  //son211005
                                            Sub71.R1 = dR4w1_old1;
                                        }
                                        else {
                                            dR4w1_old1 = Sub71.R1;
                                        }

                                        if (n4W_Retry4++ < 3) { //sylee210417-4w   /sylee210420  10->3
                                            goto Task1700_beforeOnPinSet;  //son230807
                                        }
                                        else {
                                            nFail1[net] = 2;  //sylee210417  fail
                                        }
                                    }
                                }
                            }
                            //////////////////////////////////////////////////////////////

                            //---------------
                            //son 불량이면
                            if ((Sub71.R1 < g_s4WNet[dutIdx].saData[net - 1].dRefLow)     //son211005
                                || (Sub71.R1 > g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) //son211005
                            {
                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 5)) //sylee210414 
                                {
                                    if (n4W_Retry4++ < 5) { //sylee201030   1 -> 5
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                                else {
                                    if (n4W_Retry4++ < 1) { //sylee201030   1 -> 5
                                        goto Task1700_beforeOnPinSet;   //son230807
                                    }
                                }
                            }
                            /////////////////////////////////////////////////////////////////////////////// 

#ifdef __JTECH__CUSTOMER   //SYLEE201012
                            if ((nFlagRunMode1 == 2) || (nManualStartFlag == 1))//syle201012
                            {
                                if (nRetryEndSet == 1) //sylee200928
                                {
                                    if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg >= 10) //sylee201006    //son211005
                                    {
                                        if ((Sub71.R1 < (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 0.95))          //son211005
                                            || (Sub71.R1 > (g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 1.05)))         //son211005
                                        {        
                                            if ((fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - dR4w1_old1)) 
                                                    < (fabs(g_s4WNet[dutIdx].saData[net - 1].dRefAvg - Sub71.R1))) {      //son211005
                                                Sub71.R1 = dR4w1_old1;
                                            }
                                            else {
                                                dR4w1_old1 = Sub71.R1;
                                            }
                                            if (n4W_Retry4++ < 3) {//sylee201006 5->3
                                                if (nOpenFail14W[t2] < (SysInfo05.m_nConEr + 5)) {//sylee210414
                                                    if (nNGRetryCo1++ < 100) {//sylee201012
                                                        goto Task1700_beforeOnPinSet;  //son230807
                                                    }
                                                }
                                                else {
                                                    if (nNGRetryCo1++ < 5) {//sylee210414
                                                        goto Task1700_beforeOnPinSet;  //son230807
                                                    }
                                                }
                                            }
                                            else {
                                                nNGRetryCo1 = nNGRetryCo1;
                                            }
                                        }
                                    }
                                }
                            }

#endif

                            ///////////////////////////////////////////////////////////////////////////////                                
                            //son R값이 0.01 이하로 너무 작으면
                            if (Sub71.R1 < dMinR1) //sylee200506
                            {
                                if (n4W_Retry3 < 3) {//sylee200506
                                    n4W_Retry3++;
                                    goto Task1700_beforeOnPinSet;  //son230807
                                }
                                else
                                {
                                    //son R값이 0.01 이하로 너무 작다고 error 처리 (Pin Contact error)
                                    Sub71.R1 = 8888887;//sylee200506

    ////////////////////////////////////////////////////////////////////////////////////////////////
                                    int t1, t2, t3, t4;
                                    if (m_nMode1 == 171 || m_nMode1 == 176) //sylee211222 
                                    {
                                        //SYLEE220312ADD2 4w  0.1보다 작은 경우 999999 open으로 표시되던 것을    
                                        //                pin  4개  다 접촉되어 있으면 0.1정도로 표시하도록 수정.
                                        if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 10) {
                                            Sub71.OnPinAllReset1();
                                            t1 = n4WNet[net][_4W_PIN2] - 1;
                                            t2 = n4WNet[net][_4W_PIN3] - 1;
                                            t3 = n4WNet[net][_4W_PIN1] - 1;
                                            t4 = n4WNet[net][_4W_PIN4] - 1;

                                            Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                            Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                            Sub71.Delay_100ns(nDelay10);

                                            Sub71.AOnReadV1I1(5);

                                            // if( (Sub71.Y1>(nISet*0.8))  &&  (Sub71.W1<0.5)){
                                            if (Sub71.Y1 > (nISet * 0.8)) {

                                                Sub71.OnPinAllReset1();

                                                t1 = n4WNet[net][_4W_PIN1] - 1;
                                                t2 = n4WNet[net][_4W_PIN4] - 1;
                                                t3 = n4WNet[net][_4W_PIN2] - 1;
                                                t4 = n4WNet[net][_4W_PIN3] - 1;

                                                Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                                Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                                Sub71.Delay_100ns(nDelay10);

                                                Sub71.AOnReadV1I1(5);
                                                if (Sub71.Y1 > (nISet * 0.8)) {
                                                    Sub71.R1 = 0.09;
                                                }
                                            }
                                        }
                                    }  //SYLEE220312ADD2

////////////////////////////////////////////////////////////////////////////////////////////////
                                }
                            }
                            //////////////////////////////////////////////////////////////////////////////////
                            n4W_Retry1++;//sylee200415  

                            if (SysInfo05.m_n4WSet1 == _4W_SET_NORMAL) //sylee200525-2  //sylee201018  0->1      
                            {                                                         //son201117 1 -> _4W_SET_NORMAL
                                if ((Sub71.R1 < g_s4WNet[dutIdx].saData[net - 1].dRefLow)         //son211005
                                    || (Sub71.R1 > g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//son211005
                                    if (nRetryEndSet == 1) {//sylee200525
                                        nRetryEndSet = 2;
                                    }
                                }
                            }

                            if (n4W_Retry1 < nRetryEndSet) {//two measure
                                goto Task1700_beforeOnPinSet;  //son230807
                            }
                            //////////////////////////////////////////////////////////////////////////////////

                            if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL)//sylee200525  //sylee201018  0->1
                            {                                                   //son201117 1 -> _4W_SET_NORMAL
                                if (n4w_Measure1_Enable == 1) {
                                    if (Sub71.R1 < 1.0) {
                                        d4W_Percent5 = 22.5;
                                    }
                                    else if (Sub71.R1 < 10.0) {
                                        d4W_Percent5 = 13.5;
                                    }
                                    else {
                                        d4W_Percent5 = 2.7;
                                    }

                                    if ((nRetryEndSet == 1) && (n4W_Retry1 == 1)) {//sylee200420-1
                                        if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0) {//SYLEE220205 //SYLEE220312ADD
                                            dDiffRate2 = fabs(Sub71.R1 - g_s4WNet[dutIdx].saData[net - 1].dRefAvg) / g_s4WNet[dutIdx].saData[net - 1].dRefAvg * 100.; //ref.=gd4W1[i+5][6]   //son211005
                                            if (dDiffRate2 > d4W_Percent5) {//3%
                                                nRetryEndSet = 2;
                                                goto Task1700_beforeOnPinSet;  //son230807
                                            }
                                        }
                                    }

                                }
                                else {//auto pcb
                                    if ((nRetryEndSet == 1) && (n4W_Retry1 == 1)) {//sylee200420-1
                                        if ((g_s4WNet[dutIdx].saData[net - 1]).dRefAvg > 3.0) {//SYLEE220205 //SYLEE220312ADD
                                            if ((Sub71.R1 < g_s4WNet[dutIdx].saData[net - 1].dRefLow)     //son211005
                                                || (Sub71.R1 > g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//son211005
                                                nRetryEndSet = 2;
                                                goto Task1700_beforeOnPinSet;  //son230807
                                            }
                                        }
                                    }
                                }

                            }


                            //////////////////////////////////////////////////////////////////////////////////
                            //  if(SysInfo05.m_n4WSet1>0){//sylee200525
                            if ((nRetryEndSet == 2) && (n4W_Retry1 == 2))//sylee200420-1
                            {
                                Sub71.R1 = (n4WData1[net][0] + n4WData1[net][1]) / 2.;
                                dDiffRate2 = fabs(n4WData1[net][0] - n4WData1[net][1]) / Sub71.R1 * 100.;

                                if (Sub71.R1 < 1.0) {
                                    d4W_Percent5 = 22.5;
                                }
                                else if (Sub71.R1 < 10.0) {
                                    d4W_Percent5 = 13.5;
                                }
                                else {
                                    d4W_Percent5 = 2.7;
                                }


                                if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL)//sylee200525   //sylee201018  0->1
                                {                                                      //son201117 1 -> _4W_SET_NORMAL
                                    if (dDiffRate2 >= d4W_Percent5)  //=3
                                    {
                                        nCo11++;
                                        //sylee200909 import         
                                        nRetryEndSet = 4;
                                        //sylee200909 import      
                                        goto Task1700_beforeOnPinSet;  //son230807
                                    }
                                }
                            }
                            //  }
                            ///////////////////////////////////////////////////////////////////////////////
                            double dMin1, dMax1, dSum1;
                            if (SysInfo05.m_n4WSet1 > _4W_SET_NORMAL) {//sylee200525  //sylee201018  0->1
                                if (n4W_Retry1 == 4) {//sylee200420-1               
                                    dMin1 = 0.0;  dMax1 = 0.0; dSum1 = 0.0;
                                    for (int nL1 = 0; nL1 < 4; nL1++) {
                                        if (nL1 == 0) { dMin1 = n4WData1[net][0];  dMax1 = n4WData1[net][0]; }
                                        if (dMin1 > n4WData1[net][nL1]) {
                                            dMin1 = n4WData1[net][nL1];
                                        }
                                        else if (dMax1 < n4WData1[net][nL1]) {
                                            dMax1 = n4WData1[net][nL1];
                                        }
                                        dSum1 += n4WData1[net][nL1];
                                    }
                                    Sub71.R1 = (dSum1 - (dMin1 + dMax1)) / 2.;
                                }
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////
                            //sylee200506                                


                            double dOffsetRate1;


                            /////////////////////////////////////////////////////////////////////////////////////////////////

                            if (Sub71.R1 <= 300) {  //sylee230203
                                if (Sub71.R1 <= 0.2) { dOffsetRate1 = 0.2;    d4W_RoffSet2 = d4W_Noise1; }
                                else if (Sub71.R1 <= 0.5) { dOffsetRate1 = 0.2;    d4W_RoffSet2 = d4W_Noise1; }
                                else if (Sub71.R1 <= 1.0) { dOffsetRate1 = 0.2;    d4W_RoffSet2 = d4W_Noise1; }
                                else if (Sub71.R1 < 20.0) { dOffsetRate1 = 0.3;    d4W_RoffSet2 = d4W_Noise2; }
                                else if (Sub71.R1 <= 45.0) { dOffsetRate1 = 0.3;    d4W_RoffSet2 = d4W_Noise3; }
                                else if (Sub71.R1 <= 100.0) { dOffsetRate1 = 0.5;    d4W_RoffSet2 = d4W_Noise3; }
                                else if (Sub71.R1 <= 300.0) { dOffsetRate1 = 0.5;    d4W_RoffSet2 = d4W_Noise3; }

                                dRef4wR1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;
                                dDiffR1 = Sub71.R1 - dRef4wR1;
                                dDiffR2 = fabs(dDiffR1);    //son float의 절대값을 구한다.

                                if (dDiffR2 <= d4W_RoffSet2) {
                                    Sub71.R1 = dRef4wR1 + (dDiffR1 * dOffsetRate1);
                                }
                                else {
                                    if (dDiffR1 > 0) { Sub71.R1 = Sub71.R1 - d4W_RoffSet2; }
                                    else { Sub71.R1 = Sub71.R1 + d4W_RoffSet2; }
                                }
                            }

                            /////////////////////////////////////////////////////////////////////////////////////////////////



                        }
                        else  //4WSETUP140107
                        {



Task2700://sylee180823-1

                            if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 20.0) {//sylee180320-2       //son210223 1-> _4W_PIN1 enum 변경  //son211005
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 4);   //sylee180205 //VC  RELAY PinNo(0~8k)   //sylee170523-3               
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY1);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);  //sylee180205  //VB  RELAY PinNo(0~8k)  //sylee170523-3       
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY2);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 2);  //sylee180205  //VB  TR PinNo(0~8k)  //sylee160603-1   
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);   //sylee160603-1     //
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);  //sylee180205  //VC  TR PinNo(0~8k)   //sylee160603-1      
                            }
                            else {

                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3] - 1, 4);   //sylee180205 //VC  RELAY PinNo(0~8k)   //sylee170523-3               
                                //  Sub71.Delay_100ns(1500);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2] - 1, 3);  //sylee180205  //VB  RELAY PinNo(0~8k)  //sylee170523-3       
                                //  Sub71.Delay_100ns(1500);  //sylee180205-2
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4] - 1, 2);  //sylee180205  //VB  TR PinNo(0~8k)  //sylee160603-1   
                                //  Sub71.Delay_100ns(300);   //sylee160603-1     //
                                Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1] - 1, 1);  //sylee180205  //VC  TR PinNo(0~8k)   //sylee160603-1      
                            }
                            calPart = FileSysInfo01.checkUseCalDataPart(n4WNet[net][_4W_PIN3] - 1, n4WNet[net][_4W_PIN4] - 1);    //son220419_2

                            Sub71.Delay_100ns(nDelay10);
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I 
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (n4W_IDropCheck1(net) == -1) { //sylee180823-1 //sylee180912-1
                                    goto Task2700;//sylee180823-1
                                }
                            }

                            //son Sub71.R1  계산 (R = VC / I)
                            //SYLEE200909 ARun201_4w_R1(nISet);  //sylee150710

                            ARun201_4w_R2(nISet, n4W_Retry1);  //sylee200909     

                            //son Sub71.R1 R값 변환  (raw R -> real R. 4W는 real R 로 판정함)
                            ARun201_4w_R_Cal1(m_nMode1, calPart);//sylee150710   //son220412

                            nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET  
                            if (nRet1 != 1) {
                                AfxMessageBox(" Errro No 1023, \n    PIN ALL RESET  SET ERROR !,      ,   4W Run Start Error!!!");
                                return 0;
                            }
                        }

                        if (Sub71.R1 > dRoffset2) {//sylee180704-5
                            Sub71.R1 = Sub71.R1 - dRoffset1;
                        }

                        if (Sub71.W1 > 10.0) {  //sylee200217-4WCVMODE
                            Sub71.R1 = 9999999999;
                        }
                        if (Sub71.W1 <= 0.0) { //sylee150713  import.
                            Sub71.R1 = 9999999999; //sylee150713  import.
                        } //sylee150713  import.

                        if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                            if (Sub71.Y1 > nISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
                                Sub71.R1 = 99999999999;
                            }
                            if (Sub71.Y1 < nISetPercentLow) {//sylee120914   //I    ISEC 1%
                                Sub71.R1 = 99999999999;
                            }
                        }
                        if (Sub71.W1 > nVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                            Sub71.R1 = 99999999999;
                        }

                    }
                    else {//sylee131119
                        //son 4W Contact fail(I 값이 일정 수준이 안 나오는 케이스라는 의미) 표시
                        Sub71.R1 = 999999998; //sylee131119 
                    }//if(nPos1[net]!=2)//sylee131112


                    //son min, max 값 생성 
                    if (Kcount > 2) {
                        if (k == 0) {
                            dR14w[11][net] = Sub71.R1; //min
                            dR14w[12][net] = Sub71.R1; //max
                        }
                        else {
                            if (dR14w[11][net] > Sub71.R1) {
                                dR14w[11][net] = Sub71.R1; //min
                            }
                            if (dR14w[12][net] < Sub71.R1) {
                                dR14w[12][net] = Sub71.R1; //max
                            }
                        }
                    }

                    //son sum 값을 생성
                    dR14w[j + 5][net] = dR14w[j + 5][net] + Sub71.R1;   //R1;   //son <----dR14w[6][net] 값이 여기서 write됨.
                    dVB14w[j + 5][net] = dVB14w[j + 5][net] + Sub71.V1;  //vb
                    dVC14w[j + 5][net] = dVC14w[j + 5][net] + Sub71.X1;  //vc
                    dI14w[j + 5][net] = dI14w[j + 5][net] + Sub71.Y1;   //i

                }// for( k=0; k<10; k++  for( k=0; k<Kcount; k++)//sylee131112



                //-------------------------------------------------------------------
                //son d4WSet2(Ref.Low) 값을 n4wLowRetryPer1를 반영해서  결정한다.
                double d4wSet1, d4wSet2;//sylee171101-1
                d4wSet1 = 0;  d4wSet2 = 0;//sylee171101-1

                if (g_s4WNet[dutIdx].saData[net - 1].dRefLow > g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {    //son211005
                    d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5 //son211005
                }
                else if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh < g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {//son211005
                    d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5 //son211005
                }
                else {
                    d4wSet1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg * n4wLowRetryPer1;//sylee171104-5
                }

                if (g_s4WNet[dutIdx].saData[net - 1].dRefLow < d4wSet1) {    //son211005
                    d4wSet2 = d4wSet1;
                }
                else {
                    d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;    //son211005
                }

                if (n4wLowRetryPer1 == 0.0) {//sylee171104-5
                    d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;//sylee171104-5 //son211005
                }

                //--------
                //양품    

                //son Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                //sylee171101-1   if((gd4W1[i+5][5] <=Sub71.R1) && (Sub71.R1<=gd4W1[i+5][7]) ){//양품    //sylee150721
                if ((d4wSet2 <= Sub71.R1) && (Sub71.R1 <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) { //양품  //sylee150721 //sylee171101-1 //son211005
                    nRetryCo1 = 0;//sylee150721
                    n4W_Pass[net] = 1;
                }

                //--------
                //불량 //sylee150721
                else {
                    nRetryCo1++;//sylee150721
                    if (nRetryCo1 < nRetrySet) {//sylee150721
                        goto Task1311;//sylee150721
                    }
                    t1 = n4WNet[net][_4W_PIN1];//sylee170304     //son210223 1-> _4W_PIN1 enum 변경
                    // t2=nPieceNoPin[1][t1];//PIECE  piece no      //sylee170304
                    t2 = nPinToPiece(t1);//SYLEE171225-2
                    n4w_Fail1_Piece[t2]++;//sylee170304
                }

////////////////////////////////////////////////////////////////////////////////////////////////
                //son R값이 0.01 이하로 너무 작으면
                if (Sub71.R1 < dMinR1) //sylee200506                        
                {
                    //son R값이 0.01 이하로 너무 작다고 error 처리 (Pin Contact error)
                    Sub71.R1 = 8888887;//sylee200506   


                    int t1, t2, t3, t4;
                    if (m_nMode1 == 171 || m_nMode1 == 176)//sylee211222 
                    {
                        //SYLEE220312ADD2 4w  0.1보다 작은 경우 999999 open으로 표시되던 것을    
                        //                pin  4개  다 접촉되어 있으면 0.1정도로 표시하도록 수정.
                        if (g_s4WNet[dutIdx].saData[net - 1].dRefAvg <= 10) {
                            Sub71.OnPinAllReset1();
                            t1 = n4WNet[net][_4W_PIN2] - 1;
                            t2 = n4WNet[net][_4W_PIN3] - 1;
                            t3 = n4WNet[net][_4W_PIN1] - 1;
                            t4 = n4WNet[net][_4W_PIN4] - 1;

                            Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                            Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                            Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                            Sub71.Delay_100ns(nDelay10);

                            Sub71.AOnReadV1I1(5);

                            // if( (Sub71.Y1>(nISet*0.8))  &&  (Sub71.W1<0.5)){
                            if (Sub71.Y1 > (nISet * 0.8)) {

                                Sub71.OnPinAllReset1();

                                t1 = n4WNet[net][_4W_PIN1] - 1;
                                t2 = n4WNet[net][_4W_PIN4] - 1;
                                t3 = n4WNet[net][_4W_PIN2] - 1;
                                t4 = n4WNet[net][_4W_PIN3] - 1;

                                Sub71.AOnPinSet1(2, t1, 2);    //Vc  TR    
                                Sub71.Delay_100ns(DEF_4W_PIN_DELAY3);
                                Sub71.AOnPinSet1(2, t2, 1);    //Vb  TR  
                                Sub71.Delay_100ns(nDelay10);

                                Sub71.AOnReadV1I1(5);
                                if (Sub71.Y1 > (nISet * 0.8)) {
                                    Sub71.R1 = 0.09;
                                }
                            }
                        }
                    } //SYLEE220312ADD2

                }
////////////////////////////////////////////////////////////////////////////////////////////////


            }  ////for END   for (int net2 = 1; net2 <= nEnd; net2++)


        }//  fOR J   //SYLEE170304

        //########################################################################################
        //1차의  마지막 부분 


        //########################################################################################
        //2차 검사   ==> 삭제됨.
        nZeroCo2 = 0;//sylee180520-1 

       //=====================
       //양품 판정 
       //=====================           
        for (net = 1; net <= nEnd; net++)
        {
            if (nFlag_Fail_Full != 1) {//sylee160528-5   
                if (dRec4w[mode][1] != n4WNet[net][_4W_MODE]) {// RECIPE NO SEARCH  //sylee13111\28
                    continue;
                }
            }
            else { //sylee160528-5
                if (dRec4w[mode][1] < n4WNet[net][_4W_MODE]) { //sylee160528-5  //son 10:_4W_MODE
                    continue;
                }

                if (ng4WResult_2[net] == 3) {//sylee160528-5  //  fail  mohm detect
                    continue;
                }
            }

            t1 = n4WNet[net][_4W_PIN1];
            //  t2=nPieceNoPin[1][t1];//PIECE  piece no
            t2 = nPinToPiece(t1);//SYLEE171225-2 

            //son Skip해야할  Piece인지 확인.
            if (g_nSkipPieceFlag1 == 1) {///sylee160203-ITS  //SYLEE180528-1      //son220624
                if (g_nSkipPieceInfo[t2] == 2) {//sylee160203-ITS     //son220624
                    continue;
                }
            }

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {//sylee131022
                if (SysInfo19.m_nData[nBlockCountP][t2] == 1) {//sylee131022    //disable                
                    continue;
                }
            }

            if (nOpenFail1[t2] > 0 || nShortFail1[t2] > 0) {//sylee131022  open error , short error?
                continue;
            }

            /* //sylee180529-1
               if(( nAutoReTest[nBlockCountP]!=0) && (SysSet211.m_nDisable4wRetest==1)){  //sylee180521-1   //son220503
               if( nOpenFail14W[t2] >0){
               continue;
               }
               }
               *///sylee180529-1

            if ((nAutoReTest[nBlockCountP] != 0) && (SysSet211.m_nDisable4wRetest == 1)) {  //sylee180521-1  //son220503
                //sylee180529-1 if( nOpenFail14W[t2] >0){
                if (n4wFail1Old[t2] > 0) {//sylee180529-1
                    continue;
                }
                if (nOpenFail14W[t2] >= SysInfo05.m_nConEr) {//sylee180529-1
                    continue;
                }
            }

            /*  //SYLEE200625
                if(( nAutoReTest[nBlockCountP]< gRun05.m_nReCh)&&(nManualStartFlag!=1)&&(SysSet211.m_nDisable4wRetest!=1)){  //sylee160604-1    //son220503
                if( nOpenFail14W[t2] >=SysInfo05.m_nConEr){ //sylee131022
                continue;
                }
                }
                */

            if (ng4WResult[net] == 2) {//sylee131022//pass
                continue;
            }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet       
                int tmp1;
                tmp1 = n4WNet[net][_4W_PIN1];    //son210223 1-> _4W_PIN1 enum 변경
                // tmp1=nPieceNoPin[1][tmp1];
                tmp1 = nPinToPiece(tmp1);//SYLEE171225-2

                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][tmp1];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];

                //son 해당 piece가 PASS 상태인 Cell이면 4W 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif  //son220803 end

            if (dR14w[6][net] <= 0) {//sylee200507-import
                //sylee200507    dR14w[6][net]=0.01;//sylee150722
                dR14w[6][net] = 9999999;//sylee200507 
            }


            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            double d4wSet1, d4wSet2;//sylee171101-1
            d4wSet1 = 0;//sylee171101-1 //son dRefHigh와 dRefLow의 중앙값 또는 RefAvg 근사값.
            d4wSet2 = 0;//sylee171101-1

            //son dRefLow가 dRefAvg보다 큼 : 잘못 설정됨 
            if (g_s4WNet[dutIdx].saData[net - 1].dRefLow > g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {     //son211005
                d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5      //son211005
            }
            //son dRefHigh가 dRefAvg보다 작음 : 잘못 설정됨 
            else if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh < g_s4WNet[dutIdx].saData[net - 1].dRefAvg) {   //son211005
                d4wSet1 = ((g_s4WNet[dutIdx].saData[net - 1].dRefHigh + g_s4WNet[dutIdx].saData[net - 1].dRefLow) / 2.) * n4wLowRetryPer1;//sylee171104-5       //son211005
            }
            else {
                d4wSet1 = g_s4WNet[dutIdx].saData[net - 1].dRefAvg * n4wLowRetryPer1;//sylee171104-5
            }

            if (g_s4WNet[dutIdx].saData[net - 1].dRefLow < d4wSet1) {     //son211005
                d4wSet2 = d4wSet1;
            }
            else {
                d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;     //son211005
            }

            //son d4wSet2에  RefLow(하한값) 설정
            if (n4wLowRetryPer1 == 0.0) {//sylee171104-5
                d4wSet2 = g_s4WNet[dutIdx].saData[net - 1].dRefLow;//sylee171104-5      //son211005
            }

            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            int n4W_Pass1;//1= pass. 2=fail, 3 ful scale//sylee160528-5


            n4W_Pass1 = 0; //sylee160606-1  import

            if (nFlag_Fail_Full != 1) {//sylee160528-5

                //-------
                //양품  pass//sylee171104-3

                //son Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                if ((d4wSet2 <= dR14w[6][net]) && (dR14w[6][net] <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh))    //son211005
                {
                    n4W_Pass1 = 1;
                }
                //-------
                // 불량 
                else {
                    n4W_Pass1 = 2;    // fail
                }

            }
            else// full scale
            {

                //son 현재 전압 recipe mode(ex:171) 와 현재 net의 mode가 같을 때  
                if (dRec4w[mode][1] == (int)g_s4WNet[dutIdx].saData[net - 1].n4wMode)   //sylee160611-2 import
                {
                    //---------------
                    //son 양품 판정

                    //son dR14w[6][net] 는 R 값. R값이 Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                    //sylee171104-3 if( (gd4W1[i+5][5] <=dR14w[6][net])  &&  (dR14w[6][net]<=gd4W1[i+5][7])  ){
                    if ((d4wSet2 <= dR14w[6][net]) && (dR14w[6][net] <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) {//sylee171104-3  //son211005
                        n4W_Pass1 = 1; //pass log
                        ng4WResult_2[net] = 3;//pass detect      //son ??? 양품인데 왜 3 ???              

                        g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug     
                    }

                    //---------------
                    //son 불량 판정
                    else
                    {
                        //son 전압 mode Recipe의  MaxR 보다 작으면
                        if (dR14w[6][net] <= dRec4w1[mode][3]) {//fail  //sylee160611-2 import
                            n4W_Pass1 = 2; //fail
                            ng4WResult_2[net] = 3;//pass detect                       
                            g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                        }
                        else {//sylee160602-1- very import.    //sylee160611-2 import
                            if (mode == nEndStep1) { //end mode//sylee160602-1- very import.   //sylee160708 
                                n4W_Pass1 = 2; //fail
                                ng4WResult_2[net] = 3;//pass detect                       
                                g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                            }
                        }

                    }

                }

                //son 현재 전압 recipe mode(ex:171) 와 현재 net의 mode가 다를  때  
                else      //end of if( dRec4w[ik][1]==n4WNet[net][_4W_MODE]) 
                {
                    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

                    //---------------
                    //son 양품 판정
                    //---------------
                    //son dR14w[6][net] 는 R 값.  R값이 Ref.Low 값보다 크거나 같고, Ref.High값보다 작거나 같으면 양품으로 판정한다.
                    if ((g_s4WNet[dutIdx].saData[net - 1].dRefLow <= dR14w[6][net])        //son211005
                        && (dR14w[6][net] <= g_s4WNet[dutIdx].saData[net - 1].dRefHigh)) //son211005
                    {  //sylee160611-2 import
                        n4W_Pass1 = 1; //pass log
                        ng4WResult_2[net] = 3;//pass detect    //son ??? 양품인데 왜 3 ???               
                        g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                    }

                    //---------------
                    //son 불량 판정
                    //---------------
                    else  //sylee160611-2 import
                    {

                        if (dR14w[6][net] <= dRec4w1[mode][3]) {//fail
                            n4W_Pass1 = 2; //fail
                            ng4WResult_2[net] = 3;//pass detect    
                            g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug    
                        }
                        else {//sylee160602-1- very import.   

                            if (mode == nEndStep1) { //end mode//sylee160602-1- very import.   //sylee160708 
                                n4W_Pass1 = 2; //fail
                                ng4WResult_2[net] = 3;//pass detect                       
                                g_s4WNet[dutIdx].saData[net - 1].nCurrMode = m_nMode1;//debug     
                            }
                        }
                    }

                }  //end of if( dRec4w[ik][1]==n4WNet[net][_4W_MODE])
                //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

            } // // end of     if( nFlag_Fail_Full!=1 )//sylee160528-5

            //###############################################################################3

            //son221025 Sheet Retest 일때 블록별 초기화를 하지 않는 대신 d4W_Log1[nBlockCountP][net]을 먼저 99999999로 초기화하는 기능 추가.
            if (nReSheetFlag1 == 1)
                //son231205_2 d4W_Log1[nBlockCountP][net] = (float)99999999;     //son2201025  
                d4W_Log1[nBlockCountP][net] = (float)9999999;     //son231205_2  99999999 -> 9999999 Merge 문제 때문에 7자리로 수정. 
                                                                  //    NG%10.2f 로 출력시 공백없이 "NG99999999.00" 출력되서 머지가 어려움.
                                                                  //    7자리로 바꾸고 NG%11.2f 로 출력하면 "NG 9999999.00"으로 공백출력됨.

            //son 양품인 R 값을   d4W_Log1[nBlockCountP][net]에 저장. 
            if (n4W_Pass1 == 1) {//sylee160528-5
                ng4WResult[net] = 2;//sylee131022  //son 2:pass
                d4W_Log1[nBlockCountP][net] = (float)dR14w[6][net];//sylee150722
            }

            //son 불량인 R 값을 마이너스 또는 999999.0으로 d4W_Log1[nBlockCountP][net]에 저장.
            else if (n4W_Pass1 == 2)//sylee160528-5
            {
                ng4WResult[net] = 3;  //son 3:fail      //son231026  NO_TEST, Pass, Fail 표시 정확히 하기 위해 3(불량) write 추가.

                //son 측정값이 200 ohm 이상이면 에러처리
                if (dR14w[6][net] >= 200000) {//sylee171026-3
                    dR14w[6][net] = 999999.0;//sylee160524-1
                }

//son230817 삭제하기로 결정. d4W_R1[net] 값이 사용되는 부분이 현재 함수 내에 없음. 불필요한 코드로 판단되어 삭제함. 
//son230809 begin: 제이텍 4W Csv와 Error.txt 4W error R 값 불일치문제  관련해서 이동. 
//              현재 위치로 코드 이동 후에 불일치문제점 해결됨.  ???? 무슨 일을 하는 코드인지 확인 필요
//                if (d4W_R1[net] > 0.0) {//sylee180220-5
//                    if (d4W_R1[net] < dR14w[6][net]) {
//                        dR14w[6][net] = d4W_R1[net];
//                    }
//                    else {
//                        d4W_R1[net] = dR14w[6][net];
//                    }
//                }
//                else if (d4W_R1[net] == 0.0) { //sylee180220-5
//                    d4W_R1[net] = dR14w[6][net];
//                }
//son230809 end

#ifdef __SAVE_4W_SAMPLING_TIME  //son231117
                //son GTS에서 4w pin이 많아서 sampling이 오래 걸리는 문제가 있었음.   
                //    __SAVE_4W_SAMPLING_TIME 기능 On일 때에만 불량이어도 sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하고
                //    Off 일 때에는 나노시스 고객처럼 튀는 값이 write된다고 불만갖지 않도록 불량으로 출력한다.
                if (n4w_Sample_Enable == 1) //sylee200903   //sylee201030
                    d4W_Log1[nBlockCountP][net] = (float)dR14w[6][net];//sylee200903
                
                else //sylee200903
                    d4W_Log1[nBlockCountP][net] = (float)-dR14w[6][net];//sylee160524-1
                
#else
                //son231101 나노시스문제점 수정. 
                //   4W sampling 수집시에 비정상적으로 큰 값이 Log4W_SAMPLE#_20221008_185246_ALL_Ok.CSV 파일에 wrtie되는 문제 
                //   sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하는게 문제였으므로 
                //   sampling도 일반 4W Csv와 동일하게 불량값을 마이너스로 write한다.
                d4W_Log1[nBlockCountP][net] = (float)-dR14w[6][net];   //son231101 
#endif

                //son 4W Fail 만 모아놓은 리스트에 현재 4W Fail 정보를 write한다.
                //son231107 if (g_n4WFailCount < MAX_4W_NET) //sylee160605-1     //son-4WDUT-20200403: 5000-> MAX_4W_NET  
                if (g_n4WFailCount <= MAX_4W_NET) //son231107 10000개 처리 불가 문제 수정
                {
                    g_n4WFailCount++;

                    n4WFail1[g_n4WFailCount][0] = g_n4WFailCount;
                    n4WFail1[g_n4WFailCount][1] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0];  //PIN1
                    n4WFail1[g_n4WFailCount][2] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1];  //PIN2
                    n4WFail1[g_n4WFailCount][3] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2];  //PIN3
                    n4WFail1[g_n4WFailCount][4] = (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3];  //PIN4
                    n4WFail1[g_n4WFailCount][5] = g_s4WNet[dutIdx].saData[net - 1].dRefLow;  //set LOW        //son211005
                    n4WFail1[g_n4WFailCount][6] = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;  //SET AVE
                    n4WFail1[g_n4WFailCount][7] = g_s4WNet[dutIdx].saData[net - 1].dRefHigh; //SET HIGH   //son211005

//son230809 moved to upper. 제이텍 4W csv와 Error.txt R 값 불일치 문제점 원인. 
//          문제해결을 위해 4W Csv(d4W_Log1[nBlockCountP][net]) 와 Error.txt(n4WFail1[g_n4WFailCount][8]) 
//          write 이전 시점으로 옮기니 불일치가 해결됨.
//                    if (d4W_R1[net] > 0.0) {//sylee180220-5
//                        if (d4W_R1[net] < dR14w[6][net]) {
//                            dR14w[6][net] = d4W_R1[net];
//                        }
//                        else {
//                            d4W_R1[net] = dR14w[6][net];
//                        }
//                    }
//                    else if (d4W_R1[net] == 0.0) { //sylee180220-5
//                        d4W_R1[net] = dR14w[6][net];
//                    }
//
                    n4WFail1[g_n4WFailCount][8] = dR14w[6][net];  //FAIL R  //son 이미 CalConvert를 한 real R 
                    n4WFail1[g_n4WFailCount][9] = dVB14w[6][net];  //  VB
                    n4WFail1[g_n4WFailCount][10] = dVC14w[6][net];  //  VC
                    n4WFail1[g_n4WFailCount][11] = dI14w[6][net];  //  I
                    n4WFail1[g_n4WFailCount][12] = m_nMode1;  //  MODE  SET
                    //sylee160605-1 n4WFail1[g_n4WFailCount][13]=m_nMode1;  //  

                    //son RefHigh 대 측정값비율
                    if (g_s4WNet[dutIdx].saData[net - 1].dRefHigh == 0)     //son231020_2 devide by zero 예방
                        n4WFail1[g_n4WFailCount][13] = 0;                   //son231020_2
                    else                                                    //son231020_2
                        n4WFail1[g_n4WFailCount][13] = (dR14w[6][net] / g_s4WNet[dutIdx].saData[net - 1].dRefHigh) * 100.;  //  //sylee160605-1 //son211005
                    //SYLEE200616-1 t1=  (int)g_s4WNet[dutIdx].saData[net-1].wPiece;//PIECE  pin no

                    t1 = (int)(g_s4WNet[dutIdx].saData[net - 1]).waPin[0];//SYLEE200616-1
                    //t1=nPieceNoPin[1][t1];//PIECE  piece no
                    t1 = nPinToPiece(t1);//SYLEE171225-2
                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314

                    if (nFailPiece[t1][nPStep1] >= SysInfo05.m_nConEr) {//sylee160117
                        n4wMoreThanFlag = 1;//sylee160117                          
                    }

                    nOpenFail14W[t1]++;//SYLEE131022
                    //  n4wFail1Old[t1]++;//sylee160601-5
                    nOpenFail14WBlock[nBlockCountP][t1]++;//SYLEE131022 //son Graph 출력을 위한 값
                    //  n4WFail1[g_n4WFailCount][14]=gd4W1[i+5][0];  //  PIECE                        
                    n4WFail1[g_n4WFailCount][14] = t1;////PIECE  no   //sylee20120314
                    n4WFail1[g_n4WFailCount][15] = net;  // net no
                    n4WFail1[g_n4WFailCount][17] = nBlockCountP;  // block no

                    if (dRec4w[mode][2] > dR14w[6][net]) {
                        n4WFail1[g_n4WFailCount][16] = 2;  // range down
                        nW4FailOut1++;
                    }
                    else if (dR14w[6][net] > dRec4w[mode][3]) {
                        n4WFail1[g_n4WFailCount][16] = 3;  // range up
                        nW4FailOut1++;
                    }
                    else {//if( (dRec4w[mode][2]<=dR14w[6][net])   &&   (dR14w[6][i]<=dRec4w[mode][3])    ){ // 측정 range in  불량 
                        n4WFail1[g_n4WFailCount][16] = 1;  // range in
                    }

                    if (nPos1[net] == 2) {//sylee181005-2  
                        n4WFail1[g_n4WFailCount][19] = 2;  // contact fail  
                    }
                    else {
                        n4WFail1[g_n4WFailCount][19] = 0;
                    }
#ifdef __GTS_4W_SPCIALNET__
                    n4WFail1[g_n4WFailCount][F_4W_NET_SPECIAL] = g_s4WNet[dutIdx].saData[net - 1].bNetSpecial;    //son221114
#endif

                } // end of   if( g_n4WFailCount<= MAX_4W_NET)

                //  else//sylee160528-5  // full scale

            }   //end of else   // fail   


        }// end of      for( net=1; net<=nEnd; net++) //양품 판정

        //#########################################################################################################

        n4WFail1[0][0] = g_n4WFailCount;//total count fail



task2_NEXT_MODE:  //son240713

        Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018 


    }//for(mode=1; mode<=5; mode++)




/////////////////////////////////////////////////////////////////////////////

    double d11[20];

    if (n4W_RetryFlag1 == 2)//sylee210419/////
    {

        for (net = 1; net <= nEnd; net++)
        {
            d11[2] = d4W_Log1[nBlockCountP][net];             //son R
            d11[3] = g_s4WNet[dutIdx].saData[net - 1].dRefAvg;  //son RefAvg
            d11[6] = (d11[2]) - (d11[3]);//*0.15;//             //son diff    : R - RefAvg 
            d11[7] = d11[6] / d11[3] * 100.;//*0.15;             //son diffRate: (R - RefAvg)/RefAvg * 100
            if (d11[7] < 0) {
                d11[7] = -d11[7];
            }
            if (d11[7] <= 1) {
                d11[9] = d11[6] * 0.8;//sylee210420-1
            }
            else if (d11[7] <= 2) {
                d11[9] = d11[6] * 0.6;//sylee210420-1
            }
            else if (d11[7] <= 30) {
                d11[9] = d11[6] * 0.3;//sylee210420-1
            }
            else {
                d11[9] = d11[6] * 0.8;
            }
            d4W_Log1[nBlockCountP][net] = d11[3] + d11[9];
        }

    }





    //sylee191127
    //==========================================================================================================

    tStart1001 = GetuSecond();//SYLEE150701

    nRelay1OffSkip = 0;//sylee170424-1
    if (n4Wire == 4) { //interlock 
        Sub71.On4WireMode(0); //4WIRE  a=1 ON, 0 OFF
    }

    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704 

    Sub71.OnPinResetInit();//sylee151221   //ACE400


    for (int w3 = 1; w3 <= nPieceMax; w3++) {
        n4wFail1Old[w3] = nOpenFail14W[w3];//SYLEE160604
    }


    //==========================================================================================================
    //sylee160605-1


    //SYLEE180521-1 if( (nAutoReTest[nBlockCountP]== gRun05.m_nReCh)||  (SysSet211.m_nDisable4wRetest==1)){  //sylee160604-1    //son220503
    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh)  //SYLEE180521-1
    {
        //-------------------------------------------------
        //son 4w  error list sorting  : Ref High Over Rate 
        if (SysSet13.m_n4wFailSortMode == F_4W_SORT_HIGH_OVERRATE)  //son230106_2  4W Fail Sort 모드 선택기능 관련  
        {                                                           //             0:RefHigh OverRate  1: 4w NetNo 
            double dMax2; //son n4WFail1[k5][13](RefHigh대비 측정값)의 최대값
            int k3, k5; 
            int nMax2No;  //son n4WFail1[k5][13](RefHigh대비 측정값)의 최대값 위치 표시
            int nNewNo;
            int nInter1;

            nInter1 = 0;
            ::ZeroMemory(&n4WFail2T, sizeof(n4WFail2T));
            if (SysSet211.m_nDisable4wRetest != 1) {//sylee180521-1       //son 4w recheck enable  (0:enable, 1: disable)   //son220503
                ::ZeroMemory(&nOpenFail14W, sizeof(nOpenFail14W));
            }

            nNewNo = 0;
            for (k3 = 1; k3 <= g_n4WFailCount; k3++) {
                n4WFail1[k3][18] = 0;
            }

            for (int pi1 = 1; pi1 <= g_nPieceMax1; pi1++)
            {
                for (k3 = 1; k3 <= g_n4WFailCount; k3++)
                {
                    dMax2 = 0.0;
                    nMax2No = 0;
                    for (k5 = 1; k5 <= g_n4WFailCount; k5++)
                    {
                        if (nOpenFail14W[pi1] >= SysInfo05.m_nConEr) {   //sylee131022 
                            continue;
                        }
                        t1 = (int)n4WFail1[k5][1];//PIECE  pin no
                        //t1=nPieceNoPin[1][t1];//PIECE  piece no
                        t1 = nPinToPiece(t1);//SYLEE171225-2
                        //nOpenFail14W[t1]++;//SYLEE131022
                        //interlock??// 
                        if (nInter1 == 0) {
                            if (t1 <= 0) {
                                nInter1 = 1;
                                str.Format("Error No 4013 :  4w  Pin Piece no?.  Pin=%d, piece=%d  ", (int)n4WFail1[k5][1], t1);
                                MyTrace(PRT_BASIC, str);     //son221104_2
                                AfxMessageBox(str, MB_OK);
                            }
                        }
                        if (pi1 != t1) {
                            continue;
                        }

                        //son 이미 RefHigh대 측정값 비율로 정렬완료이면 skip한다.
                        t1 = (int)n4WFail1[k5][18]; 
                        if (t1 == 1) {
                            continue;
                        }

                        //son RefHigh 대 측정값 비율이 가장 큰  n4WFail1[k5]을 찾는다. 
                        if (n4WFail1[k5][13] > dMax2) { 
                            dMax2 = n4WFail1[k5][13];
                            nMax2No = k5;   //son  RefHigh 대 측정값의 최대값 위치(Location)
                        }
                    }//end of  for( int k5=1; k5<=g_n4WFailCount; k5++)

                    //son 가장 큰  n4WFail1[k5]부터 n4WFail2T[nNewNo]에 write해서 정렬한다.
                    if (nMax2No > 0) {//max  sort select
                        n4WFail1[nMax2No][18] = 1;   //son n4WFail2T[nNewNo]에 write해서 정렬 되었다고 표시
                        t1 = (int)n4WFail1[nMax2No][1];//PIECE  pin no
                        // t1=nPieceNoPin[1][t1];//PIECE  piece no
                        t1 = nPinToPiece(t1);//SYLEE171225-2
                        nOpenFail14W[t1]++;
                        nNewNo++;
                        n4WFail2T[nNewNo][0] = nNewNo;
                        n4WFail2T[nNewNo][1] = n4WFail1[nMax2No][1];
                        n4WFail2T[nNewNo][2] = n4WFail1[nMax2No][2];
                        n4WFail2T[nNewNo][3] = n4WFail1[nMax2No][3];
                        n4WFail2T[nNewNo][4] = n4WFail1[nMax2No][4];
                        n4WFail2T[nNewNo][5] = n4WFail1[nMax2No][5];
                        n4WFail2T[nNewNo][6] = n4WFail1[nMax2No][6];
                        n4WFail2T[nNewNo][7] = n4WFail1[nMax2No][7];
                        n4WFail2T[nNewNo][8] = n4WFail1[nMax2No][8];
                        n4WFail2T[nNewNo][9] = n4WFail1[nMax2No][9];
                        n4WFail2T[nNewNo][10] = n4WFail1[nMax2No][10];
                        n4WFail2T[nNewNo][11] = n4WFail1[nMax2No][11];
                        n4WFail2T[nNewNo][12] = n4WFail1[nMax2No][12];
                        n4WFail2T[nNewNo][13] = n4WFail1[nMax2No][13];
                        n4WFail2T[nNewNo][14] = n4WFail1[nMax2No][14];
                        n4WFail2T[nNewNo][15] = n4WFail1[nMax2No][15];
                        n4WFail2T[nNewNo][16] = n4WFail1[nMax2No][16];
                        n4WFail2T[nNewNo][17] = n4WFail1[nMax2No][17];
                        n4WFail2T[nNewNo][18] = n4WFail1[nMax2No][18];
                        n4WFail2T[nNewNo][19] = n4WFail1[nMax2No][19];
#ifdef __GTS_4W_SPCIALNET__
                        n4WFail2T[nNewNo][F_4W_NET_SPECIAL] = n4WFail1[nMax2No][F_4W_NET_SPECIAL];  //son221114

#endif
                    //  nOpenFail14W[t1]++;//SYLEE131022
                    }

                }//end of for( int k3=1; k3<=g_n4WFailCount; k3++)

            }//end of        for(int pi1=1; pi1<=g_nPieceMax1; pi1++)


            if (g_n4WFailCount != nNewNo) {
                g_n4WFailCount = nNewNo;
                //   str.Format("Error No 4012 :  4w  error list sorting error.  g_n4WFailCount=%d,  nNewNo=%d  ",g_n4WFailCount,nNewNo);
                //  AfxMessageBox(str, MB_OK);  
                //  error messsage    
            }

            ::ZeroMemory(&n4WFail1, sizeof(n4WFail1));
            memmove(n4WFail1, n4WFail2T, sizeof(n4WFail1));
        }

    }//end of  if( nAutoReTest[nBlockCountP]== gRun05.m_nReCh)  //sylee160604-1

    //==========================================================================================================
    Sub71.AOnRelayOffSel(1);//SYLEE170314-1
    Sub71.OnRelayAllOff1();//sylee200131
    Sub71.OnCCCV_Set(1);  //sylee200217-4WCVMODE
    nFlag_4W_OUT50V = 0;//SYLEE200411 




    //###################################################################################
    //------------------------------
    //son 4W Sampling data 생성
    //------------------------------
    if (n4w_Sample_Enable == 1)//sylee150812-1
    {
        if (n4w_Sample_RunCount[dutIdx] <= n4w_Sample_SetCount)
        {
            n4w_Sample_Old = 2;

            int nEnd;
            nEnd = (int)g_s4WNet[dutIdx].wCount;
            g_n4wSampleFailCo1 = 0;//SYLEE171103-1

            for (int net = 1; net <= nEnd; net++)
            {
                if (d4W_Log1[nBlockCountP][net] < 0) {
#ifdef __SAVE_4W_SAMPLING_TIME  //son231117
                    //son 0보다 작으면 d4W_Log2에서는 플러스가 되게 만든다. =>  8000까지 튀는 값이 write되는 문제 있을 수 있음.
                    //    추가 사유: GTS에서 4w pin이 많아서 sampling이 오래 걸리는 문제가 있었음.   
                    //    __SAVE_4W_SAMPLING_TIME 기능 On일 때에만 불량이어도 sampling 일 때는 0보다 큰 값으로 write해서 정상으로 출력하고
                    //    Off 일 때에는 나노시스 고객처럼 튀는 값이 write된다고 불만갖지 않도록 불량으로 출력한다.
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = -d4W_Log1[nBlockCountP][net];
                    
#else                    
                    //son231101 4wSampling 튀는 값 나노시스문제점 수정. 마이너스 값일 때 fail 처리 기능 추가
                    //    여기서 d4W_Log2에 마이너스 그대로  write되면 바로 아래 아래의
                    //    if (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] < 0) 코드에서 g_n4wSampleFailCo1++ 처리가 된다.
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = d4W_Log1[nBlockCountP][net];   //son231101
#endif                    
                }
                else {
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = d4W_Log1[nBlockCountP][net];//sylee200615
                }

                if (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] == 0)      //son220518
                    d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] = 999999;  //son220518


                if ((d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] >= 200000) 
                        || (d4W_Log2[dutIdx][n4w_Sample_RunCount[dutIdx] + 1][net] < 0))  //sylee201128
                {
                    g_n4wSampleFailCo1++;
                    t1 = (int)(g_s4WNet[dutIdx].saData[net - 1]).waPin[0];  //sylee201128       //sylee201204-patch      
                    t1 = nPinToPiece(t1); //sylee201128                    
                    nOpenFail14W[t1]++; //sylee201128   
                    //SYLEE210414-1-    g_n4WFailCount++;//sylee201128                     
                    nFailPiece[t1][nPStep1]++;//sylee201128
                    nOpenFail14WBlock[nBlockCountP][t1]++;  //sylee201128                

                }//sylee150813-1


            }//sylee150813-1

            if (n4w_Sample_RunCount[dutIdx] >= 0)//SYLEE171103-1  =
            {
                if (n4w_Sample_RunCount[dutIdx] < n4w_Sample_SetCount) //sylee170518
                {
                    if (g_n4wSampleFailCo1 == 0)//sylee150813-1
                    {
                        n4w_Sample_RunCount[dutIdx]++;//sylee150812-
                        n4w_Sample_ok1 = 1;//sylee171103-5

                        //son211220 Unitech 요구사항. 4W_Setup_A.txt에 sample sheet번호, BarCode 정보 추가 
                        g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].wSheetNo = n4w_Sample_SheetCount[dutIdx] + 1;  //son211220
                                //son SheetCount는 4W Error 뿐 아니라 Open, Short 불량등의 다른 이유로 증가할 수 있지만, 
                                //    4wSampling matching 정보는  RunCount가 증가하는 시점의 SheetCnt가 필요하다. 
                                //    그래서 SheetCnt가 증가하는 AProcess101()이 아니라, ARun201_4w_3() 시점에서 +1한 SheetCnt로  보관한다.
                                
                        //ReadBarCode_fromHandlerDrive(g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].strBarCode, g_strLotName);  //son211220   //son220124
                        GetBarCode(g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].strBarCode);     //son240622

                        MyTrace(PRT_BASIC, "n4w_Sample_RunCount[%d]=%d, n4w_Sample_SheetCount[%d]+1=%d, BarCode=%s\n",  //son211715
                            dutIdx, n4w_Sample_RunCount[dutIdx], dutIdx, (n4w_Sample_SheetCount[dutIdx] + 1),
                            g_4wSampling[dutIdx][n4w_Sample_RunCount[dutIdx]].strBarCode);

                        //son 박봉규부장님 요구사항으로 추가. 이전 BarCode.txt를 잘못 읽지 않도록 읽고나면 계측기 쪽에서 지운다.
                        //son230707 fName없이 delete하는 문제때문에 삭제.  계측기 입장에서는 안 지우는게 더 나은것으로 판단되어 
                        //          DeleteFile(fName)  삭제함. ChildView1에서도 BarCode.txt를 사용하기 때문에 여기서 지우면 Childview1은 못 읽을 수 있어.
                        //son230707 DeleteFile(fName);//son211117  //son220124 moved from ReadBarCode_fromHandlerDrive()
                    }
                }
            }
            n4w_Sample_Old = nBlockCountP;//sylee150812-1          
        }
    }
    else {
        n4w_Sample_Finish = 0;//sylee150813-1
    }
    //###################################################################################

#ifndef _PC_TEST_
    if (g_n4WFailCount > 0)//sylee210301
    {
        //  m_nMode1=dRec4w[mode][1];
        m_nMode1 = 171;
        mode = 1;
        if (SysSet13.m_n4WCVMode == 1) { //sylee200217-4WCVMODE
            if (m_nMode1 == 171)  m_nMode1 = 176;
            if (m_nMode1 == 172)  m_nMode1 = 177;
        }

        nCC = (int)dRec[m_nMode1][1];
        nVRel = (int)dRec[m_nMode1][2];
        nVSet = (int)dRec[m_nMode1][3];
        nIR = (int)dRec[m_nMode1][4];
        nISet = (int)dRec[m_nMode1][5];
        nDelay10 = (int)dRec[m_nMode1][6] * 10;
        Sub71.nADCount1 = (int)dRec[m_nMode1][7];    //sylee150713
        nFil = (int)dRec[m_nMode1][8];//SYLEE130706
        nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130706 
        nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
        n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123

        Kcount = 1;

        if (nISet < 0.1) {
            AfxMessageBox(" Error No 7706, \n    I Set  ( <0.1 ) SET ERROR !,  4W  Start Error!!!");
        }
        if (nIR == 1 || nIR == 2) {   //mA
            nISetVal1 = nISet * 0.1;
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {
            nISetVal1 = nISet * 0.1;
        }
        else {
            AfxMessageBox(" Error No 1024, \n    I RANGE 1~5   SET ERROR !,      4W FAIL  Run Start Error!!!");
            return 0;
        }

        n4Wire = 4;
        nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
        nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
        //=========================================================================================
        //interlock   
        if (nCC != 1 && nCC != 2) {
            AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     4W Run Start Error!!!");
            return 0;
        }

        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  
        Sub71.AOnReadV1Enable1(5);
        //sylee180910-1    Sub71.FilterSet(4);//sylee130706  
        Sub71.I_Filter(nIFilter);//sylee130706

        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on        
        }
        else {
            Sub71.I_Gain(1);  //1x  =io off
        }

        if (n4Wire == 4) {   //ACE380
            if (n4wGain == 2) {
                Sub71.On4W_GainSet(2);
            }
            else  if (n4wGain == 3) {
                Sub71.On4W_GainSet(3);
            }
            else  if (n4wGain == 4) {
                Sub71.On4W_GainSet(4);
            }
            else {
                Sub71.On4W_GainSet(1);
            }
        }
        else {
            Sub71.On4W_GainSet(1);
        }

        //**********************************************************//

        if (mode == 1) {//sylee150128 ace380 
            Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //RELAY ON 
        }
        else {//    if(ik==1){//sylee150128 ace380          
            Sub71.nModeIR = 1;
            if (nISet == 1) {//sylee150715
                Sub71.AOnISet1Run1(nISet);
            }
            else {
                Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE150701
            }
        } //if(ik==1){//sylee150128 ace380

        Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 

        if (mode == 4) {
            Sub71.Delay_100ns(5000); //5ms  //sylee150709 
        }
        // nRCount=1;
        nLoop = 0;//SYLEE20120302  //sylee131128   
        //sylee200515-patch nEnd=(int)gd4W1[0][0];
        // int dutIdx = get4wDutIdx(); 
        nEnd = (int)g_s4WNet[dutIdx].wCount; //sylee200515-patch

        if (nEnd < 0) { //son241009 0도 처리하게 
            str.Format("Error No 7115 , \n\n  Process Stop. \n\n  4W NET LIST wCount< 0!    \n\n\n\n   => .BDL\4w.ini check. \n  4W  RUN STOP \n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }
        //sylee170729-1  if(nEnd>=5000){
        if (nEnd >= MAX_4W_NET) {//sylee200521 //son231107 Def_4WMax1 -> MAX_4W_NET(10000)
            str.Format("\n\nError No 7801,  4w total count over ( >=%d)      \4w.ini check. !     \n\n\n    \n\n\n ", 
                                                        MAX_4W_NET); //sylee210427 //son231107 Def_4WMax1 -> MAX_4W_NET(10000)
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
        }

        if (SysSet19.m_n4WHVon == 1) { //sylee200217-4WCVMODE
            Sub71.FilterSet(4);     //sylee190525  //sylee191023-1
        }
        else {//sylee191023-1
            Sub71.FilterSet(1);
        }//sylee191023-1
        nRet1 = Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.nADCount1 = 1;

        //##################################################################################################################



//sylee210112

        if (SysSet19.m_n4WHVon == 1) { //sylee200217-4WCVMODE
            Sub71.FilterSet(4);
        }
        else {
            Sub71.FilterSet(1);
        }


        int nEnd2;//sylee210405-1   
        if (g_n4WFailCount > 50) {//sylee210405-1 
            nEnd2 = 50;
        }
        else {
            nEnd2 = g_n4WFailCount;
        }

        if (mode == 1)//sylee201005
        {
            //sylee210405-1  for( int neterr=1; neterr<=g_n4WFailCount; neterr++)   // net 
            for (int neterr = 1; neterr <= nEnd2; neterr++)   // net //sylee210405-1    
            {
                n4WFail1[neterr][21] = 0;
                n4WFail1[neterr][22] = 0;
                n4WFail1[neterr][23] = 0;
                n4WFail1[neterr][24] = 0;
                net = (int)n4WFail1[neterr][15];
                t1 = n4WNet[net][_4W_PIN1]; //son211102 1-> _4W_PIN1
                t2 = nPinToPiece(t1);//SYLEE171225-2  
                //////////////////////////////////////////////////////////////////////////////////////
                int nFailCo1;

                for (int ik1 = _4W_PIN1; ik1 <= _4W_PIN4; ik1++)     //son211102 1-> _4W_PIN1,  4-> _4W_PIN4
                {
                    nFailCo1 = 0;

                    for (int ik2 = _4W_PIN1; ik2 <= _4W_PIN4; ik2++) //son211102 1-> _4W_PIN1,  4-> _4W_PIN4
                    {
                        if (ik1 == ik2) {
                            continue;
                        }
                        Sub71.AOnPinSet1(2, n4WNet[net][ik1] - 1, 1);   //VB  TR 
                        Sub71.AOnPinSet1(2, n4WNet[net][ik2] - 1, 2);   //VC  TR PinNo(0~8k) //SYLEE20111022   nMod =1,VB,    =2VC,
                        for (int k1 = 1; k1 <= 200; k1++) { //300uS
                            if (net == 1 && k1 <= 10) {//200us
                                Sub71.Delay_100ns(200);  //20uS
                            }
                            Sub71.Delay_100ns(100);  //10uS
                            Sub71.AOnReadV1I1(5); // READ  4W V  , I
                            if (SysSet13.m_n4WCVMode != 1) { //sylee200217-4WCVMODE
                                if (Sub71.Y1 > (nISet * 0.6)) {//ok
                                    break;
                                }
                            }
                            else {//sylee191015-2
                                if (Sub71.Y1 > (nISet * 0.3)) {//sylee//sylee191015-2
                                    break;
                                }
                            }
                            if (k1 == 200) {//fail
                                nFailCo1++;
                                //nPos1[net]=2;                          
                            }
                        }
                        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                    }

                    if (nFailCo1 == 3) {
                        n4WFail1[neterr][20] = 1;
                        n4WFail1[neterr][8] = 999999999;  //son Fail R
                        n4WFail1[neterr][20 + ik1] = 1;
                        nFailCo1 = 3;
                        //contact fail
                    }
                }

                /////////////////////////////////////////////////////////////////////////////////////////


            }//end of   for( i=1; i<=nEnd; i++)   // net 

        }//end of       if(mode==1)


        //###################################################################################

        if (n4Wire == 4) { //interlock 
            Sub71.On4WireMode(0); //4WIRE  a=1 ON, 0 OFF
        }

        Sub71.FilterSet(0);//sylee130704 
        Sub71.I_Filter(0);//sylee130704 
        Sub71.AOnRelayOffSel(1);//SYLEE170314-1
        Sub71.OnRelayAllOff1();//sylee200131
        Sub71.OnCCCV_Set(1);  //sylee200217-4WCVMODE
        Sub71.FilterSet(1);  //sylee200612

        nFlag_4W_OUT50V = 0;//SYLEE200411 

    } //if(g_n4WFailCount>0)
#endif

//sylee210203
    n4W_Use = 0;//sylee200612

    nManual4WStartFlag1=0; //sylee230426-8 MANUAL START:  ABORT DIO

    return 1;
}


//son211112 Unitech 요구사항. 4W_Setup_A.txt에 step, BarCode 정보 추가 요청
//son output : 미리 저장된 BarCode정보를  pStrBarCode 에 카피해서 돌려준다.
int CChildView7::GetBarCode(char* pStrBarCode) //son240622  ReadBarCode_fromHandlerDrive()-> GetBarCode()
{
    strcpy(pStrBarCode, g_strBarCode);  
    return 1;
}

//son HandlerDrive에서 "BarCode.txt" 파일을 읽는다. 
//    매번 TEST마다 호출 하지 않는다.
//    1) Auto 화면에서 START+TEST 를 받았을 때 호출.    
//    2) ChildView1 처음 로딩시에 1회만  호출 (for 초기화)
//    return : 1 (정상),  0, -1 (비정상)
int CChildView7::ReadBarCode_TXT()  //son240622
{
#ifdef __MST__CUSTOMER 
    ::ZeroMemory(g_strBarCode, sizeof(g_strBarCode));   //son240622
    ::ZeroMemory(g_strLotName, sizeof(g_strLotName));   //son240622

    ::ZeroMemory(g_strModelName, sizeof(g_strModelName));
    ::ZeroMemory(g_strSheetNo, sizeof(g_strSheetNo));
    ::ZeroMemory(g_strTotalNo, sizeof(g_strTotalNo));   //son240109
#endif
    
    int ret =_ReadBarCode_fromHandlerDrive(g_strBarCode, g_strLotName, g_strModelName, g_strSheetNo, g_strTotalNo);  //son240622
    MyTrace(PRT_BASIC,"Read BarCode.txt: BarCode=%s, LotName=%s, Model=%s, SheetNo=%s, TotalNo=%s, nBarcodefile_MC_Mode1=%d\n",
                                g_strBarCode, g_strLotName, g_strModelName, g_strSheetNo, g_strTotalNo, nBarcodefile_MC_Mode1);

    return ret;
}


//son220124 제이텍 요청       D:\log4w\ 폴더명에 LotName 추가 
//son230707 대만유니텍        READ형식 Detail 로그 출력관련 pStrModelName, pStrSheetNo 추가
//son240109 대만유니텍        READ형식 Detail 로그 출력관련 pStrTotalNo 추가

//son 실제 BarCode.txt read 하는 함수.
//    return : 1 (정상),  0, -1 (비정상)
int CChildView7::_ReadBarCode_fromHandlerDrive(char* pStrBarCode, char* pStrLotName, char* pStrModelName, char* pStrSheetNo,//son230707
                                                char* pStrTotalNo)     //son240109
{

    //------------------------------------------------------------------------------------
    // "D:\\FromHandler\\BarCode.txt" 파일을 read해서 현재 Block의 BarCode 정보를 가져온다. 
    FILE* fp;
    char fName[FILE_PATH_SIZE], buf[GET_BUF_SMALL_SIZE], buf2[GET_BUF_SMALL_SIZE];   //son230707 255:GET_BUF_SMALL_SIZE
    CString strTemp;

    if (pStrBarCode == NULL)
    {
        strTemp.Format("Error No 1702 :  pStrBarCode is NULL! \nCan't process ReadBarCode_fromHandlerDrive()! ");
        MyTrace(PRT_BASIC, strTemp);
        AfxMessageBox(strTemp, MB_OK);
        return -1;
    }

    //son Set default return string.  "BarCode.txt" 파일이 없는 경우 공백을 ouput str으로 리턴.
    strcpy(pStrBarCode, "");

    ::ZeroMemory(&fName, sizeof(fName));
    strcat(fName, SysInfoView01.m_pStrFileDrive1);
    strcat(fName, "\\BarCode.txt");               //son211112
    fp = fopen(fName, "rt");
    if (fp == NULL) {
        //son 파일이 없는게 정상일 수 있으므로 메시지 박스, err Msg 는 출력하지 않는다.

        //strTemp.Format("Error No 1700 : Can't open \"%s\" file.\n", fName);
        //MyTrace(PRT_BASIC, strTemp);        
        //AfxMessageBox(strTemp, MB_OK);    
        return -1;
    }

    //----------------
    //son File Read
    CString str;

    //son 이태호부장님 요구사항. 중간에 공백이 들어간 경우도 처리 가능해야 한다.
    ::ZeroMemory(buf, sizeof(buf));
    fscanf(fp, "%30[^\n]s\n", buf); //son211117 '\n' 문자를 입력받기 전까지 공백을 포함하여 30자만 입력 받는다. 
    fgets(buf2, sizeof(buf),fp); //son230707 다음줄에 영향이 없게 별도의 buffer에 개행문자까지 현재 줄을 마저 읽는다.

    //son BarCode가 없다는 의미로 Handler가 "Empty"로 채워준 경우 공백을 output str으로 리턴
    if (strcmp(buf, "Empty") == 0)
        strcpy(pStrBarCode, "");

    //son Handler가 "BarCode.txt" 에 의미있는 str을 채워 줬다면
    else
    {

        //son BarCode가 MAX_BARCODE_STR 사이즈를 넘으면 잘라서 copy한다.
        str.Format("%s", buf);
        str = str.Left(MAX_BARCODE_STR);

        strcpy(pStrBarCode, str);    //son returning pStrBarCode 

    }

    //son220124 제이텍 요구사항.  d:\log4w\폴더명에 LotName 추가를 위해 LotName을 BarCode.txt에서 확인한다. 
    ::ZeroMemory(&buf, sizeof(buf));
    fscanf(fp, "%30[^\n]s\n", buf); //son211117 
    fgets(buf2, sizeof(buf2),fp);    //son230707 
    str.Format("%s", buf);
    str = str.Left(MAX_LOTNAME_STR);
    strcpy(pStrLotName, str);       //son returning  pStrLotName

#if 1 //#ifdef __MST__CUSTOMER 
    //son Read Main장비 Model Name
    ::ZeroMemory(&buf, sizeof(buf));
    fscanf(fp, "%30[^\n]s\n", buf); //son211117 
    fgets(buf2, sizeof(buf2),fp);    //son230707 
    str.Format("%s", buf);
    str = str.Left(MAX_MODELNAME_STR);
    strcpy(pStrModelName, str);    

    //son Read SheetNo (in Lot) 
    //    1개 Lot안에 60개의 PCB가 있다면 1~ 60까지의 SheetNo가 write 된다. 
    //    PCB가 바뀔 때 마다  SheetNo는 하나씩 증가한다. 
    //    Lot이 바뀐다면 Lot Name이 바뀌면서 SheetNo는 1로 초기화되어 다시 카운트한다. 
    ::ZeroMemory(&buf, sizeof(buf));
    fscanf(fp, "%30[^\n]s\n", buf); //son211117 
    fgets(buf2, sizeof(buf2),fp);    //son230707 
    str.Format("%s", buf);
    str = str.Left(MAX_SHEETNO_STR);
    strcpy(pStrSheetNo, str);    

//son240109 begin:
    //son Read TotalNo (in Same Model) 
    //    1개 Lot안에 60개의 PCB가 있고, 같은 모델로 3개의 Lot을 찍는다면 , TotalNo는  1~180까지의 No를 갖는다. 
    //    Model이 바뀌면 Model Name이 바뀌고 TotalNo는 1로 초기화된다. 
    ::ZeroMemory(&buf, sizeof(buf)); 
    fscanf(fp, "%30[^\n]s\n", buf);  
    fgets(buf2, sizeof(buf2),fp);    
    str.Format("%s", buf);
    str = str.Left(MAX_SHEETNO_STR);    //son size는 SheetNo와 동일.
    strcpy(pStrTotalNo, str);    
//son240109 end.
#endif

    ::ZeroMemory(buf, sizeof(buf));//sylee240130
    fscanf(fp, "%30[^\n]s\n", buf); //sylee240130
	fgets(buf2, sizeof(buf),fp);//sylee240130

#ifdef __MST__CUSTOMER    //son240627
#if 0  //son240627
   	nBarcodefile_MC_Mode1=0;//sylee240130
	if( (nManualStartFlag != 1) && (nKeyStartFlag != 1) ){//sylee130306joytch
		if (strcmp(buf, "AUTO") == 0){//sylee240130
       		nBarcodefile_MC_Mode1=1;//sylee240130
		}
	}

#else //son240627
    //son240627 기존에 BarCode.txt 6번째 라인에 "AUTO"이면 4W CSV write하게 코딩된 것이 위험해서 수정함.
    //  1) 이전 버전 장비 SW가  "AUTO" write 안하는 경우에  계측기만 새 SW 적용되면 4W Csv 로그 안할 수 있기 때문에
    //     BarCode.txt 6번째 라인에 "MANUAL" 수신시 4W Csv 로그를 "안하도록" 수정.
    //  2) 해당 기능을 MST에 한해서만 적용해서  다른 고객사는 BarCode.txt와 무관하게 그냥 CSV 로그 하도록 수정.

    //son nBarcodefile_MC_Mode1   1: 4W Csv 기록    1이 아니면: 4W CSV 기록 안함
   	nBarcodefile_MC_Mode1= 1; //son240627 default는  1로 해서 기본적으로 4W Csv 기록하도록 수정.
	if( (nManualStartFlag != 1) && (nKeyStartFlag != 1) ){  //son240627
		if (strcmp(buf, "MANUAL") == 0){//son240627 배준식 차장요청으로 MANUAL일 때 로그를 안 하는 것으로 수정.
       		nBarcodefile_MC_Mode1=0;//son240627
		}
	}
#endif //son240627
#endif //son240627


    fclose(fp);


    return 1;
}



/////////////////////////////////////////////////////////
//sylee200604
 
//son 4W Sub71.R1  계산 함수 (R = VC / I),  I range 반영
int CChildView7::ARun201_4w_R2(double nISet, int nStep)//sylee200909
{

    if (Sub71.Y1 < 0.0000001) {
        Sub71.Y1 = 0.0000001;
    }
    if (nStep < 1) {//sylee200909
        ::ZeroMemory(&d4W_VC1, sizeof(d4W_VC1));//sylee200909
        ::ZeroMemory(&d4W_I1, sizeof(d4W_I1));//sylee200909
    }


    double nT1, nT2;  //4WSETUP140107

    nT1 = nISet - nISet * 0.1;
    nT2 = nISet + nISet * 0.1;

    if (SysSet13.m_n4WCVMode != 1) {//sylee200909
        if (nStep == 0) { //2
            if (nT1 < Sub71.Y1) {
                if (Sub71.Y1 < nT2) {
                    Sub71.Y1 = nISet; //SYLEE140107 //SYLEE171024-1 I FIX 
                }
            }
        }
    }

    d4W_VC1[nStep] = Sub71.W1;//sylee200909
    d4W_I1[nStep] = Sub71.Y1;//sylee200909

    if (nStep == 1) { //2
        //son Retry 첫번째, 두번째 를 이용해서 R값을 구한다. : 기본 retry는 2회
        Sub71.R1 = ((d4W_VC1[0] + d4W_VC1[1]) / (d4W_I1[0] + d4W_I1[1]));
        //   Sub71.R1=((Sub71.W1)/Sub71.Y1);
    }
    else if (nStep == 3) { //4
        //son Retry 0, 1, 2, 3 의 VC, I 값을 가지고 일종의 평균을 내서 R 값을 구한다.
        Sub71.R1 = ((d4W_VC1[0] + d4W_VC1[1]) / (d4W_I1[0] + d4W_I1[1])) + ((d4W_VC1[2] + d4W_VC1[3]) / (d4W_I1[2] + d4W_I1[3]));
        Sub71.R1 = Sub71.R1 / 2.;
    }
    else {//    if( nStep==0 || nStep==2 ){
        Sub71.R1 = ((Sub71.W1) / Sub71.Y1);
    }

    if (Sub71.Y1 > 0)
    {
        if (nIR == 1 || nIR == 2) {
            Sub71.R1 = Sub71.R1 * 10.;
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {
            Sub71.R1 = Sub71.R1 * 1000.;
        }
        else {
            Sub71.R1 = 9999999999;
        }
    }
    else {
        Sub71.R1 = 99999999999;
    }
    Sub71.R1 = Sub71.R1 * 1000.;   //R1;



    if (Sub71.Y1 < nFlag_4W_SetI) {//sylee211125
        Sub71.R1 = 9999999;
    }

    //sylee230124  if (Sub71.W1 < 0.1) {
    if (Sub71.W1 < 0.01) {  //sylee230125
        Sub71.R1 = 9999999;//sylee210925
    }

    //son 문제점: Sub71.R1 값은 retry가 반영되었지만, 
    //            Sub71.Y1, Wub71.W1 은 그냥 현재 read한 I값, VC값이다. 

    return 1;

}





////////////////////////////////////////
//sylee200603




//son R 값 계산.  Cal 반영 안 된 AD 기준
int CChildView7::ARun201_4w_R1(double nISet)//sylee150710
{

    if (Sub71.Y1 < 0.0000001) {
        Sub71.Y1 = 0.0000001;
    }

    double nT1, nT2;  //4WSETUP140107

    nT1 = nISet - nISet * 0.1;
    nT2 = nISet + nISet * 0.1;

    if (SysSet13.m_n4WCVMode != 1) {//sylee200909
        if (nT1 < Sub71.Y1) {
            if (Sub71.Y1 < nT2) {
                Sub71.Y1 = nISet; //SYLEE140107 //SYLEE171024-1 I FIX RAY
            }
        }
    }

    // Sub71.Y1=nISet; //SYLEE171024-1 I FIX RAY

    if (Sub71.Y1 > 0)
    {
        if (nIR == 1 || nIR == 2) {//sylee161207-0      
            Sub71.R1 = ((Sub71.W1) / Sub71.Y1) * 10.;//sylee161207-0  x10  ray ok 
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {  //SYLEE150904 //ACE400
            Sub71.R1 = ((Sub71.W1) / Sub71.Y1) * 1000.;//배율 /1000   
        }
        else {
            Sub71.R1 = 9999999999;
        }
    }
    else {
        Sub71.R1 = 99999999999;
    }
    Sub71.R1 = Sub71.R1 * 1000.;   //R1;

    return 1;

}




//son 해당 cell을 Display한다.
void CChildView7::GraphDisplayBlock(int nCell, int nResult) //nResult=0
{
    CDC* pDC;
    CWnd* pWnd;
    CRect AllRect;
    RECT Rect;
    CString strMsg;
    int nFontS, nFontW;
    COLORREF clr1;

    //son AProcess101()이 수행중이면 리턴
    if (nProcessFlag1 == 1) {//sylee130216joytech
        return;
    }

    if (SysInfoBlock.m_nStepDirection == 2 || SysInfoBlock.m_nStepDirection == 3 || SysInfoBlock.m_nStepDirection == 4) {//SYLEE180511-1
        nCell = g_Map2_CellStep[nCell];//SYLEE180417-1
    }

    if (nCell > nCellMax)
        return;

    pWnd = (CStatic*)GetDlgItem(IDC_STATIC_GRAPH);
    pDC = pWnd->GetDC();

    //-------------------------------
    //son 폰트 지정

    if (nCellMaxX <= 2 && nCellMaxY <= 2) { //sylee140115 
        nFontW = 100;     //son FW_THIN : 가늘게
        nFontS = 10;      //son // font size denominator이므로 값이 작을 수록 크게 출력된다.
    }
    else if (nCellMaxX <= 4 && nCellMaxY <= 4) {
        nFontW = 100;
        nFontS = 20;
    }
    else if (nCellMaxX <= 5 && nCellMaxY <= 10) {
        nFontW = 100; nFontS = 30;
    }
    else if (nCellMaxX <= 8 && nCellMaxY <= 15) {
        nFontW = 100; nFontS = 40;
    }
    else if (nCellMaxX <= 10 && nCellMaxY <= 20) {
        nFontW = 100; nFontS = 50;
    }
    else if (nCellMaxX <= 12 && nCellMaxY <= 25) {
        nFontW = 100; nFontS = 60;
    }
    else if (nCellMaxX <= 14 && nCellMaxY <= 30) {
        nFontW = 100; nFontS = 70;
    }
    else if (nCellMaxX <= 16 && nCellMaxY <= 35) {
        nFontW = 100; nFontS = 80;
    }
    else if (nCellMaxX <= 18 && nCellMaxY <= 40) {
        nFontW = 100; nFontS = 130;
    }
    else if (nCellMaxX <= 25 && nCellMaxY <= 45) {
        nFontW = 100; nFontS = 140;
    }
    else if (nCellMaxX <= 30 && nCellMaxY <= 50) {
        nFontW = 100; nFontS = 150;
    }
    else {
        nFontW = 100; nFontS = 160;
    }


    //====================================================
    LOGFONT lf;
    lf.lfHeight = MulDiv(9, pDC->GetDeviceCaps(LOGPIXELSY), nFontS);
    // 9:  기준 폰트 사이즈
    // pDC->GetDeviceCaps(LOGPIXELSY) : 현재 PC 해상도, 지금 PC는 96으로 측정됨. numerator(곱하는 수)
    // nFontS는 나누는 수(denominator)이므로  현재 해상도에 가까울 수록 9 포인트 폰트 사이즈가 나옴. 
    // nFontS가 현재 해상도 보다 크면 9보다 작은 폰트, 해상도보다  작으면 9보다 큰 폰트가 됨.

    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = nFontW;
    lf.lfItalic = FALSE;
    lf.lfUnderline = FALSE;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = HANGEUL_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    //  sprintf(lf.lfFaceName, "%s", "굴림"); //mst 
    sprintf(lf.lfFaceName, "%s", "System"); //os-english  nano

    CFont* pNewFont = new CFont;
    CFont* pOldFont = NULL;

    pNewFont->CreateFontIndirect(&lf);
    pOldFont = pDC->SelectObject(pNewFont);


    //------------------------------------------
    // Box 컬러 설정 

    // BackGround를 지정한다.

    AllRect.left = m_RectBlock[nCell].left;
    AllRect.right = m_RectBlock[nCell].right;
    AllRect.top = m_RectBlock[nCell].top;
    AllRect.bottom = m_RectBlock[nCell].bottom;

    CBrush BackGrBrush;

    //SYLEE130601 move 
    nBlockMaxX = SysInfoBlock.m_nCol;
    nBlockMaxY = SysInfoBlock.m_nRow;
    nPieceMaxX = SysInfoPiece.m_nCol;
    nPieceMaxY = SysInfoPiece.m_nRow;

    nBlockMaxXTotal = nBlockMaxX * nPieceMaxX - SysInfoPiece.m_nColDel;  ///*******       //son blockCol * pieceCol
    nBlockMaxYTotal = nBlockMaxY * nPieceMaxY - SysInfoPiece.m_nRowDel;  ///*******       //son blockRow * pieceRow

    //son nCell로 row, col을 계산한다.
    int nRow/*ka1*/, nCol/*ka2*/;  //SYLEE120901
    nRow = ((nCell - 1) / (nBlockMaxXTotal));//몫    //SYLEE120901 
    nCol = nCell - (nBlockMaxXTotal * nRow);//나머지 //SYLEE120901
    nRow = nRow + 1;

    //son row, col에 맞는 block, piece를 찾아낸다.
    int nBlock/*nn1*/, nPiece/*nn2*/;
    nBlock = nDisCell1[nRow][nCol][0];
    nPiece = nDisCell1[nRow][nCol][1];

    //son 해당 piece가 Disable이면 No Test로 지정. BLOCK_RES_PIECE_DISABLE(쑥색) 현재 사용 안함.
    if (SysInfo19.m_nData[nBlock][nPiece] == 1) {
        nResult = BLOCK_RES_NO_TEST;        //son220823 5: BLOCK_RES_NO_TEST
    }

    if (nProcessFail1 != 0) {//sylee170415
        nResult = BLOCK_RES_O_S;            //son220823 4: BLOCK_RES_O_S
    }

    if (nResult == BLOCK_RES_INIT0) {       //son220823 0: BLOCK_RES_INIT0
        clr1 = RGB(255, 255, 255);          // WHITE  //sylee170114
    }
    else if (nResult == BLOCK_RES_PASS) {   //son220823 1: BLOCK_RES_PASS
        clr1 = RGB(0, 255, 0);              //PASS  GREEN     
    }
    else if (nResult == BLOCK_RES_OPEN) {   //son220823 2: BLOCK_RES_OPEN
        clr1 = RGB(255, 255, 0);            //OPEN   YELLOW 
    }
    else if (nResult == BLOCK_RES_SHORT) {  //son220823 3: BLOCK_RES_SHORT
        clr1 = RGB(255, 0, 0);              //SHORT    WHITE RED
    }
    else if (nResult == BLOCK_RES_O_S) { //son220823 4: BLOCK_RES_O_S
        clr1 = RGB(0, 0, 255);              //OPEN  SHORT   BLUE  
    }
    else if (nResult == BLOCK_RES_NO_TEST) {//son220823 5: BLOCK_RES_NO_TEST
        clr1 = RGB(0, 110, 110);            // No TEST   DARKGREEN //sylee170114
    }
    else if (nResult == BLOCK_RES_UNDEF) { //son220823 6: BLOCK_RES_UNDEF
        //clr1 = RGB(20, 240, 1120);    //son 잘못된 코드.  
        clr1 = RGB(20, 240, 96);            //DISABLE???  //son220823 1120 ->96  연두색으로 수정.
    }
    else if (nResult == BLOCK_RES_RUN_FAIL) { //son220823 7: BLOCK_RES_RUN_FAIL
        clr1 = RGB(255, 255, 255);          // Run Fail  WHITE  //sylee170114
    }
    else if (nResult == BLOCK_RES_4W) {//SYLEE131022  4WCODE_131118 //son220823 8: BLOCK_RES_4W
        clr1 = RGB(255, 0, 255);            //4W   Magenta
    }
    else if (nResult == BLOCK_RES_PIECE_DISABLE) { //sylee160203-ITS //son220823 9: BLOCK_RES_PIECE_DISABLE
        clr1 = RGB(128, 128, 0);            //PIECE DISABLE(쑥색)  //sylee160203-ITS
    }
    else {
        clr1 = RGB(0, 0, 0);  //BLACK 
    }

    //son 4W Sampling 중에는 Grid Graph의 백그라운드 색을 4W(연보라)로 설정한다.
    if (n4w_Sample_Enable == 1) {//sylee160521
        clr1 = RGB(255, 176, 255); //245,122.236    //son 연보라
    }

    BackGrBrush.CreateSolidBrush(clr1);

    CBrush* pOldBrush = pDC->SelectObject(&BackGrBrush);

    pDC->FillRect(AllRect, &BackGrBrush);
    pDC->SelectObject(pOldBrush);


    //----------------------------------
    // Box 그리기  

    Rect.top = AllRect.top;//sylee140115 
    Rect.bottom = AllRect.bottom;//sylee140115 
    Rect.left = AllRect.left;//sylee140115 
    Rect.right = AllRect.right;//sylee140115   

    pDC->SetBkColor(RGB(255, 225, 255)); // 

    pDC->SetBkColor(clr1); // //sylee140402
    pDC->SetTextColor(RGB(0, 0, 0));

    if ((nPieceMaxX > 1) || (nPieceMaxY > 1)) {  //SYLEE121120
        strMsg.Format("%d-%d", nDisCell1[nRow][nCol][0], nDisCell1[nRow][nCol][1]);//SYLEE120901
        if ((nDisCell1[nRow][nCol][0] > 0) && (nDisCell1[nRow][nCol][1] > 0)) {//sylee121119
            pDC->DrawText(strMsg, -1, &Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS | DT_VCENTER);    //SYLEE140402        
        }
    }
    else {
        strMsg.Format("%d", nCell);
        if (nCell > 0) {
            pDC->DrawText(strMsg, -1, &Rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS | DT_VCENTER); //SYLEE140402  
        }
    }

    pDC->SetBkColor(RGB(255, 255, 255));
    pDC->SelectObject(pOldFont);
    delete pNewFont;



    //----------------------------------
    // Box Line 그리기  


    CPen m_penBack;

    m_penBack.CreatePen(PS_SOLID, 0, RGB(0, 0, 0));
    CPen* pOldPen = pDC->SelectObject(&m_penBack);

    pDC->MoveTo(AllRect.left, AllRect.top);
    pDC->LineTo(AllRect.right, AllRect.top);

    pDC->LineTo(AllRect.right, AllRect.bottom);
    pDC->LineTo(AllRect.left, AllRect.bottom);
    pDC->LineTo(AllRect.left, AllRect.top);

    pDC->MoveTo(AllRect.left + 1, AllRect.top + 1);
    pDC->LineTo(AllRect.right - 1, AllRect.top + 1);

    pDC->LineTo(AllRect.right - 1, AllRect.bottom - 1);
    pDC->LineTo(AllRect.left + 1, AllRect.bottom - 1);
    pDC->LineTo(AllRect.left + 1, AllRect.top + 1);


    pDC->SelectObject(pOldPen);
    m_penBack.DeleteObject();
    ReleaseDC(pDC);

}




void CChildView7::OnDraw(CDC* pDC)
{
    // TODO: Add your specialized code here and/or call the base class


}


BEGIN_EVENTSINK_MAP(CChildView7, CFormView)
    //{{AFX_EVENTSINK_MAP(CChildView7)
    ON_EVENT(CChildView7, IDC_BUTTON103, -600 /* Click */, OnButton103, VTS_NONE)       //son 'DUT'버튼
    ON_EVENT(CChildView7, IDC_BUTTON105, -600 /* Click */, OnButton105, VTS_NONE)       //son Clear 버튼
    ON_EVENT(CChildView7, IDC_BUTTON2001, -600 /* Click */, OnButton2001, VTS_NONE)     //son ErrorView 버튼
    ON_EVENT(CChildView7, IDC_BUTTON2002, -600 /* Click */, OnButton2002, VTS_NONE)     //son Rech.ON 버튼
    ON_EVENT(CChildView7, IDC_BUTTON2003, -600 /* Click */, OnButton2003, VTS_NONE)     //son JigTest 버튼
    //}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CChildView7::OnButton105() //SYLEE170810-2
{

    nErrPinClear = 1;
}

//son 'DUT' 버튼 클릭 시 '화면 값(DUT, TPin, HPin, LPin) 업데이트 
void CChildView7::OnButton103() //SYLEE150817
{
    CString str;
    int nMultyNetTotalTmp;
    int c, c2, c3;//sylee150920


    //son AProcess101()이 수행중이면 리턴
    if (nProcessFlag1 == 1) {//SYLEE20111225
        return;
    }

    if (nMultyNetTotal >= 1 && nMultyNetTotal <= MAX_DUT) { //son220824_2 DefDutMax2 -> MAX_DUT
        nMultyNetTotalTmp = nMultyNetTotal;
    }
    else {
        nMultyNetTotalTmp = 1;
    }


    if (nMulNetFlag < 0) {//SYLEE150817
        nMulNetFlag = 1;
    }
    else if (nMulNetFlag < nMultyNetTotalTmp) {
        nMulNetFlag++;
    }
    else if (nMulNetFlag >= nMultyNetTotalTmp) {
        nMulNetFlag = 1;
    }



    //son 'DUT' 출력
    str.Format("%d", nMulNetFlag);
    m_Label8.SetCaption(str);//SYLEE150817

    int dutId = getDutId();     //son190704 nMulNetFlag = dutId

    c = nPinDa1H[dutId][2][0];    //son 총핀수        //SYLEE180810-1-DUT16   //son190704-4WDUT16
    c2 = nPinDa1H[dutId][2][1];   //son 상부 핀수 
    c3 = nPinDa1H[dutId][2][2];   //son 하부 핀수

    //son 'TPin' (총핀수) 출력
    str.Format("%d", c);//sylee150920
    m_Label6.SetCaption(str);  //

    //son 'HPin' (상부핀) 수 출력
    str.Format("%d", c2);//sylee150920  
    m_Label18.SetCaption(str);

    //son 'LPin'(하부핀) 수 출력
    str.Format("%d", c3);//sylee150920 
    m_Label20.SetCaption(str);

}

void CChildView7::OnButton2001() //prin
{
    CString Str;

    if (SysSet13.m_nSet7 == 1) {//sylee130724
        Str.Format("Z:\\ERROR.CSV");// SYLEE20120418 
        ::ShellExecute(NULL, "open", "EXCEl.EXE", Str, "NULL", SW_SHOWNORMAL);
    }
    else {
        Str.Format("Z:\\ERROR.TXT");// SYLEE20120418 최승환DL요청 
        ::ShellExecute(NULL, "open", "notepad.EXE", Str, "NULL", SW_SHOWNORMAL);
    }
}


int CChildView7::AutoSelf_OPen1_Log1(int nMode)
{
    CString str;
    FILE* fp;
    int nRet;

    CTime   curTime = CTime::GetCurrentTime();
    ::ZeroMemory(&fName, sizeof(fName));
    str.Format("d:\\Log\\Event_Self_Open1_%.0fV_%dY%dM%dD_%dH%dM%dS.CSV",
        nVSet, curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    strcat(fName, str);//sylee121202
    fp = fopen(fName, "wt");
    if (fp == NULL) {
        AfxMessageBox(" Error No 8201 !\n\n     d:\\QC\\Open_Set1_.TXT.  file Data Saving Error !     file close!", MB_OK); //error messege
        return 0;
    }

    nRet = FileSysInfo01.LoadSaveSer13(_LOAD, nMode, PART_MIXED); //son220412
    if (nRet != 1) {
        str.Format("Error No 7002,   \n   Auto  Calibration fun. \n\n\n  Calibration file reading Error , \n   Mode no= %d  ", nMode);
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    fprintf(fp, "\n\n");

    str.Format("   <  IDLE TEST >  Open Pin의  Short여부 check   ");
    fprintf(fp, str);

    fprintf(fp, "\n\n");

    for (int i = 1; i <= nFailL1CoOpen; i++) {
        Sub71.R1 = nFailL1Open[i][F_RAW_R];   //son220419_4 6:F_RAW_R

        int calPart = FileSysInfo01.checkUseCalDataPart(nFailL1Open[i][F_VB_PIN] - 1, nFailL1Open[i][F_VC_PIN] - 1);    //son220419_2
        RCalCovert(nMode, Sub71.R1, RAW_TO_REAL, calPart);   // m_nMode1 1~76   //son220412 
        nFailL1Open[i][17] = Sub71.R1; //son220419_4 17:F_PRORV_RAW_R ????    17은 판정용 Raw R 영역인데 Real을 write 하고 있음. 이상함.
        //     fprintf(fp, "No=,%d, Pin1=,%.0f, Pin2=,%.0f,R=,%.2f,Real R=,%.2f\n",   i, nFailL1Open[i][F_VB_PIN],nFailL1Open[i][F_VC_PIN],nFailL1Open[i][F_RAW_R],nFailL1Open[i][17]); 
        fprintf(fp, " %d, Jig Up :  Open  PIN ERROR = %.0f-%.0f\n",
            i, nFailL1Open[i][F_VB_PIN], nFailL1Open[i][F_VC_PIN]); //son220419_4 5:F_VC_PIN
    }

    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format(" < 문제 >  ");
    }
    else {
        str.Format(" < Error >  ");
    }
    fprintf(fp, str);
    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format(" *  문제 :  지그 대기(AWAY) 상태에서   Open 측정시  판정 저항 값 보다 작은 경우의   문제가 발생했습니다.   ");
    }
    else {
        str.Format(" *  Error :  jig  away,    open test  is  error.      short pin check!    ");
    }
    fprintf(fp, str);
    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format(" -> 조치 : 계측기 피씨를  재 부팅 해주십시요.  이후 계속 발생시 Open 불량 Pin을 조치 하십시요.  switch card 교체등 확인 ");
    }
    else {
        str.Format(" -> check point  : pc rebooting! ,      Error short pin check!,     switch card  change check! ");
    }

    fprintf(fp, str);
    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format(" -> 조치 : 이전 sheet를  다시 측정해주십시요. ");
    }
    else {
        str.Format(" ->    Trouble PCB Sheet  retest! ");
    }

    fprintf(fp, str);
    fprintf(fp, "\n\n");


    str.Format("Make Date,  %dY/%dM/%dD, %dH-%dM-%dS", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    fprintf(fp, str);
    fclose(fp);
    //=========================================================================================
    ::ShellExecute(NULL, "open", "notepad.EXE", fName, "NULL", SW_SHOWNORMAL);

    return 1;
}


//son OpenTest R 값 출력
int CChildView7::ARun201_O11_Log1(int nMode)  //sylee210309
{
    CString str;
    FILE* fp;
    int nRet, nRCount, nPinA, nPinB, i, k, ipEnd, ip, nNo;
    double nVSet2;


    //son221031 if (OpenMes1Step == 200) {
    if (OpenMes1Step >= 200) {  //son221031
        OpenMes1Step = 200;
    }

    if (nFlagOpenMes1 != 1) {//SYLEE210309-1
        return 1;
    }
    int dutId = getDutId();
    //=======================
    //son BDL Name을 추출
    int nEnd = 0;
    CString strBdlName;
    strBdlName.Format("%s", SysInfoView01.m_pStrFilePathBDL);  //son201209: m_pStrFilePathBDL으로 수정
    for (int i3 = 1; i3 <= 10; i3++)
    {
        nEnd = strBdlName.Find('\\');
        if (nEnd > 1) {
            strBdlName = strBdlName.Mid(nEnd + 1);
        }
        else {
            break;
        }
    }

    CString str3;
    CTime  curTime = CTime::GetCurrentTime();
    str3.Format("D:\\logOpen\\%04d%02d%02d_", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());
    str3 = str3 + strBdlName;       //son ex) D:\logOpen\20210906_2I00502NA0

    int dutIdx = get4wDutIdx();
    CString strDutNo, str4;

    str4.Format("");
    if (dutIdx == 0)
        strDutNo.Format("");
    else
        strDutNo.Format("_DUT%d", dutIdx + 1);
    str4 = str3 + strDutNo;

    char buf[FILE_PATH_SIZE];   //son210420 255 -> FILE_PATH_SIZE 
    sprintf(buf, "%s", str4);
    if (!CheckDirExist(buf))
    {
        if (!MakeNewDir(str4))
        {
            CString strbuf;
            strbuf.Format("%s creat Error!!", buf);
            AfxMessageBox(strbuf);
            return -1;
        }
        else {

        }
    }
    //================================================ 
    ::ZeroMemory(&fName, sizeof(fName));
    if (nVSet == 15) {
        nVSet2 = 10.;
    }
    else {
        nVSet2 = nVSet;
    }
    nNo = (OpenMes1StepT - 1) / 200 + 1;
    str.Format("__No%d__No%d__%.0fV.CSV", nNo * 200 - 199, nNo * 200, nVSet2);

    if (OpenMes1StepT <= 1) {
        strLog1.Format("\\Open__%02dH_%02dM_", curTime.GetHour(), curTime.GetMinute());
    }
    str = str4 + strLog1 + str;


    strcat(fName, str);//sylee121202
    if (OpenMes1StepT <= 1) {
        fp = fopen(fName, "wt");

    }
    else {
        fp = fopen(fName, "at");
    }
    if (fp == NULL) {
        AfxMessageBox(" Error No 8201 !\n\n     d:\\LogOpen\\   Open1_.CSV.  file  Saving Error !   ", MB_OK); //error messege
        return 0;
    }
    nRet = FileSysInfo01.LoadSaveSer13(_LOAD, nMode, PART_MIXED); //son220412
    if (nRet != 1) {
        str.Format("Error No 7002,   \n   Auto  Calibration fun. \n\n\n  Calibration file reading Error , \n   Mode no= %d  ", nMode);
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }
    //------------------------
    //pin no 1-2 
    g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920   //son190704-4WDUT16
    ipEnd = 1;
    if ((g_nPieceMax1 > 1)) {//PIECE
        ipEnd = g_nPieceMax1;
    }

    //son  nRcount, nRCountTotal : DUT 별 모든 piece의 개수를 더한다.
    nRCount = 0;
    for (ip = 1; ip <= ipEnd; ip++) //sylee121128 
    {
        //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
        if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
        {
            nRCount = nRCount + g_pvBDLData2Op[nMulNetFlag][ip]->size() - 1;//SYLEE150817 //son200420-4WNET10000
        }
        else {//SYLEE150817
            nRCount = nRCount + g_pvBDLData2Op[1][ip]->size() - 1;        //son200420-4WNET10000
        }
    }
    ///////////////////////////////////////////////////////////////////////////
    int nRCountTotal;

    nRCountTotal = nRCount;
    int calPart_OpenMes1_R[MAX_PIN];  //son220907_2 17000 ->  MAX_PIN으로 수정

    //son220907_2 Range Check 추가
    nRCount = g_pvBDLData2Op[1][1]->size() - 1;
    if ((nRCount * ipEnd) >= MAX_PIN)
    {
        //son221116 piece 1에는 16761개,  piece 2에는 100개 이런식으로 불균형하게 pin이 할당 될 수 있으므로 
        //          단순히 곱하지 말고 더해서 체크하도록 한다. 
        int nOpenAllPieceCount = 0;
        for (ip = 1; ip <= ipEnd; ip++)
            nOpenAllPieceCount += g_pvBDLData2Op[1][ip]->size() - 1;

        if (nOpenAllPieceCount >= MAX_PIN)
        {
            str.Format("Error No 7300, \n\n ARun201_O11_Log1(): nOpenAllPieceCount = %d\n  Range(<%d) Over!!\n piece1 nOpenCount=%d, pieceCount=%d\n",
                nOpenAllPieceCount, MAX_PIN, nRCount, ipEnd);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            MyTrace(PRT_BASIC, str);
            //son221116 return -1;
        }
    }

    int calPartIdx;                 //son220419_2
    if (OpenMes1Step == 1)
    {
        fprintf(fp, "   ,");
        for (i = 1; i <= nRCountTotal; i++) {   //son220907_2 nRCount -> nRCountTotal
            fprintf(fp, " No%d,", i);
        }
        fprintf(fp, "\n\n");

        fprintf(fp, "   ,");
        for (ip = 1; ip <= ipEnd; ip++) //sylee121128 
        {
            //son 이 시점의 nRcount: 현재 piece의 g_pvBDLData2Op[nMulNetFlag][ip] 개수
            //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) //sylee180810-1-dut16
            if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
            {
                nRCount = g_pvBDLData2Op[nMulNetFlag][ip]->size() - 1;//SYLEE150817  //son200420-4WNET10000
            }
            else {//SYLEE150817
                nRCount = g_pvBDLData2Op[1][ip]->size() - 1;     //son200420-4WNET10000
            }

            //son VB, VC Pin 을 출력한다.
            for (i = 1; i <= nRCount; i++)
            {
                //if (nMulNetFlag > 0 && nMulNetFlag < DefDutMax) 
                if (nMulNetFlag > 0 && nMulNetFlag < MAX_DUT1) //son220824_2 
                {
                    nPinA = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wFirstPin;
                    nPinB = (*g_pvBDLData2Op[nMulNetFlag][ip])[i].wPin;
                }
                else {
                    nPinA = (*g_pvBDLData2Op[1][ip])[i].wFirstPin;
                    nPinB = (*g_pvBDLData2Op[1][ip])[i].wPin;
                }
                //calPartIdx = (ip - 1) * ipEnd + nRCount;   //son220419_2  
                calPartIdx = (ip - 1) * nRCount + i;     //son220907_2 Range Over로 죽는 문제 수정
                calPart_OpenMes1_R[calPartIdx] = FileSysInfo01.checkUseCalDataPart(nPinA, nPinB);    //son220419_2
                fprintf(fp, " %d/%d,", nPinA + 1, nPinB + 1);
            }
        }
        fprintf(fp, "\n\n");
    }

    ///////////////////////////////////////////////////////////////////////////
    //------------------------
    //   for(   k=1; k<=OpenMes1Step; k++){

    k = OpenMes1Step;

    fprintf(fp, "%d ,", OpenMes1StepT);
    for (i = 1; i <= nRCountTotal; i++)
    {
        Sub71.R1 = OpenMes1[k][i];
        if (Sub71.R1 <= 0) {
            Sub71.R1 = 99999999;
        }
        else {
            RCalCovert(nMode, Sub71.R1, RAW_TO_REAL, calPart_OpenMes1_R[i]);   // m_nMode1 1~76   //son220412 
            if (Sub71.R1 < 1) {
                Sub71.R1 = 1.0;
            }
        }
        if (nMode > 10) {
            if (Sub71.R1 <= 100) {
                fprintf(fp, " %.1f,", Sub71.R1);
            }
            else if (Sub71.R1 == 99999999) {
                //fprintf(fp, " 100, " );
                fprintf(fp, " ???, ");
            }
            else {
                //fprintf(fp, " 100, " );
                fprintf(fp, " >100ohm, ");
            }
        }
        else {
            if (Sub71.R1 <= 1000) {
                fprintf(fp, " %.1f,", Sub71.R1);
            }
            else if (Sub71.R1 == 99999999) {
                //fprintf(fp, " 1000, " );
                fprintf(fp, " ???, ");
            }
            else {
                //fprintf(fp, " 1000, " );    
                fprintf(fp, " >1kohm, ");
            }
        }
    }
    fprintf(fp, "\n");
    //   }
    //------------------------ 
    fclose(fp);
    //=========================================================================================
    // ::ShellExecute(NULL,"open","notepad.EXE",fName,"NULL",SW_SHOWNORMAL);

    return 1;
}






int CChildView7::AutoSelf_LvShort1_Log1(int nMode)
{
    CString str;
    FILE* fp;
    int nRet;

    CTime   curTime = CTime::GetCurrentTime();
    ::ZeroMemory(&fName, sizeof(fName));
    str.Format("d:\\Log\\Event_Self_LvShort1_%.0fV_%dY%dM%dD_%dH%dM%dS.CSV", nVSet, curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    strcat(fName, str);//sylee121202
    fp = fopen(fName, "wt");
    if (fp == NULL) {
        AfxMessageBox(" Error No 8201 !\n\n     d:\\Event_Self_LvShort1.TXT.  file Data Saving Error !     file close!", MB_OK); //error messege
        return  0;
    }

    nRet = FileSysInfo01.LoadSaveSer13(_LOAD, nMode, PART_MIXED);  //son220412
    if (nRet != 1) {
        str.Format("Error No 7002,   \n   Auto  Calibration fun. \n\n\n  Calibration file reading Error , \n   Mode no= %d  ", nMode);
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    fprintf(fp, "\n\n");

    for (int i = 1; i <= nFailL1Co; i++) {
        Sub71.R1 = nFailL1[i][F_RAW_R];       //son220419_4 6:F_RAW_R
        int calPart = FileSysInfo01.checkUseCalDataPart(nFailL1[i][F_VB_PIN] - 1, nFailL1[i][F_VC_PIN] - 1);    //son220419_2
        RCalCovert(nMode, Sub71.R1, RAW_TO_REAL, calPart);   // m_nMode1 1~76   //son220412 
        nFailL1[i][17] = Sub71.R1;

        if (nFailL1[i][F_VB_PIN] > nFailL1[i][F_VC_PIN]) { //son220419_4 4:F_VB_PIN,  5:F_VC_PIN
            fprintf(fp, " %d, Jig Up :  SHORT   PIN ERROR = %.0f-%.0f \n", i, nFailL1[i][F_VC_PIN], nFailL1[i][F_VB_PIN]);
        }
        else {
            fprintf(fp, " %d, Jig Up :  SHORT   PIN ERROR = %.0f-%.0f \n", i, nFailL1[i][F_VB_PIN], nFailL1[i][F_VC_PIN]);
        }
    }


    fprintf(fp, "\n\n");


    if (nG_Language != 2) {//SYLEE150707
        str.Format(" *   문제 :  지그 대기(AWAY) 상태에서  쇼트 측정  자체 진단시    쇼트 문제가 발생했습니다.  ");
    }
    else {
        str.Format(" *  ERROR :   jig away,     short  test  occur   short pin.     Check  short! ");
    }
    fprintf(fp, str);
    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format("  -> 조치 :  계측기 피씨를  재 부팅 해주십시요.  이후 계속 발생시 쇼트불량핀을 조치 하십시요.   ");
    }
    else {
        str.Format("  ->  BBT Controller pc  rebooting!,   short pin check!   ");
    }

    fprintf(fp, str);
    fprintf(fp, "\n\n");

    if (nG_Language != 2) {//SYLEE150707
        str.Format("  -> 조치 :  스위치 카드  교체 또는 배선 핀 등의  쇼트 원인 찾아서  조치 하십시요 ");
    }
    else {
        str.Format("  ->  switch card change  check!,   flat cable [switch card~ pin block]  check!,   pin block particle check!   etc.check! ");
    }
    fprintf(fp, str);
    fprintf(fp, "\n\n");


    if (nG_Language != 2) {//SYLEE150707
        str.Format("  -> 조치 :  바로 이전측정한 PCB  SHEET를  다시 측정해주십시요. ");
    }
    else {
        str.Format("  ->  error pcb sheet retest! ");
    }
    fprintf(fp, str);
    fprintf(fp, "\n\n");


    str.Format("Make Date,  %dY/%dM/%dD, %dH-%dM-%dS", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    fprintf(fp, str);

    fclose(fp);
    //=========================================================================================
    ::ShellExecute(NULL, "open", "notepad.EXE", fName, "NULL", SW_SHOWNORMAL);

    return 1;
}




int CChildView7::AutoSelf_OPen1_Run1()  //SYLEE140823
{

    int i, nb1, nb2, nb3, nOpenNo, nRet;


    nAutoSelf_OPen1_Run_Status = 1;
    nAutoSelf_OPen1_Error = 0;


    nOpenNo = 0;
    for (i = 1; i <= 7; i++) {  //sylee20111210
        nb1 = SysInfo05.m_nStep[i];   //open, ushort, short, hr, hv 
        if (nb1 == TEST_OPEN) {
            nOpenNo = i;
            break;
        }
    }//end for(   i=1; i<=7; i++){  //sylee20111210

    if (nOpenNo > 0) {
        nb2 = (int)nProStep1[nb1][3];  // mode 1~65    R 
        nb3 = (int)nProStep1[nb1][2];  // R  RAW
    }//endof if(nOpenNo>0){
    i = nOpenNo;
    if (i > 0)
    {
        ::ZeroMemory(&nFailL1Open, sizeof(nFailL1Open));
        ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));
        ::ZeroMemory(&nReFlagOpenOld, sizeof(nReFlagOpenOld));
        ::ZeroMemory(&nReFlagOpenCur, sizeof(nReFlagOpenCur));
        nOpenRetryFlag1 = 0;//sylee121117
        nFailL1CoOpen = 0;

        nRet = ARun201_O11(nb1, nb2, nb3, i);   //sylee120901

        Sub71.AIRangeOff();// i range all off
        Sub71.AIVBOff();//VB OFF

        if (nFailL1CoOpen > 0) {//error  loggoing file save
            AutoSelf_OPen1_Log1(nb2);
            nAutoSelf_OPen1_Error = 2;//SYLEE140823
            //  AfxMessageBox(" ERORR NO 7701 :  지그 대기(AWAY) 상태에서   Open 측정시  판정 저항 값 보다 작은 경우의  문제가 발생했습니다.  \n   계측기 피씨를  재 부팅 해주십시요. ");
            AfxMessageBox(" ERORR NO 7701 :  ( jig away )  open pin  is short error.    \n    tester pc  reboot!  or  selftest !");
        }

    }//end of if(i>0){
    //판정 결과   error message  logfile



    nAutoSelf_OPen1_Run_Status = 0;

    return 1;

}


int CChildView7::AutoSelf_Fun1_OpenLvShort1()
{

    long lTimeDelay1;//SYLEE140903   

    if (nAutoSelf_Jigup_Event1 == 3)
    {
        //------------------------------------------------------------
        //son "Idle Time Jig up Test Delay"(SysSet15.m_nSet1) 설정
        lTimeDelay1 = SysSet15.m_nSet1 * 10000;//SYLEE140903
        if (SysSet15.m_nSet1 < 1000) {//SYLEE140903
            lTimeDelay1 = 10000000;
        }
        if (SysSet15.m_nSet1 > 10000) {//SYLEE140903
            lTimeDelay1 = 100000000;
        }
        Sub71.Delay_100ns(lTimeDelay1);     //SYLEE140903
        //Sleep(50);
        //son OpenTest 수행 
        nAutoSelf_OPen1_Run_Flag = 1;
        if (nAutoSelf_OPen1_Run_Flag == 1) {
            AutoSelf_OPen1_Run1();
            nAutoSelf_OPen1_Run_Flag = 0;
        }

        //----------------------
        //son LV ShortTest 수행 
        nAutoSelf_LvShort1_Run_Flag = 1;

        if (nAutoSelf_LvShort1_Run_Flag == 1) {
            AutoSelf_LvShort1_Run1();
            nAutoSelf_LvShort1_Run_Flag = 0;
        }
    }
    nAutoSelf_Jigup_Event1 = 0;

    return 1;

}




int CChildView7::AutoSelf_LvShort1_Run1()  //SYLEE140823
{

    int i, nb1, nb2, nb3, nShortNo;
    int nRet;


    nAutoSelf_LvShort1_Run_Status = 1;
    nAutoSelf_LvShort1_Error = 0;

    //----------------------------------------------------------
    //son SysInfo05.m_nStep[i]중에서 Short인 step 위치를 찾는다.  

    nShortNo = 0;
    for (i = 1; i <= 7; i++)  //sylee20111210
    {
        //son 0:skip, 1:open, 2:uShort LV, 3:Short LV, 4:HR Short(LV), 5:Leak1, 6:Leak2, 7:4W)
        nb1 = SysInfo05.m_nStep[i];   //open, ushort, short, hr, hv 

        //son LV Short인 경우
        if (nb1 == TEST_U_SHORT || nb1 == TEST_SHORT || nb1 == TEST_HR_SHORT)
        {
            nShortNo = i;
            break;
        }
    }//end for(   i=1; i<=7; i++)  //sylee20111210

    if (nShortNo > 0) {
        nb2 = (int)nProStep1[nb1][3];  // mode 1~65    R 
        nb3 = (int)nProStep1[nb1][2];  // R  RAW
    }//endof if(nOpenNo>0)
    i = nShortNo;
    if (i > 0) {

        ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
        ::ZeroMemory(&nShortFail1, sizeof(nShortFail1));
        ::ZeroMemory(&nShortFail1Flag1, sizeof(nShortFail1Flag1));////sylee20120921//100=piecemax

        //  nOpenRetryFlag1=0;//sylee121117
        nFailL1Co = 0;


        if (nb3 < 100) {
            nb3 = 100;
        }

        if (nCycleRunFlag != 2 && nProOneP_Flag1 == 2 && nFailCount[TEST_OPEN] == 0 && nProOneP_RunFlag1 == 1) {  //son210331 enum 
            //son  nb1: test mode,  nb2: Calibration Mode 1~65,  nb3: R RAW,  i: 현재 step 
            nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, i, 2);  //one piece
#ifndef _PC_TEST_
            if (nRet == 0) { nProcessFail1 = 1; }
#endif
        }
        else {
            nRet = ARun201_S2_SQ2_LV_Re_VB(nb1, nb2, nb3, i, 1);  //multi. piece
#ifndef _PC_TEST_
            if (nRet == 0) { nProcessFail1 = 1; }
#endif
        }

        Sub71.AIRangeOff();// i range all off
        Sub71.AIVBOff();//VB OFF

        if (nFailL1Co > 0) {//error  loggoing file save
            AutoSelf_LvShort1_Log1(nb2);
            nAutoSelf_LvShort1_Error = 2;//SYLEE140823
            //  AfxMessageBox(" ERORR NO 7702 :  지그 대기(AWAY) 상태에서     Short 문제가 발생했습니다. ");
            AfxMessageBox(" ERORR NO 7702 :  ( jig away )  open pin  is short error.    \n    tester pc  reboot!  or  selftest !");
        }

    }//end of if(i>0){
    //판정 결과   error message  logfile


    nAutoSelf_LvShort1_Run_Flag = 0;
    nAutoSelf_LvShort1_Run_Status = 0;


    return 1;

}


void CChildView7::n4W_TotalFile1() //  //sylee170808-2
{

    if (n4WlogFlagOn1 != 1) {
        n4WlogFlagOn1 = 1;
    }
    else {
        n4WlogFlagOn1 = 2;
    }

    n4WlogFlagCo1 = 0;//sylee170808-2

    CTime  curTime = CTime::GetCurrentTime();
    str71.Format("D:\\log4W\\Total_4W_%04d%02d%02d_%02d%02d%02d.CSV", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    ::ZeroMemory(&fName71, sizeof(fName71));
    strcat(fName71, str71);

}




//son220704 현재 사용하지 않는 버튼.
void CChildView7::OnButton2002() // message clear//sylee170808-2
{

#if 0   // 테스트용  //son220701
    //son 사용하지 않는 버튼. 코드 테스트용으로 필요시에 사용한다.
    //ex) On_SparkFileLog1_I(10, 10);

#else
    CString str;
    //if( SysSet13.m_nSet12==1 ){//sylee121130

 
    if (SysSet13.m_nSet8 != 1) {//sylee171104-5
        return;
    }

    n4W_TotalFile1(); //  //sylee170808-2

    if (n4WlogFlagOn1 == 1) {
        str.Format("4wFile");
    }
    else {
        str.Format("4wFile.");
    }
    m_button1.SetWindowText(str);

#endif
    return;
}


//son CycleTest 버튼
// 한번 누르면 nCycleRunFlag를 2로 만들어서 Cycle Test를 시작.
// 다시 누르면 nCycleRunFlag를 0으로 만들어서 Cycle Test를 Stop 
void CChildView7::OnButton2003() //cycle
{

    CString str;

    if (nCycleRunFlag < 2) {
        //      if(MessageBox(" \n Cycle Run Start ? \n ", "Confirm", MB_ICONEXCLAMATION | MB_YESNO) == IDYES){ 
        if (MessageBox(" \n Jig Test Start ? \n ", "Confirm", MB_ICONEXCLAMATION | MB_YESNO) == IDYES) {
            if (SysSet17.m_nSet11 == 1) {
                nCycleRunFlag = 2;//start                
            }
            else {
                AfxMessageBox("   [MANUAL]=>[CYCLE]=> Cycle Enable Check! ", MB_OK);
            }
        }
        else {
            nCycleRunFlag = 0;
        }
    }
    else {//stop
        nCycleRunFlag = 0;
        //sylee130925   m_list1.ResetContent();
        str.Format("****************************");
        m_list1.AddString(str);
        nlist1++;
        // str.Format(" ===>  Cycle Run Stoped.  "  ); 
        str.Format(" ===>  Jig Test Stoped.  ");
        m_list1.AddString(str);
        nlist1++;
        str.Format("****************************");
        m_list1.AddString(str);
        nlist1++;
    }

    nCycleRunCount = 0;//cycle//sylee130805 
    nCycleRunStatus = 0;//cycle//sylee130805 
    nCycleRunShort = 0;
    nCycleRunOpen = 0;
    nCycleRunPass = 0;
}


//son 이 코드는 전혀  수행이 안 되는 걸로 보임. 
//    FormView는 Dialog가 아니어서 OnInitDialog() Virtual 함수가 없다.
BOOL CChildView7::OnInitDialog()
{
    str.Format(" ACE400 ");
#ifdef __ACE550__
    str.Format(" ACE550 ");
#elif defined __ACE500__
    str.Format(" ACE500 ");
#elif defined __ACE1000__
    str.Format(" ACE1000 ");
#endif


if( SysSet19.m_nSet14  == 1) { //sylee240119 
	str.Format("*QC Leak ADCLog");
}

    m_Label501.SetCaption(str);
    UpdateData(FALSE);

    //  CDialog::OnInitDialog();
    nRunProc1 = 0;
    A_OnInit();//demo
    ReadFileB(1);  //jig read set

    return TRUE;
}


//son200510-4WLOG  
// ChildView7->FileSysInfo.cpp로 DisplayBlock_ReadMode1() 이동.  
//  FileSysInfo 내부 LoadSaveBlockInfo() 내부에서 호출할 수 있도록 전역함수로 변경.
/*
//son 장비에서 실제 Step 순서 (Z:\\STEPPATH.TXT => SysInfoBlock.m_nStepDirection)를 가져 온다.
int CChildView7::DisplayBlock_ReadMode1()  //sylee180502-1
{
        FILE *fp;
        char *fName;
        fName="Z:\\STEPPATH.TXT";
        char str[5];

        fp = fopen(fName,"rt");
        if(fp == NULL){
            //  AfxMessageBox(" ERROR 7501  file read error . Z:\\STEPPATH.TXT   ", MB_OK | MB_ICONSTOP);
            if( SysInfoBlock.m_nStepDirection<1 || SysInfoBlock.m_nStepDirection>4){
                SysInfoBlock.m_nStepDirection=1;
            }
            return 1;
        }
        ::ZeroMemory(&str, sizeof(str));
        fscanf(fp, "%s\n", str);

        if(str[0]=='A'){
            SysInfoBlock.m_nStepDirection=1;
        }else if(str[0]=='B'){
            SysInfoBlock.m_nStepDirection=2;
        }else if(str[0]=='C'){
            SysInfoBlock.m_nStepDirection=3;
        }else if(str[0]=='D'){
            SysInfoBlock.m_nStepDirection=4;
        }else{
            if( SysInfoBlock.m_nStepDirection<1 || SysInfoBlock.m_nStepDirection>4){
                SysInfoBlock.m_nStepDirection=1;
            }
        }
         fclose(fp);

    return 1;
}
*/

//==================================================================
//son Block 정보를 업데이트한다.
int CChildView7::DisplayBlock_Map1()  //sylee180418-1
{

    int Namo, i, j, k1, nCount1, nType1;
    int nBlockMaxX, nBlockMaxY, nPieceMaxX, nPieceMaxY;//,nPieceMaxX,nPieceMaxY;
    int No, Block1, Block2, Piece1, y2, x2;
    int nPo1;
    int row, col;


    FileSysInfo01.LoadSaveBlockInfo(_LOAD);     //son BDLPath\\\SETUP2\\Block.ini 를 SysInfoBlock에 로딩    //son220824_5
    FileSysInfo01.LoadSavePieceInfo(_LOAD);     //son BDLPath\\\SETUP2\\Piece.ini 를 SysInfoPiece에 로딩
                                                //son210430 LoadSaveSub25 ->LoadSavePieceInfo

    nBlockMaxX = SysInfoBlock.m_nCol;
    nBlockMaxY = SysInfoBlock.m_nRow;//y 
    nPieceMaxX = SysInfoPiece.m_nCol;
    nPieceMaxY = SysInfoPiece.m_nRow;

    //son Manual -> Set1 에서 '8) Block XY+- : Auto Display'가  Enable이 아니면 리턴 
    if (SysSet211.m_nSet21 != 1)//disable
    {
        ::ZeroMemory(&g_Map2_CellStep, sizeof(g_Map2_CellStep));
        SysInfoBlock.m_nStepDirection = 1;

        //son210330 : Manual -> Set1 에서 '8) Block XY+- : Auto Display' 옴션 꺼져 있을 때 모든 step=0인 문제 보완. 
        //            여기서 리턴해 버려서 g_Map3_BlockStep[]의 값이 모두 0이었음. 초기화가 전혀 안 된 상태로 운영됨.
        //            다음과 같이 SysInfoBlock.m_nStepDirection=1일때의  default 일반순서와 똑같이 step 값 초기화함.
        ::ZeroMemory(&g_Map3_BlockStep, sizeof(g_Map3_BlockStep));
        nCount1 = 0;
        //son 'A'            //son : X방향. 좌->우 반복 진행. 일반적인 순서.
        //son g_Map3_BlockStep[] =  0,  1,  2,  3,  4,    ->
        //son                           5,  6,  7,  8,    ->
        for (row = 1; row <= nBlockMaxY; row++)      //son                           9, 10, 11, 12,    ->
        {                                         //son                          13, 14, 15, 16,    ->
            for (col = 1; col <= nBlockMaxX; col++)    //son                          17, 18, 19, 20,    ->
            {
                nCount1++;
                g_Map3_BlockStep[(row - 1) * nBlockMaxX + col] = nCount1;
            }
        }

        return 1;
    }


    //  nFlagBlockPath=0;
    //  if(SysInfoBlock.m_nStepDirection==2|| SysInfoBlock.m_nStepDirection==3|| SysInfoBlock.m_nStepDirection==4){
      //     nFlagBlockPath=1;
    //  }     

    ::ZeroMemory(&g_Map2_CellStep, sizeof(g_Map2_CellStep));

    //son200515-4WLOG
    //son Step 방향이 'A'가 아니고 Block이 1개밖에 없는 경우에 Block-Piece 맵이 안그려지는 문제 관련
    //    nBlockMaxX, nBlockMaxY가 1일때에도 g_Map2_CellStep를 제대로 설정하도록 0보다 작은 경우에 리턴하도록 수정함.
    //if((nBlockMaxX<=1)&&(nBlockMaxY<=1)){
    if ((nBlockMaxX <= 0) && (nBlockMaxY <= 0)) {
        return 1;
    }

    if (SysInfoBlock.m_nStepDirection != 1 &&   //son 1,  A    (X, Left  -> Right  )
        SysInfoBlock.m_nStepDirection != 2 &&   //son 2,  B    (X, Left->Right , Right <- Left )   
        SysInfoBlock.m_nStepDirection != 3      //son 3,  C    (Y, Top -> Bottom  )               
        && SysInfoBlock.m_nStepDirection != 4)  //son 4,  D    (Y, Top->Bottom, Bottom->Top )     
    {
        SysInfoBlock.m_nStepDirection = 1;
    }





    //son 장비에서 실제 Step 순서 (Z:\\STEPPATH.TXT => SysInfoBlock.m_nStepDirection)를 가져 온다.
    FileSysInfo01.DisplayBlock_ReadMode1();//sylee180502-1  //son200515-4WLOG

    nType1 = SysInfoBlock.m_nStepDirection;



    //-----------------------------
    //son g_Map3_BlockStep[] 생성
    //-----------------------------

    ::ZeroMemory(&g_Map3_BlockStep, sizeof(g_Map3_BlockStep));
    nCount1 = 0;

    //son200525-4WLOG: 신규추가
    //son Step 순서가 X 방향, 좌->우 이면     
    if (nType1 == 1)         //son 'A'             //son : X방향. 좌->우 반복 진행. 일반적인 순서.
    {                                              //son g_Map3_BlockStep[] =  0,  1,  2,  3,  4,    ->
                                                   //son                           5,  6,  7,  8,    ->
        for (row = 1; row <= nBlockMaxY; row++)    //son                           9, 10, 11, 12,    ->
        {                                          //son                          13, 14, 15, 16,    ->
            for (col = 1; col <= nBlockMaxX; col++)//son                          17, 18, 19, 20,    ->
            {
                nCount1++;
                g_Map3_BlockStep[(row - 1) * nBlockMaxX + col] = nCount1;
            }
        }
    }


    ////son200525-4WLOG: 신규추가
    //son Step 순서가 X 방향, 좌->우, 우->좌 반복     
    else if (nType1 == 2)    // 'B'               //son g_Map3_BlockStep[] =  0,  1,  2,  3,  4,  ->
    {                                             //son                           8,  7,  6,  5,  <-    
                                                  //son                           9, 10, 11, 12,  ->   
        for (row = 1; row <= nBlockMaxY; row++)   //son                          16, 15, 14, 13,  <-   
        {                                         //son                          17, 18, 19, 20   ->    

            if (row % 2)   //son 홀수이면 좌->우
            {
                for (col = 1; col <= nBlockMaxX; col++)
                {
                    nCount1++;
                    g_Map3_BlockStep[(row - 1) * nBlockMaxX + col] = nCount1;
                }
            }

            else    //son 짝수이면 우->좌
            {
                for (col = nBlockMaxX; col >= 1; col--)
                {
                    nCount1++;
                    g_Map3_BlockStep[(row - 1) * nBlockMaxX + col] = nCount1;
                }
            }
        }
    }


    //son Step 순서가 Y 방향이면
    else if (nType1 == 3 || nType1 == 4)
    {

        //son nType1 == 3   'C'
        //son // Block Step 진행 순서  : Y 방향 . 상->하 반복 진행
        //son g_Map3_BlockStep[] =  0,  1, 5,  9, 13, 17,     ->
        //son                           2, 6, 10, 14, 18,     ->
        //son                           3, 7, 11, 15, 19,     ->
        //son                           4, 8, 12, 16, 20      ->

        //son nType1 ==4   'D'
        //son // Block Step 진행 순서 : Y방향, 상->하,  하->상  번갈아 진행
        //son g_Map3_BlockStep[] =  0,   1,  5,  9, 13, 17,     ->
        //son                           18, 14, 10,  6,  2      <-
        //son                            3,  7, 11, 15, 19,     ->
        //son                           20, 16, 12,  8,  4      <-


        ::ZeroMemory(&g_Map10_CellNo, sizeof(g_Map10_CellNo));    //son g_Map10_CellNo[DEF_MAX_PIECE1][DEF_MAX_PIECE1]
        ::ZeroMemory(&Map20, sizeof(Map20));    //son Map20[DEF_MAX_PIECE1][DEF_MAX_PIECE1]

        for (row = 1; row <= nBlockMaxY; row++)
        {
            for (col = 1; col <= nBlockMaxX; col++)
            {
                nCount1++;

                //son 여기서 g_Map10_CellNo[][]는  g_Map3_BlockStep[]을 write하기 위한 임시값이다.
                g_Map10_CellNo[row][col] = nCount1;  //son 임시로 Block번호를 write  MaxX:2 MAxY:3
                                                   //ex)   1 2    
                                                   //      3 4
                                                   //      5 6
            }
        }

        nCount1 = 0;
        for (col = 1; col <= nBlockMaxX; col++)
        {

            //son Y 방향부터 진행
            for (row = 1; row <= nBlockMaxY; row++)
            {
                nCount1++;
                if (nType1 == 3) {
                    nPo1 = g_Map10_CellNo[row][col];
                }
                if (nType1 == 4) {
                    Namo = col % 2;

                    //son 홀수 이면
                    if (Namo != 0) {//odd
                        nPo1 = g_Map10_CellNo[row][col];
                    }
                    //son 짝수 이면
                    else {
                        nPo1 = g_Map10_CellNo[nBlockMaxY - row + 1][col];
                    }
                }

                //son Block Step 순서를 g_Map3_BlockStep에 write한다.
                //ex) nType1 = 3 :  g_Map3_BlockStep[] = 1, 3, 5, 2, 4, 6
                //ex) nType1 = 4 :  g_Map3_BlockStep[] = 1, 3, 5, 6, 4, 2
                g_Map3_BlockStep[nCount1] = nPo1;
            }
        }
    }


    //son g_Map10_CellNo[][]에 TotalPiece 번호를 다시 write.  (전체 block 기준으로 한 piece) 
    //    Block이 6개,  Piece가 6개라면  1~36까지의 값이 할당.
    ::ZeroMemory(&g_Map10_CellNo, sizeof(g_Map10_CellNo));
    nCount1 = 0;
    for (j = 1; j <= (nBlockMaxY * nPieceMaxY); j++) {
        for (i = 1; i <= (nBlockMaxX * nPieceMaxX); i++) {
            nCount1++;
            g_Map10_CellNo[j][i] = nCount1;
        }
    }

    nCount1 = 0;


    //nType1=2;


    //-----------------------------
    //son g_Map2_CellStep[] 생성
    //-----------------------------

    //son GraphDisplayBlock()에서 사용할 g_Map2_CellStep[]를 생성한다.
    if (nType1 == 1)//A
    {
        for (j = 1; j <= (nBlockMaxY * nPieceMaxY); j++) {
            for (i = 1; i <= (nBlockMaxX * nPieceMaxX); i++) {
                nCount1++;
                g_Map2_CellStep[nCount1] = g_Map10_CellNo[j][i];
            }
        }

    }

    //===============================================================
    else if (nType1 == 2)//B
    {
        
        //B
        for (j = 1; j <= (nBlockMaxY * nPieceMaxY); j++)
        {
            //son (blockRow -1)이 짝수이면 'A' 와 똑같이 진행  (blockRow == blockY)
            Namo = ((j - 1) / nPieceMaxY) % 2;
            if (Namo == 0)//odd
            {
                for (i = 1; i <= (nBlockMaxX * nPieceMaxX); i++)
                {
                    nCount1++;
                    g_Map2_CellStep[nCount1] = g_Map10_CellNo[j][i];
                }
            }

            //son (blockRow-1)이 홀수이면 'A'와는 반대방향으로 진행  (blockRow == blockY)
            else {//even
                for (i = nBlockMaxX; i >= 1; i--) {
                    for (k1 = 1; k1 <= nPieceMaxX; k1++) {
                        nCount1++;
                        g_Map2_CellStep[nCount1] = g_Map10_CellNo[j][(i - 1) * nPieceMaxX + k1];
                    }
                }
            }
        }
        //}
    }

    //===============================================================
    else if (nType1 == 3)//C
    {
         
                //C
        for (j = 1; j <= (nBlockMaxY * nPieceMaxY); j++)
        {
            for (i = 1; i <= (nBlockMaxX * nPieceMaxX); i++)
            {
                nCount1++;
                //  No=g_Map10_CellNo[j][i];
                No = 0;
                //  nDisCell1[y[x  0=block  1 =piece
                Block1 = nDisCell1[j][i][0];
                Piece1 = nDisCell1[j][i][1];
                Block2 = g_Map3_BlockStep[Block1];    //son Block Direction에 의해 변경된 block 번호

                //son g_Map10_CellNo[y2][x2]의 값을 g_Map2_CellStep[nCount]에 할당.
                for (y2 = 1; y2 <= (nBlockMaxY * nPieceMaxY); y2++)
                {
                    for (x2 = 1; x2 <= (nBlockMaxX * nPieceMaxX); x2++)
                    {
                        if ((Block2 == nDisCell1[y2][x2][0]) && (Piece1 == nDisCell1[y2][x2][1]))
                        {
                            No = g_Map10_CellNo[y2][x2];
                            g_Map2_CellStep[nCount1] = No;
                            break;
                        }
                    }
                }
            }
        }
        ////////////////////////////////////////////////////////////

        //      }
    }

    //===============================================================         
    else if (nType1 == 4)//D
    {

  
            //D
        for (j = 1; j <= (nBlockMaxY * nPieceMaxY); j++) {
            for (i = 1; i <= (nBlockMaxX * nPieceMaxX); i++) {
                nCount1++;
                //  No=g_Map10_CellNo[j][i];
                No = 0;
                //  nDisCell1[y[x  0=block  1 =piece
                Block1 = nDisCell1[j][i][0];
                Piece1 = nDisCell1[j][i][1];
                Block2 = g_Map3_BlockStep[Block1];
                for (y2 = 1; y2 <= (nBlockMaxY * nPieceMaxY); y2++) {
                    for (x2 = 1; x2 <= (nBlockMaxX * nPieceMaxX); x2++) {
                        if ((Block2 == nDisCell1[y2][x2][0]) && (Piece1 == nDisCell1[y2][x2][1])) {
                            No = g_Map10_CellNo[y2][x2];
                            g_Map2_CellStep[nCount1] = No;
                            break;
                        }
                    }
                }
            }
        }
        ////////////////////////////////////////////////////////////

        //  }
    }
    return 1;
}

 


    //son 화면에 그려지는 모양인 m_waDisCell[][][]에 block, piece 번호등의 번호를 설정.
int CChildView7::DisplayNo()
{
    ///////////////////////////////////////////////////////////////
    //SYLEE120901

    int nPosX, nPosY, t2;

    ::ZeroMemory(nDisCell1, sizeof(nDisCell1));     //son 화면에 표시될 cell 정보
    ::ZeroMemory(nDisBlock1, sizeof(nDisBlock1));
    ::ZeroMemory(nDisPiece1, sizeof(nDisPiece1));

    //--------------------------------------------------
    // block map read //SYLEE120901
    nPosX = nPosY = 0;

    for (int ky1 = 1; ky1 <= SysInfoBlock.m_nRow; ky1++) {
        for (int kx1 = 1; kx1 <= SysInfoBlock.m_nCol; kx1++) {
            t2 = SysInfoBlock.m_nData[ky1 - 1][kx1 - 1];
            nDisBlock1[ky1][kx1] = t2;
        }
    }

    //--------------------------------------------------
    // PIECE map read //SYLEE120901
    nPosX = nPosY = 0;
    for (int ky2 = 1; ky2 <= SysInfoPiece.m_nRow; ky2++) {
        for (int kx2 = 1; kx2 <= SysInfoPiece.m_nCol; kx2++) {
            t2 = SysInfoPiece.m_nData[ky2 - 1][kx2 - 1];
            nDisPiece1[ky2][kx2] = t2;
        }
    }


    //--------------------------------------------------
    // Display mapping //SYLEE120901    

    nPosX = nPosY = 0;

    for (int blockRow = 1; blockRow <= SysInfoBlock.m_nRow; blockRow++)
    {
        for (int blockCol = 1; blockCol <= SysInfoBlock.m_nCol; blockCol++)
        {
            for (int pieceRow = 1; pieceRow <= SysInfoPiece.m_nRow; pieceRow++)
            {
                for (int pieceCol = 1; pieceCol <= SysInfoPiece.m_nCol; pieceCol++)
                {
                    nPosX = (blockCol - 1) * SysInfoPiece.m_nCol + pieceCol;   //son display Col
                    nPosY = (blockRow - 1) * SysInfoPiece.m_nRow + pieceRow;    //son display Row
                    nDisCell1[nPosY][nPosX][0] = nDisBlock1[blockRow][blockCol];// [1,1],[2,1]      block No
                    nDisCell1[nPosY][nPosX][1] = nDisPiece1[pieceRow][pieceCol];// [1,1~3] [2,1~3]  piece No
                }
            }
        }
    }

    /////////////////////////////////////////////////////////////////
    nDisBlock1[0][1] = SysInfoBlock.m_nRow;
    nDisBlock1[0][2] = SysInfoBlock.m_nCol;
    nDisPiece1[0][1] = SysInfoPiece.m_nRow;
    nDisPiece1[0][2] = SysInfoPiece.m_nCol;


    return TRUE;
}




void CChildView7::A_Language() //sylee151028 //LANGUAGE CHANGE
{

    //  CString str;

    //  str=LoadMessage(1,"TitleAuto", 102);
    if (SysSet211.m_nSet13 == 1) {//sylee160907-1   //chinese
        gDef_Language1 = 3;//redboard
    }
    else {//sylee160907-1
        gDef_Language1 = 2; //englishos
    }//sylee160907-1

    if (gDef_Language1 == 3) {//sylee151028-1 

        m_button2001.SetWindowText(LoadMessage(1, "TitleAuto", 102));   //sylee151028  /error view
        m_button2003.SetWindowText(LoadMessage(1, "TitleAuto", 103));   //sylee151028  /jig test

        m_Label29.SetWindowText(LoadMessage(1, "TitleAuto", 201));   //sylee151028  status
        m_Label301.SetWindowText(LoadMessage(1, "TitleAuto", 202));   //sylee151028  cycletime
        m_Label701.SetWindowText(LoadMessage(1, "TitleAuto", 203));   //sylee151028  
        m_Label702.SetWindowText(LoadMessage(1, "TitleAuto", 204));   //sylee151028  
        m_Label703.SetWindowText(LoadMessage(1, "TitleAuto", 205));  //sylee151028  
        m_Label704.SetWindowText(LoadMessage(1, "TitleAuto", 206));   //sylee151028  

        m_Label2001.SetWindowText(LoadMessage(1, "TitleAuto", 207));
        m_Label2002.SetWindowText(LoadMessage(1, "TitleAuto", 208));
        m_Label2003.SetWindowText(LoadMessage(1, "TitleAuto", 209));
        m_Label2004.SetWindowText(LoadMessage(1, "TitleAuto", 210));
        m_Label2005.SetWindowText(LoadMessage(1, "TitleAuto", 211));

    }

}

void CChildView7::A_OnInit()
{
    CString str, strT1;

    char  szTemp[30];
    char  szTemp1[11][30];
    char  szStep1[40][30];    //                          name           Voltate                 R
                              //son m:1 OPEN    szStep1[1]: "OPEN",    szStep1[11]: "xxx V",  szTemp1[21]: "xxx ohm" 
                              //son m:2 uShort  szStep1[2]: "uShort",  szStep1[12]: "xxx V",  szTemp1[22]: "xxx ohm" 
                              //son m:3 L Short szStep1[3]: "L Short", szStep1[13]: "xxx V",  szTemp1[23]: "xxx ohm" 
                              //son m:4 HR      szStep1[4]: "HR",      szStep1[14]: "xxx V",  szTemp1[24]: "xxx ohm" 
                              //son m:5 LEAK1   szStep1[5]: "LEAK1",   szStep1[15]: "xxx V",  szTemp1[25]: "xxx ohm" 
                              //son m:6 LEAK2   szStep1[6]: "LEAK2",   szStep1[16]: "xxx V",  szTemp1[26]: "xxx ohm" 
                              //son m:7 4W      szStep1[7]: "4W",      szStep1[17]: "xxx V",  szTemp1[27]: "xxx ohm" 

    int   szStep1Col[10];

    int nRet, m, m2;
    int nMod1;
    int j3, i3, j4, i4;
    int ki, TmpNo1, TmpNo2;
    double  aa, ab;

	nSamePcbFlag = 0;//sylee230426-5
	nManual4WStartFlag1=0; //sylee230426-8 MANUAL START:  ABORT DIO
    n4w_AutoCalCo1 = 0;   //sylee171020-1 

    g_nPrevDioCmd = 0xffff;  //son241119 계측기 초기화 직후 main 장비 요청에 무응답 문제 수정

    nRunOld_AbortSkip = D_OFF;     //son240119  //son240503 nRunOld_StartAbort_JoyTech -> nRunOld_AbortSkip

    if (SysSet211.m_nSet13 == 1) {//sylee160907-1
        nG_Language = 2;//chinese   //sylee160907-1
    }
    else {//sylee160907-1
        nG_Language = 2;//sylee150707//englishos
    }//sylee160907-1


    if (nRecheck_old_Flag <= 0) {
        nRecheck_old_Flag = 1;//sylee131001   
    }

    nCycleRunFlag = 0;//cycle//sylee130805
    nEt_LogCount = 0;  //sylee130219joytech //estimation
    nRet = 0;
    nAutoContinueFail = 0;

    ::ZeroMemory(&nEtLog, sizeof(nEtLog));//sylee130131 //estimation
    ::ZeroMemory(&nEtLogTime, sizeof(nEtLogTime));//sylee130131
    ::ZeroMemory(&GraphDisplay1, sizeof(GraphDisplay1));//SYLEE121129
    ::ZeroMemory(&nProStep1, sizeof(nProStep1));
    ::ZeroMemory(&nProStep2, sizeof(nProStep2));
    ::ZeroMemory(&szTemp1, sizeof(szTemp1));
    ::ZeroMemory(&szStep1, sizeof(szStep1));
    ::ZeroMemory(&szStep1Col, sizeof(szStep1Col));
    ::ZeroMemory(&nAutoReTest, sizeof(nAutoReTest));//max bock
    ::ZeroMemory(&dCalA1, sizeof(dCalA1));//temp//gobal  //4WSETUP140107
    ::ZeroMemory(&g_b4wSampleEnd, sizeof(g_b4wSampleEnd));  //son200320-4WDUT16 신규추가 //son211217_2  삭제.  
                                                            //son220203 4W Retest 안된다는 GTS 문제점 보고되어 20년 3월 기능 삭제했던 것 복구

    ::ZeroMemory(&g_d4W_Log1_nBlockDutInfo, sizeof(g_d4W_Log1_nBlockDutInfo));  //son200320-4WDUT16 신규추가  
    //::FillMemory(g_d4W_Log1_nBlockDutInfo, sizeof(g_d4W_Log1_nBlockDutInfo), -1); //son210722 일단 0으로 초기화하는 것 유지하기로 한다.
                                            //son 초기화가 0이어서  default로 첫번째 DUT로 출력이 되는게 출력 안 되는 거 보다 나을 수 있음. 

    //CalibrationLS1_Func(); //sylee140708      //son220419_5 미사용으로 삭제.

    //son "\SETUP2\PieceRange.ini"를 struct CSysInfoPieceRange에 Load(type=2)
    FileSysInfo01.LoadSavePieceRangeInfo(1, _LOAD);  //son for DUT1 
                                                     //son210430 LoadSaveSub11 -> LoadSavePieceRangeInfo

    //son "C:\\ACE400\\Setup\\PieceDisplay.ini"를 SysInfo02에 로딩
    FileSysInfo01.LoadSaveSub12(_LOAD);

    //son BDLPath\\\SETUP2\\Block.ini 를 SysInfoBlock에 로딩
    FileSysInfo01.LoadSaveBlockInfo(_LOAD); //son220824_5


    //son "\SETUP2\Recipe.ini"를 struct CSysInfo05에 Save(type=1) 또는 Load(type=2)
    Check_DDrive_FreeSpace();      //son221215 d 드라이브 용량 체크 
    FileSysInfo01.LoadSaveSub15(_LOAD);
    FileSysInfo01.printLog_Recipe();    //son220901 Recipe를 D:\Log 폴더에 출력.

    //son Multi DUT 4W Net Data:  BDLPath\4W.ini 파일을 읽어서  g_s4WNet[dutIdx]에 로딩한다.
//sylee210317   FileSysInfo01.LoadSaveSub17(_LOAD);  

    //son "\\SETUP2\\BlockDis.ini"를  SysInfo19에 로딩
    FileSysInfo01.LoadSaveSub19(_LOAD, 1);

    //son "C:\\ACE400\\Setup\\AutoCount.ini" 를 SysInfo20에 로딩
    FileSysInfo01.LoadSaveSub20(_LOAD);

    //son BDLPath"\\\SETUP2\\Piece.ini" 를 SysInfoPiece에 로딩
    FileSysInfo01.LoadSavePieceInfo(_LOAD); //son210430 LoadSaveSub25 ->LoadSavePieceInfo

    //son "C:\\ACE400\\SETUP\\SysSet15.ini"에서 SelfTest Setting 관련 값을 SysSet15에 로딩하거나 Save
    FileSysInfo01.LoadSaveSet15(_LOAD);//sylee121115-1
    FileSysInfo01.LoadSaveSet16(_LOAD);//sylee130218-//estimation
    FileSysInfo01.LoadSaveSet19(_LOAD);//sylee150407//estimation
    FileSysInfo01.LoadSaveSet17(_LOAD);//sylee130805
    //son "C:\\ACE400\\SETUP\\SysSet21_ACE400.ini" (전압 설정 Recipe)를 struct CSysSet21에 Load
    FileSysInfo01.LoadSaveSet21(_LOAD);//sylee130618  //load 
    FileSysInfo01.LoadSaveSet22(_LOAD);//sylee130618  //load 
    FileSysInfo01.SaveInfo_Piece1(_SAVE);//sylee130911
    //son "\\SETUP2\\BlockDis.ini"를  다시 write한다. 
    FileSysInfo01.LoadSaveSub19(_SAVE, 2); //save//sylee131101
    FileSysInfo01.SaveInfo_Block1();//sylee180209-1

    //son 4W용 dRec4w[15][11]을 read한다.
    FileSysInfo01.LoadSaveSet21_4W_Range(_LOAD);//SYLEE171012-1

    //son 4W용 dRec4w[15][11]을 write한다.
    FileSysInfo01.LoadSaveSet21_4W_Range(_SAVE);//SYLEE171012-1

    FileSysInfo01.LoadSaveSet21_4W_Cal1Pin(_LOAD);//sylee171020-1
    FileSysInfo01.LoadSaveSet21_4W_Cal1Pin(_SAVE);//sylee171020-1

    //son210115 Init_ComiDaqDevice() 함수로 이동. 
    //
    // SysInfoView01.m_pStrFileDrive1 초기화 없이 STEPPATH.TXT access시에 down 문제 보완을 
    // 위해  A_OnInit()에서 호출하던 것을 Init_ComiDaqDevice() 으로 이동함.
    // LoadSaveBlockInfo(_LOAD)보다 먼저 LoadFileDrive1()이 호출되어야 한다.
    // ChildView1, ChildView7에서 공통으로 사용되고 가장 먼저 초기화되므로 이쪽 위치가 더 적절하다.
    //FileSysInfo01.LoadFileDrive1();//sylee201201-1

    if (SysSet19.m_nSet12 != 1) {//SYLEE201024-1  //SPARK NEW BOARD 
        nFlag_NewSparkBaord = 2;//SYLEE201024-1  //SPARK NEW BOARD    
    }
    else {
        nFlag_NewSparkBaord = 0;  //SPARK OLD BOARD
    }


    if (nMultyNetTotal < 1) {//sylee180810-1-dut16
        nMultyNetTotal = 1;
    }

    for (int dut = 1; dut <= nMultyNetTotal; dut++)//s:ylee180810-1-dut16
    {
        //son "\SETUP2\PieceRange.ini"를 struct CSysInfoPieceRange에 또는 Load(type=2)
        FileSysInfo01.LoadSavePieceRangeInfo(dut, _LOAD);//sylee180810-1-dut16
                                                         //son210430 LoadSaveSub11 -> LoadSavePieceRangeInfo

        //son PieceRange.ini의 정보로 g_nPinPieceNo1[] 정보 생성, Piece별 ShortTestData 생성
        ReadPinPieceNo(dut); //sylee180810-1-dut16
    }


    nDisPMaxX = 545;
    nDisPMaxY = 510;
    nLine1 = 0;
    nLine2 = nLine1 / 2;  //nLine1  +시 축소 / - 100 확대 됨??????

    nBlockMaxX = SysInfoBlock.m_nCol; //son Block Col 개수    
    nBlockMaxY = SysInfoBlock.m_nRow;     //son Block Row 개수 
    nPieceMaxX = SysInfoPiece.m_nCol;     //son Piece Col 개수
    nPieceMaxY = SysInfoPiece.m_nRow;     //son Piece Row 개수 
    nCellMaxX = nBlockMaxX * nPieceMaxX - SysInfoPiece.m_nColDel;     //son BlockCol * PieceCol 개수
    nCellMaxY = nBlockMaxY * nPieceMaxY - SysInfoPiece.m_nRowDel;     //son BlockRow * PieceRow 개수

    nBlockMax = nBlockMaxX * nBlockMaxY; ///*******
    nBlockMax1 = nBlockMax;

    //========================================================================================================
    //PIECE  

    ::ZeroMemory(&nBlockPieceYX1, sizeof(nBlockPieceYX1));
    int cell = 0;
    for (int row = 1; row <= nCellMaxY; row++)
    {
        for (int col = 1; col <= nCellMaxX; col++) {
            cell++;
            nBlockPieceYX1[row][col] = cell;//cellno
        }
    }
    nBlockPieceYX1[0][1] = nCellMaxY;
    nBlockPieceYX1[0][2] = nCellMaxX;



    //========================================================================================================
    //sylee121019 
    //son 화면 라벨 초기화
    DisplayRes1_BigLabel(TEST_DIS_IDLE);//test  //1=pass,  2 fail  //SYLEE20120314  //son220824

    ki = 1;

    for (int col1 = 0; col1 < SysInfoBlock.m_nCol; col1++)
    {
        for (int row1 = 0; row1 < SysInfoBlock.m_nRow; row1++)
        {
            for (int col2 = 0; col2 < SysInfoPiece.m_nCol; col2++)
            {
                for (int row2 = 0; row2 < SysInfoPiece.m_nRow; row2++)
                {
                    j3 = row2 + (row1 * SysInfoPiece.m_nRow) + 1;
                    i3 = col2 + (col1 * SysInfoPiece.m_nCol) + 1;
                    j4 = (int)SysInfoBlock.m_nData[row1][col1];
                    i4 = (int)SysInfoPiece.m_nData[row2][col2];
                }
            }
        }
    }


    nPieceMax = nPieceMaxX * nPieceMaxY;
    g_nPieceMax1 = nPieceMax;

    nCellMax = nCellMaxX * nCellMaxY;   //son Block * Piece 개수
//son220823_2 begin:     
    if (nCellMax > MAX_CELL)     //son240510  10000: MAX_CELL
    {
        str.Format(" Error 7600!, BDL File Check! \n\nEngeneer Call! nCellMaxX(%d) is over MAX_CELL(%d)\n",
                                                                    nCellMax, MAX_CELL);      //son240510
        AfxMessageBox(str);
        MyTrace(PRT_BASIC, str);
    }  
//son220823_2 end

    if (nBlockMaxX > 0) {
        nBlockXGap = nDisPMaxX / nBlockMaxX;
    }
    else {
        nBlockXGap = 1;
    }
    if (nBlockMaxY > 0) {
        nBlockYGap = nDisPMaxY / nBlockMaxY;
    }
    else {
        nBlockYGap = 1;
    }
    if (nPieceMaxX > 0) {
        nPieceXGap = nDisPMaxX / nPieceMaxX;
    }
    else {
        nPieceXGap = 1;
    }
    if (nPieceMaxY > 0) {
        nPieceYGap = nDisPMaxY / nPieceMaxY;
    }
    else {
        nPieceYGap = 1;
    }
    if (nCellMaxX > 0) {
        nCellXGap = nDisPMaxX / nCellMaxX;
    }
    else {
        nCellXGap = 1;
    }
    if (nCellMaxY > 0) {
        nCellYGap = nDisPMaxY / nCellMaxY;
    }
    else {
        nCellYGap = 1;
    }

    for (row = 1; row <= nCellMaxY; row++)    //sylee20120321   nBlockMaxY-> nCellMaxY
    {
        for (int col = 1; col <= nCellMaxX; col++)
        {
            if (row == 1 && col == 1) {
                m_RectBlock[1].left = 0;
                m_RectBlock[1].right = nCellXGap - nLine2;
                m_RectBlock[1].top = 0;  //k max 200
                m_RectBlock[1].bottom = nCellYGap - nLine2;
            }
            else {  //cell max 200
                cell = (int)(nCellMaxX * (row - 1) + col);
                m_RectBlock[cell].left = m_RectBlock[1].left + (m_RectBlock[1].right * (col - 1));
                m_RectBlock[cell].right = m_RectBlock[cell].left + m_RectBlock[1].right;
                m_RectBlock[cell].top = (long)(m_RectBlock[1].top + (m_RectBlock[1].bottom * (row - 1)));
                m_RectBlock[cell].bottom = m_RectBlock[cell].top + m_RectBlock[1].bottom;
            }
        }
    }

    gRun05.m_nConFail = SysInfo05.m_nConFail;//sylee20120309

    if (nAutoClear1 == 2) {
        nBlockCountP = 0;
        nAutoClear1 = 0;
    }

    ::ZeroMemory(&szTemp, sizeof(szTemp));
    if (nBDLk == 2) {
        str.Format("BDL READING ERROR     ");
    }
    else {
        str.Format("%s", SysInfoView01.m_pStrFileBDLName);  //sylee121202
    }
    m_Label1.SetCaption(str);

    ::ZeroMemory(&gRun05, sizeof(gRun05));

    //==========================================================================
    //son TEST_TYPE name 설정
    str.Format("OPEN");   szStep1Col[TEST_OPEN] = 1;
    strcat(szStep1[TEST_OPEN], str);
    str.Format("uShort"); szStep1Col[TEST_U_SHORT] = 1;
    strcat(szStep1[TEST_U_SHORT], str);
    str.Format("L Short");  szStep1Col[TEST_SHORT] = 1; //SYLEE130214joytechrequest 
    strcat(szStep1[TEST_SHORT], str);
    str.Format("HR");    szStep1Col[TEST_HR_SHORT] = 1;
    strcat(szStep1[TEST_HR_SHORT], str);
    str.Format("LEAK1");    szStep1Col[TEST_LEAK1] = 1;   //SYLEE130816 NANOSYS LEAK
    strcat(szStep1[TEST_LEAK1], str);
    str.Format("LEAK2");    szStep1Col[TEST_LEAK2] = 1;  //sylee140923
    strcat(szStep1[TEST_LEAK2], str);
    str.Format("4W");    szStep1Col[TEST_4W] = 1;//sylee140923
    strcat(szStep1[TEST_4W], str);



    //son OPEN Voltage str 생성 ----
    strcat(szStep1[10 + TEST_OPEN],     //son220906 11: 10 +TEST_OPEN
        getStr_SysRecipe_m_nOpenV());      //son210324 for TestConditionLog


//son uShort Voltage str 생성 ----
    if (SysInfo05.m_nShort1V > 0 && SysInfo05.m_nShort1V < 2) {
        str.Format("1V");
    }
    else {
        str.Format("?");
    }
    strcat(szStep1[10 + TEST_U_SHORT], str); //son220906 12: 10+ TEST_U_SHORT


    //son Short Voltage str 생성   ---- 
    if (SysInfo05.m_nShort2V > 0 && SysInfo05.m_nShort2V < 3) {
        str.Format("%dV", SysInfo05.m_nShort2V * 10);
    }
    else {
        str.Format("?");
    }
    strcat(szStep1[10 + TEST_SHORT], str);   //son220906 13: 10 +TEST_SHORT


    //son HR  Short Voltage str 생성   ---- 
    if (SysInfo05.m_nHRV > 0 && SysInfo05.m_nHRV < 2) {
        str.Format("10V");
    }
    else {
        str.Format("?");
    }
    strcat(szStep1[10 + TEST_HR_SHORT], str); //son220906 14: 10 +TEST_HR_SHORT

    //son Leak1  Short Voltage str 생성   ---- 
    strcat(szStep1[10 + TEST_LEAK1],          //son220906 15: 10 +TEST_LEAK1
        getStr_SysRecipe_Leak1Voltage()); //sylee20111115 //son210324 for TestConditionLog 

//son Leak2  Short Voltage str 생성   ---- 
    strcat(szStep1[10 + TEST_LEAK2],       //son220906 16: 10 + TEST_LEAK2
        getStr_SysRecipe_Leak2Voltage()); //sylee140923   //son210324 for TestConditionLog

#ifdef __YP_VIET_CUSTOMER
    //son210824: 베트남영풍 코드. Apple 검수 대비
    //son 4W는 무조건 15V 로 출력
    str.Format("15 V");
    strcat(szStep1[10 + TEST_4W], str); //son200814  //son220906

#endif  


    //===============================
    // 저항값  SETUP
    //===============================
    //son   nProStep1[testType][1] : real R  저항값  을 설정한다.


    //---------------------------------------
    // <Continuity> Open  real R 저항값 설정

    nProStep1[TEST_OPEN][1] = getValOhm_SysRecipe_m_nCon();         //son210324: for TestConditionLog
    if (nProStep1[TEST_OPEN][1] >= 1000) {//sylee141030
        nOpenHighRFlag = 1;
    }
    else {
        nOpenHighRFlag = 0;
    }

    strcat(szStep1[20 + TEST_OPEN],      //son220906  21: 20 +TEST_OPEN
        getStrOhm_R(nProStep1[TEST_OPEN][1]));      //son210324: for TestConditionLog


 //---------------------------------------
 //  <uShort> 저항값 real R 설정

    nProStep1[TEST_U_SHORT][1] = getValOhm_SysRecipe_m_nShortR(); //son210324 for TestConditionLog
    strcat(szStep1[20 + TEST_U_SHORT],   //son220906 22: 20 +TEST_U_SHORT
        getStrOhm_R(nProStep1[TEST_U_SHORT][1])); //sylee20111115   //son210324 



 //-------------------------------
 // <L Short> 저항값 real R 설정

    nProStep1[TEST_SHORT][1] = getValOhm_SysRecipe_m_nShortR2();  //son210324 for TestConditionLog
    strcat(szStep1[20 + TEST_SHORT],     //son220906 23: 20 +TEST_SHORT
        getStrOhm_R(nProStep1[TEST_SHORT][1]));   //sylee20111115 //son210324 


//------------------------------
// <HR Short> 저항값 real R 설정
    nProStep1[TEST_HR_SHORT][1] = getValOhm_SysRecipe_m_nHR();     //son210324 for TestConditionLog
    strcat(szStep1[20 + TEST_HR_SHORT],  //son220906 24: 20 +TEST_HR_SHORT
        getStrOhm_R(nProStep1[TEST_HR_SHORT][1])); //son210324


//-----------------------------------

 
  ::ZeroMemory(&nLeakHighFlag1, sizeof(nLeakHighFlag1));//sylee230828
   nLeakHighFlag2=0;//sylee230830


// HV  저항값 (LEAK1_HV) real R설정
//  nMCon1=gRun05.m_nCon;

    nProStep1[TEST_LEAK1][1] = getValOhm_SysRecipe_Leak1R();     //son210324 for TestConditionLog
    strcat(szStep1[20 + TEST_LEAK1],     //son220906 25: 20 +TEST_LEAK1
        getStrOhm_R(nProStep1[TEST_LEAK1][1]));  //son210324

	nLeakHighFlag1[1]=0; //sylee230828
	if((nProStep1[TEST_LEAK1][1] /1000000)==200){//sylee230828
	    nLeakHighFlag1[1]=1;//sylee230828
	}

    if((nProStep1[TEST_LEAK1][1] /1000000)>200){//sylee230828
	    nLeakHighFlag1[1]=2;//sylee230828
	}
//-----------------------------------
// HV2  저항값 (LEAK2 HV) real R 설정
//SYLEE140923

    nProStep1[TEST_LEAK2][1] = getValOhm_SysRecipe_Leak2R();     //son210324 for TestConditionLog
    strcat(szStep1[20 + TEST_LEAK2],    //son220906 26: 20 +TEST_LEAK2 
        getStrOhm_R(nProStep1[TEST_LEAK2][1]));  //son210324   

	nLeakHighFlag1[2]=0; //sylee230828
	if((nProStep1[TEST_LEAK1][2] /1000000)==200){//sylee230828
	    nLeakHighFlag1[2]=1;//sylee230828
	}
	if((nProStep1[TEST_LEAK1][2] /1000000)> 200){//sylee230828
	    nLeakHighFlag1[2]=2;//sylee230828
	}

//son220630_2 나노시스도 전류설정이 Auo화면에 반영되도록 GTS와 똑같이 수정함.
//#ifdef __NANOSYS__CUSTOMER   //SYLEE201203-1
//    str.Format("/20mA");
//    strcat( szStep1[20 +TEST_OPEN] , str);       //son OPEN 전류설정
//    strcat( szStep1[20 +TEST_U_SHORT] , str);    //son uShort 전류설정은 Recipe에 없음.
//
//    str.Format("/1mA");
//    strcat( szStep1[20 +TEST_SHORT] , str);      //son LShort    전류 설정
//    strcat( szStep1[20 +TEST_HR_SHORT] , str);   //son HR Short  전류 설정
//
//    str.Format("/10mA");
//    strcat( szStep1[20 +TEST_LEAK1] , str);     //son Leak1  전류 설정
//    strcat( szStep1[20 +TEST_LEAK2] , str);     //son Leak2  전류 설정
//#else


//son220609 begin
//son220609 리노정밀(나노시스)만 전류세분화 기능이 실제 동작함. 
//son220609 GTS는 전류 세분화 기능의 UI만 있고 실제로는  사용 못함.
//son220902 나노시스, GTS를 제외한 고객사는 전류 세분화 기능 mA가 보이면 안됨
//          특히 LM디지털, MST는 전류 세분화 기능이 보이면 안 됨. 
//son220913#if ( (defined(__GTS__CUSTOMER) && !defined(__MST__CUSTOMER)) 
//son240905_2 #if (defined(__GTS__CUSTOMER )  || defined(__NANOSYS__CUSTOMER))      //son220902_2  //son220915_2
#if (defined(__GTS__CUSTOMER )  || defined(__MULTI_CURRENT__))  //son240905_2

//son240905_2 #ifdef __NANOSYS__CUSTOMER
#ifdef __MULTI_CURRENT__   //son240905_2

    //son240905_2 __MULTI_CURRENT__ define 이고  전류세분화 기능이 On이면 mA를 같이 출력해 준다.
    //            __GTS__CUSTOMER 는 SysSet13.m_nSet1 == 1  상관없이 그냥 mA를 출력한다.
    if (SysSet13.m_nSet1 == 1)  //son240905_2 
#endif
    {
        //son 전류를 /%s로 추가하니까 RECIPE.txt 출력시에 mA는 한줄 아래로 출력되는 문제가 있음.
        //    추후 고객이 한줄 아래로 출력되는 것을 싫어한다면 아래 부분을 /%s가 아니라 \\%s로 수정

        //str.Format("\\%s", STR_OPEN_CURR(SysInfo05.m_nOpen_Current)); //son220902
        str.Format("\\ %s", getStr_OpenCurrent(SysInfo05.m_nOpenV, SysInfo05.m_nOpen_Current)); //son221227
        strcat(szStep1[20 + TEST_OPEN], str);     //son OPEN  Ohm /전류 str   //son220906  21: 20 +TEST_OPEN


        //strcat( szStep1[20 +TEST_U_SHORT] , str);   //son uShort 전류설정은 Recipe에 없음.


        str.Format("\\ %s", STR_SHORT_CURR(SysInfo05.m_nShort_Current));  //son220902
        strcat(szStep1[20 + TEST_SHORT], str);   //son LShort    Ohm /전류 str  //son220906 23: 20 +TEST_SHORT
        strcat(szStep1[20 + TEST_HR_SHORT], str);//son HR Short  Ohm /전류 str  //son220906 24: 20 +TEST_HR_SHORT


        str.Format("\\ %s", STR_LEAK_CURR(SysInfo05.m_nLeak1_Current));   //son220902
        strcat(szStep1[20 + TEST_LEAK1], str);   //son Leak1  Ohm /전류 str    //son220906 25: 20 +TEST_LEAK1


        str.Format("\\ %s", STR_LEAK_CURR(SysInfo05.m_nLeak2_Current));   //son220902 
        strcat(szStep1[20 + TEST_LEAK2], str);    //son Leak2  Ohm /전류 str  //son220906 26: 20 +TEST_LEAK2
    }
#else

#endif 
//son220609 end



    //------------------------------
    // OPEN Recipe, testMode 설정
    int nTep[5];

    ::ZeroMemory(&nTep, sizeof(nTep));
    ::ZeroMemory(&nVbSet, sizeof(nVbSet));//sylee20120306


    //son m_nMode값 (nProStep1[TEST_OPEN][3]) 을 dRecSetup[][] 테이블에서 찾는다.
    //    Recipe 전압(SysInfo05.m_nOpenV)과 Recipe Open R(nProStep1[TEST_OPEN][1])에 맞는 mode를 찾는다.
    if (SysInfo05.m_nOpenV <= 1)
    {
        //son Recipe에서 가져온 Open R(Cal 적용) 값이 1보다 작다면 error
        //    nProStep1[testType][1] : Cal 적용 저항값(real R. ohm)
        //    nProStep1[testType][3] : 해당 검사의 Recipe 위치(m_nMode 값, Test mode) 

        if (nProStep1[TEST_OPEN][1] < 1) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][1];
            AfxMessageBox("  OPEN SET ( 1V ) ,   R Range 1 ohm under.  Recipe Check?  ", MB_OK);
        }
        //son Open R값이 1V open range1보다 작다면 loc1의 dRec[] mode1(key)값을 nProStep1[TEST_OPEN][3]에 할당한다.
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[0][1]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][6];    //son mode1
        }
        //son Open R값이 1V open range2보다 작다면 loc1의 dRec[] mode2(key)값을 nProStep1[TEST_OPEN][3]에 할당한다.
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[0][2]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][7];    //son mode2
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[0][3]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][8];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[0][4]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][9];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[0][5]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][10];
        }
        else {
            nProStep1[TEST_OPEN][3] = dRecSetup[0][2];
            AfxMessageBox("  OPEN SET ( 1V ) ,  \n\n Recipe Check!   \n\n   R Range Set  100Kohm OVER.    ", MB_OK);
        }

    }
    //int m_nOpenV;                 //son m_combo22
    //son 0: <Volt.>, 1: *, 2: 10V, 3: *, 4: 30V,  5: 40V, 6: 50V*, 7: 60V, 8: 70V, 9: 80V, 
    //   10: 90V,  11: 100V*, 12: 110V, 13: 120V, 14: 130V, 15: 140V, 16: 150V*, 17: 160V, 18: 170V, 19: 180V
    //   20: 190V, 21: 200V*, 22: 210V, 23: 220V, 24: 230V, 25: 240V, 26: 250V*  
    else if (SysInfo05.m_nOpenV <= 30)
    {
        //son TmpNo1: m_combo22(Recipe> Open Voltage combo) 의 index-1 
        TmpNo1 = SysInfo05.m_nOpenV - 1;
        if (TmpNo1 > 30) {
            AfxMessageBox("  OPEN R Range No. 30  Over ,  \n\n  software error!  \n\n    ", MB_OK);
        }
        if (TmpNo1 < 1) {
            AfxMessageBox("  OPEN R Range No. 1  under ,  \n\n  software error!  \n\n    ", MB_OK);
        }
        if (nProStep1[TEST_OPEN][1] < 1) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][1];
            //AfxMessageBox("  OPEN SET ( 1V ) ,   R Range 1 ohm under.  Recipe Check?  ", MB_OK );
            str.Format("  OPEN SET ( %d V ) ,   R Range 1 ohm under.  Recipe Check? ", SysInfo05.m_nOpenV - 40);
            AfxMessageBox(str, MB_OK);
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[TmpNo1][1]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][6];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[TmpNo1][2]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][7];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[TmpNo1][3]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][8];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[TmpNo1][4]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][9];
        }
        else if (nProStep1[TEST_OPEN][1] <= dRecSetup[TmpNo1][5]) {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][10];
        }
        else {
            nProStep1[TEST_OPEN][3] = dRecSetup[TmpNo1][2];

            if (SysInfo05.m_nOpenV == 1) {
                str.Format(" OPEN SET ( %d V ) ,  \n\n Recipe Check!   \n\n   R Range Set  Max.    OVER.", (SysInfo05.m_nOpenV - 1));
            }
            else {
                str.Format(" OPEN SET ( %d V ) ,  \n\n Recipe Check!   \n\n   R Range Set  Max.    OVER.", (SysInfo05.m_nOpenV - 1) * 10);
            }

            AfxMessageBox(str, MB_OK);
        }
    }

    ///////////////////////////////////////////////////////////////
    int nCalNo1;
    nCalNo1 = 0;

#ifdef __MULTI_CURRENT__  //SYLEE220426   //son220609
    //son "Current 20mA , 10mA, 5mA enable"이면  전류 설정에 따라 m_nMode를 바꿔 준다.
    if (SysSet13.m_nSet1 == 1) {//SYLEE220428
        nCalNo1 = nProStep1[TEST_OPEN][3];    //son m_nMode : default 10mA 

        //son dRec중 저저항 set는 5의 배수 +1 위치임. ex) 6:MODE6_OPEN_10V, 11:MODE11_OPEN_20V
        if ((nCalNo1 % 5) == 1) {
            //son Open User전류설정값:   SysSet21_ACE400 dRec 5개중 5번째(5의 배수 +5 위치) : 20mA 
            //son 6   1   1   15  2   100      <= 100: 5의 배수 +1 : 10mA   
            //son 7   1   1   15  3   100     
            //son 8   1   1   15  3   2000    
            //son 9   1   1   15  2   50       <=  50: 5의 배수 +4 : 5mA
            //son 10  1   1   15  2   200      <= 200: 5의 배수 +5 : 20mA
            //
            //    주의!!*현재 open의 경우 recipe의 전류설정 enum순서와 실제 dRec의 전류 설정순서가 다른 문제가 있으므로 주의한다.
            //    Open dRec 전류 순서 :  1:10mA, 2th:10mA, 3:200mA,  4:5mA, 5:20mA
            //    "220428_리노정밀_전류다중화선택기능(이상윤부장님구현)"  문서 참조
            if (SysInfo05.m_nOpen_Current == CURR_20mA) { //son220706 //son230711 1: CURR_20mA
                nProStep1[TEST_OPEN][3] = (nCalNo1 / 5) * 5 + 5;    //ex) 10:MODE10_OPEN_10V, 15:MODE15_OPEN_20V 
            }
            //son if (SysInfo05.m_nOpen_Current == CURR_10mA) Open User전류설정값: 2:10mA (default) 

            //son Open User전류설정값  3: 5mA를 사용하도록 5의 배수 +4위치로 재지정
            else if (SysInfo05.m_nOpen_Current == CURR_5mA) { //son220706  //son230711 3:CURR_5mA
                nProStep1[TEST_OPEN][3] = (nCalNo1 / 5) * 5 + 4;    //ex) 9:MODE9_OPEN_10V,   14:MODE14_OPEN_20V
            }
        }
    }
#endif

    ///////////////////////////////////////////////////////////////

    nVbSet[4] = (SysInfo05.m_nOpenV - 1) * 10;
    if (nVbSet[4] > 250) {
        nVbSet[4] = 0;
        AfxMessageBox("  ERROR NO 7011 , RECIPE OPEN SELECT VOLTAGE ERROR, 250V OVER. ?.", MB_OK);
    }


    if (nVbSet[4] <= 20) { //SYLEE140627
        nVbSet[4] = 0;
    }


    //#######################################################################################################################
    // uSHORT ONLY 1V  testMode 설정

    //son   nProStep1[testType][1] : Cal 적용 저항값
    //son   nProStep1[testType][3] : 해당 검사의 Recipe 위치(m_nMode 값, Test mode) 

    if (nProStep1[TEST_U_SHORT][1] < 1) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][6];
        AfxMessageBox("  u Short Set  ( 1V ) ,   R Range 1 ohm under.  Recipe Check?  ", MB_OK);
    }
    else if (nProStep1[TEST_U_SHORT][1] <= dRecSetup[40][1]) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][6];
    }
    else if (nProStep1[TEST_U_SHORT][1] <= dRecSetup[40][2]) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][7];
    }
    else if (nProStep1[TEST_U_SHORT][1] <= dRecSetup[40][3]) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][8];
    }
    else if (nProStep1[TEST_U_SHORT][1] <= dRecSetup[40][4]) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][9];
    }
    else if (nProStep1[TEST_U_SHORT][1] <= dRecSetup[40][5]) {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][10];
    }
    else {
        nProStep1[TEST_U_SHORT][3] = dRecSetup[40][2];
        AfxMessageBox("  u Short Set ( 1V ) ,  \n\n Recipe Check!   \n\n   R Range Set  100Kohm OVER.    ", MB_OK);
    }

    //#######################################################################################################################
    // SHORT  testMode 설정
    //only 10v   RECIPESETUP
    nTep[1] = (int)(nProStep1[TEST_SHORT][1] / 1000.);

    //#####################################################
    //RECIPESETUP //SYLEE130702  
    //10V ADC I   

    if (SysInfo05.m_nShort2V == 1) {
        TmpNo1 = 41;
        TmpNo2 = 10;
    }
    else if (SysInfo05.m_nShort2V == 2) {
        TmpNo1 = 42;
        TmpNo2 = 20;//VOLTAGE
    }
    else {
        TmpNo1 = 41;
        TmpNo2 = 10;//VOLTAGE
        AfxMessageBox(" ERROR:  SHORT R  :  Voltage Select  ,  \n\n  software error!  \n\n    ", MB_OK);
    }

    if (nTep[1] < 1) {
        nTep[3] = dRecSetup[TmpNo1][1];
        str.Format("  LV SHORT SET ( %d V ) ,   R Range 1 ohm under.  Recipe Check? ", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][1]) {
        nTep[3] = dRecSetup[TmpNo1][6];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][2]) {
        nTep[3] = dRecSetup[TmpNo1][7];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][3]) {
        nTep[3] = dRecSetup[TmpNo1][8];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][4]) {
        nTep[3] = dRecSetup[TmpNo1][9];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][5]) {
        nTep[3] = dRecSetup[TmpNo1][10];
    }
    else {
        nTep[3] = dRecSetup[TmpNo1][2];

        str.Format(" LV SHORT SET ( %d V ) ,  \n\n Recipe Check!   \n\n   R Range Set  Max.    OVER.", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }

    nProStep1[TEST_SHORT][3] = nTep[3];


    //#######################################################################################################################
    //HR
    //only 10v 


    nTep[1] = (int)(nProStep1[TEST_HR_SHORT][1] / 1000.);

    if (nTep[1] < 1) {
        nTep[3] = dRecSetup[41][1];
        AfxMessageBox("  HR SET ( 10V ) ,   R Range 1 ohm under.  Recipe Check?  ", MB_OK);
    }
    else if (nTep[1] <= dRecSetup[41][1]) {
        nTep[3] = dRecSetup[41][6];
    }
    else if (nTep[1] <= dRecSetup[41][2]) {
        nTep[3] = dRecSetup[41][7];
    }
    else if (nTep[1] <= dRecSetup[41][3]) {
        nTep[3] = dRecSetup[41][8];
    }
    else if (nTep[1] <= dRecSetup[41][4]) {
        nTep[3] = dRecSetup[41][9];
    }
    else if (nTep[1] <= dRecSetup[41][5]) {
        nTep[3] = dRecSetup[41][10];
    }
    else {
        nTep[3] = dRecSetup[41][10];
        AfxMessageBox("  HR SET ( 10V ), \n\n Recipe Check!   \n\n  R Range Set 20Mohm   OVER.   ", MB_OK);
    }

    nProStep1[TEST_HR_SHORT][3] = nTep[3];

    ///////////////////////////////////////////////////////////////

#ifdef __MULTI_CURRENT__  //SYLEE220426   //son220609
    //son Multi Current 20mA , 10mA, 5mA enable이면
    if (SysSet13.m_nSet1 == 1) {//SYLEE220428
        nCalNo1 = nProStep1[TEST_HR_SHORT][3];
        if (((nCalNo1 % 5) == 1) || ((nCalNo1 % 5) == 2)) {
//son220706 begin:  
            if (SysInfo05.m_nShort_Current == CURR_20mA) {          //son230711 1:CURR_20mA
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_20mA; //son SysSet21_ACE400 dRec 5개중 1번째 : 20mA
            }
            else    if (SysInfo05.m_nShort_Current == CURR_10mA) {  //son230711 2:CURR_10mA
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_10mA; //son dRec m_nMode 5개중 2번째 : 10mA
            }
            else    if (SysInfo05.m_nShort_Current == CURR_5mA) {   //son230711 3:CURR_5mA
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_5mA; //son dRec m_nMode 5개중 3번째 : 5mA
            }
            else    if (SysInfo05.m_nShort_Current == CURR_3mA) {          //son230711 4:CURR_3mA
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_3mA; //son dRec m_nMode 5개중 4번째 : 3mA
            }
            else    if (SysInfo05.m_nShort_Current == CURR_1mA) {          //son230711 5:CURR_1mA
//son220706 end    
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_1mA; //son dRec m_nMode 5개중 5번째 : 1mA
            }
            else {
                nProStep1[TEST_HR_SHORT][3] = (nCalNo1 / 5) * 5 + CURR_10mA;
            }
        }
    }
#endif

    ///////////////////////////////////////////////////////////////
        //#######################################################################################################################
        ///HV SET  RECIPESET

    if (SysInfo05.m_nHv < 1) {
        TmpNo1 = 45;
        TmpNo2 = 50;
        AfxMessageBox(" RECIPE,   HV  SHORT, \n\n    VOLTAGE SELECT ERROR ( 30V> UNDER ),  \n\n  software error!  \n\n    ", MB_OK);
    }
    else if (SysInfo05.m_nHv < 24) {
        TmpNo1 = 42 + SysInfo05.m_nHv;
        TmpNo2 = (SysInfo05.m_nHv + 2) * 10;//VOLTAGE
    }
    else {
        TmpNo1 = 45;
        TmpNo2 = 50;
        AfxMessageBox(" RECIPE,   HV  SHORT, \n\n    VOLTAGE SELECT ERROR ( 250V< OVER ),  \n\n  software error!  \n\n    ", MB_OK);
    }

    if (nTep[1] < 1) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][1];
        str.Format("  HV SHORT SET ( %d V ) ,   R Range 1 ohm under.  Recipe Check? ", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][1]) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][6];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][2]) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][7];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][3]) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][8];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][4]) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][9];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][5]) {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][10];
    }
    else {
        nProStep1[TEST_LEAK1][3] = dRecSetup[TmpNo1][2];

        str.Format(" HV SHORT SET ( %d V ) ,  \n\n Recipe Check!   \n\n   R Range Set  Max.    OVER.", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }

    /////////////////////////////////////////////////////////////  

#ifdef __MULTI_CURRENT__  //SYLEE220426   //son220609
    //son Multi Current 20mA , 10mA, 5mA enable이면
    if (SysSet13.m_nSet1 == 1) {//SYLEE220428
        nCalNo1 = nProStep1[TEST_LEAK1][3];
        if (((nCalNo1 % 5) == 1) || ((nCalNo1 % 5) == 2)) {
//son220706 begin
            if (SysInfo05.m_nLeak1_Current == CURR_20mA) {  //LEAK1 20mA   //son230711 1:CURR_20mA     
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + CURR_20mA;   //son SysSet21_ACE400 m_nMode 5개중 1번째 : 20mA
            }
            else    if (SysInfo05.m_nLeak1_Current == CURR_10mA) {  //son230711 2:CURR_10mA
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + CURR_10mA;   //son dRec m_nMode 5개중 2번째 : 10mA
            }
            else    if (SysInfo05.m_nLeak1_Current == CURR_5mA) {  //son230711 3:CURR_5mA
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + CURR_5mA;   //son dRec m_nMode 5개중 3번째 : 5mA
            }
            else    if (SysInfo05.m_nLeak1_Current == CURR_3mA) {  //son230711 4:CURR_3mA
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + CURR_3mA;   //son dRec m_nMode 5개중 4번째 : 3mA
            }
            else    if (SysInfo05.m_nLeak1_Current == CURR_1mA) {  //son230711 5:CURR_1mA 
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + CURR_1mA;   //son dRec m_nMode 5개중 5번째 : 1mA
            }
//son220706 end 
            else {
                nProStep1[TEST_LEAK1][3] = (nCalNo1 / 5) * 5 + 2;
            }
        }
    }
#endif

    ///////////////////////////////////////////////////////////////

        //#######################################################################################################################
        ///HV2 SET  RECIPESET


    if (SysInfo05.m_nHv2 < 1) {
        TmpNo1 = 45;
        TmpNo2 = 50;
        AfxMessageBox("  ERROR 7712 \n  RECIPE,   HV2  Voltage Select!  ERROR!  ,   \n\n    ", MB_OK);
        //  AfxMessageBox("    \n  RECIPE 화면에서 HV2 임의의 전압값을 선택  설정 해 주십시요.,   ", MB_OK );

    }
    else if (SysInfo05.m_nHv2 < 24) {
        TmpNo1 = 42 + SysInfo05.m_nHv2;
        TmpNo2 = (SysInfo05.m_nHv2 + 2) * 10;//VOLTAGE
    }
    else {
        TmpNo1 = 45;
        TmpNo2 = 50;
        AfxMessageBox(" ERROR 7713 \n  RECIPE,   HV2   Voltage Select!  ERROR! ,    \n\n    ", MB_OK);
        // AfxMessageBox("    \n   RECIPE 화면에서 HV2 임의의 전압값을 선택  설정 해 주십시요.,   ", MB_OK );
    }

    if (nTep[1] < 1) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][1];
        //AfxMessageBox("  OPEN SET ( 1V ) ,   R Range 1 ohm under.  Recipe Check?  ", MB_OK );
        str.Format("  HV SHORT SET ( %d V ) ,   R Range 1 ohm under.  Recipe Check? ", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][1]) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][6];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][2]) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][7];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][3]) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][8];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][4]) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][9];
    }
    else if (nTep[1] <= dRecSetup[TmpNo1][5]) {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][10];
    }
    else {
        nProStep1[TEST_LEAK2][3] = dRecSetup[TmpNo1][2];

        str.Format("  \n\n Recipe HV2 Select Set !   \n\n   R Range Set  Max.  OVER.  ( %d V ) , ", TmpNo2);
        AfxMessageBox(str, MB_OK);
    }


    /////////////////////////////////////////////////////////////

#ifdef __MULTI_CURRENT__  //SYLEE220426   //son220609
    //son Current 20mA , 10mA, 5mA enable이면
    if (SysSet13.m_nSet1 == 1) {//SYLEE220428
        nCalNo1 = nProStep1[TEST_LEAK2][3];
        if (((nCalNo1 % 5) == 1) || ((nCalNo1 % 5) == 2)) {
//son220706 begin
            if (SysInfo05.m_nLeak2_Current == CURR_20mA) {     //son230711 1:CURR_20mA             
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + CURR_20mA; //son SysSet21_ACE400 m_nMode 5개중 1번째 : 20mA
            }
            else    if (SysInfo05.m_nLeak2_Current == CURR_10mA) {  //son230711 2:CURR_10mA
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + CURR_10mA; //son dRec m_nMode 5개중 2번째 : 10mA
            }
            else    if (SysInfo05.m_nLeak2_Current == CURR_5mA) {  //son230711 3:CURR_5mA
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + CURR_5mA; //son dRec m_nMode 5개중 3번째 : 5mA
            }
            else    if (SysInfo05.m_nLeak2_Current == CURR_3mA) {  //son230711 4:CURR_3mA
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + CURR_3mA; //son dRec m_nMode 5개중 4번째 : 3mA
            }
            else    if (SysInfo05.m_nLeak2_Current == CURR_1mA) {  //son230711 5:CURR_1mA        
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + CURR_1mA; //son dRec m_nMode 5개중 5번째 : 1mA
            }
//son220706 end
            else {
                nProStep1[TEST_LEAK2][3] = (nCalNo1 / 5) * 5 + 2;
            }
        }
    }
#endif

    ///////////////////////////////////////////////////////////////

    FileSysInfo01.LoadSaveSet13(2);//load //sylee181005-3   

    nProStep1[TEST_4W][3] = MODE171_4W; //4W //SYLEE20120129  TEMP   //SYLEE140923 //son220906

    ::ZeroMemory(&SysInfoSer13.m_nData, sizeof(SysInfoSer13.m_nData));//sylee20111224
    ::ZeroMemory(&gdCal1, sizeof(gdCal1));//sylee20111224

    A_Run101Init3();//INTERLOCK CHECK

    //  ex) "C:\\ACE400\\SETUP\\CAL\\CALR206B.INI" 에서 이전의 Calibration Ref 값 Load 또는 Save
    nRet = FileSysInfo01.LoadSaveSer13(_LOAD, 206, PART_MIXED);//syLEE170612      //son220412
    if (nRet != 1) {
        str.Format("ERRor NO 7002-1,   \n   Calibration file reading Error , \n   Mode no= 206  ");
        AfxMessageBox(str);
        //  return ; 
    }
    //  ex) "C:\\ACE400\\SETUP\\CAL\\CALR207B.INI" 에서 이전의 Calibration Ref 값 Load 또는 Save
    nRet = FileSysInfo01.LoadSaveSer13(_LOAD, 207, PART_MIXED);   //son220412
    if (nRet != 1) {
        str.Format("ERRor NO 7002-2,   \n   Calibration file reading Error , \n   Mode no= 207  ");
        AfxMessageBox(str);
        //  return ; 
    }


    //  TEST_OPEN           = 1,    //  TEST_U_SHORT     = 2,    //  TEST_SHORT       = 3,    //  TEST_HR_SHORT    = 4,    //  TEST_LEAK1       = 5,    //  TEST_LEAK2       = 6,
    for (int testType = TEST_OPEN; testType <= TEST_LEAK2; testType++) //SYLEE140923
    {
        aa = 0.0;
        ab = 0.0;

        //son   nProStep1[testType][3] : 해당 검사의 Recipe m_nMode 값, Test mode 
        nMod1 = (int)nProStep1[testType][3];


        if (nMod1 > 0 && nMod1 <= 362)//sylee130703
        {

            //--------------------------------------------------------------
            //son dRec[nMod1]의 설정값을 nCC, nVRel ... nHVGain에 할당한다.
            A_Run101Init1(nMod1);//INTERLOCK CHECK
            //------------------------------------------------
            //son Calibration Reference Data를  Load한다. 

            //  ex) "C:\\ACE400\\SETUP\\CAL\\CALR%02dB.INI" 에서 이전의 Calibration Ref 값 Load 
            //son Cal Use=1 일때에는  SysInfoSer13.m_nData[part][mode][1~3][i]를 읽어서 gdCal1[part][mode][1~3][j]에 저장한다.
            nRet = FileSysInfo01.LoadSaveSer13(_LOAD, nMod1, PART_MIXED); //son220412
            if (nRet != 1) {
                str.Format("ERRor NO 7002,   \n   Calibration file reading Error , \n   Mode no= %d  ",
                    //son240827 (int)nProStep1[testType][3]);    
                    nMod1);    //son240827 double을 int로 출력해서 오류값 출력문제 수정

                AfxMessageBox(str);
                return;
            }

            // hdpark230105 spark begin
            nRet = FileSysInfo01.LoadSaveSer13(_LOAD, nMod1, PART_SPARK);
            if (nRet != 1) {
                str.Format("ERRor NO 7002,   \n  Spark Calibration file reading Error , \n   Mode no= %d  ",
                    nProStep1[testType][3]);
                AfxMessageBox(str);
                return;
            }
            //hdpark230105 spark end

            int calCnt, calIdx, m_nMode1;
            double  aa, ab;
            int nPo;

            nPo = 0;       aa = 0.0;         ab = 0.0;

            calCnt = (int)gdCal1[PART_UPPER][nMod1][0][0];// Cal  list su (개수)  //son220412                 
            m_nMode1 = nMod1;


            int nOpenOffset1;//sylee181229
            nOpenOffset1 = 0;//sylee181229                     

            if (testType == TEST_OPEN)//sylee181229 
            {
                if (SysSet19.m_nSet33 > 0) {//sylee181229
                    if (SysSet19.m_nSet33 > 30) {
                        nOpenOffset1 = 30;//sylee181229 //sylee210308  100->30
                    }
                    else
                    {
                        //son 'MAP' > 'SET3' (Leak Set)
                        //son System OpenOffset.  'OPEN Offset R'. Open Offset R(recipe와 별도. 강제 설정)
                        nOpenOffset1 = SysSet19.m_nSet33;//sylee181229
                    }
                }
                //son   nProStep1[testType][1] : Recipe의 real R ohm 
                Sub71.R1 = nProStep1[testType][1] + nOpenOffset1; //sylee181229 
            }
            else {//sylee181229 
                //son   nProStep1[testType][1] : real R ohm
                Sub71.R1 = nProStep1[testType][1];
            }




#if (defined(__CCTC__CUSTOMER))//sylee220923    
            if (SysSet13.m_nSet8 == 1) { //son Map > Set1 > '*  200M  L'
                if (testType == TEST_LEAK1 || testType == TEST_LEAK2) {//sylee220923	
                    if (Sub71.R1 > (100 * 1000000)) { 
                        Sub71.R1 = (100 * 1000000); }
                }
            }
#endif 



            //son Open Test 이고 
            //son Manual-> Set1-> "11) Recipe: OPEN R.Offset" (SysSet211.m_nSet24) 이 Enable이라면
            if ((testType == TEST_OPEN) && (SysSet211.m_nSet24 == 1))//SYLEE181016-1
            {
                //SYLEE181016-1
                if ((SysInfo05.m_nCC[3] == 1)                                 //son Open Offset 사용(m_check4)이 체크됨.
                    && (SysInfo05.m_nCC[4] > 0) && (SysInfo05.m_nCC[4] <= 50)) //son Open Offset 값이(m_edit2)이 0 이상 50이하 
                {
                    //son 측정된 저항값에 SysInfo05.m_nCC[4](Recipe ->m_edit2)  Open offset 값을 더해서 저항값을 결정한다.
                    Sub71.R1 = Sub71.R1 + SysInfo05.m_nCC[4];
                }
            }

            //---------------------------------------------------------------
            //son nProStep1[testType][2] 설정
            //   Sub71.R1 의 Open Offset 더해진 real R 값을  ADC(Raw R) 값으로 변환한다.
            //---------------------------------------------------------------
            int part = PART_UPPER;  //son220412  초기화이므로 part를 default인 Upper로 고정하여 진행한다.
            if (Sub71.R1 > 0 && (calCnt > 0) && (calCnt <= MAX_CAL_RLIST))  //son220407 128: MAX_CAL_RLIST
            {
                //son 현재 Open 저항에 해당하는 Cal 저항 위치 (calIdx) 를 찾는다. 
                for (calIdx = 1; calIdx <= calCnt; calIdx++) {
                    if (Sub71.R1 <= gdCal1[part][m_nMode1][CAL_REF_R][calIdx]) {     //sylee121006      //son220407
                        break;
                    }
                }

                // min 값 보다  작은 경우 
                //son calIdx가 range를 벗어난 경우 예외처리
                if (calIdx == 1)
                {
                    if (gdCal1[part][m_nMode1][CAL_REF_R][1] >= 0.0) {           //son220407
                        if (gdCal1[part][m_nMode1][CAL_REF_RAWR][1] <= 0.0) {     //son220407
                            Sub71.R1 = 0.0;
                        }
                        else {
                            if (gdCal1[part][m_nMode1][CAL_REF_R][1] != 0) {  //son220407
                                //----------------------
                                //son real R -> Raw R (ADC)
                                //son OpenOffset AD R =  (OpenOffeset R / Cal Ref R) * Cal Raw AD
                                Sub71.R1 = (Sub71.R1 / gdCal1[part][m_nMode1][CAL_REF_R][1]) * gdCal1[part][m_nMode1][CAL_REF_RAWR][1];  //son220407
                            }
                            else {
                                //error
                                str.Format("Error No 7222 ,   Divide by Zero. \n /gdCal1[part][m_nMode1][CAL_REF_R][1] \n Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                                MyTrace(PRT_BASIC, str);     //son221104_2
                                AfxMessageBox(str);
                            }
                        }

                    }
                }

                // max값 보다 큰 경우  
                //son calIdx가 range를 벗어난 경우 예외처리
                else if (calIdx == calCnt)
                {
                    if (gdCal1[part][m_nMode1][CAL_REF_R][calCnt] != 0) {    //son220407
                        //sylee121006    Sub71.R1= (Sub71.R1/gdCal1[part][m_nMode1][CAL_REF_R][calCnt]) *   gdCal1[part][m_nMode1][CAL_REF_RAWR][calCnt]; 
                        Sub71.R1 = gdCal1[part][m_nMode1][CAL_REF_RAWR][calCnt];  //son220407
                    }
                    else {
                        str.Format("Error No 7202 ,   Divide by Zero. \n  gdCal1[part][m_nMode1][CAL_REF_R][calCnt]   \n  Mode=%d  OnInit  Real R -> Raw R Converting Error   !       \n\n", m_nMode1);
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(str);
                    }
                }

                //--------------------------
                //son Real R -> Raw R (ADC)
                //son (Raw R / Ref Raw R)  는 (Real R / Ref Real R) 와 동일하므로
                //son Raw R =  (Real R Gap / Ref Real R Gap) * Ref Raw R Gap
                else
                {
                    if ((gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx] - gdCal1[part][m_nMode1][CAL_REF_R][calIdx - 1]) != 0.0)    //son220407
                    {
                        aa = (Sub71.R1 - gdCal1[part][m_nMode1][CAL_REF_R][calIdx - 1]) 
                                / (gdCal1[part][m_nMode1][CAL_REF_R][calIdx] - gdCal1[part][m_nMode1][CAL_REF_R][calIdx - 1]);  

                            // [3]= lookup table Calibration Raw R    //son220407 3:CAL_REF_RAWR
                        ab = gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx] - gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx - 1];   //son Cal Raw AD Gap  //son220407

                        Sub71.R1 = ab * aa + gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx - 1];     //son220407
                    }
                    else {
                        Sub71.R1 = (Sub71.R1 / gdCal1[part][m_nMode1][CAL_REF_R][calIdx - 1]) * gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx - 1];     //son220407
                    }
                }

                //---------------------------------------------
                //son nProStep1[testType][2]: Raw R값 저장 !!
                //---------------------------------------------
                nProStep1[testType][2] = (double)Sub71.R1;
                if (nProStep1[testType][2] < 0) {
                    str.Format("Error No 7117. !  \n \n nProStep1 step  testType=%d,   \n\n   nProStep1[testType][2]< 0     error      ", testType);
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(str, MB_OK); //error messege
                }

                // hdpark220715 begin Add Leak Cal Offset
                if (testType == TEST_HR_SHORT)
                {
                    if (calIdx > 26)    // 10MOhm 이상
                    {
                        double dDiffer = gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx - 1] - gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx];
                        double dValidOffset = dDiffer * 0.3;    // 30 %

                        int n10Percent = (int)(Sub71.R1 * 0.10);
                        int n5Percent = (int)(Sub71.R1 * 0.05);

                        if (n10Percent > dValidOffset)
                        {
                            n10Percent = (int)(dValidOffset + 0.5);
                            n5Percent = (int)(n10Percent / 2.0);
                        }

                        g_nProRv2[testType] = (int)Sub71.R1;// + n10Percent;  // Cal 허용 편차 10 % 적용
                        g_nProRv3[testType] = (int)Sub71.R1;// + n5Percent;  // Cal 허용 편차  5 % 적용
                    }
                    else
                    {
                        g_nProRv2[testType] = Sub71.R1;
                        g_nProRv3[testType] = Sub71.R1;
                    }
                }
                else if (testType == TEST_LEAK1 || testType == TEST_LEAK2)
                {
                    if (calIdx > 12)    // 10MOhm 이상
                    {
                        double dDiffer = gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx - 1] - gdCal1[part][m_nMode1][CAL_REF_RAWR][calIdx];
                        double dValidOffset = dDiffer * 0.3;    // 30 %

                        int n10Percent = (int)(Sub71.R1 * 0.10);
                        int n5Percent = (int)(Sub71.R1 * 0.05);

                        if (n10Percent > dValidOffset)
                        {
                            n10Percent = (int)(dValidOffset + 0.5);
                            n5Percent = (int)(n10Percent / 2.0);
                        }

                        g_nProRv2[testType] = (int)Sub71.R1;// + n10Percent;  // Cal 허용 편차 10 % 적용
                        g_nProRv3[testType] = (int)Sub71.R1;// + n5Percent;  //Cal 허용 편차  5 % 적용
                    }
                    else
                    {
                        g_nProRv2[testType] = Sub71.R1;
                        g_nProRv3[testType] = Sub71.R1;
                    }
                }
                // hdpark220715 end
            }
            else {   //error 경우 ??????????????                     
                str.Format("Error No 7117. !  \n \n Recipe  testType=%d,   \n\n Calibration Mode No=%d, \n\n or (R VALUE(%.2f) >0)? calCnt=%d    ",
                    testType, nMod1, Sub71.R1, calCnt);         //son220712 Sub71.R1, calCnt 출력 추가
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str, MB_OK); //error messege
                //  AfxMessageBox(" Error No 7101 !   Oninit   ", MB_OK); //error messege                    
            }



            if (testType == TEST_OPEN) {//sylee170814-1    JUNG DIRECTOR
                int nCalNo;
                double dCalNoR;

                nCalNo = (int)nProStep1[TEST_OPEN][3];
                dCalNoR = 100;
                //RCalCovert( nCalNo,  dCalNoR , 2 );  
                RCalCovert(nCalNo, dCalNoR, REAL_TO_RAW, PART_UPPER);  //son220412 
                nProRv1_O = (int)Sub71.R1; //sylee170814-1
                if (nProRv1_O < 100) {
                    nProRv1_O = 100;
                }

            }
        }//     if( nMod1>0 && nMod1<=75)


    }// for( int testType=1; testType<=5; testType++)




    int n4WRecNo, nEndNo1, nEnd4W_No;

    n4WRecNo = 0;
    nEndNo1 = 4;

    if (SysSet13.m_n4WCVMode == 1) {//sylee200515-patch
        nEnd4W_No = 179;//sylee200515-patch
    }
    else {
        nEnd4W_No = 177;//sylee200515-patch
    }

    if (nEndNo1 > 0)
    {
        for (int ik1 = 171; ik1 <= nEnd4W_No; ik1++) {//SYLEE140729 //sylee200515-patch
            n4WRecNo = ik1;
            nRet = FileSysInfo01.LoadSaveSer13(_LOAD, n4WRecNo, PART_MIXED); //son220412
            if (nRet != 1) {
                str.Format("ERRor NO 7012,   \n   4w Calibration file reading Error , \n   Mode no= %d  ", n4WRecNo);
                AfxMessageBox(str);
                return;
            }
        }
    }


    int nVSet1;

    if (SysInfo05.m_nOpenV == 3) {//sylee130724
        nVSet1 = 20;
    }
    else {
        nVSet1 = 10;
    }


    int nHvSel1;//sylee140923-1
    nHvSel1 = 0; //sylee140923-1
    n4WEnableRun = 0;//sylee20120305
    for (int k = 1; k <= TEST_4W; k++)      //son231020 7: TEST_4W
    {
        m = SysInfo05.m_nStep[k];//open=1, ushort=2, short=3, hr=4, hv1=5,  hv2=6,  4w=7

        if (m == TEST_4W) {//sylee140923    //son231020 7:TEST_4W
            //son Recipe step 중에 4W 가 있다고 표시
            n4WEnableRun = 1;//sylee20120305
            FileSysInfo01.LoadSaveSub17(_LOAD);
        }
        if (nHvSel1 == 0) {//sylee140923-1
            if (m == TEST_LEAK1) {           //son231020 5: TEST_LEAK1
                nHvSel1 = 2;//sylee140923-1
            }
            if (m == TEST_LEAK2) {           //son231020 6: TEST_LEAK2
                nHvSel1 = 3;//sylee140923-1
            }
        } //sylee140923-1        
    }



    if (SysSet13.m_nSet11 == 1) {//SYLEE180131
        if (nVbSet[4] > 200) {//sylee180110-3
            nVbSet[4] = 200;
        }
    }

    if (nHvSel1 == 3) {//sylee140923-1
        g_VSet1 = nVSet1;
        g_VSet2 = (int)dRec[(int)nProStep1[TEST_U_SHORT][3]][3];
        g_VSet3 = (int)dRec[(int)nProStep1[TEST_LEAK2][3]][3];
        g_VSet4 = nVbSet[4];//sylee130430
    }
    else {//sylee140923-1
        g_VSet1 = nVSet1;
        g_VSet2 = (int)dRec[(int)nProStep1[TEST_U_SHORT][3]][3];
        g_VSet3 = (int)dRec[(int)nProStep1[TEST_LEAK1][3]][3];
        g_VSet4 = nVbSet[4];//sylee130430
    }//sylee140923-1

    g_VSet3_Fisrt = g_VSet3; //sylee140923-1
    g_VSet3_old = g_VSet3; //sylee140923-1
    A_Run101Init2(g_VSet1, g_VSet2, g_VSet3, g_VSet4);  //sylee140923-1


    //---------------------
    //son RECIPE.TXT 출력
    //----------------------

    FILE* fpRecipeTxt; //sylee161101-1  //son240905_3 fp7 -> fpRecipeTxt
    char* fName7;//sylee161101-1
    int  nRecipeTxtFile_Enable;//sylee161101-1
    fName7 = "Z:\\RECIPE.TXT";//sylee161101-1

    nRecipeTxtFile_Enable = 0;//sylee161101-1
    fpRecipeTxt = fopen(fName7, "wt");//sylee161101-1  //son240905_3
    if (fpRecipeTxt == NULL) {//sylee161101-1  //son240905_3
        AfxMessageBox(" ERROR 7301  file make error . Z:\\RECIPE.TXT   ", MB_OK | MB_ICONSTOP);
    }
    else {
        nRecipeTxtFile_Enable = 1;//sylee161101-1
    }



#ifdef __SIMTECH__CUSTOMER         
    CTime  curTime = CTime::GetCurrentTime();
    CString strDateTime;

    //son220425 Simmtech는 RECIPE.TXT에 날짜 추가 요청 
    fprintf(fpRecipeTxt, "%d-%02d-%02d  %02d:%02d:%02d\n",  //son240905_3
        curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
        curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
#endif
    //-----------------------------------------------
    //son step[1] (보통 OPEN) Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[1];   //son 1: Open, 2: uShort (LV), 3: Short (LV), 4: HR Short (LV),  5: Leak1 (HV), 6: Leak2 (HV), 7: *4W 
                               //son TEST_TYPE 참고

    strT1.Format("");
    m2 = 0;

    if (m > 0) {
        str.Format("%s", szStep1[m]);               //son  szStep1[1]: "OPEN"
        m_Label1003.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);           //son szStep1[11]: "xxx V" 
        m_Label10.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);           //son szStep1[21]: "xxxx ohm / xx mA "
        m_Label3.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;
    }
    else {
        str.Format("");
        m_Label1003.SetCaption(str);
        m_Label10.SetCaption(str);
        m_Label3.SetCaption(str);
        str.Format("*Open Skip? -> "); strT1 += str;
    }

    //-------------------------------------
    //son step[2]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[2];
    str.Format(" / "); strT1 += str;

    if (m > 0) {

        str.Format("%s", szStep1[m]);                   //son szStep1[1]: "OPEN" 
        m_Label1015.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);              //son szStep1[11]: "xxx V"
        m_Label601.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);              //son szStep1[21]: "xxxx ohm / xx mA "
        m_Label12.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;
    }
    else {
        str.Format("");
        m_Label1015.SetCaption(str);
        m_Label601.SetCaption(str);
        m_Label12.SetCaption(str);

        str.Format("*LShort Skip? -> "); strT1 += str;
    }


    //-------------------------------------
    //son step[3]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[3];

    str.Format(" / "); strT1 += str;

    if (m > 0) {

        str.Format("%s", szStep1[m]);                   //son szStep1[1]: "OPEN"
        m_Label1031.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);              //son szStep1[11]: "xxx V"
        m_Label602.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);              //son szStep1[21]: "xxxx ohm / xx mA "
        m_Label23.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;
    }
    else {
        str.Format("");
        m_Label1031.SetCaption(str);
        m_Label602.SetCaption(str);
        m_Label23.SetCaption(str);
        str.Format("*Leak Skip? -> "); strT1 += str;
    }


    //-------------------------------------
    //son step[4]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[4];

    //son200312-4WDUT16
    int n4WTotalPin;
    int    dutIdx = get4wDutIdx();         // g_s4WNet의 index. 0부터 시작함.  //son190704-4WDUT16
    n4WTotalPin = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16



    if (m > 0) {

        str.Format(" / "); strT1 += str;

        str.Format("%s", szStep1[m]);                   //son szStep1[7]: "4W"
        m_Label1032.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);              //son szStep1[17]: "xxx V"
        m_Label604.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);              //son szStep1[27]: "xxxx ohm / xx mA "
        m_Label32.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;

    }
    else {
        str.Format("");
        m_Label1032.SetCaption(str);
        m_Label604.SetCaption(str);
        m_Label32.SetCaption(str);

        if (n4WTotalPin > 0) {
            str.Format(" / "); strT1 += str;
            str.Format(" *4W Skip? -> "); strT1 += str;
        }
    }

    //-------------------------------------
    //son step[5]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[5];

    if (m > 0) {

        if (m2 > 0) {
            str.Format(" / "); strT1 += str;
        }

        str.Format("%s", szStep1[m]);                   //son szStep1[1]: "OPEN" 
        m_Label1004.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);              //son szStep1[11]: "xxx V"
        m_Label2.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);              //son szStep1[21]:"xxxx ohm / xx mA "
        m_Label4.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;
    }
    else {
        str.Format("");
        m_Label1004.SetCaption(str);
        m_Label2.SetCaption(str);
        m_Label4.SetCaption(str);
    }

    //-------------------------------------
    //son step[6]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[6];

    if (m > 0) {
        if (m2 > 0) {
            str.Format(" / "); strT1 += str;
        }
        str.Format("%s", szStep1[m]);                   //son szStep1[1] : "OPEN"
        m_Label131.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[10 + m]);              //son szStep1[11]: "xxx V"    
        m_Label132.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        str.Format("%s", szStep1[20 + m]);              //son szStep1[21]: "xxxx ohm / xx mA "
        m_Label133.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
        m2 = m;

        if (nRecipeTxtFile_Enable == 1) { //sylee161101-1
            fprintf(fpRecipeTxt, "%s\n", strT1);//sylee161101-1  //son240905_3
        }

    }
    else {
        str.Format("");
        m_Label131.SetCaption(str);
        m_Label132.SetCaption(str);
        m_Label133.SetCaption(str);
    }

    //-------------------------------------
    //son step[7]   Recipe 영역 출력
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    m = SysInfo05.m_nStep[7];

    if (m > 0) {
        if (m2 > 0) {
            str.Format(" / "); strT1 += str;
        }
        str.Format("%s", szStep1[m]);                 //son szStep1[1]: "OPEN"
        m_Label134.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;

        str.Format("%s", szStep1[10 + m]);            //son szStep1[11]: "xxx V"
        m_Label135.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;

        str.Format("%s", szStep1[20 + m]);            //son szStep1[21]: "xxx ohm / xxx mA" 
        m_Label136.SetCaption(str);
        strT1 += str; str.Format(" "); strT1 += str;
    }
    else {
        str.Format("");
        m_Label134.SetCaption(str);
        m_Label135.SetCaption(str);
        m_Label136.SetCaption(str);
    }

    if (nRecipeTxtFile_Enable == 1) //sylee161101-1
    {
        CString strtmp[8];
        CString strT2;
        int no;

        strT2 = strT1;
        fprintf(fpRecipeTxt, " ");//sylee161101-1   //son240905_3

        for (int i7 = 1; i7 <= 7; i7++)  //sylee150308  4->5
        {
            no = strT2.Find('/');
            strtmp[i7] = strT2.Left(no);
            strT2 = strT2.Mid(no + 1);
            if (no < 1) {
                strtmp[i7] = strT2;  //son  '/'를 제외하고 '/' 앞의 str을 strtmp[i7]에 담는다.
            }

#if 0    //son240905_2  SysSet13.m_nSet1 == 1 ((전류세분화 설정) 시에 Leak mA 두번 출력되는 문제 때문에 삭제. 
         //  위쪽의 son240905_2 표시된 코드를 보면 Label 출력용 szStep1[20 + m]에  이미 mA 출력을 하고 있다. 여기서 추가할 필요 없음.

            //son Current 20mA , 10mA, 5mA (전류세분화 설정 기능) enable이면
            if (SysSet13.m_nSet1 == 1)
            {

                //son220907 전류 세분화 기능 정식 제공시에는 이 코드는 삭제 필요.
                //          A_OnInit()에서 szStep1[20 +m] 에 이미 ohm/mA 로 mA 정보가 포함될 예정임. GTS, 나노시스,리노정밀은 이미 그렇게 제공
                //son220913#if ( (defined(__GTS__CUSTOMER) && !defined(__MST__CUSTOMER)) 
#if (defined(__GTS__CUSTOMER )  || defined(__NANOSYS__CUSTOMER))       //son220915_2

#else
                if (strtmp[i7][1] == 'L' && strtmp[i7][2] == 'E' && strtmp[i7][3] == 'A' && strtmp[i7][4] == 'K')
                {
                    //son LEAK1 이면
                    if (strtmp[i7][5] == '1') {
                        if (SysInfo05.m_nLeak1_Current == 2) {      //son220706
                            fprintf(fpRecipeTxt, "%s10mA\n", strtmp[i7]);  //son240905_3
                        }
                        else {
                            fprintf(fpRecipeTxt, "%s20mA\n", strtmp[i7]);  //son240905_3
                        }
                    }

                    //son LEAK2 이면
                    else if (strtmp[i7][5] == '2') {
                        if (SysInfo05.m_nLeak2_Current == 2) {    //son220706
                            fprintf(fpRecipeTxt, "%s10mA\n", strtmp[i7]);  //son240905_3
                        }
                        else {
                            fprintf(fpRecipeTxt, "%s20mA\n", strtmp[i7]);  //son240905_3
                        }
                    }
                    else {
                        fprintf(fpRecipeTxt, "%s\n", strtmp[i7]);//sylee181005-3  //son240905_3
                    }
                }
                else
#endif
                {
                    fprintf(fpRecipeTxt, "%s\n", strtmp[i7]);//sylee181005-3  //son240905_3
                }

            }
            else 
#endif
            {//sylee181005-3
                fprintf(fpRecipeTxt, "%s\n", strtmp[i7]);//sylee161101-1   //son240905_3
            }
            if (no < 1) {
                break;
            }
        }

        if (SysInfo05.m_nSp == 1) {//sylee170725
            fprintf(fpRecipeTxt, " Spark ON\n");  //son240905_3
            fprintf(fpRecipeTxt, " Spark %dV\n", (SysInfo05).m_nSparkSet);  //son240905_3
        }
        else {//sylee170725 
            fprintf(fpRecipeTxt, " Spark OFF\n");  //son240905_3
        }//sylee170725

        if(SysInfo05.m_nConFail>0){//sylee240418
           fprintf(fpRecipeTxt, " ConFail Cnt %d\n", (SysInfo05).m_nConFail);  //son240905_3
		}else{
		   fprintf(fpRecipeTxt, " ConFail Cnt 0\n" );  //son240905_3
		}



//======================================================================================

		nRecipe_4W_Use=0;
        for (int step = 1; step <= TEST_4W; step++)    //son231020 7:TEST_4W             
        {               
            if (SysInfo05.m_nStep[step] == TEST_4W) {  
                nRecipe_4W_Use=1;
				break;
            }
		}

        //------------------------------------------------
        //son 4W Set Limit 설정 룰  RECIPE.TXT에 출력
		if(nRecipe_4W_Use==1)
		{
			FileSysInfo01.LoadSaveSub18(_LOADLOW);    //sylee230522 SST 이진봉부장요청으로 추가 
			FileSysInfo01.LoadSaveSub18(_LOADHIGH);   //sylee230522
			fprintf(fpRecipeTxt, "===== 4W SET Ref. Limit Condition ======,\n"); //sylee230522  //son240905_3
			fprintf(fpRecipeTxt, "NO.,Start mohm, Finish mohm, -%, -mohm,\n");   //sylee230522  //son240905_3
			for(int i=1; i<= MAX_LIMIT4W_RNG; i++)                       //sylee230522     
			{
				if( (gd4W1_P1Low[i][1]>0) && (gd4W1_P1Low[i][2]>0) ){
					fprintf(fpRecipeTxt, "NO.%d,", i);  //son240905_3
					for(k=1; k<LIMIT4W_SIGMA_COEF; k++)       
					{
						if(gd4W1_P1Low[i][LIMIT4W_R_START]<=0){
							gd4W1_P1Low[i][LIMIT4W_R_START]=0;
							if(i!=1){	gd4W1_P1Low[i][k]=0;	}
						}
						if(gd4W1_P1Low[i][LIMIT4W_R_START]> MAX_4W_R){  
							gd4W1_P1Low[i][LIMIT4W_R_START]=0;		gd4W1_P1Low[i][k]=0;
						}
						if(k< LIMIT4W_SIGMA_COEF){ 
							fprintf(fpRecipeTxt, "  %d,", (int)gd4W1_P1Low[i][k] );     //son240905_3
						}else{
							fprintf(fpRecipeTxt, "  %2.1f,", gd4W1_P1Low[i][k] );    //son240905_3
						}
					} 
					fprintf(fpRecipeTxt, "  \n"  );  //son240905_3
				}		
			}
    
		//======================================================================================
			fprintf(fpRecipeTxt, "NO.,Start mohm,Finish mohm,+%,+mohm,Sigma,\n"); //sylee230522  //son240905_3
			for(i=1; i<=(MAX_LIMIT4W_RNG); i++)     //sylee230522
			{ 		
				if( (gd4W1_P2High[i][1]>0) && (gd4W1_P2High[i][2]>0) ){
					fprintf(fpRecipeTxt, "NO.%d,", i);			  //son240905_3
					for(k=1; k<= LIMIT4W_SIGMA_COEF; k++)
					{
						if(gd4W1_P2High[i][LIMIT4W_R_START]<=0){
							gd4W1_P2High[i][LIMIT4W_R_START]=0;
							if(i!=1){
								gd4W1_P2High[i][k]=0;
							}
						}
						if(gd4W1_P2High[i][LIMIT4W_R_START]> MAX_4W_R){ 
							gd4W1_P2High[i][LIMIT4W_R_START]=0;	gd4W1_P2High[i][k]=0;
						}
						if(k< LIMIT4W_SIGMA_COEF){ 
							fprintf(fpRecipeTxt, "  %d,", (int)gd4W1_P2High[i][k] );    //son240905_3
						}else{
							fprintf(fpRecipeTxt, "  %2.1f,", gd4W1_P2High[i][k] );   //son240905_3
						}
					}				
					fprintf(fpRecipeTxt, "  \n"  );  //son240905_3
				}
			}  
		}
		else{
            fprintf(fpRecipeTxt, " 4W NOT USE. \n"  );  //son240905_3

		}
 
	    //======================================================================================
  

        fclose(fpRecipeTxt);//sylee161101-1  //son240905_3
    }


    if (SysSet211.m_nSet26 != 1) {//sylee200919  OPEN R Meas.Logging
        strT1.Format(""); //sylee140415
    }

    m_Label112.SetCaption(strT1);   //son 왼쪽 상단 Recipe Label에 출력

    //=====================================================================
    nMCon2 = gRun05.m_nConIs;

    str.Format("%d", PinData[0][2]);
    m_Label6.SetCaption(str);  //test point?  
    str.Format("%d", SysInfo05.m_nConEr);
    m_Label7.SetCaption(str);  //error no ?
    str.Format("%d", SysInfo05.m_nIsEr);
    m_Label27.SetCaption(str);  //error no ?


    ::ZeroMemory(&szTemp, sizeof(szTemp));
    if (SysInfo20.m_nUse == 1) {
        strcat(szTemp, "OFF");
    }
    else if (SysInfo20.m_nUse == 2) {
        strcat(szTemp, "ON");
    }
    else {
        strcat(szTemp, "      ");
    }
    str.Format("%s", szTemp);
    m_Label9.SetCaption(str);   //auto count ?


//son240718    gRun05.m_nConEr = SysInfo05.m_nConEr;   //son240718 아래에 동일코드 있어서 삭제
//son240718    gRun05.m_nIsEr = SysInfo05.m_nIsEr;
//son240718    gRun05.m_nReCh = SysInfo05.m_nReCh;


    gRun05.m_nDelay1 = SysInfo05.m_nDelay1;// C USER SET
    str.Format("%d mS", SysInfo05.m_nDelay1);
    m_Label5.SetCaption(str);


    //son-32KPIN-20200212: nReSheetFlag1 값 추적을 위해 추가
    str.Format("%d", nReSheetFlag1);
    m_Label17.SetCaption(str);

    gRun05.m_nMs = SysInfo05.m_nMs;
    gRun05.m_nHv = SysInfo05.m_nHv;
    gRun05.m_nSp = SysInfo05.m_nSp;
    gRun05.m_nPr = SysInfo05.m_nPr;


    if (SysInfo05.m_nConEr < 1) {   //son240718 
        SysInfo05.m_nConEr = 1;     //son240718
    }                               //son240718
    if (SysInfo05.m_nIsEr < 1) {    //son240718
        SysInfo05.m_nIsEr = 1;      //son240718
    }                               //son240718
    gRun05.m_nConEr = SysInfo05.m_nConEr;
    gRun05.m_nIsEr = SysInfo05.m_nIsEr;
    gRun05.m_nConErSt = SysInfo05.m_nConErSt;
    gRun05.m_nReCh = SysInfo05.m_nReCh;

    gRun20.m_nPass = 0;
    gRun20.m_nOpen = 0;
    gRun20.m_nShort = 0;
    gRun20.m_nOpenShort = 0;
    gRun20.m_nFail = 0;
    gRun20.m_nTotle = 0;

    gRun21.m_nPass = 0;
    gRun21.m_nOpen = 0;
    gRun21.m_nShort = 0;
    gRun21.m_nOpenShort = 0;
    gRun21.m_nFail = 0;
    gRun21.m_nTotle = 0;

    //======================================
    str.Format("%d", nPinDa1H[1][2][0]);
    m_Label6.SetCaption(str);
    str.Format("%d", nPinDa1H[1][2][1]);
    m_Label18.SetCaption(str);
    str.Format("%d", nPinDa1H[1][2][2]);
    m_Label20.SetCaption(str);

#ifndef __AUTO_COUNT_DISPLAY_DISABLE__ //son220401    //sylee230125
    double dNum;   //son220401

    str.Format("%d", SysInfo20.m_nTotle);
    m_Label201.SetCaption(str);
    str.Format("%d", SysInfo20.m_nPass);
    m_Label202.SetCaption(str);
    str.Format("%d", SysInfo20.m_nFail);
    m_Label203.SetCaption(str);
    str.Format("%d", SysInfo20.m_nOpen);
    m_Label204.SetCaption(str);
    str.Format("%d", SysInfo20.m_nShort);
    m_Label205.SetCaption(str);
    str.Format("%d", SysInfo20.m_nOpenShort);
    m_Label206.SetCaption(str);

    if (SysInfo20.m_nTotle > 0) {
        dNum = SysInfo20.m_nPass * 100.0 / SysInfo20.m_nTotle;
        if (dNum > 100)dNum = 100;
    }
    str.Format("%2.2f", dNum);
    m_Label302.SetCaption(str);

    if (SysInfo20.m_nTotle > 0) {
        dNum = SysInfo20.m_nFail * 100.0 / SysInfo20.m_nTotle;
        if (dNum > 100)dNum = 100;
    }
    str.Format("%2.2f", dNum);
    m_Label303.SetCaption(str);
    if (SysInfo20.m_nTotle > 0) {
        dNum = SysInfo20.m_nOpen * 100.0 / SysInfo20.m_nTotle;
        if (dNum > 100)dNum = 100;
    }
    str.Format("%2.2f", dNum);
    m_Label304.SetCaption(str);
    if (SysInfo20.m_nTotle > 0) {
        dNum = SysInfo20.m_nShort * 100.0 / SysInfo20.m_nTotle;
        if (dNum > 100)dNum = 100;
    }
    str.Format("%2.2f", dNum);
    m_Label305.SetCaption(str);
    if (SysInfo20.m_nTotle > 0) {
        dNum = SysInfo20.m_nOpenShort * 100.0 / SysInfo20.m_nTotle;
        if (dNum > 100)dNum = 100;
    }
    str.Format("%2.2f", dNum);
    m_Label306.SetCaption(str);
#endif  //son220401

    //son SPARK Recipe 출력----------------
    ::ZeroMemory(&szTemp, sizeof(szTemp));
    if (SysInfo05.m_nSp == 0) {
        strcat(szTemp, "Off");
    }
    else    if (SysInfo05.m_nSp == 1) {

	// hdpark230504 spark
 //sylee241204   m_nUseACLeak = SysInfo05.m_nAC; //SysSet19.m_nSet14; 
	m_nSparkDetection[0] = SysInfo05.m_nSparkDetection[0];
	m_nSparkDetection[1] = SysInfo05.m_nSparkDetection[1];
	m_nSparkDetection[2] = SysInfo05.m_nSparkDetection[2];

#ifdef __AUTO_COUNT_DISPLAY_DISABLE__    //sylee230125
	#ifdef SPARK_CURRENT_DETECTION	
		switch(SysInfo05.m_nSparkCurrentSet)
		{
		case 0 : SysInfo05.m_dSparkCurrentSet = 1.0;	break;
		case 1 : SysInfo05.m_dSparkCurrentSet = 2.0;	break;
		case 2 : SysInfo05.m_dSparkCurrentSet = 4.0;	break;
		case 3 : SysInfo05.m_dSparkCurrentSet = 6.0;	break;
		case 4 : SysInfo05.m_dSparkCurrentSet = 10.0;	break;
		case 5 : SysInfo05.m_dSparkCurrentSet = 15.0;	break;
		case 6 : SysInfo05.m_dSparkCurrentSet = 20.0;	break;
		}
        str.Format("%3dV / %.0fmA", SysInfo05.m_nSparkSet, SysInfo05.m_dSparkCurrentSet);
	#else
        str.Format("%3dV", SysInfo05.m_nSparkSet);
	#endif
        strcat(szTemp, str);
#else
	#if defined(__YP_VIET_CUSTOMER) || defined(__SIMTECH__CUSTOMER)   //son220425 simmtech customer 추가
			//son210824: 베트남영풍 코드. Apple 검수 대비
			CString strTemp;
			strTemp.Format("ON %3dV", SysInfo05.m_nSparkSet);
			strcat(szTemp, strTemp);
	#else
			strcat(szTemp, "ON");
	#endif
#endif

    }
    else {
        strcat(szTemp, "      ");
    }
    str.Format("%s", szTemp);
    m_Label603.SetCaption(str);


    nBlockCountP = 0;

    DisplayNo();//sylee120901 

    ::ZeroMemory(&nOpenErrData, sizeof(nOpenErrData));//SYLEE130312JOYTECH
    ::ZeroMemory(&nOpenErrList, sizeof(nOpenErrList));//SYLEE130312JOYTECH
    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));//SYLEE130312JOYTECH


    //son Disable된 block-piece cell이 있다고 경고한다.
    if (SysInfo19.m_nCheck == 1) {//sylee131117
        AfxMessageBox(" *** > Piece disable set.    Auto Screen Check!   <***** ", MB_OK);
    }


    if (SysInfo19.m_nCellX != SysInfoBlock.m_nBlock) {//SYLEE131121
        str.Format(" ERROR NO 2101, \n        ,\n  \n\n Setting value Check!.\n\n   [Block Set] block count=%d,   [Piece Disable]  block count=%d \n\n ", SysInfoBlock.m_nBlock, SysInfo19.m_nCellX);
        AfxMessageBox(str, MB_OK);
    }

    if (SysInfo19.m_nCellY != SysInfoPiece.m_nPiece) {//SYLEE131121
        str.Format(" ERROR NO 2101, \n        ,\n  \n\n   Setting value Check!.\n\n    [Piece Set] piece count=%d,   [Piece Disable]  piece count=%d \n\n ", SysInfoPiece.m_nPiece, SysInfo19.m_nCellY);
        AfxMessageBox(str, MB_OK);
    }


    AHV_EST1_SET1();//estimation//sylee130219-joytech 


    int nBlockMaxX, nBlockMaxY, nPieceMaxX, nPieceMaxY;
    int nBlockTotal, nPieceTotal;
    int nRow/*ka1*/, nCol/*ka2*/, nCell;//nCell=Cellno
    int nBlock/*nn1*/, nPiece/*nn2*/;

    nBlockMaxX = SysInfoBlock.m_nCol;
    nBlockMaxY = SysInfoBlock.m_nRow;
    nPieceMaxX = SysInfoPiece.m_nCol;
    nPieceMaxY = SysInfoPiece.m_nRow;
    nBlockTotal = nBlockMaxX * nBlockMaxY;
    nPieceTotal = nPieceMaxX * nPieceMaxY;

    nBlockMaxXTotal = nBlockMaxX * nPieceMaxX - SysInfoPiece.m_nColDel;  ///*******
    nBlockMaxYTotal = nBlockMaxY * nPieceMaxY - SysInfoPiece.m_nRowDel;  ///*******




    for (nCell = 1; nCell <= (nBlockTotal * nPieceTotal); nCell++)
    {
        nRow = ((nCell - 1) / (nBlockMaxXTotal));//몫    //SYLEE120901 
        nCol = nCell - (nBlockMaxXTotal * nRow);//나머지 //SYLEE120901
        nRow = nRow + 1;

        //son row, col에 맞는 block, piece를 찾아낸다.
        nBlock = nDisCell1[nRow][nCol][0];//block
        nPiece = nDisCell1[nRow][nCol][1];//piece

        if (nBlock > SysInfoBlock.m_nBlock)     //son220823_2 begin:
        {
            str.Format(" Error 7601!, BDL File Check! \n\nEngeneer Call! nCell(%d)'s nBlock(%d) is over SysInfoBlock.m_nBlock(%d)\n",
                nCell, nBlock, SysInfoBlock.m_nBlock);
            AfxMessageBox(str);
            MyTrace(PRT_BASIC, str);
        }
        if (nPiece > SysInfoPiece.m_nPiece)
        {
            str.Format(" Error 7602!, BDL File Check! \n\nEngeneer Call! nCell(%d)'s nPiece(%d) is over SysInfoBlock.m_nPiece(%d)\n",
                nCell, nPiece, SysInfoPiece.m_nPiece);
            AfxMessageBox(str);
            MyTrace(PRT_BASIC, str);
        }  //son220823_2 end

        nBlockPieceNo1[nBlock][nPiece] = nCell;//X1=BLOCK , Y1 =PIECE = CELL
    }


    nEstEnableHv = 1;//estimation //sylee150407
    nEstEnableHr = 0;

    str.Format("%d", nMultyNetTotal);//SYLEE150817  //SYLEE150920 
    m_Label21.SetCaption(str);//SYLEE150817


    int tmp1;


    nFlag_Open_SetStart = 0;
    nFlag_HV_SetEnd = 0;


    for (int k1 = 1; k1 <= 7; k1++) {  //sylee150427    
        tmp1 = (int)(SysInfo05.m_nStep[k1]);   //open, ushort, short, hr, hv 
        if (tmp1 > 0) {
            if (tmp1 == 1) {
                nFlag_Open_SetStart = k1;
            }
            break;
        }
    }

    for (int k2 = 7; k2 > 0; k2--) {  //sylee150427      
        tmp1 = SysInfo05.m_nStep[k2];   //open, ushort, short, hr, hv 
        if (tmp1 > 0) {
            if (tmp1 == 5) {
                nFlag_HV_SetEnd = k2;
            }
            break;
        }
    }

    //sylee150426-5
    ///////////////////////////////////////////////////////////////////////////////////////////

    //son 4w Sampling 관련 데이터 초기화
    ::ZeroMemory(&d4W_Log2, sizeof(d4W_Log2));//sylee150812-1
    ::ZeroMemory(&d4W_Log3, sizeof(d4W_Log3));//sylee150812-1
    ::ZeroMemory(&d4W_Log5, sizeof(d4W_Log5));//sylee150812-1
    ::ZeroMemory(&n4w_Sample_RunCount, sizeof(n4w_Sample_RunCount));    //son200320-4WDUT16
    ::ZeroMemory(&n4w_Sample_SheetCount, sizeof(n4w_Sample_SheetCount));      //son211112 sample 시트 개수(불량인 경우도 포함) 
                                                                             //           n4w_Sample_RunCount는 양품만 카운트
    ::ZeroMemory(&g_4wSampling, sizeof(g_4wSampling));      //son211112 BarCode, step정보 4W_Setup_A.txt 출력기능
    n4w_Sample_Old = -1;//sylee150812-1
    nMulNetFlag = 1;
    str.Format("%d", nMulNetFlag);
    m_Label8.SetCaption(str);//SYLEE150817


    FileSysInfo01.LoadSaveSet211(2);//load 
    A_Language();


    if (SysSet13.m_nSet20 == 1) {//sylee170411 shin bu sung
        str.Format(" Engineer Mode! ");
    }
    else {

        str.Format(" ACE400 ");
#ifdef __ACE550__
        str.Format(" ACE550 ");
#elif defined __ACE500__
        str.Format(" ACE500 ");
#elif defined __ACE1000__
        str.Format(" ACE1000 ");
#endif

    }

	
if( SysSet19.m_nSet14  == 1) { //sylee240119 
	str.Format("*QC Leak ADCLog");
}

    m_Label501.SetCaption(str);


    OnButton2002();  //sylee170808-2

//  if(SysSet211.m_nSet22!=1){//disable
    m_Label115.SetCaption("  ");
    ::ZeroMemory(&nErrPinDisO, sizeof(nErrPinDisO));
    ::ZeroMemory(&nErrPinDisS, sizeof(nErrPinDisS));
    ::ZeroMemory(&nErrPin1O, sizeof(nErrPin1O));
    ::ZeroMemory(&nErrPin1S, sizeof(nErrPin1S));
    ::ZeroMemory(&nErrPin1S0, sizeof(nErrPin1S0));
    ::ZeroMemory(&nErrPin1O2, sizeof(nErrPin1O2));
    ::ZeroMemory(&nErrPin1S2, sizeof(nErrPin1S2));
    //  }

    //son Block 정보를 업데이트한다.
    DisplayBlock_Map1();

    ::ZeroMemory(&g_nSkipPieceTemp, sizeof(g_nSkipPieceTemp));//sylee160203-ITS  //sylee180528      //son220624
    ::ZeroMemory(&g_nSkipPieceInfo, sizeof(g_nSkipPieceInfo));//sylee160203-ITS  //sylee180528      //son220624


    //son "C:\\ACE400\\SETUP2\\SysSetPin.ini"를 struct CSysSet12에 Load(type=2) 또는 Save(type=1) 
    FileSysInfo01.LoadSaveSet12(2);//load  //SYLEE180724-1


    if (SysSet12.m_nPinTotMax == PIN_TOT_4K) {//4k  //SYLEE180724-1      1:PIN_TOT_4K
        nHalfPin1 = 2048;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_8K) {//8k     2:PIN_TOT_8K
        nHalfPin1 = 4096;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_16K) {//16k    3:PIN_TOT_16K
        nHalfPin1 = 4096 * 2;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_32K_TRANS) {//32k    4:PIN_TOT_32K_TRANS //son230216_1
        nHalfPin1 = 4096 * 4;
    }
    else {//32k
        nHalfPin1 = 4096 * 4;
    }
    Sub71.R1 = 8000000;//sylee181005-1    
    RCalCovert(MODE207_HR_SHORT_10V, Sub71.R1, REAL_TO_RAW, PART_UPPER);  //sylee181005-1  //son220412  
    nLvModelRealR = (int)Sub71.R1; //sylee181005-1

    if (nLvModelRealR < 280) nLvModelRealR = 280;
    if (nLvModelRealR > 3000) nLvModelRealR = 3000; //sylee181005-1

/*//SYLEE210429
    if(SysSet13.m_nSet9==1){//sylee181215-2
        if(nSelf1_RunEnable!=2){
          OnSelfTr1_Flag_Step1=3;//sylee181117
        }
        OnSelfTr1_Flag_Run1=0;//sylee181117
        OnSelfTr1_Set_File1(2);//sylee181117
        OnSelfTr1_Run_File2(2);//sylee181117
    }
*/
    OnSelfTr1_Stop1 = 0;//sylee190103-1

//////////////////////////////////////
    double dSet1;//sylee200916
    int nNo1;
    dSet1 = 20000000.0;//20M  
    nNo1 = (int)nProStep1[5][3];
    nLeakDischarge1AD1 = (int)RCalCovert(nNo1, dSet1, REAL_TO_RAW, PART_UPPER);     //son220412
    nNo1 = (int)nProStep1[6][3];
    nLeakDischarge1AD2 = (int)RCalCovert(nNo1, dSet1, REAL_TO_RAW, PART_UPPER);     //son220412
//////////////////////////////////////////////////////////////////////

    if (SysSet211.m_nSet26 == 1) {
        nFlagOpenMes1 = 1;//SYLEE210309-1  1=USE
    }
    else {
        nFlagOpenMes1 = 0;//SYLEE210309-1  1=USE
    }
    OpenMes1Step = 0; //SYLEE210309-1  1~200
    OpenMes1StepT = 0;
    ::ZeroMemory(&OpenMes1, sizeof(OpenMes1));//SYLEE210309-1
	//==============================
//sylee230420
 	int n4W_R1[6][100];//sylee221222
	double d4W_V[6][100];//sylee221222
	int mode;
	double dV1;

    ::ZeroMemory(&n4W_R1, sizeof(n4W_R1));
    ::ZeroMemory(&d4W_V, sizeof(d4W_V));

 	if( SysSet13.m_n4WCVMode==0){	 	 mode=171; 
	}else{		 mode=176; 	}

	 FileSysInfo01.LoadSaveSer13(_LOAD, mode , PART_UPPER);
     FileSysInfo01.LoadSaveSer13(_LOAD, mode+1, PART_UPPER);

 	int nModeStep2;
	for( int nModeStep=1; nModeStep<=5 ; nModeStep++){//sylee230128
		if(SysSet19.m_n4WHVon==1){ 	 
			nModeStep2=160+nModeStep;
			if( SysSet13.m_n4WCVMode==1){  	nModeStep2=nModeStep2+5;     }//sylee230221-1	
		}else{		               
			nModeStep2=170+nModeStep; 
			if( SysSet13.m_n4WCVMode==1){  	nModeStep2=nModeStep2+5;   	}//sylee230221-1
		}		
		
		if(nModeStep2==170 || nModeStep2==180 ){	continue;		}
         FileSysInfo01.LoadSaveSer13(_LOAD, nModeStep2 , PART_UPPER);
	}
 
	gn4W_Mode1_RangeADC1=0; 	gn4W_Mode1_RangeADC2=0;//sylee230124  
    gn4W_Mode1_RangeADC1= SysInfoSer13.m_nData[0][mode][3][6] ; //SYLEE230228 
	if(gn4W_Mode1_RangeADC1<=0){gn4W_Mode1_RangeADC1=100;} 
	gn4W_Mode1_RangeADC2=(SysInfoSer13.m_nData[0][mode][3][6]-SysInfoSer13.m_nData[0][mode][3][5])/10.;  //SYLEE230228   0.5mohm

    if(gn4W_Mode1_RangeADC2<=0){gn4W_Mode1_RangeADC2=30;} 
    dV1=(SysInfoSer13.m_nData[PART_UPPER][mode][3][6]-SysInfoSer13.m_nData[PART_UPPER][mode][4][5])
        /(SysInfoSer13.m_nData[PART_UPPER][mode][2][6]-SysInfoSer13.m_nData[PART_UPPER][mode][2][5]);

    if(SysSet16.m_nSet7>0){    d4WADCPer1=  dV1* (SysSet16.m_nSet7/100.) ;	    //SYLEE230117  
    }else{		              d4WADCPer1=0.1;	   } 

    dV1=(SysInfoSer13.m_nData[PART_UPPER][mode][4][9]-SysInfoSer13.m_nData[PART_UPPER][mode][4][8])
        /(SysInfoSer13.m_nData[PART_UPPER][mode][2][9]-SysInfoSer13.m_nData[PART_UPPER][mode][2][8]);
    if(SysSet16.m_nSet21>0){       
        d4WADCPer2=   (SysSet16.m_nSet21*0.01)  ;
    }else{	
        d4WADCPer2=0.1;	
    }

    if(SysSet16.m_nSet8>0){ 
        d4WADCPer3=(SysSet16.m_nSet8*0.01);  
    }else{		
        d4WADCPer3=0.1;
    }


    int nEnd;

    if(nRecipe_4W_Use==1){//sylee230523
        FileSysInfo01.LoadSaveSub17(2);//sylee230214-1
        dutIdx = get4wDutIdx(); 
        nEnd = (int)g_s4WNet[dutIdx].wCount;
        dutIdx = get4wDutIdx(); 
        nEnd = (int)g_s4WNet[dutIdx].wCount;
        for (  int Net1=1;  Net1<=nEnd;  Net1++) {
            d4W_Data1[Net1]=g_s4WNet[dutIdx].saData[Net1 - 1].dRefAvg;
        }
        nFlag_d4W_Data1=1; 
    }

    ::ZeroMemory(&d4W_Data1, sizeof(d4W_Data1)); 
    n4W_Data_Use1=0;
 

    nLeak1ADC_100M=0; 
    nCalNo1 = nProStep1[TEST_LEAK1][3];
    if(nCalNo1>=300){
        RCalCovert(nCalNo1, 100000000   , REAL_TO_RAW, 0);//sylee230822
        nLeak1ADC_100M=Sub71.R1;
        if(nLeak1ADC_100M>1000){nLeak1ADC_100M=0;}
    }
    nLeak2ADC_100M=0; 
    nCalNo1 = nProStep1[TEST_LEAK2][3];
    if(nCalNo1>=300){
        RCalCovert(nCalNo1, 100000000   , REAL_TO_RAW, 0);//sylee230822
        nLeak2ADC_100M=Sub71.R1;
        if(nLeak2ADC_100M>1000){nLeak2ADC_100M=0;}
    }


    //=============================================================================================

}



int CChildView7::ContinueFailCheck()
{

    FILE* fp;
    CString Str, str, str1;
    char fName[200];
    int nRunType, nRunCondition, ik2;
    int nFailCount;

    nFailCount = 0;
    nSelfOpenPinCount = 0;    //sylee141020                          
    ::ZeroMemory(&nSelfOpenPin, sizeof(nSelfOpenPin));  //sylee141020 

    if (SysInfo05.m_nConFail > 1) {//sylee141016
        nRunType = 2;
        nRunCondition = SysInfo05.m_nConFail;
    }
    else {
        //sylee141020 
        nRunType = 0;
        // nRunType=2;
        nRunCondition = 3;
    }
    ::ZeroMemory(&nConFail, sizeof(nConFail));

    if (nRunType == 2) {//sylee141016
        ::ZeroMemory(&fName, sizeof(fName));
        Str.Format("d:\\ERROR_CONTINUEFAIL.TXT");
        strcat(fName, Str);
    }

    nAutoContinueFail2w = 0;


    //=====================================================================
    //open//sylee140516
    //continue fail  2w 

    if (nFailL1CoOpen > 0) {
        nConFailOpen[0][0] = nFailL1CoOpen;
        for (int i = 1; i <= nFailL1CoOpen; i++) {
            nConFailOpen[i][1] = (int)nFailL1Open[i][F_VB_PIN];// pin1    //son220419_4 4:F_VB_PIN
            nConFailOpen[i][2] = (int)nFailL1Open[i][F_VC_PIN];// pin2    //son220419_4 5:F_VC_PIN
            nConFailOpen[i][3] = 1;//발생 횟수 
        }

        if (nConFailoldOpen[0][0] > 0) {
            for (i = 1; i <= nFailL1CoOpen; i++) {
                for (int j = 1; j <= nConFailoldOpen[0][0]; j++) {
                    if ((nConFailOpen[i][1] == nConFailoldOpen[j][1]) && (nConFailOpen[i][2] == nConFailoldOpen[j][2])) {
                        nConFailOpen[i][3] = nConFailoldOpen[j][3] + 1;//발생 횟수 
                        j = nConFailoldOpen[0][0] + 1;
                    }
                }
            }
        }

        ////////////////////////////////////////////////////////////
        nConFailoldOpen[0][0] = nConFailOpen[0][0];
        for (i = 1; i <= nFailL1CoOpen; i++) {
            nConFailoldOpen[i][1] = nConFailOpen[i][1];// pin1
            nConFailoldOpen[i][2] = nConFailOpen[i][2];// pin2
            nConFailoldOpen[i][3] = nConFailOpen[i][3];// 발생횟수 

            if (nConFailOpen[i][3] >= nRunCondition) {
                nAutoContinueFail2w = 1;
                nConFailoldOpen[i][3] = 0;// 발생횟수 

                /////////////////////////////////////////////////////////////////
                int tmp1, tmp2, tmp3;
                if (nSelfOpenPinCount <= 200) { //sylee141020
                    // tmp1=nConFail[i][1];// pin1
                    // tmp2=nConFail[i][2];// pin2
                    tmp1 = nConFailOpen[i][1];// pin1
                    tmp2 = nConFailOpen[i][2];// pin1
                    tmp3 = 0;
                    for (ik2 = 1; ik2 < nSelfOpenPinCount; ik2++) {
                        if (nSelfOpenPin[ik2] == tmp1) {
                            tmp3 = 1;
                        } //sylee141020 
                    }

                    if (tmp3 == 0) {
                        nSelfOpenPinCount++;//sylee141020   
                        nSelfOpenPin[nSelfOpenPinCount] = tmp1;
                    }
                    tmp3 = 0;
                    for (ik2 = 1; ik2 < nSelfOpenPinCount; ik2++) {
                        if (nSelfOpenPin[ik2] == tmp2) {
                            tmp3 = 1;
                        } //sylee141020 
                    }

                    if (tmp3 == 0) {
                        nSelfOpenPinCount++;
                        nSelfOpenPin[nSelfOpenPinCount] = tmp2;
                    }
                }//sylee141020 

                /////////////////////////////////////////////////////////////////
            }
        }


        nSelfOpenPin[0] = nSelfOpenPinCount;//sylee141020 


        if (nRunType == 2) {//sylee141016 
            if (nAutoContinueFail2w == 1) {
                fp = fopen(fName, "wt");
                if (fp == NULL) {
                    Str.Format("Error No7302 !  \n \n\n  d:\\AUTO\\ERROR_CONFAIL.TXT     file open?    \n\n  Saving Error !     file close!   ");
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(Str, MB_OK); //error messege          
                    MyTrace(PRT_BASIC, str);    //son220804_4
                    return 0;
                }
                CTime curTime = CTime::GetCurrentTime();
                //  fprintf(fp, "<Continue Fail Error List  2W >\n\n   "  );
                fprintf(fp, "<continue fail pin alarm >\n\n   ");
                //  fprintf(fp, "#MakeDate:, Year%04d:,Month%02d:,Day%02d,%02dH:%02dM:%02dS, \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
                fprintf(fp, " %04d:,Month%02d:,Day%02d,%02dH:%02dM:%02dS, \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

                for (i = 1; i <= nFailL1CoOpen; i++) {
                    if (nConFailOpen[i][3] >= nRunCondition) {
                        fprintf(fp, " * Pin1=%d: Pin2=%d:\n", nConFailOpen[i][1], nConFailOpen[i][2]);
                    }
                }
                str.Format(" ***>  ContinueFail Error !  ");
                m_list1.AddString(str);//
                nlist1++;
                MyTrace(PRT_BASIC, str);    //son220804_4

                nFailCount = 2;

            }

        }


    }
    else {
        //all reset 
        ::ZeroMemory(&nConFailoldOpen, sizeof(nConFailoldOpen));
    }


    //=====================================================================
    //SHORT


    if (nFailL1Co > 0) {
        nConFail[0][0] = nFailL1Co;
        for (int i = 1; i <= nFailL1Co; i++) {
            nConFail[i][1] = (int)nFailL1[i][F_VB_PIN];// pin1 //son220419_4 4:F_VB_PIN
            nConFail[i][2] = (int)nFailL1[i][F_VC_PIN];// pin2 //son220419_4 5:F_VC_PIN
            nConFail[i][3] = 1;//발생 횟수 
        }


        ////////////////////////////////////////////////////////////
        //비교 
        if (nConFailold[0][0] > 0) {
            for (i = 1; i <= nFailL1Co; i++) {
                for (int j = 1; j <= nConFailold[0][0]; j++) {
                    if ((nConFail[i][1] == nConFailold[j][1]) && (nConFail[i][2] == nConFailold[j][2])) {
                        nConFail[i][3] = nConFailold[j][3] + 1;//발생 횟수 
                        j = nConFailold[0][0] + 1;
                    }
                }
            }
        }
        ////////////////////////////////////////////////////////////
        nConFailold[0][0] = nConFail[0][0];
        for (i = 1; i <= nFailL1Co; i++) {
            nConFailold[i][1] = nConFail[i][1];// pin1
            nConFailold[i][2] = nConFail[i][2];// pin2
            nConFailold[i][3] = nConFail[i][3];// 발생횟수 
            if (nConFail[i][3] >= nRunCondition) {

                /////////////////////////////////////////////////////////////////
                int tmp1, tmp2, tmp3;
                if (nSelfOpenPinCount <= 200) { //sylee141020
                    tmp1 = nConFail[i][1];// pin1
                    tmp2 = nConFail[i][2];// pin2
                    tmp3 = 0;
                    for (ik2 = 1; ik2 < nSelfOpenPinCount; ik2++) {
                        if (nSelfOpenPin[ik2] == tmp1) {
                            tmp3 = 1;
                        } //sylee141020 
                    }
                    if (tmp3 == 0) {
                        nSelfOpenPinCount++;//sylee141020   
                        nSelfOpenPin[nSelfOpenPinCount] = tmp1;
                    }
                    tmp3 = 0;
                    for (ik2 = 1; ik2 < nSelfOpenPinCount; ik2++) {
                        if (nSelfOpenPin[ik2] == tmp2) {
                            tmp3 = 1;
                        } //sylee141020 
                    }
                    if (tmp3 == 0) {
                        nSelfOpenPinCount++;
                        nSelfOpenPin[nSelfOpenPinCount] = tmp2;
                    }
                }//sylee141020 

                /////////////////////////////////////////////////////////////////


                nAutoContinueFail2w = 1;
                nConFailold[i][3] = 0;// 발생횟수 
            }
        }


        nSelfOpenPin[0] = nSelfOpenPinCount;//sylee141020 


        if (nRunType == 2) {//sylee141016 
            if (nAutoContinueFail2w == 1) {
                fp = fopen(fName, "wt");
                if (fp == NULL) {
                    Str.Format("Error No7302 !  \n \n\n  d:\\AUTO\\ERROR_CONFAIL.TXT     file open?    \n\n  Saving Error !     file close!   ");
                    MyTrace(PRT_BASIC, str);     //son221104_2
                    AfxMessageBox(Str, MB_OK); //error messege          
                    return 0;
                }
                CTime curTime = CTime::GetCurrentTime();
                //fprintf(fp, "<Continue Fail Error List  2W >\n\n   "  );
                fprintf(fp, "< continue fail pin alarm >\n\n   ");
                //  fprintf(fp, "#MakeDate:, Year%04d:,Month%02d:,Day%02d,%02dH:%02dM:%02dS, \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
                fprintf(fp, "#   %04d / %02d/  %02d  -   %02d : %02d : %02d , \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

                for (i = 1; i <= nFailL1Co; i++) {
                    if (nConFail[i][3] >= nRunCondition) {
                        fprintf(fp, " * Pin1=%d: Pin2=%d:\n", nConFail[i][1], nConFail[i][2]);
                    }
                }

                str.Format(" ***>  ContinueFail Error !  ");
                m_list1.AddString(str);//
                nlist1++;
                MyTrace(PRT_BASIC, str);    //son220804_4

                nFailCount = 2;

            }

        }


    }
    else {
        //all reset 
        ::ZeroMemory(&nConFailold, sizeof(nConFailold));
    }



    ::ZeroMemory(&nConFail4w, sizeof(nConFail4w));
    nAutoContinueFail4w = 0;

    if (g_n4WFailCount > 0) {
        nConFail4w[0][0] = g_n4WFailCount;
        for (int i = 1; i <= g_n4WFailCount; i++) {
            nConFail4w[i][1] = (int)n4WFail1[i][1];// pin1
            nConFail4w[i][2] = (int)n4WFail1[i][2];// pin2                      
            nConFail4w[i][3] = (int)n4WFail1[i][3];// pin1
            nConFail4w[i][4] = (int)n4WFail1[i][4];// pin2
            nConFail4w[i][5] = 1;//발생 횟수
        }

        if (nConFailold4w[0][0] > 0) {
            for (i = 1; i <= g_n4WFailCount; i++) {
                for (int j = 1; j <= nConFailold4w[0][0]; j++) {
                    if ((nConFail4w[i][1] == nConFailold4w[j][1]) && (nConFail4w[i][2] == nConFailold4w[j][2]) && (nConFail4w[i][3] == nConFailold4w[j][3]) && (nConFail4w[i][4] == nConFailold4w[j][4])) {
                        nConFail4w[i][5] = nConFailold4w[j][5] + 1;//발생 횟수 
                        j = nConFailold4w[0][0] + 1;
                    }
                }
            }
        }


        ////////////////////////////////////////////////////////////
        nConFailold4w[0][0] = nConFail4w[0][0];
        for (i = 1; i <= g_n4WFailCount; i++) {
            nConFailold4w[i][1] = nConFail4w[i][1];// pin1
            nConFailold4w[i][2] = nConFail4w[i][2];// pin2
            nConFailold4w[i][3] = nConFail4w[i][3];// pin3
            nConFailold4w[i][4] = nConFail4w[i][4];// pin4
            nConFailold4w[i][5] = nConFail4w[i][5];// 발생횟수 
            if (nConFail4w[i][5] >= nRunCondition) {
                nAutoContinueFail4w = 1;
                nConFailold4w[i][5] = 0;// 발생횟수 
            }
        }


        if (nRunType == 2) {//sylee141016 
            if (nAutoContinueFail4w == 1) {
                if (nAutoContinueFail2w != 1) {
                    fp = fopen(fName, "wt");
                    if (fp == NULL) {
                        Str.Format("Error No7303 !  \n \n\n  d:\\AUTO\\ERRORCONFAIL4W.TXT     file open?    \n\n  Saving Error !     file close!   ");
                        MyTrace(PRT_BASIC, str);     //son221104_2
                        AfxMessageBox(Str, MB_OK); //error messege          
                        return 0;
                    }

                    CTime curTime = CTime::GetCurrentTime();
                    //  fprintf(fp, "<Continue Fail Error List  4W >\n\n   "  );
                    fprintf(fp, "< 4W  continue error pin list  >\n\n   ");
                    //  fprintf(fp, "#MakeDate:, Year%04d:,Month%02d:,Day%02d,%02dH:%02dM:%02dS, \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
                    fprintf(fp, "#   %04d /  %02d /  %02d  -  %02d: %02d: %02d  , \n\n\n", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

                }
                for (i = 1; i <= g_n4WFailCount; i++) {
                    if (nConFail4w[i][5] >= nRunCondition) {
                        fprintf(fp, " *ContinueFail 4W=> Pin1=%.0f,: Pin2=%.0f,: Pin3=%.0f,: Pin4=%.0f,:\n", n4WFail1[i][1], n4WFail1[i][2], n4WFail1[i][3], n4WFail1[i][4]);

                    }
                }

                str.Format(" ***>  ContinueFail 4W Error !  ");
                m_list1.AddString(str);//
                nlist1++;
                MyTrace(PRT_BASIC, str);    //son220804_4
                nFailCount = 2;

            }
        }


    }
    else {
        //all reset 
        ::ZeroMemory(&nConFailold4w, sizeof(nConFailold4w));
    }

    if (nAutoContinueFail2w == 1 || nAutoContinueFail4w == 1) {
        nAutoContinueFail = 1;
        if (nRunType == 2) {//sylee141016 
            fclose(fp);
            CTime curTime = CTime::GetCurrentTime();
            str1.Format("d:\\CONTFAIL.TXT", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
            fileCopy(str1, fName);
            ::ShellExecute(NULL, "open", "notepad.EXE", Str, "NULL", SW_SHOWNORMAL);
        }
    }
    else {
        nAutoContinueFail = 0;
    }

    if (nFailCount == 2) {
        ::ZeroMemory(&nConFailoldOpen, sizeof(nConFailoldOpen));//sylee170725-1
        ::ZeroMemory(&nConFail, sizeof(nConFail));//sylee170725-1
        ::ZeroMemory(&nConFailold, sizeof(nConFailold));//sylee170725-1
        ::ZeroMemory(&nConFailOpen, sizeof(nConFailOpen));//sylee170725-1
        ::ZeroMemory(&nConFail4w, sizeof(nConFail4w));//sylee170725-1
        ::ZeroMemory(&nConFailold4w, sizeof(nConFailold4w));//sylee170725-1
    }

    return 1;

}



int  CChildView7::AHV_ADCI_Read1(double nProRv1) //sylee120919 
{

    int delay_time;
    long TimeT1;
    double nOldAdc1, diff1;

    nOldAdc1 = 0;
    delay_time = 10000;//1ms
    diff1 = 0;
    TimeT1 = 100000;
    Sub71.Delay_100ns(10000); //1ms

    //son 5000번 반복.
    for (int nK1 = 1; nK1 < 5000; nK1++) {
        Sub71.AOnReadV1I1_ADC_I();


        if (nK1 == 1) {
            nOldAdc1 = Sub71.R1;
        }
        else {
            diff1 = (double)abs((int)(nOldAdc1 - Sub71.R1));
            nOldAdc1 = Sub71.R1;
        }

        if (((diff1 >= 0 && diff1 < 5) && (Sub71.R1 < (nProRv1))) || (Sub71.R1 < (nProRv1))) {
            break;
        }

        if (TimeT1 > 3000000) {//sylee121005   5sec->0.3sec   //sylee121024   1sec->0.3   
            break;
        }
        Sub71.Delay_100ns(delay_time); //1ms
        TimeT1 = TimeT1 + delay_time;

    }

    return 1;

}


int  CChildView7::AHV_ADCI_Read1_OneToM(double nProRv1, double nTimeOutSet1, int nntype) //sylee121120
{
    if (nShort_Flag1 == __LV) {//1:__LV  2:__HV  //sylee201205
        ALV_ADCI_Read1_Avg1(nProRv1, nTimeOutSet1, nntype);  //sylee121120new
    }
    //son __HV case
    else { 
		if(	(nLeakADCFlag1==2)  &&  (nntype==4) ){//sylee230814-1  <300Mohm  //sylee230907
			AHV_ADCI_Read1_Avg2(); //sylee230811 //sylee230907
		}else{   		 
		   	AHV_ADCI_Read1_Avg1(nProRv1, nTimeOutSet1, nntype);  //sylee121120new			 
		}
    } 
    return 1;
}


int  CChildView7::AHV_ADCI_Read1_OneToM(double nProRv1, double nTimeOutSet1) //sylee121120
{
    int nntype = 1;
    if (nShort_Flag1 == __LV) {//1:__LV  2:__HV  //sylee201205
        ALV_ADCI_Read1_Avg1(nProRv1, nTimeOutSet1, nntype);  //sylee121120new
    }
    //son __HV case
    else {       
		AHV_ADCI_Read1_Avg1(nProRv1, nTimeOutSet1, nntype);  //sylee121120new		
	//  AHV_ADCI_Read1_Avg2(); //sylee230811 
    }
    return 1;
}


int  CChildView7::AHV_ADCI_Read1_Wait1(double nProRv1, double nTimeOutSet1) //sylee121016
{
    int delay_time;
    long TimeT1;
    double nOldAdc1, diff1;
    __int64   tStart1, tStart2, tStart3;

    nOldAdc1 = 0;
    diff1 = 0;
    TimeT1 = 0;
    delay_time = 1000;//us 
    nTimeOutSet1 = 3000000;  //300mS    //sylee121022
    //nTimeOutSet1=15000000;  //1.5S    //sylee121019   

    Sub71.Delay_100ns(delay_time); //200us
    TimeT1 = delay_time;

    tStart1 = GetuSecond();
    Sub71.AOnReadV1I1_ADC_I();
    tStart2 = GetuSecond();
    tStart3 = (tStart2 - tStart1) * 10;
    TimeT1 = TimeT1 + (long)(tStart3);

    for (int nK1 = 1; nK1 < 500000; nK1++) {
        Sub71.AOnReadV1I1_ADC_I();
        TimeT1 = TimeT1 + (long)(tStart3);
        if (nK1 == 1) {
            nOldAdc1 = Sub71.R1;
        }
        else {
            diff1 = (double)(nOldAdc1 - Sub71.R1);
            if (diff1 <= 0) diff1 = -diff1;
            nOldAdc1 = Sub71.R1;
        }
        if (Sub71.R1 < 10) {//sylee201117
            Sub71.R1 = 99999;
        }
        if (((diff1 >= 0 && diff1 < 10) && (Sub71.R1 < nProRv1))) {
            break;
        }
        if (TimeT1 > nTimeOutSet1) {//sylee121005   5sec->1.5sec 
            break;
        }
        if ((TimeT1 > 800000) && (Sub71.R1 > 10000)) {//sylee121028   80msec 
            break;
        }
        Sub71.Delay_100ns(delay_time); //1ms
        TimeT1 = TimeT1 + delay_time;
    }
    return 1;
}






int  CChildView7::ALV_ADCI_Read1_OneToM(double nProRv1, double nTimeOutSet1) //sylee121018
{

    int delay_time;
    long TimeT1;
    double nOldAdc1, diff1;
    __int64   tStart1, tStart2, tStart3;
    int nDataShift;//sylee140917

    nDataShift = 0;//sylee140917 

    nOldAdc1 = 0;
    diff1 = 0;
    TimeT1 = 0;
    delay_time = 500;//50us 
    nTimeOutSet1 = nTimeOutSet1 * 3;  ////sylee140922 

    if (nTimeOutSet1 < 100) {
        nTimeOutSet1 = 5000000;
    }
    //sylee121016 Sub71.Delay_100ns(100000 ); //10ms
    Sub71.Delay_100ns(delay_time); //50us
    TimeT1 = delay_time;

    tStart1 = GetuSecond();
    Sub71.AOnReadV1I1_ADC_I();
    tStart2 = GetuSecond();
    tStart3 = (tStart2 - tStart1) * 10;
    TimeT1 = TimeT1 + (long)(tStart3);



    //son 5000번 반복.
    for (int nK1 = 1; nK1 < 5000; nK1++) {


        Sub71.AOnReadV1I1_ADC_I();
        TimeT1 = TimeT1 + (long)(tStart3);

        if (nK1 == 1) {
            nOldAdc1 = Sub71.R1;
        }
        else {
            diff1 = (double)abs((int)(nOldAdc1 - Sub71.R1));
            nOldAdc1 = Sub71.R1;
        }

        if (((diff1 > 0 && diff1 < 5) && (Sub71.R1 < (nProRv1))) || (Sub71.R1 < (nProRv1))) {//sylee140823 AND
            Sub71.AOnReadV1I1_ADC_I();
        }

        if (((diff1 > 0 && diff1 < 5) && (Sub71.R1 < (nProRv1))) || (Sub71.R1 < (nProRv1))) {
            // if(nDataShift>0){//sylee140917  //SYLEE140918 2->0
            break;
            //}
        }

        if (nK1 < 5) {
            Sub71.Delay_100ns(delay_time * 2);
            TimeT1 = TimeT1 + delay_time * 2;
        }


        if (TimeT1 > nTimeOutSet1) {//sylee121005   1.5sec->0.5sec   150mS
            Sub71.R1 = 50000;
		    //son240628 Sub71.R1 = 65000;  //sylee240517  //son240628 BH 고정 Short 문제 때문에 sylee240517 원상복구
		    
            break;
        }
        Sub71.Delay_100ns(delay_time); //1ms
        TimeT1 = TimeT1 + delay_time;
    }

    return 1;

}



int  CChildView7::AHV_ADCI_Read1_LV1(double nProRv1, int nCase) //sylee120921
{
    int delay_time;
    long TimeT1;
    double nOldAdc1, diff1;

    nOldAdc1 = 0;
    delay_time = 5000;  //10mS ->500us
    diff1 = 0;
    TimeT1 = 0;



    if (nCase == 1)
    {
        Sub71.Delay_100ns(delay_time);


        for (int nK1 = 1; nK1 < 5000; nK1++) //500mS
        {

            TimeT1 = TimeT1 + delay_time;

            Sub71.AOnReadV1I1(nVRel);   //if( nVRel==1 || nVRel==2  || nVRel==3 || nVRel==4)
            if (nIR == 1 || nIR == 2) {
                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
            }
            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
            }

            if (nK1 == 1) {
                nOldAdc1 = Sub71.R1;
            }
            else {
                diff1 = (double)abs((int)(nOldAdc1 - Sub71.R1));
                nOldAdc1 = Sub71.R1;
            }
            if ((nK1 > 2 && (diff1 >= 0 && (diff1 < (nOldAdc1 * 0.2))) && (Sub71.R1 > nProRv1)) || (Sub71.R1 > nProRv1)) {
                break;
            }
            else if (Sub71.R1 < (nProRv1 * 0.8)) {
                delay_time = int(delay_time * 2);
                TimeT1 = TimeT1 + (long)(delay_time * 2);
            }
            else {
                delay_time = nK1 * 10000;
                TimeT1 = TimeT1 + nK1 * 10000;
            }
            if (nK1 < 10) {
                Sub71.Delay_100ns(delay_time);
                TimeT1 = TimeT1 + delay_time;
            }


            //  if(nK1>500 && Sub71.R1>20000 ){//50mS
            //      break;
            //  }

            if (TimeT1 > 20000000) {//sylee120918  0.1sec ->2s
                break;
            }
        }

    }
    else if (nCase == 2)
    {


        delay_time = 1000;  //100us
        TimeT1 = 0;

        for (int nK1 = 1; nK1 < 500; nK1++) //500mS
        {

            Sub71.Delay_100ns(delay_time);
            TimeT1 = TimeT1 + delay_time;


            Sub71.AOnReadV1I1(nVRel);   //if( nVRel==1 || nVRel==2  || nVRel==3 || nVRel==4)


            if (nIR == 1 || nIR == 2) {
                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
            }
            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
            }


            if (nK1 == 1) {
                nOldAdc1 = Sub71.R1;
            }
            else {
                diff1 = (double)abs((int)(nOldAdc1 - Sub71.R1));
                nOldAdc1 = Sub71.R1;
            }
            if ((nK1 > 2 && (diff1 > 0 && (diff1 < (nOldAdc1 * 0.1))) && (Sub71.R1 > nProRv1)) || (Sub71.R1 > nProRv1))
            {
                break;
            }
            else if (Sub71.R1 < (nProRv1 * 0.8))
            {
                delay_time = int(delay_time * 2);
                TimeT1 = TimeT1 + (long)(delay_time * 2);
            }
            else {
                delay_time = nK1 * 1000;
                TimeT1 = TimeT1 + nK1 * 1000;
            }
            if (nK1 < 5) {
                Sub71.Delay_100ns(delay_time);
                TimeT1 = TimeT1 + delay_time;
            }


            if (TimeT1 > 500000) {//sylee120918  0.1sec ->   50ms==>100mS
                break;
            }

        }

    }

    return 1;

}





//son 왼쪽상단 'Cycle Time' 제목 라벨을 현재 TEST_MODE로 교체한다. 
int CChildView7::DisplayStatus_TestMode(int nMode) //SYLEE120925 //son220824
{

    CString str;

    nDisplayFlag1 = nMode;

    if (nMode == 0) {
    }
    else if (nMode == TEST_4W) {    //son220824
        str.Format(" %d 4W  ",nRunStep100); //sylee231016      
    }
    else if (nMode == TEST_OPEN) {  //son220824
        str.Format("%d OPEN ",nRunStep100);   //sylee231016      
    }
    else if (nMode == TEST_U_SHORT) {    //son220824
        str.Format("%d U Short",nRunStep100);  //sylee231016     
    }
    else if (nMode == TEST_SHORT) {  //son220824
        str.Format("%d LV Short",nRunStep100); //sylee231016     
    }
    else if (nMode == TEST_HR_SHORT) { //son220824
        str.Format("%d HR Short",nRunStep100); //sylee231016     
    }
    else if (nMode == TEST_LEAK1) { //son220824
        str.Format("%d HV1 ",nRunStep100);   //sylee231016     
    }
    else if (nMode == TEST_LEAK2) {//SYLEE140923
        str.Format("%d HV2  ",nRunStep100);    //sylee231016         
    }
    else if (nMode == 31) {
        str.Format("Cycle Time   ");
    }

 
    DoEvents();    DoEvents(); //sylee231016     

    if (nMode != 0) {
        m_Label301.SetCaption(str);
        if (nMode < 20) {
            DoEvents();
        }
    }

    return 1;


}




//son    nMod1      0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV)
//                  5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W
//son  m_nMode1     Calibration Mode
//son  nProRv1      raw RValue
//son  nPStep1      현재 test 진행 step 
//son  nProType     1:multi piece,  2:one piece
//
//son  return       0: HW error   1: Pass 
int CChildView7::ARun201_S2_SQ2_HV_Re_VB(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
{
    // hdpark230105 spark begin
#ifdef SPARK_VB_READ
    memset(Sub71.m_tINFO, 0, sizeof(PIN_INFO) * MAX_TRIG_COUNT);
    Sub71.m_bSetVBRead = FALSE;
    Sub71.m_bVBReadMode = TRUE;
    Sub71.m_dForceCurrent = dRec[m_nMode1][5];

    Sub71.SendCmdToDigitizer(__LINE__, 0, SPARK_BEGIN);
#endif  
    // hdpark230105 spark end

	// hdpark230331 begin
#ifdef SPARK_CURRENT_DETECTION
	if      (nMod1 == TEST_LEAK1)	
	    Sub71.m_nSparkDetection = SysInfo05.m_nSparkDetection[1];
	else if (nMod1 == TEST_LEAK2)	
	    Sub71.m_nSparkDetection = SysInfo05.m_nSparkDetection[2];

    if (Sub71.m_nSparkDetection == 1)    // hdpark231121, current detection
    {
        g_nSparkWaitingEnable = 2;
    }
    else
    {
        g_nSparkWaitingEnable = 0;
    }
#else
	Sub71.m_nSparkDetection = SysInfo05.m_nSparkDetection[0];
#endif
	// hdpark230331 end

    // hdpark230105 spark begin
/*
    // spark 측정시 사용할 cal 값의 min / max 값 취득
    double dMaxSparkValue = 0.0;
    double dMinSparkValue = 250.0;
    int nMaxSparkValueCnt = 0;
    for(int RList=1;RList<=21;RList++)
    {
        if(gdCal1[PART_SPARK][m_nMode1][CAL_REF_RAWR][RList] <= 0.0)	continue;

        if(RList < 5)	// 10 ohm
        {
            //if(dMaxSparkValue < gdCal1[PART_SPARK][m_nMode1][CAL_REF_RAWR][RList])
            {
                dMaxSparkValue += gdCal1[PART_SPARK][m_nMode1][CAL_REF_RAWR][RList];
                nMaxSparkValueCnt++;
            }
        }

        if(dMinSparkValue > gdCal1[PART_SPARK][m_nMode1][CAL_REF_RAWR][RList])
        {
            dMinSparkValue = gdCal1[PART_SPARK][m_nMode1][CAL_REF_RAWR][RList]; //최소값
        }
    }
    double dCalRatio = 1.0; // 16K,  cal data로 추정
    Sub71.m_dSparkCalRatio = dCalRatio;
    Sub71.m_dMaxSparkValue = (double)(dMaxSparkValue / nMaxSparkValueCnt) * dCalRatio; // spark current 환산을 위한 ref value
    Sub71.m_dMinSparkValue = dMinSparkValue;
 */
 // hdpark230105 spark end


  //sylee201226  if(   (nProOneP_Flag1==2||nProOneP_Flag1==3) && (g_nPieceMax1Disable==0) && (nReSheetFlag1 !=1) && (  nAutoReTest[nBlockCountP]==0  ||  nManualStartFlag==1 )  && (nShortFail1Flag1==0) && ( SysInfo05.m_nShortDisable1!=7) ){//sylee200814//sylee201029
    if ((g_nSkipPieceFlag1 != 1) && (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)      //son220624
        && (g_nPieceMax1Disable == 0) && (nReSheetFlag1 != 1)
        && (nAutoReTest[nBlockCountP] == 0 || nManualStartFlag == 1)
        && (nShortFail1Flag1 == 0) && (SysInfo05.m_nShortDisable1 != 7))//sylee200814//sylee201029  //sylee201226
    {
        //son Leak One piece 통검사
        ARun201_S2_SQ2_HV_N1(nMod1, m_nMode1, nProRv1, nPStep1, nProType); //sylee200814

        if (nSpark_NetFailCheck1 == 1) {//sylee200814
//sylee241204  if (m_nUseACLeak)           //hdpark230323
//sylee241204  {
//sylee241204     ARun201_S2_SQ2_HV_Re_VB1_AC(nMod1, m_nMode1, nProRv1, nPStep1, 1); //sylee200814
//sylee241204  }   else {
                // son 개별 piece 별 Leak 검사 
                ARun201_S2_SQ2_HV_Re_VB1(nMod1, m_nMode1, nProRv1, nPStep1, 1); //sylee200814
//sylee241204  }
        }
    }
    else {
  //sylee241204     if (m_nUseACLeak)           //hdpark230323
  //sylee241204     {
  //sylee241204          ARun201_S2_SQ2_HV_Re_VB1_AC(nMod1, m_nMode1, nProRv1, nPStep1, 1); //sylee200814
  //sylee241204     }  else  {
	 
            ARun201_S2_SQ2_HV_Re_VB1(nMod1, m_nMode1, nProRv1, nPStep1, nProType);
  //sylee241204    }
    }

    Sub71.SendCmdToDigitizer(__LINE__, 0, SPARK_END);   //hdpark230504


#ifndef DEF_CARD_A1  //sylee220725

    /*  hdpark230105 spark
        // hdpark220511 spark begin
        // 고속 AD에서 받은 데이터로 결과를 산출하여 기존 변수에 Overwrite 한다.
        // 고속 AD 데이터가 없으면 기존과 동일하게 동작한다.
        if (Sub71.m_bModifySparkMeas)
        {
            Ixud_WriteDOBit(0, 5, 2, 0);    //VB Out 초기화
            CMainFrame* pMain = (CMainFrame*)AfxGetMainWnd();

            double dVBGain = 1.5;
            double dVBOffset = 1.3;
            int nSetLeakVoltIndex = (int)(dSparkLeakSet1_V / 50) - 1;

            for (int nTrg = 0; nTrg < MAX_TRIG_COUNT; nTrg++)
            {
                if (Sub71.m_tINFO[nTrg].nHWSparkOn)
                {
                    if (pMain->m_tInfoRcv[nTrg].nADSparkOn)
                    {
                        int nFail1Co = Sub71.m_tINFO[nTrg].nFailCol;

                        double dLowSparkVolt = pMain->m_tInfoRcv[nTrg].dVoltage[0];
                        double dSparkCurrent = pMain->m_tInfoRcv[nTrg].dCurrent[0];
                        double dSparkVBRead = pMain->m_tInfoRcv[nTrg].dCurrent[0];

                        srand((unsigned int)time(NULL));
                        double dRandValue = rand() % 5;
                        dRandValue /= 10;

                        int nRandValue = dRandValue;
                        int nSign = 1;
                        if (nRandValue % 2) nSign = -1;

                        double dRealSparkVBRead = (dSparkVBRead / ((dVBGain * nSetLeakVoltIndex) + dVBOffset)) * dSparkLeakSet1_V;

                        double dRealLowSparkVolt = 1.0;
                        double dHighSparkVolt = 0.0;

                        if (!Sub71.m_bVBReadMode)
                        {
                            dHighSparkVolt = (30 * dLowSparkVolt);
                            //dRealLowSparkVolt = (dHighSparkVolt * 0.25) + (dRandValue * nSign);   // 25%, when not read vb drop volt
                            dRealLowSparkVolt = (dHighSparkVolt * 0.25);
                            if (dRealLowSparkVolt > 10) dRandValue = rand() % (int)(dRealLowSparkVolt * 0.10);
                            dRealLowSparkVolt += dRandValue;
                            dHighSparkVolt += dRealLowSparkVolt;
                        }
                        else
                        {
                            //dRealLowSparkVolt = (dSparkLeakSet1_V - dRealSparkVBRead) + (dRandValue * nSign);
                            dRealLowSparkVolt = (dSparkLeakSet1_V - dRealSparkVBRead);
                            if (dRealLowSparkVolt > 10) dRandValue = rand() % (int)(dRealLowSparkVolt * 0.10);
                            dRealLowSparkVolt += dRandValue;
                            dHighSparkVolt = (30 * dLowSparkVolt) + dRealLowSparkVolt; // guess from scope graph & optimize
                        }

                        if (dHighSparkVolt > dSparkLeakSet1_V)  dHighSparkVolt = (dSparkLeakSet1_V * 0.95) + ((rand() % (int)dSparkLeakSet1_V) * 0.05);
                        nFailL1[nFail1Co][13] = dHighSparkVolt;


                        if (dRealLowSparkVolt >= dSparkLeakSet1_V)  dRealLowSparkVolt = (dSparkLeakSet1_V * 0.95) + ((rand() % (int)dSparkLeakSet1_V) * 0.05);
                        else if (dRealLowSparkVolt < 1.0)           dRealLowSparkVolt = 1.0;

                        nFailL1[nFail1Co][12] = dRealLowSparkVolt;
                    }
                }
            }

            Sub71.SendCmdToDigitizer(__LINE__, 0, SPARK_END);
        }
        //hdpark220511 spark end
    */
#endif// #ifndef DEF_CARD_A1  //sylee220725

    return 1;

}


//sylee200814//sylee200910add

//son    nMod1      0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV)
//                  5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W
//son  m_nMode1     Calibration Mode
//son  nProRv1      raw RValue
//son  nPStep1      현재 test 진행 step 
//son  nProType     1:multi piece,  2:one piece
//
//son  return       0: HW error   1: Pass 
int CChildView7::ARun201_S2_SQ2_HV_N1(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
{

    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];
    int i, ik, j, n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1, nHVIADCFlag, nDischargeCount, nShRes1T;
    int ih, logno1, nSQCount1, nSQLastY1, nSQLastPin, tp1, t1;
    int nFailFlag1, nFailFlag2, nFailFlag3, nFailFlag4, nRetry1;

    int nSQ1Fail[200], nSh1Ret1[100], dPinVC[200], dPinVB[200];

    //son210401  100 -> MAX_SQUARE_N(200)  : Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
    int nSQNet1[MAX_SQUARE_N][MAX_SQUARE_N];// pin array//sylee120908
    int nSparkset;

    double nISet, dVbR1, dVbR2, InterI;
    double nT[10];
    double nData[130][15], dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200];

    int nMSet1Flag, nMSet1Co, nMSet1CoT2, nSQStep1flag;
    int nIFilter, nHVOffSet, nHVGain, nDelayTime2, nIControl, tmp1, tmp2, Co, nHVTimeOutSet;
    int nPin1[1000], nPin2[1000];

    int nEstUse, nEt_StepSumTemp, ret1, nSparkUse, nErrorDelayTime1;
    int nProRv2, nProRv3, nProRv0, nErrorDelayFlag1, nErrorDelayTime2;//sylee141002 
    int nIGain, nErrorDelay1;//sylee150610 kushan


    int nDebug11;       //son 처음검사  (Y 방향)
    int nDebug12;       //son 두번째 검사
    int nDebug13, nDebug14, nDebug15, nDebug16;//sylee170618-test1 debugcode
    int nDebug21;       //son 처음검사 (X 방향)
    int nDebug22, nDebug23, nDebug24, nDebug25, nDebug26;//sylee170618-test1 debugcode

    short nSparkFailNo[Def_SwitchMaxPin];//sylee200714 NEW_SPARK
    int  nSparkTmp;
    int nPieceMaxN1;//sylee200814 //sylee200911-1
	int nK1Start;


   if (nMod1 == TEST_LEAK2 ){     nLeakMode1=TEST_LEAK2;//sylee230822
   }else{  nLeakMode1=TEST_LEAK1;  }//sylee230822}

    nFlagLeakMPin1=0;  //sylee230526  //sylee230817
	nLeakADCFlag1=0;//sylee230814-1 
	if( nMod1==5 ){//sylee230814-1
		if( nProStep1[TEST_LEAK1][1]>=300000000){
			nLeakADCFlag1=2;//sylee230814-1
		}
	}

	if( nMod1==6 ){//sylee230814-1
		if( nProStep1[TEST_LEAK2][1]>=300000000){
			nLeakADCFlag1=2;//sylee230814-1
		}
	} 

    nSparkIPlus1 = 0;//SYLEE201027
    nFlag_LeakDischarge1 = 0;//sylee200916-1
    //son220927 if (nMod1 == 5 || nMod1 == 6) //sylee200916-1     
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2) //sylee200916-1     //son220927
    {
        //  if(nProStep1[nMod1][1]>20000000){
        nFlag_LeakDischarge1 = 1;
        if (nMod1 == TEST_LEAK2) {  //son 6:TEST_LEAK2
            nLeakDischarge1AD0 = nLeakDischarge1AD2;
        }
        else {
            nLeakDischarge1AD0 = nLeakDischarge1AD1;
        }
        if (nLeakDischarge1AD0 < 300) {
            nLeakDischarge1AD0 = 300;
        }
        //  }
    }

    //sylee170725 
	nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    nSpark_NetFailCheck1 = 0;//sylee200814     
    nDebug11 = nDebug12 = nDebug13 = nDebug14 = nDebug15 = nDebug16 = 0;//sylee170618-test1 debugcode
    nDebug21 = nDebug22 = nDebug23 = nDebug24 = nDebug25 = nDebug26 = 0;//sylee170618-test1 debugcode

    if (SysSet13.m_nSparkMode == SPARK_NEW)
    {
        //////////////////////////////////////////////////////////////////////////////////
        nSparkV1Po2 = 0;//sylee200710 NEW_SPARK
        nSparkI1Po2 = 0;//sylee200710 NEW_SPARK
        nFlag_Spark_PinOn = 1;  //sylee200710-1 
        ::ZeroMemory(&dSparkV1, sizeof(dSparkV1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI1, sizeof(dSparkI1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI12, sizeof(dSparkI12));//sylee200710 NEW_SPARK
        ::ZeroMemory(&nSparkFailNo, sizeof(nSparkFailNo));//sylee200710 NEW_SPARK

        nSparkMaxY = 500;//sylee200710 NEW_SPARK


        if (SysSet19.m_nSet34 <= 0) {
            nSparkMaxX = 20;  //sylee200710   //MAX =50  NEW_SPARK
        }
        else {
            nSparkMaxX = SysSet19.m_nSet34;
            if (nSparkMaxX > 100) {
                nSparkMaxX = 100;
            }
        }
        nSparkGapMin = nSparkMaxX;
        nSparkMaxXSet = nSparkMaxX;//sylee210430



        if (SysSet19.m_nSet35 <= 0) {
            nSparkHWoffSet1 = 1;
        }
        else {
            nSparkHWoffSet1 = SysSet19.m_nSet35;
            if (nSparkHWoffSet1 > 500) {
                nSparkHWoffSet1 = 500;
            }
        }
        //////////////////////////////////////////////////////////////////////////////////

    }


    Sub71.OnRelay4W_OFF1();  //SYLEE181118

    // nProType=1;//sylee170617-3 test 

    //son nProType     1:multi piece,  2:one piece
    if (nProOneP_Flag1 == 3 && nProType == 2) {//sylee170306-1
        nProType = 3;
    }
    if (nReSheetFlag1 == 1 || g_nSkipPieceFlag1 == 1) { //sylee200919-1 //resheet      //son220624
        nProType = 1;
    }
    ////////////////////////////////////////////////////////////////////////////
    ////sylee160807-1     

    int  nRunFlag1_HvShort1;


    nShort_Flag1 = __HV; //1:__LV  2=__HV  //sylee161026

    nRunFlag1_HvShort1 = 0;

    ipEnd = 0;
    int dutId = getDutId();     //son190704 nMulNetFlag = dutId
    //son220927 if (nMod1 == 5 || nMod1 == 6)
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)       //son220927
    {
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId]; //SYLEE180810-1-DUT16  //son190704-4WDUT16

        if (g_nPieceMax1 >= 1) {//PIECE
            ipEnd = g_nPieceMax1;
        }
    }


    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {

        //sylee170807-5 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-5
        {
            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) {
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                    continue;
                }
            }

 //sylee230426-2
 /*
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex   open &short

                if (nManualStartFlag != 1) {
                    if (gRun05.m_nReCh > 0) {
                        if (nOpenSetFlag1 == 1) {
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {
                                if (nReFlagOpenCur[ip3] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {

                                if (nReFlagOpenOld[ip3] == 1) {
                                    continue;
                                }
                            }
                        }
                    }
                }

                /*
                if( nAutoReTest[nBlockCountP]< gRun05.m_nReCh){
                    if( nOpenFail1[ip]>0){//sylee121128
                    continue;
                    }
                }
                */
 //sylee230426-2     } else {//syle170725-3
		 
                if (nReFlagOpenOld[ip3] == 1) {///syle170725-3
                    continue;
                }

    //sylee230426-2 }


            if (nShortFail1[ip3] > 0) {
                continue;
            }

          //sylee230420   if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip3] == 1) {//sylee171120-1 
                continue;
            }//sylee171120-1
          //sylee230420   }

        }// if(nProType!=2){    //sylee170614-1

        nRunFlag1_HvShort1++;   //son HV Short 개수 카운트

    }

    if (nRunFlag1_HvShort1 < 1) {
        return 1;
    }



    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127
    nErrorDelay1 = 0;//sylee210205      3ms-> 0      //30000;//sylee150610  kushan 3mS

    tStart321 = GetuSecond();//TESTDEBUG
    //Sleep(1000);
    //return 1;//allpassing
    nRunMode_HV_LV = 1;//SYLEE150417-5  1= HV, 2=LV
    nErrorDelayTime1 = 1000;//1mS//sylee141001
    nErrorDelayTime2 = 100000;//500mS//sylee141002  //sylee150331  200mS->10ms =>   ok함 
    nErrorDelayFlag1 = 0;//sylee141002

    nProRv2 = (int)(nProRv1 * 1);
    nProRv3 = (int)(nProRv1 * 1); //sylee141001
//son240628    nProRv2 = (int)(nProRv1 * 0.99); //sylee240507 //son240628 BH 고정 Short 문제때문에 sylee240507 원상복구
//son240628    nProRv3 = (int)(nProRv1 * 0.99); //sylee240507

    if (nProRv3 < 10) { //sylee141001
        nProRv3 = 10;
    }

    nProRv0 = (int)nProRv1;//sylee150627

    if (nPinDa1H[1][2][0] < 100) {//sylee150627
        nProRv0 = (int)nProRv1;//sylee150627 
    }

    nEstUse = 0;  nFileCount = 0;
    logno1 = 0;   nShRes1T = 0; nStop = 0;  
    ipFlag = 0; //son 1이면 multi piece
    n4Wire = 0;   nIControl = 0;
    nDelayTime2 = 20000;//sylee130716
    ipEnd = 1;//PIECE
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode    
    nDischargeCount = 20;//sylee2012083
    nHVIADCFlag = 1;//test

    nHVTimeOutSet = DEFINE_HVTIMEOUT1 * 3;

    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nSh1Ret1, sizeof(nSh1Ret1));
    ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));//sylee120907
    ::ZeroMemory(&IADClog1, sizeof(IADClog1));//sylee120907

    if (nFastHv1RunStep == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nFastHv1Piece, sizeof(nFastHv1Piece));//sylee150415
        nFastHv1PieceReturn = 0;//sylee150415
    }

    //sylee170411   if(SysSet13.m_nSet19==1){//sylee150417-1 
    if (SysInfo05.m_nProSpMode == 2 || SysInfo05.m_nProSpMode == 3 || SysInfo05.m_nProSpMode == 4) {   //sylee150417-1 
        if (SysSet16.m_nSet11 == 1) {//sylee130325  //sylee130404   //estimation
            if (nFlagEstModelMake == 1 && nFlagEstModelMakeSelect == 2) {
                nEstUse = 1;//sylee130325
            }
            else if (nFlagEstModelMake == 3) {
                nEstUse = 1;//sylee130325
            }
            if (nOpenUse1 != 1) {//sylee150627
                nEstUse = 0;
            }
            if (nEstUse == 1) {//sylee130325
                nEt_LogCount++;//sylee130219jo   ytech estimation
            }
        }
        nFileCount = 0;//sylee130219joytech-estimation
    }
    //sylee170411   }

    if (SysSet15.m_nSet1 < 1 || SysSet15.m_nSet2 < 1 || SysSet15.m_nSet3 < 1) {
        AfxMessageBox("  Maker Engineer Call!  HV 100M,50M,20M  DATA<1? ,   PROCESS SET  PARAMETOR   FILE LOAD ERROR!.  ERROR NO 5001 ,PROCESS FAIL. STOP. ", MB_OK);
    }


    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     
    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
    if( nFlagLeak12==1  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1  //sylee230807
	    nVRel=4; 
	}
 	if( nFlagLeak12==2  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1 //sylee230807
	    nVRel=4; 
	}
#endif  //son231122


    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123          

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
    {
        dSparkLeakSet1 = nVSet / nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_I = (double)nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_V = (double)nVSet;
    }

    if (nVSet > 20) {//SYLEE141211
        if (nIR == 1) {
            AfxMessageBox("  Error  No 7101.  HV leak Mode,    I Range Mode 1 Use error.   Call bioptro! ", MB_OK);
            return 0;
        }
    }

    if (nProRv1 < 10) { //sylee141001
        nProRv1 = 10;
    }

    // hdpark230105 Spark begin
    if (Sub71.m_bSparkVerification)
    {
        if (nVSet < 250)
        {
            CString strMsg = "This voltage is not valid for spark validation voltage(250V)!";
            AfxMessageBox(strMsg);
            return 1;
        }
    }
    // hdpark230105 end

    // hdpark220715 begin
    if (nVSet >= 100.0) // 100 V 이상
    {
        nProRv2 = g_nProRv2[nMod1];  // hdpark220715, Cal 허용 편차 10 % 적용
        nProRv3 = g_nProRv3[nMod1];  // hdpark220715, Cal 허용 편차  5 % 적용
    }
    else
    {
        nProRv2 = nProRv1;
        nProRv3 = nProRv1;
    } // hdpark220715 end

    if (nVSet <= 50) {
        nICheckSet = 3;
    }
    else if (nVSet <= 100) {
        nICheckSet = 5;
    }
    else if (nVSet <= 150) {
        nICheckSet = 10;
    }
    else {
        nICheckSet = 20;
    }
    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7710, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }

    Sub71.nADCount1 = (int)dRec[m_nMode1][7];

	if(nLeakADCFlag1==2){ 	Sub71.nADCount1 = 60;	}//sylee230814-1


    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock  
    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 1024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 

 
 //sylee230811-3
 
    Lo1 = 2000; //sylee200915  100->1000

Task101:

    Sub71.AOnReadVB1Run1(nVRel);


    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;


    if (Simulator100 != 7)
    {
        if (Sub71.V1 > 300)
        {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();
            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1301,\n\n  고압전압 설정안되었습니다. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1301,\n\n   high voltage power set error. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }
            return 0;
        }

#ifdef _PC_TEST_
        Sub71.V1 = nVSet;       //son220927 PC_TEST에서 HW Check 에러 무시하기 위함.
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2)
        {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();

            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1313,\n \n\n 전압 설정이 안되었습니다.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1313,\n \n\n high voltage power  set  error.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            return 0;
        }
    }
 
 //sylee230811-3-test


    Sub71.FilterSet(nFil);//sylee130628 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on     
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.On4W_GainSet(1);
    Sub71.AOnReadV1Enable1(nVRel);
    Sub71.OnPinAllReset1(__LINE__); //SYLEE150120
    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);
    //sylee170427    Sub71.Delay_100ns(100000); //10mS  //sylee151203  
    Sub71.Delay_100ns(50000); //10->5mS  //sylee170427 
    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //sylee20120118

    nLeakADhigh1=0;//sylee230907

	if( ( nMod1==5 && nLeakHighFlag1[1] > 1)  ||  ( nMod1==6 && nLeakHighFlag1[2] >1) ){  //sylee230907  >= -> >
	      Sub71.Delay_100ns(3000000); //300mS  //sylee230814
          nLeakADhigh1=1;//sylee230907
	}
 	if( ( nMod1==5 && nLeakHighFlag1[1] == 1)  ||  ( nMod1==6 && nLeakHighFlag1[2] ==1) ){  //sylee230907
	      Sub71.Delay_100ns(100000); //10mS //sylee230907
	}

	nLeakHighFlag2=0;//sylee230830
	if( ( nMod1==5 && nLeakHighFlag1[1] >  1)  ||  ( nMod1==6 && nLeakHighFlag1[2] > 1) ){
	      nLeakHighFlag2=1;//sylee230830
	}
    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    //sylee140923   if( nMod1==2 || nMod1==3 || nMod1==4 || nMod1==5 )
    //son220927 if (nMod1 == 5 || nMod1 == 6)
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)   //son220927
    {
        nRCount = nBDLData3[dutId][0][1];       //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];  //SYLEE150920

        if (g_nPieceMax1 > 1) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1; //son multi piece라고 표시. 
        }
    }
    else {
        str.Format("Error No 7213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }

    nEt_StepSumTemp = 0;  //sylee130410


//=============================================================================================

    int  nDisable, nDisable2, nDisable3, ipEnd2;//sylee150611
    nDisable = 0; nDisable2 = 0; nDisable3 = 0;

    ipEnd2 = ipEnd;//sylee150611

    if (nProOneP_RunFlag1 == 1)
    {
        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
        {
            for (int ip2 = 1; ip2 <= ipEnd2; ip2++) {
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {
                    if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {
                        nDisable = 1;
                    }
                }
            }

            if (nReSheetFlag1 != 1) { //sylee150611 
                if (nDisable == 0) {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0) {

                        //son nProType 2: one piece 통검사 
                        if (nProType == 2 || nProType == 3) {//SYLEE130916  //i mode   running 
                            ipEnd = 1;
                            ipFlag = 0; //son muilti piece 아니라고 표시
                            nHVIADCFlag = 1;
                        }
                    }
                }
                //son ipFlag 0: milti piece 아님.    
                if ((ipFlag == 0) && (nProType != 0)) {//SYLEE131003
                    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
                }
            }

        }
    }

    nSparkset = 0;
    nSparkUse = 0;  // hdpark230712
    //son NEW_SPARK
    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200909 SPARK_NEW
    {
        //  nSparkRefV=SysInfo05.m_nSparkSet+SysInfo05.m_nSparkSet_B;//sylee200710-1 
        nSparkRefV = SysInfo05.m_nSparkSet;//sylee200808 NEW_SPARK
        g_nSpark1_Use = 0;//SYLEE200721 NEW_SPARK
        nSparkset = 0;

        if (SysInfo05.m_nSp == 1) {
            if (SysInfo05.m_nSparkSet > 0) {
                nHV_Vset1 = (int)nVSet;//sylee200703 SPARK_NEW
                //sylee200709   Sub71.AOnVBSet1(5,SysInfo05.m_nSparkSet); //1~ 100v set 가능   140428
                // sparktesting 
                Sub71.OnSparkADC(1);//SYLEE200714  //son ADC_B를 spark ADC로 설정
                nSparkset = nSparkHWoffSet1 + nSparkRefV;
                Sub71.AOnVBSet1(5, nSparkset); //sylee200709   JTECH  //son Spark VB값 설정
                Sub71.OnSparkOn(0); ////SPARK //SYLEE200703 SPARK_NEW
                Sub71.Delay_100ns(10000);  //1ms  //SYLEE200703 SPARK_NEW
                Sub71.OnSparkOn(1); ////SPARK ON   //SYLEE130830    1=on   ext ==off     
                nSparkUse = 1;
                g_nSpark1_Use = 1;//SYLEE200721 NEW_SPARK                   
                //Sub71.nADCount1 = 1;    //SYLEE200721 NEW_SPARK, // hdpark220914 comment, use dRec[][7] with leak
            }
        }

    }
    //son OLD_SPARK
    else
    {
        if (SysInfo05.m_nSp == 1) {
            if (SysInfo05.m_nSparkSet > 0) {
                Sub71.AOnVBSet1(5, SysInfo05.m_nSparkSet); //1~ 100v set 가능   140428      //son Spark VB 값 설정
                Sub71.OnSparkOn(0);  //SYLEE200623-2
                Sub71.Delay_100ns(10000); //sylee200623 -2
                Sub71.OnSparkOn(1); ////SPARK ON   //SYLEE130830    1=on   ext ==off     
                nSparkUse = 1;
            }
        }
    }

    //====================================================================================================================================
    if (ipEnd == 1) {//sylee150615-import
        nAHV_EST1_MODEL_TYPE1 = 2;//sylee150615-import
    }
    else {
        nAHV_EST1_MODEL_TYPE1 = 1;//sylee150615-import
    }

    if (nAHV_EST1_MODEL_TYPE2 == 2 && ipEnd != 1) {//sylee150615-import nAHV_EST1_MODEL_TYPE2=2;  one piece
        if (nEstUse == 1) {
            nEstUse = 0;
        }
        //est giveup
    }


    //====================================================================================================================================
    //###################################################################################################################################


    int nTmpPinNo2, nOldPinNo2;

    nOldPinNo2 = -1;
    dutId = getDutId();

    //######################################################################################################
    //sylee200919
    int nFlagN1_Mode, nFlagN1_ModeCo, nTmp1, nTmp2;
    nFlagN1_Mode = 0;
    nFlagN1_ModeCo = 0;
    nPieceMaxN1 = g_nPieceMax1;//sylee200814 //sylee200911-1

    if ((nShortPinRe2[0][0] == 1) && (nShortPinRe2[1][0] == nPieceMaxN1)) {
        for (int ik11 = 1; ik11 <= (nPieceMaxN1); ik11++) {
            for (int ik12 = 1; ik12 <= (nPieceMaxN1); ik12++) {
                nTmp1 = nBDLData3[dutId][ik12][1] + 1;
                nTmp2 = nShortPinRe2[1][ik11];
                if (nTmp1 == nTmp2) {
                    nFlagN1_ModeCo++;
                    break;
                }
            }
        }
        if (nPieceMaxN1 == nFlagN1_ModeCo) {
            nFlagN1_Mode = 1;
        }
    }

    if (nFlagN1_Mode != 1) {//SYLEE201024
        nFlagN1_Mode = 2;//SYLEE201024 //2=point to piece
    }

    //hdpark220511 spark begin
    if (Sub71.m_bModifySparkMeas)   //son VB Mode On 이면
    {
        Sub71.SendCmdToDigitizer(__LINE__, 0, SPARK_TRG_OFF);
        Sub71.SetVBReadMode();
        Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_ON);
        Sub71.Delay_100ns(2000);    // scope wave
    }
    //hdpark220511 spark end



//-------------------------------------------------------------
//sylee220901
/*//sylee230814-1 RAY
    int nEnd10;

    nRCount = nBDLData3[dutId][0][1];
    if (nPieceMaxN1 > 0) {
        nEnd10 = nPieceMaxN1;
    }
    else {
        if (nRCount >= 5) {
            nEnd10 = 5;
        }
        else {
            nEnd10 = nRCount;
        }
    }
    Sub71.OnPinAllReset1(__LINE__);
    for (ik = 1; ik <= nEnd10; ik++)   //son nEnd10 : Short 개수
    {
        nTmpPinNo2 = nBDLData3[dutId][ik][1];	//son shortPin pinNo
        Sub71.AOnPinSet1(2, nTmpPinNo2, 1);
    }
    nTmpPinNo2 = nBDLData3[dutId][nEnd10 + 1][1]; //son shortPin pinNo	
    Sub71.AOnPinSet1(2, nTmpPinNo2, 2);

    Sub71.Delay_100ns(100000);   //10mS      
    Sub71.OnPinAllReset1(__LINE__);
    //-------------------------------------------------------------


*/   //sylee230814-1 RAY


 nFlagLeakMPin1=1;  //sylee230526  //sylee230817

    //sylee201024 for( int ip=1; ip<=ipEnd3; ip++ ){ 
    for (int ip = 1; ip <= 1; ip++) { //sylee201024

       //if(ipFlag==1)
       //{
       //  //nRCount=nBDLData31[dutId][ip][0];     
       //  nRCount=(g_pvBDLData31[dutId][ip]->size() -1)
       //}else{
        nRCount = nBDLData3[dutId][0][1];     //son Short 총 개수
       //} 

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET  


//######################################################################################################
//######################################################################################################

        nSpark_NetFailCheck1 = 0;//sylee200814
        nSparkIPlus1 = 1;//SYLEE201027

#ifdef __AUTO_COUNT_DISPLAY_DISABLE__     //sylee230125
        nFlagN1_Mode = 2;
#endif


        if (nFlagN1_Mode == 1) {   //block  to block 

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
            {
                Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_ON);
            }
            for (int ik2 = nRCount; ik2 >= 1; ik2--)
            {
                // if( ipFlag==1 ){//short   PIECE MULT.    
                //   //nTmpPinNo2=nBDLData31[dutId][ip][ik2] ; // 1 VB,    =2VC,    //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                //   nTmpPinNo2= (*g_pvBDLData31[dutId][ip])[ik2].wFirstPin;   //son201118: vector구조로 변경
                 //}else{                        
                nTmpPinNo2 = nBDLData3[dutId][ik2][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16   //son-4WDUT16-190704
            //}

                if (ik2 > nPieceMaxN1) {
                    Sub71.AOnPinSet1(2, nTmpPinNo2, 1); // Vc,///block
                }
                else {
                    Sub71.AOnPinSet1(2, nTmpPinNo2, 2); // Vb, //point   
                }
            }

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_OFF);

            // nDelay10=800000;

            AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);


            //if( nHVIADCFlag==1){                                         
            if (Sub71.R1 <= nProRv2) {// ok//HV
            }
            else {//fail
                nSpark_NetFailCheck1 = 1;//sylee200814
                break;
            }
            //} 


//######################################################################################################

        }
        else if (nFlagN1_Mode == 0) { //sylee201024      //  point to block


            for (ik = 1; ik <= (nPieceMaxN1); ik++)
            {
                // hdpark220511 spark  
                if (Sub71.m_bModifySparkMeas)
                {
                    if (ik != 1)
                        Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_ON);
                }

                if (ik == 1) {
                    for (int ik2 = nRCount; ik2 >= 1; ik2--)
                    {
                        // if( ipFlag==1 ){//short   PIECE MULT.    
                        // //nTmpPinNo2=nBDLData31[dutId][ip][ik2] ; // 1 VB,    =2VC,  //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                        //   nTmpPinNo2= (*g_pvBDLData31[dutId][ip])[ik2].wFirstPin;   //son201118: vector구조로 변경
                         //}else{                        
                        nTmpPinNo2 = nBDLData3[dutId][ik2][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                    //}
                        if (ik2 != 1) {
                            Sub71.AOnPinSet1(2, nTmpPinNo2, 1); // Vc,///block
                        }
                        else {
                            nOldPinNo2 = nTmpPinNo2;
                            Sub71.AOnPinSet1(2, nTmpPinNo2, 2); // Vb, //point   
                        }
                    }

                }
                else {
                    Sub71.AOnPinReSet1(2, nOldPinNo2, 2);//   vb reset one pin
                   //if( ipFlag==1 ){//short   PIECE MULT.  
                    // //nTmpPinNo2=nBDLData31[dutId][ip][ik] ;  
                    //   nTmpPinNo2= (*g_pvBDLData31[dutId][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                    //}else{                         
                    nTmpPinNo2 = nBDLData3[dutId][ik][1];
                    //} 
                    Sub71.AOnPinReSet1(2, nTmpPinNo2, 1);  //   vc reset one pin    ok
                    nOldPinNo2 = nTmpPinNo2;
                    Sub71.AOnPinSet1(2, nTmpPinNo2, 2); //   vb  one pin  on
                }

                // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                    Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_OFF);

                AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);

                //if( nHVIADCFlag==1){                                         
                if (Sub71.R1 <= nProRv2) {// ok//HV 
                }
                else {//fail
                    nSpark_NetFailCheck1 = 1;//sylee200814
                    break;
                }
                //} 
            }// end of      for( ik=1; ik<=nRCount; ik++)

//###################################################################################################### 


        }
        else {  //if(nFlagN1_Mode==2){ //sylee201024   point to piece




            for (ip = 1; ip <= g_nPieceMax1; ip++)
            {
                // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                {
                    if (ip != 1)
                        Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_ON);
                }

                Sub71.OnPinAllReset1(__LINE__);
                //nRCount=nBDLData31[dutId][ip][0];//sylee201029
                nRCount = (g_pvBDLData31[dutId][ip]->size() - 1); //son201118: vector 구조로 변경

                for (int ik2 = nRCount; ik2 >= 1; ik2--)
                {
                    // if( ipFlag==1 ){//short   PIECE MULT.    
                         //nTmpPinNo2=nBDLData31[dutId][ip][ik2] ; // 1 VB,    =2VC,    //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                    nTmpPinNo2 = (*g_pvBDLData31[dutId][ip])[ik2].wFirstPin;  //son201118: vector 구조로 변경
                //}else{                        
               //   nTmpPinNo2=nBDLData3[dutId][ik2][1] ;   // 1  VB,    =2VC, //SYLEE180810-1-DUT16   //son-4WDUT16-190704
               //   nTmpPinNo2=(*g_pvBDLData31[dutId][ik2])[1].wFirstPin ;   
                //}
                    if (ik2 != 1) {
                        Sub71.AOnPinSet1(2, nTmpPinNo2, 1); // Vc,///block
                    }
                    else {
                        Sub71.AOnPinSet1(2, nTmpPinNo2, 2); // Vb, //point   
                    }
                }

           // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                     Sub71.SendCmdToDigitizer(__LINE__, nRCount, SPARK_TRG_OFF);


                AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);


                //if( nHVIADCFlag==1){                                         
                if (Sub71.R1 <= nProRv2) {// ok//HV
                }
                else {//fail
                    nSpark_NetFailCheck1 = 1;//sylee200814
                    break;
                }
                //} 
            }// end of      for( ik=1; ik<=nRCount; ik++)

        }
        //######################################################################################################
        //######################################################################################################



        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET  

    }// end of for( int ip=1; ip<=ipEnd; ip++ ){ 

#ifdef _PC_TEST_
    nSpark_NetFailCheck1 = 0;    //son221103 PC Simul에서는 아래 통과하도록. 
#endif


    if (nSpark_NetFailCheck1 == 1) {//sylee200814
       //sylee230814  goto TaskEnd800;//sylee200814
		nSpark_NetFailCheck1=0;   //sylee230814
		nPieceMaxN1=0;   //sylee230814
    }


     //###################################################################################################################################
    //====================================================================================================================================
    nSparkIPlus1 = 0;//SYLEE201027
    ipEnd = 1;//sylee201024
    ipFlag = 0;//sylee201024

    //###################################################################################################################################
   

     nFlagLeakMPin1=1;  //sylee230526  //sylee230817

    for (ip = 1; ip <= ipEnd; ip++)
    {
        //if((nProType!=1)&&(ipEnd!=1)){//sylee150610
        //sylee170307-2 if(nFastHv1RunStep==3){//sylee150415 fasthv
        //sylee170307-2     if( nFastHv1Piece[ip]!=1){  
        //sylee170307-2         continue;
        //sylee170307-2     }
        //sylee170307-2 }
        if (ipEnd != 1) {  //sylee160203-ITS
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS       //son220624
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece    <=============      //son220624
                    continue;
                }
            }
        }

        //sylee170807-6 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-6
        {

            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                    continue;
                }
            }

			/* //sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex
                if (nManualStartFlag != 1) {//SYLEE130221JOYTECH SETUP PRESS
                    if (gRun05.m_nReCh > 0) {//sylee121129
                        if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {//sylee121129 
                                if (nReFlagOpenCur[ip] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {
                                if (nReFlagOpenOld[ip] == 1) {
                                    continue;
                                }
                            }
                        }
                    }

                }//end if(nManualStartFlag!=1){//SYLEE130221JOYTECH SETUP PRESS

            }
            else {//syle170725-3
			*/ //sylee230420 
                if (nReFlagOpenOld[ip] == 1) {//syle170725-3  //SYLEE171120-2  IP3->IP
                    continue;
                }
           //sylee230420  }

            if (nShortFail1[ip] > 0) {//sylee120921
                continue;
            }

           //sylee230420  if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip] == 1) {//sylee171120-1   
                continue;
            }//sylee171120-1
           //sylee230420  }


        }//sylee170614-1  


        if (nOpenErrFlag[ip] == 1) {//move
            nOpenErrFlag[ip] = 2;
        }


        //   nCellNo= nBlockPieceNo1[nBlockCountP][ip];//nBlockPieceNo1[blockno][pieceno]==CELLNO
        //   if(nBlockRes[nCellNo]==BLOCK_RES_PASS || nBlockRes[nCellNo]==BLOCK_RES_OPEN){////0=init,  1=pass,2=open, 3 short, 4=o +s,7 기타 error

        //   if(nBlockRes[nCellNo]!=0){////0=no test,  1=pass,2=open, 3 short, 4=o +s,7 기타 error
        //       continue;
        //   }

        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;
        nECount = 0;
        nFailL1CoPiece = 0;
        nEt1 = 0;
        nShort2FailFlag1 = 0;

        //*******************************************************************************************************************************//
        //Task1:

        if (ipFlag == 1)
        {
            //son 현재 DUT, piece의 Short 총수
            //nRCount=nBDLData31[dutId][ip][0]; //SYLEE180810-1-DUT16   //son-4WDUT16-190704
            nRCount = (g_pvBDLData31[dutId][ip]->size() - 1);   //son201118: vector구조로 변경
            nRCount = nRCount - 1;//sylee200814 //sylee201023
        }
        else {
            //son Short 총수
            nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son-4WDUT16-190704
            nRCount = nRCount - (nPieceMaxN1);//sylee200814 //sylee201023
        }
        //sylee201023   nRCount=nRCount-(nPieceMaxN1);//sylee200814


        nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
        for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
        {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
            tp1 = i * i;
            if (tp1 >= nRCount) {
                nSQCount1 = i;//sylee120908
                break;
            }
        }

        //sylee170327-import  interlock
        if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
    //  if( (nSQCount1==0) ){//sylee170327-1 import
            str.Format("Error No 7513-1 ,  Short Net List <=1 (nRCount=%d) ! \n\n piece pin no set check?   HV SQUARE  COUNT = %d \n",
                nRCount, nSQCount1);    //son221103 
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }

        ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));

        //################################################################################################################################
        //SET 
        int nTmpPinNo1; //sylee160728-2


        for (ik = 1; ik <= nRCount; ik++)
        {
            i = (ik - 1) / nSQCount1 + 1;//mok
            j = (ik - 1) - nSQCount1 * (i - 1);//na

            j = j + 1;

            //son ipFlag로 멀티 piece인지 파악. nProType만 갖고 체크하지 않는다.
            if (ipFlag == 1) {//short   PIECE MULT.     
           //sylee201023    nTmpPinNo1=nBDLData31[dutId][ip][ik+(nPieceMaxN1)] ; // 1 VB,    =2VC, //SYLEE180810-1-DUT16    
                 //nTmpPinNo1=nBDLData31[dutId][ip][ik+(1)] ; // 1 VB,    =2VC,    //SYLEE180810-1-DUT16    //sylee201023 
                nTmpPinNo1 = (*g_pvBDLData31[dutId][ip])[ik + 1].wFirstPin;   //son201118: vector구조로 변경
            }
            else {
                nTmpPinNo1 = nBDLData3[dutId][ik + (nPieceMaxN1)][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 
            }


            for (int jk1 = 1; jk1 <= nOpen2Li1[ip][0][0]; jk1++) {//sylee160801-3
                if (nTmpPinNo1 == (nOpen2Li1[ip][jk1][0])) {    //sylee160816-1
                    nTmpPinNo1 = nOpen2Li1[ip][jk1][1]; //sylee160816-1
                }//sylee160728-2
            }//end of for( int jk1=1; jk1<=nOpen2Li1[ip2][0][0]; jk1++){

            nSQNet1[i][j] = nTmpPinNo1; //sylee160801-3

            if (ik == nRCount) {
                nSQLastPin = j;//sylee120908   ///last row , last col.
                nSQLastY1 = i;
            }
        }


        //sylee151109-3  if(SysSet13.m_nSet18!=1){//sylee150508  2n est
        if (nFlagEstModelMake == 1) {//sylee151109-2
            nEt_StepSumTemp = nEt_StepSumTemp + (nSQLastY1 - 1) + (nSQCount1 - 1);  //sylee130410 

            if (ip == ipEnd) {
                nEt_StepSum = nEt_StepSumTemp;//sylee130410
            }
        }

        //===================================================================================



        int iktmp, ikok;
        iktmp = 0; ikok = 0;

        if (nProOneP_RunFlag1 == 1)
        {
            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
            {
                if (nProType == 3)
                {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0)
                    {
                        for (ik = 1; ik <= nRCount; ik++)
                        {
                            ikok = 0;
                            for (int k1 = 1; k1 <= nProOneP_Short1[0]; k1++)
                            {
                                //SYLEE180810-1-DUT16   //son190704-4WDUT16
                                if ((nProOneP_Short1[k1] + 1) == (nBDLData3[dutId][ik + (nPieceMaxN1)][1] + 1)) {
                                    ikok = 1;
                                }
                            }
                            if (ikok == 0)
                            {
                                iktmp++;
                                i = (iktmp - 1) / nSQCount1 + 1;//mok
                                j = (iktmp - 1) - nSQCount1 * (i - 1) + 1;//na                    

                                //son190704-4WDUT16
                                nSQNet1[i][j] = nBDLData3[dutId][ik + (nPieceMaxN1)][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16    
                                nSQLastPin = j;
                                nSQLastY1 = i;
                            }

                        }
                    }
                }
            }
        }

        //================================================================================================================


        //nEt_StepSum=(nSQLastY1-1)*2*ipEnd;  //sylee130219joytech //estimation
        //================================================================================================================

        //#2 second search    hv  adc           
        // 1000 point 

        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        //row　가로　측정　

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
        nRetry1 = 0;//SYLEE121103

        nHVDStopTime1 = (long)GetuSecond();//sylee121103

        //sylee170617   Task1Retry://SYLEE121103
        //hdpark220511 spark begin
        if (Sub71.m_bModifySparkMeas)
        {
            Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);
            Sub71.SetVBReadMode();
        }
        // spark end

	    if(nLeakACMode1==2){//sylee241120-2
			nK1Start=0;//sylee241120 
		}else{ 
			nK1Start=1;//sylee241120
		}

        for (ik = nK1Start; ik < nSQLastY1; ik++)     // FIRST LOOP //Y  VB   //sylee241120
        {

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                nFlag_Spark_PinOn = 1;  //sylee200710-1 NEW_SPARK
                //SYLEE121103  nRetry1=0; 
                //SYLEE121103  Task1Retry: 
                //SYLEE121103  if(ik==1  || nSQStep1flag==2 || nRetry1==1){

            if ( ik == nK1Start  || nSQStep1flag == 2) {   //SYLEE121103  //sylee241204

                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET  

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

					if(nLeakACMode1==2){//sylee241120 
						if (ik2 ==(ik+1)) {//sylee241120 
							continue;//sylee241120 
						}//sylee241120- 						
					}else{//sylee241120 
						if (ik2 > ik) {
							continue;
						}
					}

                    // hdpark220511 spark
                    if (Sub71.m_bModifySparkMeas)
                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }


                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb  

                        nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127
                        if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                            nPinSetSkipVb = 3; //sylee151005 //ACE400               //son230127
                        }

                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }
                }

                nSQStep1flag = 0;
            }
            else
            {//end of if(ik==1  || nSQStep1flag==2){

                Sub71.OnPinResetVC(); 

                // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);    // 1'st row pin check

                for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                    if (ik == nSQLastY1) {  //LAST Y STEP
                        if (ih > nSQLastPin) {
                            break;//SKIP   
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 1); //=1VB,  

                    nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400               //son230127
                    }

                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ik][ih];
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    } 
                }

	    		if(nLeakACMode1==2){//sylee241120 
					for (ih = 1; ih <= nSQCount1; ih++) {  //SYLEE241120 
						if ((ik + 1) == nSQLastY1) {
							if (ih > nSQLastPin) {
								break;//SKIP
							}
						}
						Sub71.AOnPinReSet1(2, nSQNet1[ik + 1][ih], 1); 

					    tmp1 = nSQNet1[ik + 1][ih]; //SYLEE241217
                        if (nOpenErrList[tmp1][OPERR_START] > 0) {
                            for (int s1 = nOpenErrList[tmp1][OPERR_START]; s1 <= nOpenErrList[tmp1][OPERR_END]; s1++) {
                                Sub71.AOnPinReSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);    
                            }
                        }
					}
				}  


            }

            for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                if ((ik + 1) == nSQLastY1) {
                    if (ih > nSQLastPin) {
                        break;//SKIP
                    }
                }
                //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                /////////////////////////////////////////////////////////////////////////////////////////

                Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =1,VB,   all 

                nPinSetSkipVcCnt++; //sylee151005 //ACE400                  //son230127
                if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                    nPinSetSkipVc = 3; //sylee151005 //ACE400               //son230127
                }

                //--------------
                //son SPARK_NEW
                if (SysSet13.m_nSparkMode == SPARK_NEW)
                {
                    /////////////////////////////////////////////////////////////          
                    if (nSparkUse == 1 && nSparkDetect1 == 1) //SYLEE200714-2
                    {

                        if (nFailL1CoPiece < SysInfo05.m_nIsEr)   //SPARK
                        {
                            //-------------------
                            //son HW Spark 감지
                            ret1 = Sub71.OnSparkStatus(); 
                            //  ret1=0;

                            if (ret1 == 1)//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                            {
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10000);  //1ms  
                                nSparkTmp = nSQNet1[ik + 1][ih] + 1;//syloee200714

                                //sylee230305 begin:
                                t1 = nPinToPiece(nSparkTmp);
                                if (SysInfo19.m_nUse == 1) { //son PieceDisable Use ON 이면  disable인 piece를 skip 
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 
                                        continue;		//sylee230305
                                    }
                                }
                                if (g_nSkipPieceFlag1 == 1) {    
                                    if (g_nSkipPieceInfo[t1] == 2) { //son Main Handler에서 skip하라고 한 pice를 skip 
                                        continue;	
                                    }	
                                }//sylee230305 end


                                if (nSparkFailNo[nSparkTmp] != 1)//syloee200714
                                {
                                    if (nFailL1Co < 3000) {////SPARK                                                                
                                        MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                                        nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][F_BLOCK]  = nBlockCountP;//son 2: F_BLOCK  
                                        nFailL1[nFailL1Co][F_VC_PIN] = nSQNet1[ik + 1][ih] + 1;//pin  vb    //son 5:F_VC_PIN

                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                        nFailL1[nFailL1Co][F_VB_PIN] = -1;//pin  vc    //son 4:F_VB_PIN //son spark 는 VB핀이 -1 이다.
                                        t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][F_PIECE] = t1;//son 3: F_PIECE  no   //sylee20120314
                                        ////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////
                                        nFailL1[nFailL1Co][F_RAW_R]           = -1;//Sub71.R1         //son 6:F_RAW_R 측정값 
                                        nFailL1[nFailL1Co][F_PRORV_RAW_R]     = nProRv1;//nProRv1 판정 raw R   //son 17:F_PRORV_RAW_R
//sylee220725                           nFailL1[nFailL1Co][F_PRORV_REAL_R]    = nProRv1Real;//nProRv1 판정 real R   //son 7:F_PRORV_REAL_R 
                                        nFailL1[nFailL1Co][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];    //son 8:F_PRO_STEP_REAL_R
                                        nFailL1[nFailL1Co][F_VSET]            = nVSet;      //son  9:F_VSET
                                        nFailL1[nFailL1Co][F_ISET]            = nISet;      //son 10:F_ISET
                                        nFailL1[nFailL1Co][F_MODE1]           = m_nMode1;   //son 11:F_MODE1
                                        nFailL1[nFailL1Co][F_VB] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];//SPARK V1   //son 12:F_VB
                                        nFailL1[nFailL1Co][F_VC] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1   //son 13:F_VC
                                        nFailL1[nFailL1Co][F_I]  = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I //son 14:F_I
                                        nFailL1[nFailL1Co][F_TEST_TYPE] = nMod1;//I  //open ushort short hr hv   4w  //son 16:F_TEST_TYPE
                                        nFailL1[nFailL1Co][F_STEP]      = nPStep1;//sylee231016  //son 18:F_STEP
                                        nShortFlag = 1;//sylee120915
                                        Sub71.OnSparkOn(1);     //hdpark220412 
                                        Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                    }   //end of if(nFailL1Co<3000) //SPARK    
                                }

                            }// if(ret1==1)

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                    }//end of  if(nSparkUse==1)

                //SPARK############################################################################################ 

                }

                //---------------
                //son SPARK_OLD
                else
                {
                    if (nSparkUse == 1) {
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                            ret1 = Sub71.OnSparkStatus();
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                //str.Format("Error No 7502,     Spark Detect   !  "   ); 
                                str.Format("Error No 7502,  Spark Detect!  Pin=%d ", nSQNet1[ik + 1][ih] + 1);
                                m_list1.AddString(str);
                                nlist1++;

                                //SPARK############################################################################################

                                if (nFailL1Co < 3000) {////SPARK
                                    /*  if(nProOneP_RunFlag1==1){//sylee131221
                                        if(nReSheetFlag1!=1){//sylee140429-1
                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                        nProOneP_RunFlag1=0;
                                        goto TaskEnd100;
                                        }
                                        }
                                        }
                                    */

                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                    //log buffer
                                    nFailL1Co++;
                                    nFailL1CoPiece++;
                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                    nFailL1[nFailL1Co][F_BLOCK]          = nBlockCountP;//son  2:F_BLOCK  
                                    nFailL1[nFailL1Co][F_VC_PIN]         = nSQNet1[ik + 1][ih] + 1; // pin  vb //son 5:F_VC_PIN   
                                    nFailL1[nFailL1Co][F_VB_PIN]         = -1;//pin  vc       //son 4:F_VB_PIN
                                    t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no    

                                    //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                    nFailPiece[t1][nPStep1]++;//PIECE  error count //sylee20120314
                                    nFailL1[nFailL1Co][F_PIECE]           = t1;//son 3:F_PIECE //PIECE  no   //sylee20120314 
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                    nFailL1[nFailL1Co][F_RAW_R]           = -1;//Sub71.R1   //son 6:F_RAW_R 
                                    nFailL1[nFailL1Co][F_PRORV_RAW_R]     = nProRv1;//nProRv1 판정 R //son 17:F_PRORV_RAW_R 
//sylee220725                       nFailL1[nFailL1Co][F_PRORV_REAL_R]    = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303  //son 7:F_PRORV_REAL_R
                                    nFailL1[nFailL1Co][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];    //son 8:F_PRO_STEP_REAL_R
                                    nFailL1[nFailL1Co][F_VSET]            = nVSet;  //son 9:F_VSET
                                    nFailL1[nFailL1Co][F_ISET]            = nISet;     //son 10:F_ISET
                                    nFailL1[nFailL1Co][F_MODE1]           = m_nMode1;  //son 11:F_MODE1
                                    nFailL1[nFailL1Co][F_VB]              = -1;//Sub71.V1;//VB //son 12:F_VB 측정값
                                    nFailL1[nFailL1Co][F_VC]              = -1;//Sub71.X1;//VC //son 13:F_VC 측정값
                                    nFailL1[nFailL1Co][F_I]               = -1;//Sub71.Y1;//I  //son 14:F_I  측정값
                                    nFailL1[nFailL1Co][F_STEP]            = nPStep1;//sylee231016  //son 18:F_STEP
                                    nFailL1[nFailL1Co][F_TEST_TYPE]       = nMod1;//I  //open ushort short hr hv   4w  //son 16:F_TEST_TYPE

                                    nShortFlag = 1;//sylee120915
                                    Sub71.OnSparkOn(1); // hdpark220412
                                    /* //sylee150618
                                        if(nProOneP_RunFlag1==1){//sylee140514
                                        if(nReSheetFlag1!=1){//sylee140514
                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                        nProOneP_RunFlag1=0;
                                        goto TaskEnd100;
                                        }
                                        }
                                        }

                                    */
                                    Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                }   //end of if(nFailL1Co<3000){ //SPARK
                                //SPARK############################################################################################                                 


                            }// if(ret1==1){

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                    }//end of  if(nSparkUse==1){

                }   //end of SPARK_OLD

                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ik + 1][ih];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                    Sub71.Delay_100ns(10000); //1ms
                    Sub71.AOnReadV1I1_ADC_I();

                    if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                            Sub71.Delay_100ns(1000); //1ms
                    }
                */

            } // ih

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

            //////////////////////////////////////////////////////////////////////////////////


            if (nHVIADCFlag == 1) {
                //#1-1                 
                if (nFastHv1RunStep == 1) {//sylee150415 fasthv                  
                    nFastHv1AdRun = 1;//sylee150415 fasthv                               
                }
                else {
                    nFastHv1AdRun = 0;//sylee150415 fasthv  
                }

                if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {//sylee130325   //sylee150407                  
                    AHV_ADCI_Read1_EST1(nProRv2, nDelay10);  //sylee130107  //estimation
                }
                else {
                    AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);//sylee150227
                }
                //  Sub71.R1= dIADC1  ;//ADC
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv2);
            }

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
            {
                /////////////////////////////////////////////////////////////   

                //sylee200724-1
                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                {
                    if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                        //  ret1=Sub71.OnSparkStatus();
                        //  ret1=0;

                        //  if(ret1==1){//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                        //      Sub71.OnSparkOn(0);
                        //  Sub71.Delay_100ns(10000);  //1ms  
                        nSparkTmp = nSQNet1[ik + 1][ih] + 1;//syloee200714
                        if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                            if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);


                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                //log buffer
                                nFailL1Co++;
                                nFailL1CoPiece++;
                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih] + 1;//pin  vb

                                nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                ////////////////////////////////////////////////////////////////////////////////
                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                //////////////////////////////////////////////////////////////////////////////////////
                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                nFailL1[nFailL1Co][9] = nVSet;
                                nFailL1[nFailL1Co][10] = nISet;
                                nFailL1[nFailL1Co][11] = m_nMode1;
                                //hdpark231121.
                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt //son241115
                                nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt //son241115
                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current   //son241115
                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                nShortFlag = 1;//sylee120915
                                Sub71.OnSparkOn(1); //hdpark220412
                                Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                            }   //end of if(nFailL1Co<3000){ //SPARK    
                        }

                        //  }// if(ret1==1){

                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                }//end of  if(nSparkUse==1){

                //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                if (nSparkUse == 1) {  //sylee200714-2 ok wait
                    ret1 = Sub71.OnSparkStatus();//sylee200713-
                    //ret1=0;
                    if (ret1 == 1) {
                        Sub71.OnSparkOn(0);
                        Sub71.Delay_100ns(10000);  //1ms  
                        Sub71.OnSparkOn(1);
                    }
                }

                //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                /*    if(nSparkUse==1){//sylee200714  wait
                            ret1=Sub71.OnSparkStatus();//sylee200713-
                            if(ret1==1){

                    if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK
                        ret1=Sub71.OnSparkStatus();
                        if(ret1==1){//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                            Sub71.OnSparkOn(0);
                            Sub71.Delay_100ns(10000);  //1ms
                            nSparkTmp=nSQNet1[ik+1][nSQCount1]+1;//syloee200714
                            if(nSparkFailNo[nSparkTmp]!=1){//syloee200714

                                if(nFailL1Co<3000){////SPARK
                                        if(nSparkI1Po2<nSparkMaxY){
                                            nSparkI1Po2++;
                                        }

                                        dSparkI1[nSparkI1Po2][nSparkMaxX+6]=nSQNet1[ik+1][nSQCount1]+1 ; //fail  //=nSQNet1[ik+1][ih]+1

                                        nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1]=nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2]=nBlockCountP;//block
                                    //  nFailL1[nFailL1Co][5]=nSQNet1[ik+1][ih]+1 ;//pin  vb
                                        nFailL1[nFailL1Co][5]=nSQNet1[ik+1][nSQCount1]+1 ;//pin  vb
                                        nSparkTmp=nSQNet1[ik+1][nSQCount1]+1;//syloee200714
                                        nSparkFailNo[nSparkTmp]=1;//syloee200714
                                        nFailL1[nFailL1Co][4]=-1;//pin  vc
                                        t1=nSQNet1[ik+1][nSQCount1]+1;//PIECE  pin no
                                        t1=nPinToPiece(t1);//SYLEE171225-2  //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3]=t1;////PIECE  no   //sylee20120314
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortFail1Flag1=1;//sylee20120921//100=piecemax
                                        nFailL1[nFailL1Co][6]=-1 ;//Sub71.R1
                                        nFailL1[nFailL1Co][17]=nProRv1;//nProRv1 판정 R
                                        nFailL1[nFailL1Co][7]=nProRv1Real;//nProRv1 판정 R    //SYLEE20120303
                                        nFailL1[nFailL1Co][8]=nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9]=nVSet;
                                        nFailL1[nFailL1Co][10]=nISet;
                                        nFailL1[nFailL1Co][11]=m_nMode1;
                                        nFailL1[nFailL1Co][12]=-1;//Sub71.V1;//VB
                                        nFailL1[nFailL1Co][13]=-1;//Sub71.X1;//VC
                                        nFailL1[nFailL1Co][14]=-1;//Sub71.Y1;//I
                                        nFailL1[nFailL1Co][16]=nMod1;//I  //open ushort short hr hv   4w
                                        nShortFlag=1;//sylee120915
                                        Sub71.OnSparkOn(1);
                                        Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC

                                }   //end of if(nFailL1Co<3000){ //SPARK
                            }

                        }// if(ret1==1){

                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK

                    }//end of  if(nSparkUse==1){
                }

                */
                //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


            }

            IADClog1[ip][ik] = Sub71.R1;///logging 
            if (nHVIADCFlag == 1) {
                if (Sub71.R1 <= nProRv2) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
                   /*//sylee170617-1     ok
                   if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;
                       Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                       Sub71.Delay_100ns(2000000);  //200ms  //SYLEE121103 10->200
                       goto Task1Retry;
                   }
                   */
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    nSQStep1flag = 2;

                }


            }
            else {
                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
/* //sylee170617  
                   if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;
                       Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                       Sub71.Delay_100ns(nErrorDelayTime1);  //10ms
                       goto Task1Retry; //sylee170617-test
                   }
*/
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    nSQStep1flag = 2;
                }
            }


            if (nFlagEstModelMakeSelect == 2) {//sylee130325    //estimation
                nFailFlag1 = 0;  // ALLPASS
            }


            if (nFastHv1RunStep == 1) {//sylee150415 fasthv
                if (nFastHv1AdRun == 1) {
                    if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                        nFailFlag1 = 0;  // ALLPASS
                        nFastHv1Piece[ip] = 1;
                        nFastHv1PieceReturn = 1;//sylee150415
                        goto TaskEnd300;
                    }
                }
            }

            //==============================================================================================================================
            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block 

            if (nFailFlag1 == 1) {  //if error  

                nDebug11 = 1;//sylee170618-test1 debugcode
                nFastHv1AdRun = 0;//sylee150415 fasthv
                Sub71.OnPinResetVB(27211);   //sylee121029 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //V                    

                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;

                    if (ik2 > ik) { //doublecheck#2 
                        continue;
                    }

                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                    if (Sub71.m_bModifySparkMeas)
//<                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }

                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                    if (Sub71.m_bModifySparkMeas)
//<                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

                    //=====================================================================================================================

                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610 


                    if (nHVIADCFlag == 1) {
                        AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 2);//sylee150227
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                    }



                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv2) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV      // hdpark220715 nProRv2 -> nProRv1
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 

                    //=====================================================================================================================
                    //##################################################################################################################################

                    //one line & one line  search
                    if (nFailFlag2 == 1) {



                        nDebug12 = 1;//sylee170618-test1 debugcode

                      // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                       if (Sub71.m_bModifySparkMeas)
//<                           Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                        // Leak VC Pin Search
                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih6 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }
                            Sub71.OnPinResetVB(27333);//SYLEE121016***** all reset                                   
                            // Sub71.Delay_100ns(100);//10uSEC   


                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=1VB,                                    
                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ik2][ih6];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }
                            //=====================================================================================================================

                            //sylee210205   Sub71.Delay_100ns(10000);//sylee150302   1mS   
                            Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                            if (nHVIADCFlag == 1) {
                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 3);//sylee150227   // hdpark220715 nProRv2 -> nProRv3
                               //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {

                                Sub71.Delay_100ns(nDelay10);
                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                }

                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }

                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }

                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv3) {// ok//HV // hdpark220715, nProRv2 -> nProRv3
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line  


                            //=====================================================================================================================
                            //################################################################################################################################
                            ///one point  & one point search

                            if (nFailFlag3 == 1) {

                                nDebug13 = 1;//sylee170618-test1 debugcode

                                // Leak VB Pin Search
                                for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin                                             

                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih2 > nSQLastPin) {

                                            break;//SKIP
                                        }
                                    }

                                    Sub71.OnPinResetVC(27430); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    if (nErrorDelayFlag1 == 1) {//sylee141002
                                        nErrorDelayFlag1 = 0;//sylee141002
                                        Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS
                                    }


                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all

                                    /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ik + 1][ih2] + 1;//syloee200714

													//sylee230305 begin
													t1 = nPinToPiece(nSparkTmp); //sylee230305
													if (SysInfo19.m_nUse == 1) {  
													    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                                    }
													if (g_nSkipPieceFlag1 == 1) {    
													    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  
                                                            nFailL1[nFailL1Co][F_BLOCK]           = nBlockCountP;//son 2:F_BLOCK 
                                                            nFailL1[nFailL1Co][F_VC_PIN]          = nSQNet1[ik + 1][ih2] + 1;//pin  vb  //son 5:F_VC_PIN

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][F_VB_PIN]          = -1;//pin  vc   //son 4:F_VB_PIN 
                                                            t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;//PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][F_PIECE]           = t1;//son 3:F_PIECE //PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][F_RAW_R]           = -1;//Sub71.R1   //son 6:F_RAW_R 
                                                            nFailL1[nFailL1Co][F_PRORV_RAW_R]     = nProRv1;//nProRv1 판정 R //son 17:F_PRORV_RAW_R 
//sylee220725                                               nFailL1[nFailL1Co][F_PRORV_REAL_R]    = nProRv1Real;//nProRv1 판정 R   // son 7:F_PRORV_REAL_R
                                                            nFailL1[nFailL1Co][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];    //son 8:F_PRO_STEP_REAL_R
                                                            nFailL1[nFailL1Co][F_VSET]            = nVSet;      //son 9:F_VSET
                                                            nFailL1[nFailL1Co][F_ISET]            = nISet;     //son 10:F_ISET
                                                            nFailL1[nFailL1Co][F_MODE1]           = m_nMode1;  //son 11:F_MODE1
                                                            nFailL1[nFailL1Co][F_VB] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];//SPARK V1  //son 12:F_VB 측정값
                                                            nFailL1[nFailL1Co][F_VC] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1  //son 13:F_VC 측정값
                                                            nFailL1[nFailL1Co][F_I]  = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1; //son 14:F_I  측정값
                                                            nFailL1[nFailL1Co][F_STEP]            = nPStep1;//sylee231016      //son 18:F_STEP
                                                            nFailL1[nFailL1Co][F_TEST_TYPE]       = nMod1;//I  //open ushort short hr hv   4w  //son 16:F_TEST_TYPE
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1); //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                }// if(ret1==1){

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                                        }//end of  if(nSparkUse==1){

                                    //SPARK############################################################################################ 


                                    }


                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }


                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610                                                      
                                    //$$$$$$$$$$$$$$$$$$$ HV #1-4                                               
                                    if (nHVIADCFlag == 1) {
                                        // Sub71.Delay_100ns(nDelay10);//SYLEE141001
                                        //SYLEE141001
                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150227
                                        //     Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ  //sylee141016
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                        }


                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }


                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }

                                    }

                                    //*********************************************//
                                    nHVDStopTime2 = (long)GetuSecond();
                                    nHVDStopTime3 = (nHVDStopTime2 - nHVDStopTime1);
                                    if (nHVDStopTime3 > nHVTimeOutSet) { //15sec
                                        nHVDStopFlag = 1;//sylee121009
                                        Sub71.R1 = 20000;
                                        nFailL1CoPiece = 3000;
                                    }
                                    //************************************************// 

								  	if (Sub71.R1 > nProRv1){//sylee241224-2
									    if((int)nProStep1[nMod1][1]>=200000000){//sylee241224-2
										     if( Sub71.R1<(nProRv1*1.10)){//sylee241224-2 
												 nLeakNearFlag1=1;//sylee241226
												 Sub71.Delay_100ns(100000);  //10ms 
												 nLeakNearPin1=(nSQNet1[ik + 1][ih2] + 1);//sylee241226
												 nLeakNearPin2=(nSQNet1[ik2][ih6] + 1);//sylee241226
												 AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1);//sylee241226							
												 nLeakNearFlag1=0;//sylee241226
											}
										}
									} 

                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV // hdpark220715, nProRv3 -> nProRv1
                                        }
                                        else {//fail

                                            nFailFlag4 = 1;
                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {//sylee130107
                                                if ((nFailL1[iq1][4] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //   if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }
                                    //=====================================================================================================================


                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ik2][ih6];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }
                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;

                                    }  //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1 


                                    if (nFailFlag4 == 1) {

                                        nDebug14 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;

                                        nErrorDelayFlag1 = 1;//sylee141002
                                        //sylee170620     Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS

                                        //if((nOpenErrList[tmp1][0]<=0)&&(nOpenErrList[tmp2][0]<=0)){ 

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1)) {


                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                if (nProOneP_RunFlag1 == 1) {//sylee131221
                                                    if (nReSheetFlag1 != 1) {//sylee140429-1
                                                        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {//sylee131221
                                                            nProOneP_RunFlag1 = 0;
                                                            //sylee150616-import    goto TaskEnd100;
                                                        }
                                                    }
                                                }

                                                /*  //sylee150618
                                                if(nProOneP_RunFlag1==1){//sylee131221
                                                    if(nReSheetFlag1!=1){//sylee140429-1
                                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                                            nProOneP_RunFlag1=0;
                                                            goto TaskEnd100;
                                                        }
                                                    }
                                                }
                                                */

                                                if (nSparkUse == 1) {
                                                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                        break;// complete  error 
                                                    }
                                                }


                                                //####################################################################################//SYLEE150624
                                                /*    //sylee170613 

                                                                int iSum5,iCo5,iSet5;//sylee150627
                                                                iSum5=0;iCo5=0;//sylee150627

                                                                if(nPinDa1H[1][2][0]<100){//sylee150627

                                                                    iSet5=1;//SYLEETESTMODE-1
                                                                    if(Sub71.R1<340){//sylee150627
                                                                        iSet5=30;  //sylee150629   20->30
                                                                    }
                                                                    if(Sub71.R1<500){//sylee150627
                                                                        iSet5=10;
                                                                    }

                                                                }else{
                                                                    iSet5=1;
                                                                    if(Sub71.R1<340){//sylee150627
                                                                        iSet5=3;
                                                                    }
                                                                }

                                                                for(int k5=1;k5<=iSet5;k5++){//sylee150627

                                                                    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET

                                                                    if(k5==1){//sylee150627
                                                                        Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC
                                                                    }

                                                                    Sub71.AOnPinSet1(2,nSQNet1[ik+1][ih2], 2) ;  // =2VC  all
                                                                    Sub71.AOnPinSet1(2,nSQNet1[ik2][ih6], 1);   // =1,VB,   all

                                                                    if(k5==1){
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627
                                                                    }
                                                                    AHV_ADCI_Read1_OneToM(nProRv3,nDelay10);//sylee150627

                                                                    if(Sub71.R1<700.){//sylee150627
                                                                        iSum5=iSum5+(int)Sub71.R1;//sylee150627
                                                                        iCo5++;//sylee150627
                                                                    }//sylee150627

                                                                    if(Sub71.R1>=700){//sylee150627
                                                                        break;
                                                                    }

                                                                }//sylee150627

                                                                if(iCo5>1){//sylee150627
                                                                    Sub71.R1=iSum5/iCo5;//sylee150627
                                                                }//sylee150627

                                                                if(nPinDa1H[1][2][0]<100){//sylee150627
                                                                    nProRv3=nProRv0;
                                                                }

                                                                if( Sub71.R1<=nProRv3){//sylee150627
                                                                    break;
                                                                }

                                                */  //sylee170613 

                                                //##############################################################################  //sylee150627

                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block 


										       if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
													   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1
												    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
														nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
													}
													else {
														nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
														nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
													}
												}else{

													if( (ik+1) < ik2 ){//sylee241204-2
													    nFailL1[nFailL1Co][F_AC]=0;
													}else{
													    nFailL1[nFailL1Co][F_AC]=1;
													}
														nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc

                                                    for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
														if ((nFailL1[i5][5] == ( nSQNet1[ik2][ih6] + 1)) && (nFailL1[i5][4] == ( nSQNet1[ik + 1][ih2] + 1))) {  
															nFailL1[i5][F_AC] =0;
															nFailL1[nFailL1Co][F_AC]=0;
														}
													} 

												} 


                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }

                                                t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no   

                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016  //son 18: F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                nShortFlag = 1;//sylee120915
                                                nDebug15 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000){//array size nFailL1[



                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC   

                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }


                                        }   //endof if((nPin1[0]<1)&&(nPin2[0]<1)){ 




                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(27841); //VbCall reset    


                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923

                                                if (Sub71.R1 <= nProRv3) {// ok//HV   line & one
                                                }
                                                else {//fail                    

                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(27854); ///PIN ALL RESET 
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                        AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923

                                                        //####################################################################################//SYLEE150624
                                                        if (Sub71.R1 > nProRv3) {


                                                            int iSum5, iCo5, iSet5;//sylee150627
                                                            iSum5 = 0; iCo5 = 0;//sylee150627


                                                            if (nPinDa1H[1][2][0] < 100) {//sylee150627

                                                                iSet5 = 1;//SYLEETESTMODE-1
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 30;  //sylee150629   20->30
                                                                }
                                                                if (Sub71.R1 < 500) {//sylee150627
                                                                    iSet5 = 10;
                                                                }
                                                            }
                                                            else {
                                                                iSet5 = 1;
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 3;
                                                                }
                                                            }

                                                            for (int k5 = 1; k5 <= iSet5; k5++) {//sylee150627

                                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                                if (k5 == 1) {//sylee150627
                                                                    Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC   
                                                                }

                                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all

                                                                if (k5 == 1) {
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627                                                                    
                                                                }
                                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150627   // hdpark220715, nProRv3 -> nProRv1

                                                                if (Sub71.R1 < 700.) {//sylee150627
                                                                    iSum5 = iSum5 + (int)Sub71.R1;//sylee150627
                                                                    iCo5++;//sylee150627
                                                                }//sylee150627

                                                                if (Sub71.R1 >= 700) {//sylee150627
                                                                    break;
                                                                }


                                                            }//sylee150627

                                                            if (iCo5 > 1) {//sylee150627
                                                                Sub71.R1 = iSum5 / iCo5;//sylee150627
                                                            }//sylee150627

                                                        }



                                                        if (nPinDa1H[1][2][0] < 100) {//sylee150627                                                                                  
                                                            nProRv3 = nProRv0;
                                                        }
                                                        //####################################################################################  //sylee150627
                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one // hdpark220715, nProRv3 -> nProRv1
                                                        }
                                                        else {//fail
                                                            if (Sub71.R1 < nProRv1) {//sylee141001
                                                                for (int ir = 1; ir < 4; ir++) {
                                                                    Sub71.R1 = Sub71.R1 * 1.1;//sylee141001
                                                                    if (Sub71.R1 > nProRv1) {
                                                                        break;
                                                                    }
                                                                }
                                                            }


                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            //sylee151208-1-import      nSQNet1[ik+1][ih2]=nPin1[st1];
                                                            //sylee151208-1-import      nSQNet1[ik2][ih6]=nPin2[st2];                                                                       


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                if(nProOneP_RunFlag1==1){//sylee131221
                                                                    if(nReSheetFlag1!=1){//sylee140429-1
                                                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                                                            nProOneP_RunFlag1=0;
                                                                            goto TaskEnd100;
                                                                        }
                                                                    }
                                                                }
                                                                */

                                                                nFailCount[nMod1] = nFailCount[nMod1]++;

                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                /*//sylee151208-1-import
                                                                    if( nSQNet1[ik+1][ih2]<nSQNet1[ik2][ih6]){
                                                                        nFailL1[nFailL1Co][5]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                        nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                    }else{
                                                                        nFailL1[nFailL1Co][4]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                        nFailL1[nFailL1Co][5]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                    }
                                                                */  


																if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
																	   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1

																	if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
																	}
																	else {//sylee151208-1-import
																		nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
																	}//sylee151208-1-import
																}else{

																	if( (ik+1) < ik2 ){//sylee241204-2
																		nFailL1[nFailL1Co][F_AC]=0;
																	}else{
																		nFailL1[nFailL1Co][F_AC]=1;
																	}

																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc

                                                					   for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
																			if ((nFailL1[i5][5] == (nSQNet1[ik2][ih6] + 1)) && (nFailL1[i5][4] == (nSQNet1[ik + 1][ih2] + 1))) {  
																				nFailL1[i5][F_AC] =0;
																				nFailL1[nFailL1Co][F_AC]=0;
																			}
																		} 

																}  



                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }

                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc

                                                                //sylee151208-1-import  t1=nSQNet1[ik+1][ih2]+1;//PIECE  pin no 
                                                                t1 = nPin1[st1] + 1;//PIECE  pin no  //sylee151208-1-import


                                                                //  }else{
                                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                    //}


                                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314



                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016  //son 18: F_STEP
                                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w


                                                                nShortFlag = 1;//sylee120915


                                                                nDebug16 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000)//array size nFailL1[



                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC 

                                                            //      Sub71.Delay_100ns(30000);//3mSEC  //sylee150904-3 //ace400

                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1){}else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++){ 

                                                }//end if }else{//fail  if( Sub71.R1<=nProRv1){// ok//HV   line & one

                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }



                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++){     


                                        } //end of   if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ){ //vb                                                         




                                    }   //if(nFailFlag4==1){ 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++){  //X   // Second LOOP   vb pin  

                                    //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC(28093);

                                // hdpark221117 Add, VB Mode로 인한 Leak 오류 수정
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                                for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  
                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih3 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                             
                                    /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ik + 1][ih3] + 1;//syloee200714

													//sylee230305 begin
													t1 = nPinToPiece(nSparkTmp); //sylee230305
													if (SysInfo19.m_nUse == 1) {  
													    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                                    }
													if (g_nSkipPieceFlag1 == 1) {    
													    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih3] + 1;//pin  vb

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ik + 1][ih3] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016  //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1); //hdpark220412
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                }// if(ret1==1){

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                                        }//end of  if(nSparkUse==1){

                                    }
                                    //SPARK############################################################################################ 

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih3];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }
                                }

                            }// if(nFailFlag3==1){ 

                            // hdpark220511 spark
                            if (Sub71.m_bModifySparkMeas)
                                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);


                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################


                        }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 


                    //=====================================================================================================================
                    }// end of  if(nFailFlag2==1){   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++){     // FIRST LOOP //Y   //Vc



            }//end of  if(nFailFlag1==1){


            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }


        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB



        //==============================================================================================================================
        //################################################################################################################################

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 








        //================================================================================================================
        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        // Y 
        //세로 

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;
        nRetry1 = 0;    //SYLEE121103  
        nHVDStopTime1 = (long)GetuSecond();//sylee121103

         //sylee170617   Task2Retry:  //SYLEE121103

 	   if(nLeakACMode1==2){//sylee241120 
			nK1Start=0;//sylee241120 
		}else{ 
			nK1Start=1;//sylee241120
		}	

        for (ik = nK1Start; ik < nSQCount1; ik++) {     // FIRST LOOP //Y  VB  //sylee241120

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                nFlag_Spark_PinOn = 1;  //sylee200710-1 NEW_SPARK

            //SYLEE121103  nRetry1=0; 

            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                break;// complete  error                                                 
            }

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);        // 2'nd col pin check

            //SYLEE121103 Task2Retry:

            if ( ik == nK1Start || nSQStep1flag == 2) {   //SYLEE121103   //sylee241204

                //SYLEE121103  if(ik==1  || nSQStep1flag==2  || nRetry1==1){  

                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {
    	              
					if(nLeakACMode1==2){//sylee241120
						if (ik2 ==(ik+1)) {//sylee241120
							continue;//sylee241120
						}//sylee241120						
					}else{//sylee241120
						if (ik2 > ik) {
							continue;
						}
					}
                    for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=1vb

                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////
                        /* //debug
                        Sub71.Delay_100ns(10000); //1ms
                        Sub71.AOnReadV1I1_ADC_I();

                        if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                        Sub71.Delay_100ns(1000); //1ms
                        }
                        */
                        //////////////////////////////////////////////////////////////////////////////////

                    }
                }

                nSQStep1flag = 0;



            }
            else {//end of if(ik==1  || nSQStep1flag==2){


                Sub71.OnPinResetVC(28339);
                //   Sub71.Delay_100ns(100);//10uSEC  

                for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                    if (ih == nSQLastY1) {  //LAST Y STEP
                        if (ik > nSQLastPin) {
                            break;//SKIP   
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ih][ik], 1); //=2VC,  
                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ih][ik];
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    }
                    ///////////////////////////////////////////////////////////////////////////
                    /* //debug
                    Sub71.Delay_100ns(10000); //1ms
                    Sub71.AOnReadV1I1_ADC_I();

                    if( Sub71.R1>1000){// ok//HV
                    // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                    Sub71.Delay_100ns(1000); //1ms
                    }
                    */
                    //////////////////////////////////////////////////////////////////////////////////

                }


                if(nLeakACMode1==2){//sylee241120-3
					for (ih = 1; ih <= nSQLastY1; ih++) {  //X   // Second LOOP   vb pin  
						if (ih == nSQLastY1) {
							if ((ik + 1) > nSQLastPin) {
								break;//SKIP
							}
						}
						Sub71.AOnPinReSet1(2, nSQNet1[ih][ik + 1], 1);  
					  
                        tmp1 = nSQNet1[ih][ik + 1]; //SYLEE241217
                        if (nOpenErrList[tmp1][OPERR_START] > 0) {
                            for (int s1 = nOpenErrList[tmp1][OPERR_START]; s1 <= nOpenErrList[tmp1][OPERR_END]; s1++) {
                                Sub71.AOnPinReSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);    
                            }
                        }

					}
				} 


            }   




            for (ih = 1; ih <= nSQLastY1; ih++) {  //X   // Second LOOP   vb pin  
                if (ih == nSQLastY1) {
                    if ((ik + 1) > nSQLastPin) {
                        break;//SKIP
                    }
                }


                Sub71.AOnPinSet1(2, nSQNet1[ih][ik + 1], 2);   // =1,VB,   all    


                //--------------
                //son SPARK_NEW
                if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                {
                    /////////////////////////////////////////////////////////////////////////////////////////////
                    if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {    //SPARK 
                            ret1 = Sub71.OnSparkStatus();
                            //ret1=0;
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10000);  //1ms  

                                nSparkTmp = nSQNet1[ih][ik + 1] + 1;//syloee200714

                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {  
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {    
                                    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                } //sylee230305 end

                                if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714


                                    if (nFailL1Co < 3000) {////SPARK
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);


                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                        nFailL1[nFailL1Co][5] = nSQNet1[ih][ik + 1] + 1;//pin  vb

                                        // hdpark220511 spark
                                        if (Sub71.m_bModifySparkMeas)
                                            Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                        nSparkTmp = nSQNet1[ih][ik + 1] + 1;//syloee200714
                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                        nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                        t1 = nSQNet1[ih][ik + 1] + 1;//PIECE  pin no    

                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                           nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                        nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                        nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016   //son 18:F_STEP
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                        nShortFlag = 1;//sylee120915

                                        Sub71.OnSparkOn(1); //hdpark220412


                                    }   //end of if(nFailL1Co<3000) //SPARK
                                }

                            }

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                        // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                        if (Sub71.m_bModifySparkMeas)
//<                            Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                    }// end of if(nSparkUse==1)

                /////////////////////////////////////////////////////////////////////////////////////////////////

                }

                //----------------
                //son SPARK_OLD
                else
                {
                    if (nSparkUse == 1)
                    {
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {    //SPARK 
                            ret1 = Sub71.OnSparkStatus();
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                str.Format("Error No 7503,  Spark Detect!  Pin=%d ", nSQNet1[ih][ik + 1] + 1);
                                m_list1.AddString(str);
                                nlist1++;

                                //sylee230305 begin
                                t1  = nSQNet1[ih][ik + 1] + 1;//sylee230305
                                t1 = nPinToPiece(t1);//sylee230305
                                if (SysInfo19.m_nUse == 1) {  
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {    
                                    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                } //sylee230305 end

                                //SPARK############################################################################################

                                if (nFailL1Co < 3000) {////SPARK

                                /*  if(nProOneP_RunFlag1==1){//sylee131221
                                if(nReSheetFlag1!=1){//sylee140429-1
                                if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                nProOneP_RunFlag1=0;
                                goto TaskEnd100;
                                }
                                }
                                }
                                */

                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                    //log buffer
                                    nFailL1Co++;
                                    nFailL1CoPiece++;
                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                    nFailL1[nFailL1Co][5] = nSQNet1[ih][ik + 1] + 1;//pin  vb
                                    nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                    t1 = nSQNet1[ih][ik + 1] + 1;//PIECE  pin no    

                                    //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                    nFailL1[nFailL1Co][9] = nVSet;
                                    nFailL1[nFailL1Co][10] = nISet;
                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                    nFailL1[nFailL1Co][12] = -1;//Sub71.V1;//VB
                                    nFailL1[nFailL1Co][13] = -1;//Sub71.X1;//VC
                                    nFailL1[nFailL1Co][14] = -1;//Sub71.Y1;//I
                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016   //son 18:F_STEP
                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                    nShortFlag = 1;//sylee120915

                                    Sub71.OnSparkOn(1); //hdpark220412


                                    /*//sylee150618
                                    if(nProOneP_RunFlag1==1){//sylee140514
                                    if(nReSheetFlag1!=1){//sylee140514
                                    if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                    nProOneP_RunFlag1=0;
                                    goto TaskEnd100;
                                    }
                                    }
                                    }
                                    */

                                }   //end of if(nFailL1Co<3000){ //SPARK

                                //SPARK############################################################################################  

                                //  Sub71.OnSparkOn(1);
                            }

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 
                    //}
                    }// end of if(nSparkUse==1){
                }

                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ih][ik + 1];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                Sub71.Delay_100ns(10000); //1ms
                Sub71.AOnReadV1I1_ADC_I();
                if( Sub71.R1>1000){// ok//HV
                // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                Sub71.Delay_100ns(1000); //1ms
                }
                */

            }

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);

            //////////////////////////////////////////////////////////////////////////////////

            ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            if (nHVIADCFlag == 1) {
                if (nFastHv1RunStep == 1) {//sylee150415 fasthv                  
                    nFastHv1AdRun = 1;
                }
                else {
                    nFastHv1AdRun = 0;
                }
                //#2-1                 
                if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {//sylee130325  //sylee150407
                    AHV_ADCI_Read1_EST1(nProRv2, nDelay10);  //sylee130107
                }
                else {
                    AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);//sylee150227  //1차 측정 
                }
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv2);
            }


            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
            {

                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                if (nSparkUse == 1) {  //sylee200714-2 ok wait
                    ret1 = Sub71.OnSparkStatus();//sylee200713-
                //ret1=0;
                    if (ret1 == 1) {
                        Sub71.OnSparkOn(0);
                        Sub71.Delay_100ns(10000);  //1ms  
                        Sub71.OnSparkOn(1);
                    }
                }
                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                {
                    //ret1=Sub71.OnSparkStatus();//sylee200713-
                    //if(ret1==1){  

                    if (nFailL1CoPiece < SysInfo05.m_nIsEr) {    //SPARK 
                    //  ret1=Sub71.OnSparkStatus();
                    //  if(ret1==1){
                        Sub71.OnSparkOn(0);
                        Sub71.Delay_100ns(10000);  //1ms  

                        nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1; ;//syloee200714

                        if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714


                            if (nFailL1Co < 3000) {////SPARK

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우  
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                //sylee200724   if(nSparkI1Po2<nSparkMaxY){
                                //sylee200724       nSparkI1Po2++;
                                //sylee200724   } 
                                dSparkI1[nSparkI1Po2][nSparkMaxX + 6] = (float)nSQNet1[nSQLastY1][ik + 1] + 1; //fail  nSQNet1[ih][ik+1]  


                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                //log buffer
                                nFailL1Co++;
                                nFailL1CoPiece++;
                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                //sylee200713   nFailL1[nFailL1Co][5]=nSQNet1[ih][ik+1]+1 ;//pin  vb


                                nFailL1[nFailL1Co][5] = nSQNet1[nSQLastY1][ik + 1] + 1;//pin  vb
                                nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1;//syloee200714
                                nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                t1 = nSQNet1[nSQLastY1][ik + 1] + 1;//PIECE  pin no 

                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                nFailL1[nFailL1Co][9] = nVSet;
                                nFailL1[nFailL1Co][10] = nISet;
                                nFailL1[nFailL1Co][11] = m_nMode1;

                                //hdpark231121.
                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;  // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt    //son241115
                                nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt  //son241115
                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current    //son241115

                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016  //son 18:F_STEP
                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                nShortFlag = 1;//sylee120915

                                Sub71.OnSparkOn(1);  //hdpark220412


                            }   //end of if(nFailL1Co<3000) //SPARK
                        }

                        //  }

                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 
                    //  }

                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                    if (Sub71.m_bModifySparkMeas)
//<                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                }// end of if(nSparkUse==1)



            ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            }

            IADClog1[ip][ik] = Sub71.R1;///logging

            if (nHVIADCFlag == 1) {
                if (Sub71.R1 <= nProRv2) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

               //                   Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
               /* //sylee170617-1
               if( nRetry1==0  && Sub71.R1>=10000 ){
               nRetry1=1;

               //                       Sub71.OnPinResetVB();
               Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
               Sub71.Delay_100ns(2000000);  //200ms

               goto Task2Retry;  //sylee170617-test
               }

               */
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;

                }
            }
            else {
                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //   nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }
                /*//sylee170617-1   ok
                            if( nRetry1==0  && Sub71.R1>=10000 ){
                                nRetry1=1;
                //                    Sub71.OnPinResetVB();
                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                                Sub71.Delay_100ns(2000000);  //200ms

                                goto Task2Retry;  //sylee170617-test
                            }

                */

            }


            if (nFlagEstModelMakeSelect == 2) {//sylee130325    //estimation
                nFailFlag1 = 0;  // ALLPASS
            }

            if (nFastHv1RunStep == 1) {//sylee150415 fasthv 
                if (nFastHv1AdRun == 1) {
                    if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                        nFailFlag1 = 0;  // ALLPASS
                        nFastHv1Piece[ip] = 1;
                        nFastHv1PieceReturn = 1;//sylee150415
                        goto TaskEnd300;
                    }
                }
            }

            //==============================================================================================================================
            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block 

            if (nFailFlag1 == 1) {  //if error

                nDebug21 = 1;//sylee170618-test1 debugcode
                nFastHv1AdRun = 0;//sylee150415 fasthv          
                Sub71.OnPinResetVB(28841);   //sylee121029                

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {     // FIRST LOOP //Y   //Vc                   

                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;

                    //sylee121029   Sub71.OnPinResetVB();
                    //Sub71.Delay_100ns(100);//10uSEC   

				   if(nLeakACMode1==2){//sylee241120-2
						if (ik2 ==(ik+1)) {//sylee241120-2
							continue;//sylee241120-2
						}//sylee241120-2						
					}else{//sylee241120-2
						if (ik2 > ik) { //doublecheck#2 
							continue;
						}
					}

                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                    if (Sub71.m_bModifySparkMeas)
//<                        Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_ON);

                    for (ih = 1; ih <= nSQLastY1; ih++)    //X // Second LOOP   vc pin 
                    {
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=2VC, 

                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }

                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
 //<                   if (Sub71.m_bModifySparkMeas)
 //<                       Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);


                    //=====================================================================================================================

                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 2);//sylee150227     //2차 측정 
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }

                    }


                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv2) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 

                    //=====================================================================================================================
                    //##################################################################################################################################

                    //one line & one line  search


                    if (nFailFlag2 == 1) {

                        nDebug22 = 1;//sylee170618-test1 debugcode

                     //sylee230815   for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 
						   for (int ih6 = 1; ih6 < nSQCount1; ih6++) { //sylee230815 

                            /*//sylee131114
                            if( ik2==nSQLastY1){  //LAST Y STEP
                            if(ih6>nSQLastPin){
                            break;//SKIP
                            }
                            }
                            */

                            if (ih6 == nSQLastY1) {  //LAST Y STEP  //sylee131114
                                if (ik2 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            Sub71.OnPinResetVB(28975);//SYLEE121016***** all reset                                   
                            //  Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1); //=2VC,

                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ih6][ik2];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }

                            //=====================================================================================================================

                            //sylee210205  Sub71.Delay_100ns(10000);//sylee150302   1mS  
                            Sub71.Delay_100ns(nErrorDelay1);//sylee150610


                            if (nHVIADCFlag == 1) {
                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 3);//sylee150227   //3차 측정 
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {


                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                }


                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }


                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }


                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv3) {// ok//HV // hdpark220715, nProRv2 -> nProRv3
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV      // hdpark220715 nProRv2 -> nProRv1
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line  

                            //=====================================================================================================================
                            //################################################################################################################################
                            ///one point  & one point search
                            //$$$$$$$$$$$$$$$$$$$ HV #2-4
                            if (nFailFlag3 == 1) {

                                nDebug23 = 1;//sylee170618-test1 debugcode

                                // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                                if (Sub71.m_bModifySparkMeas)
//<                                    Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_ON);


                                for (int ih2 = 1; ih2 <= nSQLastY1; ih2++) {  //X   // Second LOOP   vb pin  


                                    if (ih2 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    if (ih6 != ih2) {//sylee121025
                                        continue;
                                    }



                                    Sub71.OnPinResetVC(29082); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    if (nErrorDelayFlag1 == 1) {//sylee141002
                                        nErrorDelayFlag1 = 0;//sylee141002
                                        Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ih2][ik + 1], 2);   // =1,VB,   all

                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ih2][ik + 1] + 1;//syloee200714

													//sylee230305 begin
													t1 = nPinToPiece(nSparkTmp); //sylee230305
													if (SysInfo19.m_nUse == 1) {  
													    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                                    }
													if (g_nSkipPieceFlag1 == 1) {    
													    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb

                                                            // hdpark220511 spark
                                                            if (Sub71.m_bModifySparkMeas)
                                                                Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1);     //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                                                    if (Sub71.m_bModifySparkMeas)
//<                                                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                                                }// if(ret1==1){

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                                        }//end of  if(nSparkUse==1){

                                        //SPARK############################################################################################ 

                                    }

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }

                                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                                    if (Sub71.m_bModifySparkMeas)
//<                                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610

                                    if (nHVIADCFlag == 1) {
                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150227   //4차 측정 
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                        }
                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }


                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }
                                    }

                                    //*********************************************//
                                    nHVDStopTime2 = (long)GetuSecond();
                                    nHVDStopTime3 = (nHVDStopTime2 - nHVDStopTime1);
                                    if (nHVDStopTime3 > nHVTimeOutSet) { //15sec
                                        nHVDStopFlag = 1;//sylee121009
                                        Sub71.R1 = 20000;
                                        nFailL1CoPiece = 3000;
                                    }
                                    //************************************************//

								  	if (Sub71.R1 > nProRv1){//sylee241224-2
									    if((int)nProStep1[nMod1][1]>=200000000){//sylee241224-2
										     if( Sub71.R1<(nProRv1*1.10)){//sylee241224-2 
												 nLeakNearFlag1=1;//sylee241226
											     nLeakNearPin1=(nSQNet1[ih2][ik + 1] + 1);//sylee241226
												 nLeakNearPin2=(nSQNet1[ih6][ik2] + 1);//sylee241226
												 Sub71.Delay_100ns(100000);  //10ms 
												 AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1);//sylee241226
												 nLeakNearFlag1=0;//sylee241226
											}
										}
									} 

                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {  // hdpark220715, nProRv3 -> nProRv1
                                        }
                                        else {

                                            nFailFlag4 = 1;
                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ih6][ik2] + 1))) {      // hdpark240109
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ih6][ik2] + 1))) {      // hdpark240109
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }
                                    //===================================================================================================================== 

                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ih6][ik2];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;
                                    }  //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1  


                                    if (nFailFlag4 == 1) {

                                        nDebug24 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;

                                        nErrorDelayFlag1 = 1;//sylee141002
                                        //sylee170620   Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1)) {

                                            if (nFailL1Co < 3000) {//array size nFailL1[                                                                                
                                                /*//sylee150618
                                                if(nProOneP_RunFlag1==1){//sylee131221
                                                if(nReSheetFlag1!=1){//sylee140429-1
                                                    if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                            nProOneP_RunFlag1=0;
                                                            goto TaskEnd100;
                                                    }
                                                }
                                                }
                                                */
                                                //####################################################################################//SYLEE150624   kunshan move

                                                /*//sylee170613 
                                                int iSum5,iCo5,iSet5;//sylee150627
                                                iSum5=0;iCo5=0;//sylee150627


                                                if(nPinDa1H[1][2][0]<100){//sylee150627
                                                iSet5=1;//SYLEETESTMODE-1
                                                if(Sub71.R1<340){//sylee150627
                                                    iSet5=30;   //sylee150629   20->30
                                                }
                                                if(Sub71.R1<500){//sylee150627
                                                    iSet5=10;
                                                }

                                                }else{
                                                iSet5=1;
                                                if(Sub71.R1<340){//sylee150627
                                                    iSet5=3;
                                                }
                                                }

                                                for(int k5=1;k5<=iSet5;k5++){//sylee150627

                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET

                                                if(k5==1){//sylee150627
                                                    Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC
                                                }

                                                Sub71.AOnPinSet1(2,nSQNet1[ih2][ik+1], 2) ;  // =2VC  all
                                                Sub71.AOnPinSet1(2,nSQNet1[ih6][ik2], 1);   // =1,VB,   all

                                                if(k5==1){
                                                Sub71.Delay_100ns(nErrorDelay1);//sylee150627
                                                }
                                                AHV_ADCI_Read1_OneToM(nProRv3,nDelay10);//sylee150627

                                                if(Sub71.R1<700.){//sylee150627
                                                    iSum5=iSum5+(int)Sub71.R1;//sylee150627
                                                    iCo5++;//sylee150627
                                                }//sylee150627

                                                if(Sub71.R1>=700){//sylee150627
                                                    break;
                                                }

                                                }//sylee150627

                                                if(iCo5>1){//sylee150627
                                                Sub71.R1=iSum5/iCo5;//sylee150627
                                                }//sylee150627

                                                if(nPinDa1H[1][2][0]<100){//sylee150627
                                                nProRv3=nProRv0;
                                                }


                                                if( Sub71.R1<=nProRv3){//sylee150627
                                                break;
                                                }


                                                */  //sylee170613 


                                                //##############################################################################  //sylee150627                        

                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece
                                                //  if( ipFlag==1 ){//short   PIECE MULT.

                                                // hdpark220511 spark
                                                if (Sub71.m_bModifySparkMeas)
                                                    Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co; 
						 

												 
									            if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
													   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1

													if (nSQNet1[ih2][ik + 1] < nSQNet1[ih6][ik2]) {//SYLEE130201
														nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//pin  vc
													}
													else {
														nFailL1[nFailL1Co][4] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][5] = nSQNet1[ih6][ik2] + 1;//pin  vc
													}
												}else{

													if( (ik+1) < ik2 ){//sylee241204-2
													    nFailL1[nFailL1Co][F_AC]=0;
													}else{
													    nFailL1[nFailL1Co][F_AC]=1;
													}
														nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//pin  vc

                                                	     for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
															if ((nFailL1[i5][5] == ( nSQNet1[ih6][ik2] + 1)) && (nFailL1[i5][4] == (  nSQNet1[ih2][ik + 1]+ 1))) {  
																nFailL1[i5][F_AC] =0;
																nFailL1[nFailL1Co][F_AC]=0;
															}
														} 

												} 


                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no                                                


                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16

                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;  //SYLEE140929-1
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                nShortFlag = 1;//sylee120915 

                                                nDebug25 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000)//array size nFailL1


                                            Sub71.Delay_100ns(nErrorDelayTime1);//10mSEC   
                                    //TESTSYLEE140929    Sub71.Delay_100ns(10000);//1mSEC   


                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }


                                        }// if((nPin1[0]<=1)&&(nPin2[0]<=1)){ 






                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(29472); //VbCall reset                                                                  
                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610
                                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923

                                                if (Sub71.R1 <= nProRv3) {// ok//HV   line & one    
                                                }
                                                else {//fail
                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(29482); ///PIN ALL RESET 
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923  // hdpark220715, nProRv3 -> nProRv1


                                                        //####################################################################################  //kunshan move 151109
                                                        if (Sub71.R1 > nProRv1) {           // hdpark220715, nProRv3 -> nProRv1
                                                            int iSum5, iCo5, iSet5;//sylee150627
                                                            iSum5 = 0; iCo5 = 0;//sylee150627                                                                                
                                                            if (nPinDa1H[1][2][0] < 100) {//sylee150628

                                                                iSet5 = 1;//SYLEETESTMODE-1
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 30;  //sylee150629   20->30
                                                                }
                                                                if (Sub71.R1 < 500) {//sylee150627
                                                                    iSet5 = 10;
                                                                }
                                                            }
                                                            else {
                                                                iSet5 = 1;
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 3;
                                                                }
                                                            }

                                                            for (int k5 = 1; k5 <= iSet5; k5++) {//sylee150627

                                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                                if (k5 == 1) {//sylee150627
                                                                    Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC   
                                                                }

                                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all


                                                                if (k5 == 1) {
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627                                                                    
                                                                }
                                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150627   // hdpark220715, nProRv3 -> nProRv1

                                                                if (Sub71.R1 < 700.) {//sylee150627
                                                                    iSum5 = iSum5 + (int)Sub71.R1;//sylee150627
                                                                    iCo5++;//sylee150627
                                                                }//sylee150627

                                                                if (Sub71.R1 >= 700) {//sylee150627
                                                                    break;
                                                                }

                                                            }//sylee150627

                                                            if (iCo5 > 1) {//sylee150627
                                                                Sub71.R1 = iSum5 / iCo5;//sylee150627
                                                            }//sylee150627

                                                            //sylee150627   
                                                        }



                                                        if (nPinDa1H[1][2][0] < 100) {//sylee150627                                                                                  
                                                            nProRv3 = nProRv0;
                                                        }
                                                        //####################################################################################




                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one // hdpark220715, nProRv3 -> nProRv1
                                                        }
                                                        else {//fail
                                                       //error loggging

                                                            if (Sub71.R1 < nProRv1) {//sylee141001
                                                                for (int ir = 1; ir < 4; ir++) {
                                                                    Sub71.R1 = Sub71.R1 * 1.1;//sylee141001
                                                                    if (Sub71.R1 > nProRv1) {
                                                                        break;
                                                                    }
                                                                }
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            //sylee151208-1-import        nSQNet1[ih2][ik+1]=nPin1[st1];
                                                            //sylee151208-1-import        nSQNet1[ih6][ik2]=nPin2[st2];                                                                            


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                    if(nProOneP_RunFlag1==1){//sylee131003
                                                                        if(nReSheetFlag1!=1){//sylee140429-1
                                                                            if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                                                    nProOneP_RunFlag1=0;
                                                                                    goto TaskEnd100;
                                                                            }
                                                                        }
                                                                    }
                                                                    */

                                                                if (nSparkUse == 1) {
                                                                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                                        break;// complete  error 
                                                                    }
                                                                }

                                                                nFailCount[nMod1] = nFailCount[nMod1]++;


                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                    /*//sylee151208-1-import
                                                                            if( nSQNet1[ih2][ik+1]<nSQNet1[ih6][ik2]){//SYLEE130201
                                                                                nFailL1[nFailL1Co][5]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                                nFailL1[nFailL1Co][4]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                            }else{
                                                                                nFailL1[nFailL1Co][4]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                                nFailL1[nFailL1Co][5]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                            }
                                                                    */

                                        

                                                               if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
																	   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1
																	if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
																	}
																	else {//sylee151208-1-import
																		nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
																	}//sylee151208-1-import 
																}else{

																	if( (ik+1) < ik2 ){//sylee241204-2
																		nFailL1[nFailL1Co][F_AC]=0;
																	}else{
																		nFailL1[nFailL1Co][F_AC]=1;
																	}
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc

                                                				   for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
																		if ((nFailL1[i5][5] == ( nPin2[st2] + 1)) && (nFailL1[i5][4] == ( nPin1[st1] + 1))) {  
																			nFailL1[i5][F_AC] =0;
																			nFailL1[nFailL1Co][F_AC]=0;
																		}
																   }  

																}   



                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                } 
                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc

                                                                //sylee151208-1-import  t1=nSQNet1[ih2][ik+1]+1;//PIECE  pin no 
                                                                t1 = nPin1[st1] + 1;//PIECE  pin no //sylee151208-1-import 

                                                            //  }else{
                                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                //}

                                                            //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w 

                                                                nShortFlag = 1;//sylee120915 
                                                                nDebug26 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000)//array size nFailL1[



                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC   


                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1){}else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++) 

                                                }//end if else //fail  if( Sub71.R1<=nProRv1)// ok//HV   line & one

                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }


                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++){     


                                        } //end of   if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ){ //vb

                                    }   //if(nFailFlag4==1){ 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++){  //X   // Second LOOP   vb pin  

                                //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC(29721);

                                //     Sub71.Delay_100ns(100);//10uSEC  

                                //SYLEE121107

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_ON);

                                for (int ih3 = 1; ih3 <= nSQLastY1; ih3++) {  //X   // Second LOOP   vb pin  
                                    /*    if(nSQPinCheck[nSQNet1[ik][ih]]==2){
                                    Sub71.AOnReadV1I1_ADC_I();      //debug
                                    if(Sub71.R1>2000){//debug
                                    Sub71.R1=Sub71.R1;//debug
                                    }
                                    }
                                    */
                                    if (ih3 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ih3][ik + 1], 2);   // =1,VB,   all   

                                    if (SysSet13.m_nSparkMode == SPARK_NEW)
                                    {
                                        /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ih3][ik + 1] + 1;//syloee200714

													//sylee230305 begin
													t1 = nPinToPiece(nSparkTmp); //sylee230305
													if (SysInfo19.m_nUse == 1) {  
													    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) {	 continue;	}	//sylee230305
                                                    }
													if (g_nSkipPieceFlag1 == 1) {    
													    if (g_nSkipPieceInfo[t1] == 2) { continue;	}	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ih3][ik + 1] + 1;//pin  vb
                                                            // hdpark220511 spark
                                                            if (Sub71.m_bModifySparkMeas)
                                                                Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ih3][ik + 1] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1);     //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000) //SPARK    
                                                    }

                                                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                                                    if (Sub71.m_bModifySparkMeas)
//<                                                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);
                                                }// if(ret1==1)

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                        }//end of  if(nSparkUse==1)

                                        //SPARK############################################################################################ 

                                    }

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ih3][ik + 1];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }

                                }

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

                            }// if(nFailFlag3==1) 

                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################

                        }//end of for( ih=1; ih<=nSQCount1; ih++)    //X // Second LOOP   vc pin 

                    //=====================================================================================================================
                    }// end of  if(nFailFlag2==1)   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc



            }//end of  if(nFailFlag1==1)



            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }


        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB


        //==============================================================================================================================
        //################################################################################################################################

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

        //      if( nFailL1CoPiece>=SysInfo05.m_nIsEr){   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
        //          break;// complete  error                                                 
        //      }



        //sylee121117-openshortlist
        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        //*******************************************************************************************************************************//
            //Task1:

        int nEnb1;


        if ((nFailL1CoOpen > 0) && (nOpShortLt1[ip][0][0] > 0)) {


            /*
                if(ipFlag==1){
                        nRCount=g_pvBDLData31[1][ip]->size() -1;
                }else{
                        nRCount=nBDLData3[1][0][1];
                }
            */

            if (ipFlag == 1)//sylee180810-1-DUT16
            {
                //nRCount=nBDLData31[dutId][ip][0]; //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                nRCount = (g_pvBDLData31[dutId][ip]->size() - 1);   //son201118: vector구조로 변경
            }
            else
            {
                nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16 //son190704-4WDUT16
            }

            nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
            for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
            {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
                tp1 = i * i;
                if (tp1 >= nRCount) {
                    nSQCount1 = i;//sylee120908
                    break;
                }
            }

            if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
                str.Format("Error No 7513-2 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                return 0;
            }

            ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));


            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            //sylee121117-openshortlist


            int nOpShortPin[100];
            int nSQLastY2, nSQLastPin2, nOpCo, nOpFlag;

            nOpCo = 0;
            nOpFlag = 0;
            ::ZeroMemory(&nOpShortPin, sizeof(nOpShortPin));

            ///====================================================================


            for (ik = 1; ik <= nOpShortLt1[ip][0][0]; ik++) {
                if (ik > nSQCount1) {
                    break;
                }


                if (ik == 1) {
                    nOpShortPin[1] = nOpShortLt1[ip][1][0];
                    nOpCo = 1;
                }
                else {

                    nOpFlag = 0;

                    for (i = 1; i <= nOpCo; i++) {
                        if (nOpShortPin[i] == nOpShortLt1[ip][ik][0]) {
                            nOpFlag = 1;
                        }
                    }

                    if (nOpFlag == 0) {
                        nOpCo++;
                        nOpShortPin[nOpCo] = nOpShortLt1[ip][ik][0];
                    }
                }
            }

            nOpShortPin[0] = nOpCo;


            //==========================================================================
            int tmp3;

            tmp3 = nOpShortLt1[ip][0][0];

            for (ik = 1; ik <= (nOpShortLt1[ip][0][0] + nOpShortPin[0]); ik++) {
                if (ik > nSQCount1) {
                    break;
                }

                if (ik <= nOpShortLt1[ip][0][0]) {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortLt1[ip][ik][1];
                }
                else {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortPin[ik - tmp3];
                }
            }

            nSQLastY2 = nSQLastY1 + 1;

            if (nOpShortLt1[ip][0][0] < nSQCount1) {
                nSQLastPin2 = nOpShortLt1[ip][0][0] + nOpShortPin[0];
            }
            else {
                nSQLastPin2 = nSQCount1;
            }



            //################################################################################################################################
        //SET 


            for (ik = 1; ik <= nRCount; ik++)
            {
                i = (ik - 1) / nSQCount1 + 1;//mok
                j = (ik - 1) - nSQCount1 * (i - 1);//na
                j = j + 1;

                /*
                if( ipFlag==1 ){//short   PIECE MULT.
                   //nSQNet1[i][j]=nBDLData31[1][ip][ik] ; // 1 VB,    =2VC,
                   nSQNet1[i][j]= (*g_pvBDLData31[1][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }else{
                nSQNet1[i][j]=nBDLData3[1][ik][1] ;   // 1  VB,    =2VC,
                }
                */

                if (ipFlag == 1)//sylee180810-1-DUT16
                {
                    //nSQNet1[i][j]=nBDLData31[dutId][ip][ik] ; // 1 VB,    =2VC, //SYLEE180810-1-DUT16    //son-4WDUT16-190704
                    nSQNet1[i][j] = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }
                else
                {
                    nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 //son190704-4WDUT16
                }

                if (ik == nRCount) {
                    nSQLastPin = j;//sylee120908   ///last row , last col.
                    nSQLastY1 = i;
                }
            }



            //#2 second search    hv  adc           
            // 1000 point 



            //################################################################################################################################
            //#1 FIRST-1  Line&Block
            //row

            ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
            nShort2FailFlag1 = 0;
            nSQStep1flag = 0;

            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

            nRetry1 = 0;


            //Task1Retry:


            for (ik = nSQLastY1; ik <= nSQLastY1; ik++) {     // FIRST LOOP //Y  VB 



                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        nEnb1 = 0;

                        for (int ik7 = 1; ik7 <= nOpShortPin[0]; ik7++) {
                            if (nOpShortPin[ik7] == nSQNet1[ik2][ih]) {
                                nEnb1 = 1;
                            }
                        }

                        if (nEnb1 == 0) {
                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,  
                        }


                    }
                }

                nSQStep1flag = 0;


                for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                    if ((ik + 1) == nSQLastY2) {
                        if (ih > nSQLastPin2) {
                            break;//SKIP
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =2,Vc,   all      

                }
                //////////////////////////////////////////////////////////////////////////////////


                if (nHVIADCFlag == 1) {

                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);

                    //  Sub71.R1= dIADC1  ;//ADC
                }
                else {
                    Sub71.Delay_100ns(nDelay10);
                    AHV_ADCI_Read1(nProRv1);
                }

                IADClog1[ip][ik] = Sub71.R1;///logging

                if (nHVIADCFlag == 1) {
                    if (Sub71.R1 <= nProRv1) {// ok//HV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail 
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                    }


                }
                else {

                    if (Sub71.R1 >= nProRv1) {//ok//LV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail

                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        //   nFailFlag1=0;//test
                        nSQStep1flag = 2;
                    }

                }

                //  nFailFlag1=0;  // ALLPASS


                //==============================================================================================================================
                //################################################################################################################################
                //#2,  second search    hv  adc  
                // vc  m block 

                if (nFailFlag1 == 1) {  //if error      



                    Sub71.OnPinResetVB(30172);   //sylee121029  

                    for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //Vc


                        nMSet1Co = 0;
                        nMSet1Flag = 0;
                        nMSet1CoT2 = 0;

                        //sylee121029   Sub71.OnPinResetVB();
                        //  Sub71.Delay_100ns(100);//10uSEC   


                        if (ik2 > ik) { //doublecheck#2 
                            continue;
                        }

                        for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            nEnb1 = 0;

                            for (int ik8 = 1; ik8 <= nOpShortPin[0]; ik8++) {
                                if (nOpShortPin[ik8] == nSQNet1[ik2][ih]) {
                                    nEnb1 = 1;
                                }
                            }

                            if (nEnb1 == 0) {
                                Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                            }

                        }
                        //=====================================================================================================================
                        if (nHVIADCFlag == 1) {
                            //  AHV_ADCI_Read1(nProRv1); 
                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                            //  Sub71.R1= dIADC1  ;//ADC
                        }
                        else {

                            Sub71.Delay_100ns(nDelay10);

                            if (nCC == 2) {//cv
                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                            }
                            else {// cc                                      
                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }

                            }
                            else if (nCC == 2) {//CV   r=(vb/i)
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                }
                            }

                        }

                        //Sub71.Delay_100ns(10000);  
    //=====================================================================================================================
                        nFailFlag2 = 0;
                        if (nHVIADCFlag == 1) {
                            if (Sub71.R1 <= nProRv1) {// ok//HV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }
                        else {
                            if (Sub71.R1 >= nProRv1) {//ok//LV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }//line & line 

                            //=====================================================================================================================
                        //##################################################################################################################################

                        //one line & one line  search


                        if (nFailFlag2 == 1) {

                            for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 


                                if (ik2 == nSQLastY1) {  //LAST Y STEP  nSQLastY1=9  //sylee131114
                                    if (ih6 > nSQLastPin) {//  nSQLastPin=6
                                        break;//SKIP   
                                    }
                                }

                                Sub71.OnPinResetVB(30285);//SYLEE121016***** all reset                                   
                                // Sub71.Delay_100ns(100);//10uSEC   


                                nEnb1 = 0;

                                for (int ik9 = 1; ik9 <= nOpShortPin[0]; ik9++) {
                                    if (nOpShortPin[ik9] == nSQNet1[ik2][ih6]) {
                                        nEnb1 = 1;
                                    }
                                }

                                if (nEnb1 == 0) {
                                    Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=Vb
                                }

                                //=====================================================================================================================


                                if (nHVIADCFlag == 1) {
                                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                    //  Sub71.R1= dIADC1  ;//ADC
                                }
                                else {


                                    Sub71.Delay_100ns(nDelay10);

                                    if (nCC == 2) {//cv
                                        Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                    }
                                    else {// cc                                      
                                        Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                    }


                                    if (Sub71.Y1 < 0.0000001) {
                                        Sub71.Y1 = 0.0000001;
                                    }


                                    if (nCC == 1) { //CC    r= (vb-vc)/i
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                        }

                                    }
                                    else if (nCC == 2) {//CV   r=(vb/i)
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }

                                }

                                nFailFlag3 = 0;
                                if (nHVIADCFlag == 1) {
                                    if (Sub71.R1 <= nProRv1) {// ok//HV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }
                                else {
                                    if (Sub71.R1 >= nProRv1) {//ok//LV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }//line & line 

                                //=====================================================================================================================
                                //################################################################################################################################
                                ///one point  & one point search

                                if (nFailFlag3 == 1) {


                                    for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin  


                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih2 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }

                                        Sub71.OnPinResetVC(30378); //Vb all reset
                                        // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all


                                        if (nHVIADCFlag == 1) {
                                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                            //  Sub71.R1= dIADC1  ;//ADC
                                        }
                                        else {
                                            Sub71.Delay_100ns(nDelay10);
                                            if (nCC == 2) {//cv
                                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                            }
                                            else {// cc                                      
                                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                            }

                                            if (Sub71.Y1 < 0.0000001) {
                                                Sub71.Y1 = 0.0000001;
                                            }


                                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                                }

                                            }
                                            else if (nCC == 2) {//CV   r=(vb/i)
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }

                                        }


                                        nFailFlag4 = 0;
                                        if (nHVIADCFlag == 1) {
                                            if (Sub71.R1 <= nProRv1) {// ok//HV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                            }
                                        }
                                        else {
                                            //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                            if (Sub71.Y1 < 5) {//ok//LV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                            }
                                        }
                                        //=====================================================================================================================


                                        //*****************************************************************************//

                                        if (nFailFlag4 == 1) {

                                            if (nHVIADCFlag != 1) {//sylee20120715==> R READ
                                                //  if( Sub71.Y1< IT1 ){ 

                                                if (nFailL1Co < 3000) {//array size nFailL1[                                 
                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece
                                                    //  if( ipFlag==1 ){//short   PIECE MULT.


                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    //nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                        //nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                                                                       

                                                    //  }else{
                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                    //}

                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                    nShortFlag = 1;//sylee120915 

                                                }   //end of if(nFailL1Co<3000)//array size nFailL1 

                                                    //  Sub71.Delay_100ns(100000);//10mSEC 
                                                    //  Sub71.Delay_100ns(30000);//3mSEC  //sylee150904-3 //ace400

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error                                                 
                                                }
                                            }
                                            else {//if( nHVIADCFlag!=1){//sylee20120715                                                                                  
                                               // ====>  I  ADC  READ                            


                                                if (nFailL1Co < 3000) {//array size nFailL1[

                                                    nFailCount[nMod1] = nFailCount[nMod1]++;

                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece 

                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }


                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }


                                                    //  if( ipFlag==1 ){//short   PIECE MULT.
                                                    //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                    //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                                
                                                    //  }else{
                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                    //}


                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w


                                                    nShortFlag = 1;//sylee120915

                                                }   //end of if(nFailL1Co<3000)//array size nFailL1[

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }


                                            }// END OF  if( nHVIADCFlag!=1)//sylee20120715


                                        }   //if(nFailFlag4==1) 

                                    } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  

                                            //----------------------------------------------------------------------------------------------------------------------

                                    Sub71.OnPinResetVC(30615);
                                    //   Sub71.Delay_100ns(100);//10uSEC   

                                    for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  
                                        /*    if(nSQPinCheck[nSQNet1[ik][ih]]==2){
                                        Sub71.AOnReadV1I1_ADC_I();      //debug
                                        if(Sub71.R1>2000){//debug
                                        Sub71.R1=Sub71.R1;//debug
                                        }
                                        }
                                        */
                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih3 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }
                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                             
                                    }


                                }// if(nFailFlag3==1){ 

                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                    break;// complete  error 
                                }

                                //################################################################################################################################


                            }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 


                            //=====================================================================================================================
                        }// end of  if(nFailFlag2==1){   ///one line & one line  search


                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                            break;// complete  error 
                        }


                        //#2
                    }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++){     // FIRST LOOP //Y   //Vc


                }//end of  if(nFailFlag1==1){

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                    break;// complete  error 
                }


            }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB



        }//if((nFailL1CoOpen>0)&&(nOpShortLt1[ip][0][0]>0)){    



    TaskEnd300://sylee150415 fasthv


        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET

    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   


//TaskEnd100://sylee130927 one-piece//sylee131221





//sylee230825 TaskEnd800://sylee200814


    if (nFastHv1RunStep == 1) {//sylee150415 fasthv   //sylee150428
        if (nFastHv1PieceReturn == 1) {
            nFastHv1RunStep = 2;//sylee150415 fasthv
        }
    }

    tStart1001 = GetuSecond();//SYLEE150426-2

    // Delay_100ns(100000);//10mSEC  ok

    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720

    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704
    Sub71.AOnReadV1Enable1(5);
    Sub71.AIRangeOff();//sylee171204 //ACE400

    if (n4w_Sample_Enable == 1) {//sylee180912-1
        Sub71.OnDisCharge1();
    }


	 nFlagLeakMPin1=0;  //sylee230526  //sylee230817


    //::ShellExecute(NULL,"close","EXCEL.EXE","d:\\LOG\\PRO1\\HVLEAK1.CSV","NULL",SW_SHOWNORMAL);

    nFlag_HV_SetEnd_Skip = 0;//sylee150427    0=idle, 1=skip 
    Sub71.OnPinResetInit();//sylee151221   //ACE400
    tStart322 = GetuSecond();//TESTDEBUG
    tStart323 = (tStart322 - tStart321);//TESTDEBUG

    nPinSetSkipVb = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee160803 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee160803 //ACE400    //son230127 

    if (nDebug11 == 1) {//sylee170618-test1 debugcode
        if (nDebug15 == 1 || nDebug16 == 1) {
        }
        else { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
        if (nDebug12 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
        if (nDebug13 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 

        }
        if (nDebug14 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
    }

    if (nDebug21 == 1) {//sylee170618-test1 debugcode
        if (nDebug25 == 1 || nDebug26 == 1) {
        }
        else { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
        if (nDebug22 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
        if (nDebug23 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
        if (nDebug24 != 1) { 
            nShortRetestFlag1 = 1;//sylee170618-1 
        }
    }

    if (SysInfo05.m_nSp == 1) {//SYLEE171103-1
        if (SysInfo05.m_nSparkSet > 0) {
            Sub71.AOnVBSet1(5, 0); //1~ 100v set 가능   140428            
            Sub71.OnSparkOn(0); ////SPARK ON   //SYLEE130830    1=on   ext ==off     
        }
    }

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
    {
        //OnSparkFileLog1_I(nSparkMaxX+7, nSparkMaxY); //sylee200710  //all log
        if (g_nSpark1_Use == 1) {//SYLEE200721 
            On_SparkFileLog1_I(nSparkMaxX + 8, nSparkI1Po2); //sylee200710  //ng log
        }
        Sub71.OnSparkADC(0);//SYLEE200714
    //  On_SparkFileLog1_V(29,1000); //sylee200710
        nFlag_Spark_PinOn = 0; //sylee200710-1
    }

    nFlag_LeakDischarge1 = 0;//sylee200916
    nFlagLeakMPin1=0;  //sylee230526  //sylee230817

    return 1;

}


//SYLEE121028  DEFINE 
//son    nMod1      0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV)
//                  5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W
//son  m_nMode1     Calibration Mode
//son  nProRv1      raw RValue
//son  nPStep1      현재 test 진행 step 
//son  nProType     1:multi piece,  2:one piece
//
//son  return       0: HW error   1: Pass 
//hdpark230323 AC LEAK
int CChildView7::ARun201_S2_SQ2_HV_Re_VB1_AC(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
{
    /// debug code
    Sub71.fpLeak = NULL; // fopen("D:\\leak.log", "a+t");   //hdpark230425


    ////

    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];
    int n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1, nHVIADCFlag, nDischargeCount, nShRes1T;
    int ih, logno1, nSQCount1, nSQLastY1, nSQLastPin, tp1, t1;
    int nFailFlag1, nFailFlag2, nFailFlag3, nFailFlag4, nRetry1;

    int nSQ1Fail[200], nSh1Ret1[100], dPinVC[200], dPinVB[200];
    //son210401  100 -> MAX_SQUARE_N(200)  : Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
    int nSQNet1[MAX_SQUARE_N][MAX_SQUARE_N];// pin array//sylee120908

    double nISet, dVbR1, dVbR2, InterI;
    double nT[10];
    double nData[130][15], dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200];

    int nMSet1Flag, nMSet1Co, nMSet1CoT2, nSQStep1flag;
    int nIFilter, nHVOffSet, nHVGain, nDelayTime2, nIControl, tmp1, tmp2, Co, nHVTimeOutSet;
    int nPin1[1000], nPin2[1000];

    int nEstUse, nEt_StepSumTemp, ret1, nSparkUse, nErrorDelayTime1;
    int nProRv2, nProRv3, nProRv0, nErrorDelayFlag1, nErrorDelayTime2;//sylee141002 
    int nIGain, nErrorDelay1;//sylee150610 kushan


    int nDebug11;       //son 처음검사  (Y 방향)
    int nDebug12;       //son 두번째 검사
    int nDebug13, nDebug14, nDebug15, nDebug16;//sylee170618-test1 debugcode
    int nDebug21;       //son 처음검사 (X 방향)
    int nDebug22, nDebug23, nDebug24, nDebug25, nDebug26;//sylee170618-test1 debugcode

    int nSparkset;      //sylee200714 NEW_SPARK
    short nSparkFailNo[Def_SwitchMaxPin];//sylee200714 NEW_SPARK


   if (nMod1 == TEST_LEAK2 ){     
       nLeakMode1=TEST_LEAK2;//sylee230822
   }
   else{  
       nLeakMode1=TEST_LEAK1;} //sylee230822}

	nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    nSparkIPlus1 = 0;//SYLEE201027
    nFlag_LeakDischarge1 = 0;//sylee200916-1
    //son220927 if (nMod1 == 5 || nMod1 == 6) //sylee200916-1
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2) //sylee200916-1     //son220927
    {
        //  if(nProStep1[nMod1][1]>20000000){
        nFlag_LeakDischarge1 = 1;
        if (nMod1 == TEST_LEAK2) {  //son 6:TEST_LEAK2
            nLeakDischarge1AD0 = nLeakDischarge1AD2;
        }
        else {
            nLeakDischarge1AD0 = nLeakDischarge1AD1;
        }
        if (nLeakDischarge1AD0 < 300) {
            nLeakDischarge1AD0 = 300;
        }
        //  }
    }

    //sylee170725 
    nDebug11 = nDebug12 = nDebug13 = nDebug14 = nDebug15 = nDebug16 = 0;//sylee170618-test1 debugcode
    nDebug21 = nDebug22 = nDebug23 = nDebug24 = nDebug25 = nDebug26 = 0;//sylee170618-test1 debugcode

    if (SysSet13.m_nSparkMode == SPARK_NEW)
    {
        //////////////////////////////////////////////////////////////////////////////////
        nSparkV1Po2 = 0;//sylee200710 NEW_SPARK
        nSparkI1Po2 = 0;//sylee200710 NEW_SPARK
        nFlag_Spark_PinOn = 1;  //sylee200710-1 
        ::ZeroMemory(&dSparkV1, sizeof(dSparkV1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI1, sizeof(dSparkI1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI12, sizeof(dSparkI12));//sylee200710 NEW_SPARK
        ::ZeroMemory(&nSparkFailNo, sizeof(nSparkFailNo));//sylee200710 NEW_SPARK

        nSparkMaxY = 500;//sylee200710 NEW_SPARK


        if (SysSet19.m_nSet34 <= 0) {
            nSparkMaxX = 20;  //sylee200710   //MAX =50  NEW_SPARK
        }
        else {
            nSparkMaxX = SysSet19.m_nSet34;
            if (nSparkMaxX > 100) {
                nSparkMaxX = 100;
            }
        }
        nSparkGapMin = nSparkMaxX;
        nSparkMaxXSet = nSparkMaxX;//sylee210430

        if (SysSet19.m_nSet35 <= 0) {
            nSparkHWoffSet1 = 1;
        }
        else {
            nSparkHWoffSet1 = SysSet19.m_nSet35;
            if (nSparkHWoffSet1 > 500) {
                nSparkHWoffSet1 = 500;
            }
        }
    }

    Sub71.OnRelay4W_OFF1();  //SYLEE181118

    // nProType=1;//sylee170617-3 test 

    if (nProOneP_Flag1 == 3 && nProType == 2) {//sylee170306-1
        nProType = 3;
    }
    if (nReSheetFlag1 == 1) { //sylee171011-1 //resheet
        nProType = 1;
    }
    ////////////////////////////////////////////////////////////////////////////
    ////sylee160807-1     

    int  nRunFlag1_HvShort1;


    nShort_Flag1 = __HV; //1:__LV  2:__HV  //sylee161026

    nRunFlag1_HvShort1 = 0;

    ipEnd = 0;
    int dutId = getDutId();     //son190704 nMulNetFlag = dutId
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)       //son220927  nMod1 5:TEST_LEAK1, 6:TEST_LEAK2
    {
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId]; //SYLEE180810-1-DUT16  //son190704-4WDUT16

        if (g_nPieceMax1 >= 1) {//PIECE
            ipEnd = g_nPieceMax1;
        }
    }

    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {

        //sylee170807-5 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-5
        {

            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) {
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                    continue;
                }
            }

		/*//sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex   open &short
                if (nManualStartFlag != 1) {
                    if (gRun05.m_nReCh > 0) {
                        if (nOpenSetFlag1 == 1) {
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {
                                if (nReFlagOpenCur[ip3] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {

                                if (nReFlagOpenOld[ip3] == 1) {
                                    continue;
                                }
                            }
                        }
                    }
                }

         
            } else {//syle170725-3
			*/ //sylee230420 
            if (nReFlagOpenOld[ip3] == 1) {///syle170725-3
                continue;
            }
           //sylee230420  }
            if (nShortFail1[ip3] > 0) {
                continue;
            }

    //sylee230420  if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip3] == 1) {//sylee171120-1 
                continue;
            }//sylee171120-1
    //sylee230420    }

        }// if(nProType!=2){    //sylee170614-1

        nRunFlag1_HvShort1++;   //son HV Short 개수 카운트

    }

    if (nRunFlag1_HvShort1 < 1) {
        return 1;
    }



    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127

    nErrorDelay1 = 0;//sylee210205      3ms-> 0      //30000;//sylee150610  kushan 3mS

    tStart321 = GetuSecond();//TESTDEBUG


    //Sleep(1000);
    //return 1;//allpassing

    nRunMode_HV_LV = 1;//SYLEE150417-5  1= HV, 2=LV
    nErrorDelayTime1 = 1000;//1mS//sylee141001
    nErrorDelayTime2 = 100000;//500mS//sylee141002  //sylee150331  200mS->10ms =>   ok함 
    nErrorDelayFlag1 = 0;//sylee141002

    nProRv2 = (int)(nProRv1 * 1);
    nProRv3 = (int)(nProRv1 * 1); //sylee141001

    if (nProRv3 < 10) { //sylee141001
        nProRv3 = 10;
    }


    nProRv0 = (int)nProRv1;//sylee150627

    if (nPinDa1H[1][2][0] < 100) {//sylee150627
        nProRv0 = (int)nProRv1;//sylee150627 
    }

    nEstUse = 0;  nFileCount = 0;
    logno1 = 0;   nShRes1T = 0; nStop = 0;  ipFlag = 0;
    n4Wire = 0;   nIControl = 0;
    nDelayTime2 = 20000;//sylee130716
    ipEnd = 1;//PIECE
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode    
    nDischargeCount = 20;//sylee2012083
    nHVIADCFlag = 1;//test


    nHVTimeOutSet = DEFINE_HVTIMEOUT1 * 3;

    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nSh1Ret1, sizeof(nSh1Ret1));
    ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));//sylee120907
    ::ZeroMemory(&IADClog1, sizeof(IADClog1));//sylee120907

    if (nFastHv1RunStep == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nFastHv1Piece, sizeof(nFastHv1Piece));//sylee150415
        nFastHv1PieceReturn = 0;//sylee150415
    }

    //sylee170411   if(SysSet13.m_nSet19==1){//sylee150417-1 
    if (SysInfo05.m_nProSpMode == 2 || SysInfo05.m_nProSpMode == 3 || SysInfo05.m_nProSpMode == 4) {   //sylee150417-1 
        if (SysSet16.m_nSet11 == 1) {//sylee130325  //sylee130404   //estimation
            if (nFlagEstModelMake == 1 && nFlagEstModelMakeSelect == 2) {
                nEstUse = 1;//sylee130325
            }
            else if (nFlagEstModelMake == 3) {
                nEstUse = 1;//sylee130325
            }
            if (nOpenUse1 != 1) {//sylee150627
                nEstUse = 0;
            }
            if (nEstUse == 1) {//sylee130325
                nEt_LogCount++;//sylee130219jo   ytech estimation
            }
        }
        nFileCount = 0;//sylee130219joytech-estimation
    }
    //sylee170411   }

    if (SysSet15.m_nSet1 < 1 || SysSet15.m_nSet2 < 1 || SysSet15.m_nSet3 < 1) {
        AfxMessageBox("  Maker Engineer Call!  HV 100M,50M,20M  DATA<1? ,   PROCESS SET  PARAMETOR   FILE LOAD ERROR!.  ERROR NO 5001 ,PROCESS FAIL. STOP. ", MB_OK);
    }


    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     
    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
    if( nFlagLeak12==1  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1  //sylee230807
	    nVRel=4; 
	}
 	if( nFlagLeak12==2  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1 //sylee230807
	    nVRel=4; 
	}
#endif  //son231122


    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123          

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
    {
        dSparkLeakSet1 = nVSet / nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_I = (double)nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_V = (double)nVSet;
    }

    if (nVSet > 20) {//SYLEE141211
        if (nIR == 1) {
            AfxMessageBox("  Error  No 7101.  HV leak Mode,    I Range Mode 1 Use error.   Call bioptro! ", MB_OK);
            return 0;
        }
    }

    if (nProRv1 < 10) { //sylee141001
        nProRv1 = 10;
    }

    // hdpark230105 Spark begin
    if (Sub71.m_bSparkVerification)
    {
        if (nVSet < 250)
        {
            CString strMsg = "This voltage is not valid for spark validation voltage(250V)!";
            AfxMessageBox(strMsg);
            return 1;
        }
    }
    // hdpark230105 end

    // hdpark220715 begin
    if (nVSet >= 100.0) // 100 V 이상
    {
        nProRv2 = g_nProRv2[nMod1];  // hdpark220715, Cal 허용 편차 10 % 적용
        nProRv3 = g_nProRv3[nMod1];  // hdpark220715, Cal 허용 편차  5 % 적용
    }
    else
    {
        nProRv2 = nProRv1;
        nProRv3 = nProRv1;
    } // hdpark220715 end

    if (nVSet <= 50) {
        nICheckSet = 3;
    }
    else if (nVSet <= 100) {
        nICheckSet = 5;
    }
    else if (nVSet <= 150) {
        nICheckSet = 10;
    }
    else {
        nICheckSet = 20;
    }
    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7710, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }

    Sub71.nADCount1 = (int)dRec[m_nMode1][7];

    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock  
    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 1024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 


    Lo1 = 2000; //sylee200915  100->1000



Task101:

    Sub71.AOnReadVB1Run1(nVRel);


    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;


    if (Simulator100 != 7) {
        if (Sub71.V1 > 300) {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();
            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1301,\n\n  고압전압 설정안되었습니다. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1301,\n\n   high voltage power set error. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }
            return 0;
        }

#ifdef _PC_TEST_
        Sub71.V1 = nVSet;       //son220927 PC_TEST에서 HW Check 에러 무시하기 위함.
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2)
        {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();

            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1313,\n \n\n 전압 설정이 안되었습니다.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1313,\n \n\n high voltage power  set  error.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            return 0;
        }
    }



    Sub71.FilterSet(nFil);//sylee130628 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on     
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.On4W_GainSet(1);
    Sub71.AOnReadV1Enable1(nVRel);
    Sub71.OnPinAllReset1(); //SYLEE150120
    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);
    //sylee170427    Sub71.Delay_100ns(100000); //10mS  //sylee151203  
    Sub71.Delay_100ns(50000); //10->5mS  //sylee170427 
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118

    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    //sylee140923   if( nMod1==2 || nMod1==3 || nMod1==4 || nMod1==5 )
    //son220927 if (nMod1 == 5 || nMod1 == 6)
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)   //son220927
    {
        nRCount = nBDLData3[dutId][0][1];       //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];  //SYLEE150920

        if (g_nPieceMax1 > 1) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }
    }
    else {
        str.Format("Error No 7213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }

    nEt_StepSumTemp = 0;  //sylee130410



//=============================================================================================

    int  nDisable, nDisable2, nDisable3, ipEnd2;//sylee150611
    nDisable = 0; nDisable2 = 0; nDisable3 = 0;

    ipEnd2 = ipEnd;//sylee150611

    if (nProOneP_RunFlag1 == 1)
    {
        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
        {
            for (int ip2 = 1; ip2 <= ipEnd2; ip2++) {
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {
                    if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {
                        nDisable = 1;
                    }
                }
            }

            if (nReSheetFlag1 != 1) { //sylee150611 
                if (nDisable == 0) {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0) {
                        if (nProType == 2 || nProType == 3) {//SYLEE130916  //i mode   running 
                            ipEnd = 1;
                            ipFlag = 0;
                            nHVIADCFlag = 1;
                        }
                    }
                }
                if ((ipFlag == 0) && (nProType != 0)) {//SYLEE131003
                    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
                }
            }

        }
    }

    nSparkset = 0;
    //son NEW_SPARK
    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200909 SPARK_NEW
    {
        if (SysInfo05.m_nSp == 1) {
            nSparkRefV = SysInfo05.m_nSparkSet;//sylee200808 NEW_SPARK
            g_nSpark1_Use = 0;//SYLEE200721 NEW_SPARK

            double dSetVolt = nSparkHWoffSet1 + nSparkRefV;
            nSparkUse = SetSparkDetectionVolt(dSetVolt);
        }

    }
    //son OLD_SPARK
    else
    {
        if (SysInfo05.m_nSp == 1) {
            if (SysInfo05.m_nSparkSet > 0) {
                Sub71.AOnVBSet1(5, SysInfo05.m_nSparkSet); //1~ 100v set 가능   140428    
                Sub71.OnSparkOn(0);  //SYLEE200623-2
                Sub71.Delay_100ns(10000); //sylee200623 -2
                Sub71.OnSparkOn(1); ////SPARK ON   //SYLEE130830    1=on   ext ==off     
                nSparkUse = 1;
            }
        }
    }

    //====================================================================================================================================
    if (ipEnd == 1) {//sylee150615-import
        nAHV_EST1_MODEL_TYPE1 = 2;//sylee150615-import
    }
    else {
        nAHV_EST1_MODEL_TYPE1 = 1;//sylee150615-import
    }

    if (nAHV_EST1_MODEL_TYPE2 == 2 && ipEnd != 1) {//sylee150615-import nAHV_EST1_MODEL_TYPE2=2;  one piece
        if (nEstUse == 1) {
            nEstUse = 0;
        }
        //est giveup
    }

    //====================================================================================================================================


    //====================================================================================================================================
    for (int ip = 1; ip <= ipEnd; ip++)
    {
        if (ipEnd != 1) {  //sylee160203-ITS
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS       //son220624
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece    <=============      //son220624
                    continue;
                }
            }
        }

        //sylee170807-6 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-6
        {

            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                    continue;
                }
            }

			/* //sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex
                if (nManualStartFlag != 1) {//SYLEE130221JOYTECH SETUP PRESS
                    if (gRun05.m_nReCh > 0) {//sylee121129
                        if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {//sylee121129 
                                if (nReFlagOpenCur[ip] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {
                                if (nReFlagOpenOld[ip] == 1) {
                                    continue;
                                }
                            }
                        }
                    }

                }//end if(nManualStartFlag!=1){//SYLEE130221JOYTECH SETUP PRESS

            }else {//syle170725-3
			*/ //sylee230420 
                if (nReFlagOpenOld[ip] == 1) {//syle170725-3  //SYLEE171120-2  IP3->IP
                    continue;
                }
            //sylee230420 }
            if (nShortFail1[ip] > 0) {//sylee120921
                continue;
            }

          //sylee230420   if (SysSet13.m_nSet18 == 1) {
                if (nPass2[ip] == 1) {//sylee171120-1   
                    continue;
                }//sylee171120-1
           //sylee230420  }


        }//sylee170614-1  

        if (nOpenErrFlag[ip] == 1) {//move
            nOpenErrFlag[ip] = 2;
        }


        //   nCellNo= nBlockPieceNo1[nBlockCountP][ip];//nBlockPieceNo1[blockno][pieceno]==CELLNO
        //   if(nBlockRes[nCellNo]==BLOCK_RES_PASS || nBlockRes[nCellNo]==BLOCK_RES_OPEN){////0=init,  1=pass,2=open, 3 short, 4=o +s,7 기타 error

        //   if(nBlockRes[nCellNo]!=0){////0=no test,  1=pass,2=open, 3 short, 4=o +s,7 기타 error
        //       continue;
        //   }

        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;
        nECount = 0;
        nFailL1CoPiece = 0;
        nEt1 = 0;
        nShort2FailFlag1 = 0;

        //*******************************************************************************************************************************//
        //Task1:

        if (ipFlag == 1)
        {
            nRCount = (g_pvBDLData31[dutId][ip]->size() - 1); //SYLEE180810-1-DUT16 //son190704-4WDUT16

        }
        else {
            nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16 //son190704-4WDUT16
        }

        nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
        for (int i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
        {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
            tp1 = i * i;
            if (tp1 >= nRCount) {
                nSQCount1 = i;//sylee120908
                break;
            }
        }

        //sylee170327-import  interlock
        if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
            //  if( (nSQCount1==0) ){//sylee170327-1 import
            str.Format("Error No 7513-1 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }

        ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));

		// hdpark230323
		for(int ir = 0; ir < MAX_SQUARE_N; ir++)
		{
			for(int ic = 0; ic < MAX_SQUARE_N; ic++)
			{
				nSQNet1[ir][ic] = -1;
			}
		}

        //################################################################################################################################
        //SET 
        int nTmpPinNo1; //sylee160728-2


        for (int ik = 1; ik <= nRCount; ik++)
        {

            int i = (ik - 1) / nSQCount1 + 1;//mok
            int j = (ik - 1) - nSQCount1 * (i - 1);//na

            j = j + 1;

            //son ipFlag로 멀티 piece인지 파악. nProType만 갖고 체크하지 않는다.
            if (ipFlag == 1) {//short   PIECE MULT.     
                nTmpPinNo1 = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin; // 1 VB,    =2VC,   //SYLEE180810-1-DUT16   //son190704-4WDUT16
            }
            else {
                nTmpPinNo1 = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16    //son190704-4WDUT16
            }


            for (int jk1 = 1; jk1 <= nOpen2Li1[ip][0][0]; jk1++) {//sylee160801-3
                if (nTmpPinNo1 == (nOpen2Li1[ip][jk1][0])) {    //sylee160816-1
                    nTmpPinNo1 = nOpen2Li1[ip][jk1][1]; //sylee160816-1
                }//sylee160728-2
            }//end of for( int jk1=1; jk1<=nOpen2Li1[ip2][0][0]; jk1++){

            nSQNet1[i][j] = nTmpPinNo1; //sylee160801-3

            if (ik == nRCount) {
                nSQLastPin = j;//sylee120908   ///last row , last col.
                nSQLastY1 = i;
            }
        }

        //sylee151109-3  if(SysSet13.m_nSet18!=1){//sylee150508  2n est
        if (nFlagEstModelMake == 1) {//sylee151109-2
            nEt_StepSumTemp = nEt_StepSumTemp + (nSQLastY1 - 1) + (nSQCount1 - 1);  //sylee130410 
            if (ip == ipEnd) {
                nEt_StepSum = nEt_StepSumTemp;//sylee130410
            }
        }
 
        int iktmp, ikok;
        iktmp = 0; ikok = 0;

        if (nProOneP_RunFlag1 == 1)
        {
            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
            {
                if (nProType == 3)
                {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0)
                    {
                        for (ik = 1; ik <= nRCount; ik++)
                        {
                            ikok = 0;
                            for (int k1 = 1; k1 <= nProOneP_Short1[0]; k1++)
                            {
                                //SYLEE180810-1-DUT16   //son190704-4WDUT16
                                if ((nProOneP_Short1[k1] + 1) == (nBDLData3[dutId][ik][1] + 1)) {
                                    ikok = 1;
                                }
                            }
                            if (ikok == 0)
                            {
                                iktmp++;
                                int i = (iktmp - 1) / nSQCount1 + 1;//mok
                                int j = (iktmp - 1) - nSQCount1 * (i - 1) + 1;//na                    

                                //son190704-4WDUT16
                                nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 
                                nSQLastPin = j;
                                nSQLastY1 = i;
                            }


                        }
                    }
                }
            }
        }

        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        //row

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));

        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
        nRetry1 = 0;//SYLEE121103

        nHVDStopTime1 = (long)GetuSecond();//sylee121103


        //hdpark220511 spark begin
        if (Sub71.m_bModifySparkMeas)
        {
            Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);
            Sub71.SetVBReadMode();
        }
        // spark end

        if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n ################################################################ \n");


        for (int col = 1; col <= nSQLastY1; col++)
        {
            for (int row = 1; row <= nSQLastY1; row++)
            {
                if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "%5d ", nSQNet1[col][row] + 1);
            }
            if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n");
        }
        if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n");

        // hdpark230228
        int nMaxRowSQ = 0, nMaxColSQ = 0;
        int nSparkTmp = 0;

        for (int iWay = 0; iWay < 2; iWay++)    // row , col
        {
	        if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n [%d] *************************************************************** \n", iWay);

            if (iWay == 0)    // row
            {
                nMaxRowSQ = nSQLastY1;
                nMaxColSQ = nSQCount1;
            }
            else            // col
            {
                nMaxRowSQ = nSQCount1;
                nMaxColSQ = nSQLastY1;
            }

            for (ik = 1; ik <= nMaxRowSQ; ik++)
            {
                if (SysSet13.m_nSparkMode == SPARK_NEW)
                    nFlag_Spark_PinOn = 1;

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr)   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                {
                    break;
                }

                // all pin reset 후 vb pin 설정 할 row를 제외한 모든 pin을 vc로 설정.
                Sub71.OnPinAllReset1(__LINE__);

                for (int ik2 = 1; ik2 <= nMaxRowSQ; ik2++)
                {
                    if (ik2 == ik)	continue;	// vb row or col 제외

                    // hdpark220511 spark
                    if (Sub71.m_bModifySparkMeas)
                        Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_ON);

                    for (ih = 1; ih <= nMaxColSQ; ih++)
                    {
						if (iWay == 0)
						{
							if (ik2 == nMaxRowSQ)
							{
								if (ih > nSQLastPin)	break;
							}

							Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); // vc set
						}
						else
						{
							if (ih == nMaxRowSQ)
							{
								if (ik2 > nSQLastPin)	break;
							}

							Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); // vc set
						}


                        nPinSetSkipVbCnt++;                 //son230127
                        if (nPinSetSkipVbCnt == 1) {        //son230127
                            nPinSetSkipVb = 3;              //son230127
                        }

                        if (nOpenErrFlag[ip] == 2) {
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++)
                                {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);
                                }
                            }
                        }
                    }
                    if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, " 0 - %d \n", iWay);
                }

                nSQStep1flag = 0;

                if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, " 1 - %d \n", iWay);

                for (ih = 1; ih <= nMaxColSQ; ih++)
                {
                    if (iWay == 0) {
                        if (ik == nMaxRowSQ)
                        {
                            if (ih > nSQLastPin)
                            {
                                nSparkTmp = nSQNet1[ik - 1][1] + 1;  // pin 이 없을 경우가 발생할 수 있음.
                                break;
                            }
                        }

						Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 2);   // vb set
                        nSparkTmp = nSQNet1[ik][ih] + 1;

                    }
                    else {
                        if (ih == nMaxRowSQ)
                        {
                            if (ik > nSQLastPin)
                            {
                                nSparkTmp = nSQNet1[1][ik - 1] + 1;
                                break;
                            }
                        }

						Sub71.AOnPinSet1(2, nSQNet1[ih][ik], 2);   // vb set
                        nSparkTmp = nSQNet1[ih][ik] + 1;
                    }

                    nPinSetSkipVcCnt++;                     //son230127
                    if (nPinSetSkipVcCnt == 1) {            //son230127
                        nPinSetSkipVc = 3;                  //son230127
                    }

                    if (SysSet13.m_nSparkMode == SPARK_NEW)
                    {
                        if (nSparkUse == 1 && nSparkDetect1 == 1)
                        {
                            if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                            {
                                ret1 = Sub71.OnSparkStatus();

                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                } //sylee230305 end

                                if (ret1 == 1)
                                {
                                    Sub71.OnSparkOn(0);
                                    Sub71.Delay_100ns(10000);
                                    //nSparkTmp = nSQNet1[ih][ik] + 1;
                                    if (nSparkFailNo[nSparkTmp] != 1)
                                    {
                                        if (nFailL1Co < 3000) {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                            nFailL1Co++;
                                            nFailL1CoPiece++;
                                            nSparkFailNo[nSparkTmp] = 1;
                                            t1 = nSparkTmp;
                                            t1 = nPinToPiece(t1);
                                            nFailPiece[t1][nPStep1]++;
                                            nShortFail1[t1]++;
                                            nShortCo1Spark[nBlockCountP][t1]++;
                                            nShortFail1Flag1 = 1;
                                            nShortFlag = 1;
                                            Sub71.OnSparkOn(1);
                                            Sub71.Delay_100ns(1000);

                                            ResultSpark(nSparkTmp, t1, nMod1, nPStep1, nProRv1, nISet, m_nMode1);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (nOpenErrFlag[ip] == 2)
                    {
                        if (iWay == 0)  tmp1 = nSQNet1[ik][ih];
                        else            tmp1 = nSQNet1[ih][ik];

                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++)
                            {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2);
                            }
                        }
                    }
                }

                // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                    Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_OFF);

                //////////////////////////////////////////////////////////////////////////////////



                if (nHVIADCFlag == 1)
                {
                    if (nFastHv1RunStep == 1) {
                        nFastHv1AdRun = 1;
                    }
                    else {
                        nFastHv1AdRun = 0;
                    }

                    if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {
                        AHV_ADCI_Read1_EST1(nProRv2, nDelay10);
                    }
                    else {
                        AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);
                    }
                }
                else {
                    Sub71.Delay_100ns(nDelay10);
                    AHV_ADCI_Read1(nProRv2);
                }

                if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                {
                    ret1 = Sub71.OnSparkStatus();
                    if (ret1 == 1)
                    {
                        nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121//hdpark230712 waiting에서 spark 검출,  
                                                                    // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                        Sub71.OnSparkOn(0);
                        Sub71.Delay_100ns(10000);  //1ms  
                        Sub71.OnSparkOn(1);
                        if (Sub71.fpSpark)
                            fprintf(Sub71.fpSpark, ", @, %d, %d, %.1f, %.1f \n", nSparkTmp, iWay, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                    }
                    else
                    {
                        nSpark1_Detect2 = 0; //hdpark230705
                    }

                    if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                    {
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                        {
                            //sylee230305 begin
                            t1 = nPinToPiece(nSparkTmp); //sylee230305
                            if (SysInfo19.m_nUse == 1) {
                                if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                            }
                            if (g_nSkipPieceFlag1 == 1) {
                                if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                            } //sylee230305 end

                            if (nSparkFailNo[nSparkTmp] != 1)
                            {
                                srand((unsigned int)time(NULL));
                                double dTemp1 = (rand() % 3);					// ~ 3 V

                                if (nFailL1Co < 3000)
                                {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                    //log buffer
                                    nFailL1Co++;
                                    nFailL1CoPiece++;
                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                    nFailL1[nFailL1Co][5] = nSparkTmp;//pin  vb

                                    nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                    nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                    t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                    //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                    ////////////////////////////////////////////////////////////////////////////////
                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                    nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                    //////////////////////////////////////////////////////////////////////////////////////
                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                    nFailL1[nFailL1Co][9] = nVSet;
                                    nFailL1[nFailL1Co][10] = nISet;
                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                    // hdpark231121 
                                    nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                    nFailL1[nFailL1Co][13] = nVSet;                 // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                    nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                    nShortFlag = 1;//sylee120915
                                }   //end of if(nFailL1Co<3000) //SPARK    
                            }

                            //  }// if(ret1==1)

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                    }//end of  if(nSparkUse==1)
                }

                IADClog1[ip][ik] = Sub71.R1;

                if (nHVIADCFlag == 1) {
                    if (Sub71.R1 <= nProRv2) {// ok//HV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail

                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        nSQStep1flag = 2;

                    }
                }
                else {
                    if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        nSQStep1flag = 2;
                    }
                }


                if (nFlagEstModelMakeSelect == 2) {//sylee130325    //estimation
                    nFailFlag1 = 0;  // ALLPASS
                }

                if (nFastHv1RunStep == 1) {//sylee150415 fasthv 
                    if (nFastHv1AdRun == 1) {
                        if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                            nFailFlag1 = 0;  // ALLPASS
                            nFastHv1Piece[ip] = 1;
                            nFastHv1PieceReturn = 1;
                            goto TaskEnd300;
                        }
                    }
                }

                //==============================================================================================================================
                //################################################################################################################################
                //#2,  second search    hv  adc  
                // vc  m block 

                // vb row는 이미 설정되어 있으므로  vc row를 설정 후 측정.  
                if (nFailFlag1 == 1) {

                    nDebug11 = 1;//sylee170618-test1 debugcode
                    nFastHv1AdRun = 0;//sylee150415 fasthv

                    for (int ik2 = 1; ik2 <= nMaxRowSQ; ik2++)
                    {
                        Sub71.OnPinResetVB(32057);

                        nMSet1Co = 0;
                        nMSet1Flag = 0;
                        nMSet1CoT2 = 0;

                        if (ik2 == ik)	continue;

                        if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n [F1] 4 - %d, ik = %d, ik2 = %d(%d) \n", iWay, ik, ik2, __LINE__);


                        for (ih = 1; ih <= nMaxColSQ; ih++)
                        {
                            if (ik2 == nMaxRowSQ) {
                                if (ih > nSQLastPin) {
                                    break;
                                }
                            }

                            if (iWay == 0)
							{
								Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); // vc set 
							}
                            else
							{
								Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); // vc set 
							}

                            if (nOpenErrFlag[ip] == 2) {
                                if (iWay == 0)  tmp1 = nSQNet1[ik2][ih];
                                else            tmp1 = nSQNet1[ih][ik2];

                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++)
                                    {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);
                                    }
                                }
                            }
                        }
                        if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, " 5 - %d \n", iWay);

                        //=====================================================================================================================

                        Sub71.Delay_100ns(nErrorDelay1);

                        if (nHVIADCFlag == 1)
                        {
                            AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 2);
                        }
                        else
                        {

                            Sub71.Delay_100ns(nDelay10);

                            if (nCC == 2) {//cv
                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                            }
                            else {// cc                                      
                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }

                            }
                            else if (nCC == 2) {//CV   r=(vb/i)
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                }
                            }
                        }

                        if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                        {
                            ret1 = Sub71.OnSparkStatus();
                            if (ret1 == 1)
                            {
                                nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121//hdpark230712 waiting에서 spark 검출,  
                                                                            // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10);  //1us  
                                Sub71.OnSparkOn(1);
                                if (Sub71.fpSpark)
                                    fprintf(Sub71.fpSpark, ", @@, %d, %d, %.1f, %.1f \n", nSparkTmp, iWay, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                            }
                            else
                            {
                                nSpark1_Detect2 = 0; //hdpark230705
                            }

                            if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                            {
                                if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                {
                                    //sylee230305 begin
                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                    if (SysInfo19.m_nUse == 1) {
                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                    }
                                    if (g_nSkipPieceFlag1 == 1) {
                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                    } //sylee230305 end

                                    if (nSparkFailNo[nSparkTmp] != 1)
                                    {
                                        srand((unsigned int)time(NULL));
                                        double dTemp1 = (rand() % 3);					// ~ 3 V

                                        if (nFailL1Co < 3000)
                                        {

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                            //log buffer
                                            nFailL1Co++;
                                            nFailL1CoPiece++;
                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                            nFailL1[nFailL1Co][5] = nSparkTmp;//pin  vb

                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                            t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                            ////////////////////////////////////////////////////////////////////////////////
                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                            //////////////////////////////////////////////////////////////////////////////////////
                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                            nFailL1[nFailL1Co][9] = nVSet;
                                            nFailL1[nFailL1Co][10] = nISet;
                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                            // hdpark231121 
                                            nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                            nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                            nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                            nShortFlag = 1;//sylee120915
                                        }   //end of if(nFailL1Co<3000) //SPARK    
                                    }

                                    //  }// if(ret1==1)

                                }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                            }//end of  if(nSparkUse==1)
                        }

                        //=====================================================================================================================
                        nFailFlag2 = 0;
                        if (nHVIADCFlag == 1) {
                            if (Sub71.R1 <= nProRv2) {// ok//HV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }
                        else {
                            if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }//line & line 

                        //=====================================================================================================================
                        //##################################################################################################################################

                        //one line & one line  search
                        // a vc & vb row, 한 Pin씩 vc로 설정 후 측정.
                        if (nFailFlag2 == 1)
                        {

                            nDebug12 = 1;//sylee170618-test1 debugcode

                            if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n 6 - %d \n", iWay);

                            // Leak VC Pin Search
                            for (int ih6 = 1; ih6 <= nMaxColSQ; ih6++)
                            {
                                if (iWay == 0) {
                                    if (ik2 == nMaxRowSQ) {
                                        if (ih6 > nSQLastPin) {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    if (ih6 == nMaxRowSQ) {
                                        if (ik2 > nSQLastPin) {
                                            break;
                                        }
                                    }
                                }

                                Sub71.OnPinResetVB(32272);	// all vc reset                                 

                                if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n [F2] 7 - %d ih6 = %d, ik2 = %d(%d) \n", iWay, ih6, ik2, __LINE__);

                                if (iWay == 0)  Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1);
                                else            Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1);

                                if (nOpenErrFlag[ip] == 2) {
                                    if (iWay == 0)  tmp1 = nSQNet1[ik2][ih6];
                                    else            tmp1 = nSQNet1[ih6][ik2];

                                    if (nOpenErrList[tmp1][0] > 0) {
                                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);
                                        }
                                    }
                                }

                                //=====================================================================================================================

                                Sub71.Delay_100ns(nErrorDelay1);

                                if (nHVIADCFlag == 1)
                                {
                                    AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 3);
                                }
                                else
                                {
                                    Sub71.Delay_100ns(nDelay10);
                                    if (nCC == 2) {//cv
                                        Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                    }
                                    else {// cc                                      
                                        Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                    }

                                    if (Sub71.Y1 < 0.0000001) {
                                        Sub71.Y1 = 0.0000001;
                                    }

                                    if (nCC == 1) { //CC    r= (vb-vc)/i
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }
                                    else if (nCC == 2) {//CV   r=(vb/i)
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }
                                }

                                if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                {
                                    ret1 = Sub71.OnSparkStatus();
                                    if (ret1 == 1)
                                    {
                                        nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121//hdpark230712 waiting에서 spark 검출,  
                                                                                    // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                        Sub71.OnSparkOn(0);
                                        Sub71.Delay_100ns(10);  //1us  
                                        Sub71.OnSparkOn(1);
                                        if (Sub71.fpSpark)
                                            fprintf(Sub71.fpSpark, ", @@@, %d, %d, %.1f, %.1f \n", nSparkTmp, iWay, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                                    }
                                    else
                                    {
                                        nSpark1_Detect2 = 0; //hdpark230705
                                    }

                                    if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                                    {
                                        if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                        {
                                            //sylee230305 begin
                                            t1 = nPinToPiece(nSparkTmp); //sylee230305
                                            if (SysInfo19.m_nUse == 1) {
                                                if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                            }
                                            if (g_nSkipPieceFlag1 == 1) {
                                                if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                            } //sylee230305 end

                                            if (nSparkFailNo[nSparkTmp] != 1)
                                            {
                                                srand((unsigned int)time(NULL));
                                                double dTemp1 = (rand() % 3);					// ~ 3 V

                                                if (nFailL1Co < 3000)
                                                {

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                    nFailL1[nFailL1Co][5] = nSparkTmp;//pin  vb

                                                    nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                    nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                    t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                    //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                    ////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    //////////////////////////////////////////////////////////////////////////////////////
                                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    // hdpark231121 
                                                    nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                    nFailL1[nFailL1Co][13] = nVSet;                 // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                    nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                    nShortFlag = 1;//sylee120915
                                                }   //end of if(nFailL1Co<3000) //SPARK    
                                            }

                                            //  }// if(ret1==1)

                                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                    }//end of  if(nSparkUse==1)
                                }

                                BOOL bProgressiveFault = FALSE; // hdpark231205
                                nFailFlag3 = 0;
                                if (nHVIADCFlag == 1) {
                                    if (Sub71.R1 <= nProRv3) {// ok//HV // hdpark220715, nProRv2 -> nProRv3
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;

                                        if (Sub71.R1 > (nProRv3 * 2))     // hdpark231205, 판정 값보다 많이 차이가 나면 진행성 불량 조건으로 판정
                                        {
                                            bProgressiveFault = TRUE;
                                        }
                                    }
                                }
                                else {
                                    if (Sub71.R1 >= nProRv1) {//ok//LV      // hdpark220715 nProRv2 -> nProRv1
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }//line & line  

                                //=====================================================================================================================
                                //################################################################################################################################
                                ///one point  & one point search

                                // a vc & a vb, vc pin은 찾았으므로 vb pin을 찾음.
                                if (nFailFlag3 == 1)
                                {
                                    BOOL bAllPassFlag = TRUE;	// hdpark231205
                                    int nSparkTmp = 0;

                                    nDebug13 = 1;//sylee170618-test1 debugcode
                                    if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n [F3] ih6 = %d, ik2 = %d(%d), nProRv3 = %d, bProgressiveFault = %d \n", ih6, ik2, nProRv3, bProgressiveFault, __LINE__);

                                    // Leak VB Pin Search
                                    for (int ih2 = 1; ih2 <= nMaxColSQ; ih2++)
                                    {
                                        if (iWay == 0) {
                                            if ((ik + 1) == nMaxRowSQ) {
                                                if (ih2 > nSQLastPin) {
                                                    break;
                                                }
                                            }
                                        }
                                        else {
                                            if ((ih2 + 1) == nMaxRowSQ) {
                                                if (ik > nSQLastPin) {
                                                    break;
                                                }
                                            }
                                        }

                                        Sub71.OnPinResetVC(32464); //all vb reset

                                        if (nErrorDelayFlag1 == 1) {
                                            nErrorDelayFlag1 = 0;
                                            Sub71.Delay_100ns(nErrorDelayTime2);
                                        }

										if (Sub71.m_bModifySparkMeas)
											Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_ON);

                                        if (iWay == 0)
										{
											Sub71.AOnPinSet1(2, nSQNet1[ik][ih2], 2);   // vb set
                                            nSparkTmp = nSQNet1[ik][ih2] + 1;
										}
                                        else
										{
											Sub71.AOnPinSet1(2, nSQNet1[ih2][ik], 2);   // vb set
                                            nSparkTmp = nSQNet1[ih2][ik] + 1;
										}

                                        if (SysSet13.m_nSparkMode == SPARK_NEW)
                                        {
                                            if (nSparkUse == 1 && nSparkDetect1 == 1)
                                            {
                                                if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                                {
                                                    ret1 = Sub71.OnSparkStatus();

                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (ret1 == 1)
                                                    {
                                                        Sub71.OnSparkOn(0);
                                                        Sub71.Delay_100ns(10000);
                                                        //int nSparkTmp = nSQNet1[ik][ih2] + 1;
                                                        if (nSparkFailNo[nSparkTmp] != 1)
                                                        {
                                                            if (nFailL1Co < 3000) {

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nSparkFailNo[nSparkTmp] = 1;
                                                                int t1 = nSparkTmp;
                                                                t1 = nPinToPiece(t1);
                                                                nFailPiece[t1][nPStep1]++;
                                                                nShortFail1[t1]++;
                                                                nShortCo1Spark[nBlockCountP][t1]++;
                                                                nShortFail1Flag1 = 1;
                                                                nShortFlag = 1;
                                                                Sub71.OnSparkOn(1);
                                                                Sub71.Delay_100ns(1000);

                                                                ResultSpark(nSparkTmp, t1, nMod1, nPStep1, nProRv1, nISet, m_nMode1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        if (nOpenErrFlag[ip] == 2)
                                        {
                                            if (iWay == 0)  tmp1 = nSQNet1[ik][ih2];
                                            else            tmp1 = nSQNet1[ih2][ik];

                                            if (nOpenErrList[tmp1][0] > 0) {
                                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++)
                                                {
                                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2);
                                                }
                                            }
                                        }

										if (Sub71.m_bModifySparkMeas)
											Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_OFF);

                                        Sub71.Delay_100ns(nErrorDelay1);

                                        if (nHVIADCFlag == 1)
                                        {
                                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);

                                        }
                                        else
                                        {
                                            Sub71.Delay_100ns(nDelay10);
                                            if (nCC == 2) {//cv
                                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                            }
                                            else {// cc                                      
                                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                            }

                                            if (Sub71.Y1 < 0.0000001) {
                                                Sub71.Y1 = 0.0000001;
                                            }

                                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }
                                            else if (nCC == 2) {//CV   r=(vb/i)
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }
                                        }

                                        if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                        {
                                            ret1 = Sub71.OnSparkStatus();
                                            if (ret1 == 1)
                                            {
                                                nSpark1_Detect2 = g_nSparkWaitingEnable;   //hdpark231121 //hdpark230712 waiting에서 spark 검출, 
                                                                                            // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                                Sub71.OnSparkOn(0);
                                                Sub71.Delay_100ns(10000);  //1ms  
                                                Sub71.OnSparkOn(1);
                                                if (Sub71.fpSpark)
                                                    fprintf(Sub71.fpSpark, ", @@@@, %d, %d, %.1f, %.1f \n", nSparkTmp, iWay, g_dWaitingSparkV, g_dWaitingSparkVOrg);  //hdpark231121
                                            }
                                            else
                                            {
                                                nSpark1_Detect2 = 0; //hdpark230705
                                            }

                                            if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                                            {
                                                if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                                {
                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1)
                                                    {
                                                        srand((unsigned int)time(NULL));
                                                        double dTemp0 = (rand() % 3);					// ~ 3 V
                                                        double dTemp1 = (rand() % 5);					// ~ 5 V

                                                        if (nFailL1Co < 3000)
                                                        {

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt(nSparkRefV + dTemp0)=%.1f, OccurVolt(nVSet - dTemp1)=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, (nSparkRefV + dTemp0), (nVSet - dTemp1));
MyTrace(PRT_BASIC, "         nSparkRefV=%d, dTemp0=%.1f, nVSet=%.1f, dTemp1=%.1f\n", nSparkRefV, dTemp0, nVSet, dTemp1);   


                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih] + 1;//pin  vb

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            // hdpark230712 임의로 spark 값을 정함.
                                                            nFailL1[nFailL1Co][12] = nSparkRefV + dTemp0;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                            nFailL1[nFailL1Co][13] = nVSet - dTemp1;         // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                            nFailL1[nFailL1Co][14] = nISet;                  // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                        }   //end of if(nFailL1Co<3000) //SPARK    
                                                    }

                                                    //  }// if(ret1==1)

                                                }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                            }//end of  if(nSparkUse==1)
                                        }

                                        //*********************************************//
                                        nHVDStopTime2 = (long)GetuSecond();
                                        nHVDStopTime3 = (nHVDStopTime2 - nHVDStopTime1);
                                        if (nHVDStopTime3 > nHVTimeOutSet) { //15sec
                                            nHVDStopFlag = 1;//sylee121009
                                            Sub71.R1 = 20000;
                                            nFailL1CoPiece = 3000;
                                        }
                                        //************************************************//

                                        nFailFlag4 = 0;
                                        if (nHVIADCFlag == 1)
                                        {
                                            if (Sub71.R1 <= (nProRv1 + ceil(nProRv1 * 0.015)))	// hdpark 허용오차 1.5 %
                                            {
                                            }
                                            else {
                                                nFailFlag4 = 1;
                                                bAllPassFlag = FALSE;   // hdpark231205
                                            }
                                        }
                                        else
                                        {
                                            if (Sub71.Y1 < 5) {//ok//LV

                                            }
                                            else {//fail
                                                nFailFlag4 = 1;
                                                bAllPassFlag = FALSE;   // hdpark231205
                                            }
                                        }
                                        //===================================================================================================================== 

                                        if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2))
                                        {

                                            ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                            if (iWay == 0)  tmp1 = nSQNet1[ik][ih2];
                                            else            tmp1 = nSQNet1[ih2][ik];

                                            Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                            if (nOpenErrList[tmp1][0] > 0) {
                                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                    Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                                }
                                            }

                                            if (iWay == 0)  tmp2 = nSQNet1[ik2][ih6];//pin  vc
                                            else            tmp2 = nSQNet1[ih6][ik2];//pin  vc


                                            Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                            if (nOpenErrList[tmp2][1] > 0) {
                                                for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                    Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                                }
                                            }
                                        }
                                        else {
                                            nPin1[0] = 0;
                                            nPin2[0] = 0;
                                        }

                                        int nVCP, nVBP;

                                        if (iWay == 0)
                                        {
                                            nVCP = nSQNet1[ik2][ih6] + 1;
                                            nVBP = nSQNet1[ik][ih2] + 1;
                                        }
                                        else
                                        {
                                            nVCP = nSQNet1[ih6][ik2] + 1;
                                            nVBP = nSQNet1[ih2][ik] + 1;
                                        }

                                        if (nFailFlag4 == 1)
                                        {
                                            nDebug14 = 1;//sylee170618-test1 debugcode

                                            if (Sub71.fpLeak)	
												fprintf(Sub71.fpLeak, "\n [F4] [%4d %4d], ih6 = %d, ik2 = %d, %.0f (%d) \n", nVCP, nVBP, ih6, ik2, Sub71.R1, __LINE__);

                                            int st1, st2;
                                            nErrorDelayFlag1 = 1;

                                            int nFailedPin = FindLeakFailPin(nVCP, nVBP);

                                            if ((nPin1[0] <= 1) && (nPin2[0] <= 1))
                                            {
                                                if (nFailL1Co < 3000 && nFailedPin != 0x3)
                                                {
                                                    if (nProOneP_RunFlag1 == 1) {
                                                        if (nReSheetFlag1 != 1) {
                                                            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {
                                                                nProOneP_RunFlag1 = 0;
                                                            }
                                                        }
                                                    }

                                                    if (nSparkUse == 1) {
                                                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                            break;
                                                        }
                                                    }

                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                                    // hdpark220511 spark
                                                    if (Sub71.m_bModifySparkMeas)
                                                        Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                    nFailL1[nFailL1Co][4] = nVBP; //nSQNet1[ik][ih2] + 1;//pin  vb
                                                    nFailL1[nFailL1Co][5] = nVCP; //nSQNet1[ik2][ih6] + 1;//pin  vc

                                                    t1 = (int)nFailL1[nFailL1Co][4];
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }

                                                    if (iWay == 0)  t1 = nSQNet1[ik][ih2] + 1;//PIECE  pin no
                                                    else            t1 = nSQNet1[ih2][ik] + 1;//PIECE  pin no

                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
    //sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                    nShortFlag = 1;

                                                    nDebug15 = 1;//sylee170618-test1 debugcode
                                                }

                                                Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC   

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;
                                                }
                                            }

                                            if ((nPin1[0] > 1) || (nPin2[0] > 1))
                                            {
                                                Sub71.OnPinAllReset1(__LINE__);
                                                for (st1 = 1; st1 <= nPin1[0]; st1++)
                                                {
                                                    Sub71.AOnPinSet1(2, nPin1[st1], 1);
                                                }
                                                for (st2 = 1; st2 <= nPin2[0]; st2++)
                                                {
                                                    ///Sub71.OnPinResetVC(__LINE__);

                                                    Sub71.AOnPinSet1(2, nPin2[st2], 2);
                                                    Sub71.Delay_100ns(nErrorDelay1);
                                                    AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4);

                                                    if (Sub71.R1 <= nProRv3) {// ok//HV   line & one
                                                    }
                                                    else
                                                    {
                                                        for (st1 = 1; st1 <= nPin1[0]; st1++)
                                                        {
                                                            Sub71.OnPinResetVB(32856);
                                                            Sub71.AOnPinSet1(2, nPin1[st1], 1);
                                                            Sub71.Delay_100ns(nErrorDelay1);
                                                            AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4);

                                                            if (Sub71.R1 > nProRv3)
                                                            {
                                                                int iSum5, iCo5, iSet5;
                                                                iSum5 = 0; iCo5 = 0;

                                                                if (nPinDa1H[1][2][0] < 100) {

                                                                    iSet5 = 1;//SYLEETESTMODE-1
                                                                    if (Sub71.R1 < 340) {
                                                                        iSet5 = 30;  //sylee150629   20->30
                                                                    }
                                                                    if (Sub71.R1 < 500) {
                                                                        iSet5 = 10;
                                                                    }
                                                                }
                                                                else {
                                                                    iSet5 = 1;
                                                                    if (Sub71.R1 < 340) {
                                                                        iSet5 = 3;
                                                                    }
                                                                }

                                                                for (int k5 = 1; k5 <= iSet5; k5++)
                                                                {
                                                                    Sub71.OnPinAllReset1(__LINE__);

                                                                    if (k5 == 1) {
                                                                        Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC   
                                                                    }

                                                                    Sub71.AOnPinSet1(2, nPin2[st2], 2);
                                                                    Sub71.AOnPinSet1(2, nPin1[st1], 1);

                                                                    if (k5 == 1) {
                                                                        Sub71.Delay_100ns(nErrorDelay1);
                                                                    }
                                                                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150627   // hdpark220715, nProRv3 -> nProRv1

                                                                    if (Sub71.R1 < 700.) {
                                                                        iSum5 = iSum5 + (int)Sub71.R1;
                                                                        iCo5++;
                                                                    }

                                                                    if (Sub71.R1 >= 700) {
                                                                        break;
                                                                    }
                                                                }

                                                                if (iCo5 > 1) {
                                                                    Sub71.R1 = iSum5 / iCo5;
                                                                }
                                                            }

                                                            if (nPinDa1H[1][2][0] < 100) {
                                                                nProRv3 = nProRv0;
                                                            }
                                                            //####################################################################################

                                                            int nVBP = nPin2[st2] + 1;
                                                            int nVCP = nPin1[st1] + 1;

                                                            if (Sub71.R1 <= nProRv1) {// ok//HV   one & one // hdpark220715, nProRv3 -> nProRv1
                                                            }
                                                            else
                                                            {
                                                                if (Sub71.R1 < nProRv1) {
                                                                    for (int ir = 1; ir < 4; ir++) {
                                                                        Sub71.R1 = Sub71.R1 * 1.1;
                                                                        if (Sub71.R1 > nProRv1) {
                                                                            break;
                                                                        }
                                                                    }
                                                                }

                                                                int nFailedPin = FindLeakFailPin(nVCP, nVBP);

                                                                if (nFailL1Co < 3000 && nFailedPin != 0x3)
                                                                {
                                                                    if (nSparkUse == 1) {
                                                                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                                            break;
                                                                        }
                                                                    }

                                                                    nFailCount[nMod1] = nFailCount[nMod1]++;

                                                                    //log buffer
                                                                    nFailL1Co++;
                                                                    nFailL1CoPiece++;
                                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                    nFailL1[nFailL1Co][4] = nVBP; //nPin2[st2] + 1;//pin  vc
                                                                    nFailL1[nFailL1Co][5] = nVCP; //nPin1[st1] + 1;//pin  vb

                                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                                        nErrPin1S0[t1] = 1;
                                                                    }
                                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                                        nErrPin1S0[t1] = 1;
                                                                    }

                                                                    t1 = nPin1[st1] + 1;//PIECE  pin no  //sylee151208-1-import
                                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
    //sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                                    nFailL1[nFailL1Co][10] = nISet;
                                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                                    nShortFlag = 1;//sylee120915
                                                                    nDebug16 = 1;//sylee170618-test1 debugcode

                                                                }

                                                                Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC 

                                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }

                                                    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                        break;
                                                    }

                                                    if (st2 < nPin2[0]) {
                                                        for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                            Sub71.AOnPinSet1(2, nPin1[st1], 1);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    //----------------------------------------------------------------------------------------------------------------------

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)
                                    if (bAllPassFlag == TRUE && bProgressiveFault == TRUE) // hdpark231205, leak fail -> pass 발생 처리
                                    {

                                        if (nFailL1Co < 3000)
                                        {
                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                            nFailL1Co++;
                                            nFailL1CoPiece++;
                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                            if (iWay == 0)  nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;	//pin  vb
                                            else            nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;	//pin  vb

                                            nFailL1[nFailL1Co][5] = -1;//pin  vc


                                            t1 = (int)nFailL1[nFailL1Co][4];
                                            if ((t1 > 0) && (t1 < 16384)) {
                                                nErrPin1S0[t1] = 1;
                                            }
                                            t1 = (int)nFailL1[nFailL1Co][5];
                                            if ((t1 > 0) && (t1 < 16384)) {
                                                nErrPin1S0[t1] = 1;
                                            }


                                            if (iWay == 0)  t1 = nSQNet1[ik2][ih6] + 1;
                                            else            t1 = nSQNet1[ih6][ik2] + 1;

                                            //t1 = nSQNet1[ik2][ih6] + 1;//PIECE  pin no  
                                            t1 = nPinToPiece(t1);
                                            nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   

                                            nShortFail1[t1]++;
                                            nShortCo1[nBlockCountP][t1]++;
                                            nShortFail1Flag1 = 1;

                                            nFailL1[nFailL1Co][6] = Sub71.R1;
                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                            nFailL1[nFailL1Co][9] = nVSet;
                                            nFailL1[nFailL1Co][10] = nISet;
                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                            nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                            nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                            nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                            nShortFlag = 1;
                                        }
                                    }
#endif

                                    Sub71.OnPinResetVC(__LINE__);
#if 1
                                    if (Sub71.m_bModifySparkMeas)
                                        Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_ON);

                                    for (int ih3 = 1; ih3 <= nMaxColSQ; ih3++)
                                    {
                                        if (iWay == 0)
                                        {
                                            if (ik == nMaxRowSQ) {
                                                if (ih3 > nSQLastPin)   break;
                                            }

											///if(FindLeakFailPin(nSQNet1[ik][ih3] + 1, nSQNet1[ik][ih3] + 1) == 0)
												Sub71.AOnPinSet1(2, nSQNet1[ik][ih3], 2);
                                        }
                                        else
                                        {
                                            if (ih3 == nMaxRowSQ) {
                                                if (ik > nSQLastPin)    break;
                                            }

											///if(FindLeakFailPin(nSQNet1[ih3][ik] + 1, nSQNet1[ih3][ik] + 1) == 0)
												Sub71.AOnPinSet1(2, nSQNet1[ih3][ik], 2);
                                        }
/*
                                        if (SysSet13.m_nSparkMode == SPARK_NEW)
                                        {
                                            if (nSparkUse == 1 && nSparkDetect1 == 1)
                                            {
                                                if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                                {
                                                    ret1 = Sub71.OnSparkStatus();

                                                    if (ret1 == 1)
                                                    {
                                                        Sub71.OnSparkOn(0);
                                                        Sub71.Delay_100ns(10000);
                                                        int nSparkTmp = nSQNet1[ik + 1][ih3] + 1;
                                                        if (nSparkFailNo[nSparkTmp] != 1)
                                                        {
                                                            if (nFailL1Co < 3000) {

                                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nSparkFailNo[nSparkTmp] = 1;
                                                                t1 = nSQNet1[ik + 1][ih3] + 1;
                                                                t1 = nPinToPiece(t1);
                                                                nFailPiece[t1][nPStep1]++;
                                                                nShortFail1[t1]++;
                                                                nShortCo1Spark[nBlockCountP][t1]++;
                                                                nShortFail1Flag1 = 1;
                                                                nShortFlag = 1;
                                                                Sub71.OnSparkOn(1);
                                                                Sub71.Delay_100ns(1000);

                                                                ResultSpark(nSparkTmp, t1, nMod1, nPStep1, nProRv1, nISet, m_nMode1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
*/
                                        if (nOpenErrFlag[ip] == 2)
                                        {
                                            if (iWay == 0)  tmp1 = nSQNet1[ik][ih3];
                                            else            tmp1 = nSQNet1[ih3][ik];

                                            if (nOpenErrList[tmp1][0] > 0) {
                                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2);
                                                }
                                            }
                                        }
                                    }
#endif
                                }

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nMaxColSQ, SPARK_TRG_OFF);

                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                    break;
                                }

                                if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n 8 - %d : ih = %d, ih6 = %d(%d) \n", iWay, ih - 1, ih6, __LINE__);
                            }
                        }

                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                            break;
                        }
                    }
                }

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                    break;
                }
            }
			Sub71.OnPinAllReset1(__LINE__);
        }

        //==============================================================================================================================
        //################################################################################################################################

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 


        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;

        nRetry1 = 0;    //SYLEE121103         

        nHVDStopTime1 = (long)GetuSecond();//sylee121103

        //sylee121117-openshortlist
        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        //*******************************************************************************************************************************//
            //Task1:

        int nEnb1;


        if ((nFailL1CoOpen > 0) && (nOpShortLt1[ip][0][0] > 0)) {


            /*
                if(ipFlag==1){
                        nRCount=g_pvBDLData31[1][ip]->size() -1;
                }else{
                        nRCount=nBDLData3[1][0][1];
                }
            */

            if (ipFlag == 1)//sylee180810-1-DUT16
            {
                //nRCount=nBDLData31[dutId][ip][0]; //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                nRCount = (g_pvBDLData31[dutId][ip]->size() - 1);   //son201118: vector구조로 변경
            }
            else
            {
                nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16 //son190704-4WDUT16
            }

            nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
            for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
            {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
                tp1 = i * i;
                if (tp1 >= nRCount) {
                    nSQCount1 = i;//sylee120908
                    break;
                }
            }

            if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
                str.Format("Error No 7513-2 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                return 0;
            }

            ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));
			for(int ir = 0; ir < MAX_SQUARE_N; ir++)
			{
				for(int ic = 0; ic < MAX_SQUARE_N; ic++)
				{
					nSQNet1[ir][ic] = -1;
				}
			}

            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            //sylee121117-openshortlist


            int nOpShortPin[100];
            int nSQLastY2, nSQLastPin2, nOpCo, nOpFlag;

            nOpCo = 0;
            nOpFlag = 0;
            ::ZeroMemory(&nOpShortPin, sizeof(nOpShortPin));

            ///====================================================================


            for (ik = 1; ik <= nOpShortLt1[ip][0][0]; ik++) {
                if (ik > nSQCount1) {
                    break;
                }


                if (ik == 1) {
                    nOpShortPin[1] = nOpShortLt1[ip][1][0];
                    nOpCo = 1;
                }
                else {

                    nOpFlag = 0;

                    for (i = 1; i <= nOpCo; i++) {
                        if (nOpShortPin[i] == nOpShortLt1[ip][ik][0]) {
                            nOpFlag = 1;
                        }
                    }

                    if (nOpFlag == 0) {
                        nOpCo++;
                        nOpShortPin[nOpCo] = nOpShortLt1[ip][ik][0];
                    }
                }
            }

            nOpShortPin[0] = nOpCo;


            //==========================================================================
            int tmp3;

            tmp3 = nOpShortLt1[ip][0][0];

            for (ik = 1; ik <= (nOpShortLt1[ip][0][0] + nOpShortPin[0]); ik++) {
                if (ik > nSQCount1) {
                    break;
                }

                if (ik <= nOpShortLt1[ip][0][0]) {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortLt1[ip][ik][1];
                }
                else {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortPin[ik - tmp3];
                }
            }

            nSQLastY2 = nSQLastY1 + 1;

            if (nOpShortLt1[ip][0][0] < nSQCount1) {
                nSQLastPin2 = nOpShortLt1[ip][0][0] + nOpShortPin[0];
            }
            else {
                nSQLastPin2 = nSQCount1;
            }



            //################################################################################################################################
        //SET 


            for (int ik = 1; ik <= nRCount; ik++)
            {
                int i = (ik - 1) / nSQCount1 + 1;//mok
                int j = (ik - 1) - nSQCount1 * (i - 1);//na
                j = j + 1;

                /*
                if( ipFlag==1 ){//short   PIECE MULT.
                   //nSQNet1[i][j]=nBDLData31[1][ip][ik] ; // 1 VB,    =2VC,
                   nSQNet1[i][j]= (*g_pvBDLData31[1][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }else{
                nSQNet1[i][j]=nBDLData3[1][ik][1] ;   // 1  VB,    =2VC,
                }
                */

                if (ipFlag == 1)//sylee180810-1-DUT16
                {
                    //nSQNet1[i][j]=nBDLData31[dutId][ip][ik] ; // 1 VB,    =2VC, //SYLEE180810-1-DUT16    //son-4WDUT16-190704
                    nSQNet1[i][j] = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }
                else
                {
                    nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 //son190704-4WDUT16
                }

                if (ik == nRCount) {
                    nSQLastPin = j;//sylee120908   ///last row , last col.
                    nSQLastY1 = i;
                }
            }



            //#2 second search    hv  adc           
            // 1000 point 



            //################################################################################################################################
            //#1 FIRST-1  Line&Block
            //row

            ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
            nShort2FailFlag1 = 0;
            nSQStep1flag = 0;

            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

            nRetry1 = 0;


            //Task1Retry:


            for (ik = nSQLastY1; ik <= nSQLastY1; ik++) {     // FIRST LOOP //Y  VB 



                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        nEnb1 = 0;

                        for (int ik7 = 1; ik7 <= nOpShortPin[0]; ik7++) {
                            if (nOpShortPin[ik7] == nSQNet1[ik2][ih]) {
                                nEnb1 = 1;
                            }
                        }

                        if (nEnb1 == 0) {
                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,  
                        }


                    }
                }

                nSQStep1flag = 0;


                for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                    if ((ik + 1) == nSQLastY2) {
                        if (ih > nSQLastPin2) {
                            break;//SKIP
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 2);

                }
                //////////////////////////////////////////////////////////////////////////////////


                if (nHVIADCFlag == 1) {

                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);

                    //  Sub71.R1= dIADC1  ;//ADC
                }
                else {
                    Sub71.Delay_100ns(nDelay10);
                    AHV_ADCI_Read1(nProRv1);
                }

                IADClog1[ip][ik] = Sub71.R1;///logging

                if (nHVIADCFlag == 1) {
                    if (Sub71.R1 <= nProRv1) {// ok//HV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail 
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                    }


                }
                else {

                    if (Sub71.R1 >= nProRv1) {//ok//LV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail

                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        //   nFailFlag1=0;//test
                        nSQStep1flag = 2;
                    }

                }

                //  nFailFlag1=0;  // ALLPASS


                //==============================================================================================================================
                //################################################################################################################################
                //#2,  second search    hv  adc  
                // vc  m block 

                if (nFailFlag1 == 1) {  //if error      



                    Sub71.OnPinResetVB(33486);   //sylee121029  

                    for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //Vc


                        nMSet1Co = 0;
                        nMSet1Flag = 0;
                        nMSet1CoT2 = 0;

                        //sylee121029   Sub71.OnPinResetVB();
                        //  Sub71.Delay_100ns(100);//10uSEC   


                        if (ik2 > ik) { //doublecheck#2 
                            continue;
                        }

                        for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            nEnb1 = 0;

                            for (int ik8 = 1; ik8 <= nOpShortPin[0]; ik8++) {
                                if (nOpShortPin[ik8] == nSQNet1[ik2][ih]) {
                                    nEnb1 = 1;
                                }
                            }

                            if (nEnb1 == 0) {
                                Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                            }

                        }
                        //=====================================================================================================================
                        if (nHVIADCFlag == 1) {
                            //  AHV_ADCI_Read1(nProRv1); 
                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                            //  Sub71.R1= dIADC1  ;//ADC
                        }
                        else {

                            Sub71.Delay_100ns(nDelay10);

                            if (nCC == 2) {//cv
                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                            }
                            else {// cc                                      
                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }

                            }
                            else if (nCC == 2) {//CV   r=(vb/i)
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                }
                            }

                        }

                        //Sub71.Delay_100ns(10000);  
    //=====================================================================================================================
                        nFailFlag2 = 0;
                        if (nHVIADCFlag == 1) {
                            if (Sub71.R1 <= nProRv1) {// ok//HV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }
                        else {
                            if (Sub71.R1 >= nProRv1) {//ok//LV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }//line & line 

                            //=====================================================================================================================
                        //##################################################################################################################################

                        //one line & one line  search


                        if (nFailFlag2 == 1) {

                            for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 


                                if (ik2 == nSQLastY1) {  //LAST Y STEP  nSQLastY1=9  //sylee131114
                                    if (ih6 > nSQLastPin) {//  nSQLastPin=6
                                        break;//SKIP   
                                    }
                                }

                                Sub71.OnPinResetVB(33599);//SYLEE121016***** all reset                                   
                                // Sub71.Delay_100ns(100);//10uSEC   


                                nEnb1 = 0;

                                for (int ik9 = 1; ik9 <= nOpShortPin[0]; ik9++) {
                                    if (nOpShortPin[ik9] == nSQNet1[ik2][ih6]) {
                                        nEnb1 = 1;
                                    }
                                }

                                if (nEnb1 == 0) {
                                    Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=Vb
                                }

                                //=====================================================================================================================


                                if (nHVIADCFlag == 1) {
                                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                    //  Sub71.R1= dIADC1  ;//ADC
                                }
                                else {


                                    Sub71.Delay_100ns(nDelay10);

                                    if (nCC == 2) {//cv
                                        Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                    }
                                    else {// cc                                      
                                        Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                    }


                                    if (Sub71.Y1 < 0.0000001) {
                                        Sub71.Y1 = 0.0000001;
                                    }


                                    if (nCC == 1) { //CC    r= (vb-vc)/i
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                        }

                                    }
                                    else if (nCC == 2) {//CV   r=(vb/i)
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }

                                }

                                BOOL bProgressiveFault = FALSE;      // hdpark231205
                                nFailFlag3 = 0;
                                if (nHVIADCFlag == 1) {
                                    if (Sub71.R1 <= nProRv1) {// ok//HV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;

                                        if (Sub71.R1 > (nProRv1 * 2))     // hdpark231205, 판정 값보다 많이 차이가 나면 진행성 불량 조건으로 판정
                                        {
                                            bProgressiveFault = TRUE;
                                        }
                                    }
                                }
                                else {
                                    if (Sub71.R1 >= nProRv1) {//ok//LV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }//line & line 

                                //=====================================================================================================================
                                //################################################################################################################################
                                ///one point  & one point search

                                if (nFailFlag3 == 1) {

                                    BOOL bAllPassFlag = TRUE;   // hdpark231205

                                    for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin  


                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih2 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }

                                        Sub71.OnPinResetVC(__LINE__); //Vb all reset
                                        // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                        Sub71.AOnPinSet1(2, nSQNet1[ik][ih2], 2);


                                        if (nHVIADCFlag == 1) {
                                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                            //  Sub71.R1= dIADC1  ;//ADC
                                        }
                                        else {
                                            Sub71.Delay_100ns(nDelay10);
                                            if (nCC == 2) {//cv
                                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                            }
                                            else {// cc                                      
                                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                            }

                                            if (Sub71.Y1 < 0.0000001) {
                                                Sub71.Y1 = 0.0000001;
                                            }


                                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                                }

                                            }
                                            else if (nCC == 2) {//CV   r=(vb/i)
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }

                                        }


                                        nFailFlag4 = 0;
                                        if (nHVIADCFlag == 1) {
                                            if (Sub71.R1 <= nProRv1) {// ok//HV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                                bAllPassFlag = FALSE;
                                            }
                                        }
                                        else {
                                            //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                            if (Sub71.Y1 < 5) {//ok//LV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                                bAllPassFlag = FALSE;
                                            }
                                        }

                                        if (nFailFlag4 == 1) {

                                            if (nHVIADCFlag != 1) {

                                                if (nFailL1Co < 3000) {                              
                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                                    if (nSQNet1[ik][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = nSQNet1[ik][ih2] + 1;//PIECE  pin no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                    nShortFlag = 1;//sylee120915 

                                                } 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error                                                 
                                                }
                                            }
                                            else {                                                                             

                                                if (nFailL1Co < 3000) {
                                                    nFailCount[nMod1] = nFailCount[nMod1]++;

                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece 

                                                    if (nSQNet1[ik][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }


                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }

                                                    t1 = nSQNet1[ik][ih2] + 1;//PIECE  pin no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                    nShortFlag = 1;
                                                } 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break; 
                                                }
                                            }
                                        }
                                    }

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)
                                    if (bAllPassFlag == TRUE && bProgressiveFault == TRUE) // hdpark231205, leak fail -> pass 발생 처리, 진행성 불량
                                    {

                                        if (nFailL1Co < 3000)
                                        {
                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                            nFailL1Co++;
                                            nFailL1CoPiece++;
                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                            nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2];//pin  vb
                                            nFailL1[nFailL1Co][5] = -1;//pin  vc


                                            t1 = (int)nFailL1[nFailL1Co][4];
                                            if ((t1 > 0) && (t1 < 16384)) {
                                                nErrPin1S0[t1] = 1;
                                            }
                                            t1 = (int)nFailL1[nFailL1Co][5];
                                            if ((t1 > 0) && (t1 < 16384)) {
                                                nErrPin1S0[t1] = 1;
                                            }

                                            t1 = nSQNet1[ik + 1][ih2];//PIECE  pin no  
                                            t1 = nPinToPiece(t1);
                                            nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   

                                            nShortFail1[t1]++;
                                            nShortCo1[nBlockCountP][t1]++;
                                            nShortFail1Flag1 = 1;

                                            nFailL1[nFailL1Co][6] = Sub71.R1;
                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                            nFailL1[nFailL1Co][9] = nVSet;
                                            nFailL1[nFailL1Co][10] = nISet;
                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                            nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                            nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                            nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                            nShortFlag = 1;
                                        }
                                    }
#endif


                                    Sub71.OnPinResetVC(__LINE__);

                                    for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {
                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih3 > nSQLastPin2) {
                                                break;
                                            }
                                        }
                                        Sub71.AOnPinSet1(2, nSQNet1[ik][ih3], 2);
                                    }
                                }

                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                    break; 
                                }
                            }
                        }

                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                            break;
                        }
                    }
                }

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                    break;// complete  error 
                }
            } 
        }  



    TaskEnd300://sylee150415 fasthv


        Sub71.OnPinAllReset1(33972); ///PIN ALL RESET

    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   


    if (nFastHv1RunStep == 1) {//sylee150415 fasthv   //sylee150428
        if (nFastHv1PieceReturn == 1) {
            nFastHv1RunStep = 2;//sylee150415 fasthv
        }
    }

    tStart1001 = GetuSecond();//SYLEE150426-2

    // Delay_100ns(100000);//10mSEC  ok

    Sub71.OnPinAllReset1(33987); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720

    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704
    Sub71.AOnReadV1Enable1(5);


    Sub71.AIRangeOff();//sylee171204 //ACE400

    if (n4w_Sample_Enable == 1) {//sylee180912-1
        Sub71.OnDisCharge1();
    }

    nFlag_HV_SetEnd_Skip = 0;//sylee150427    0=idle, 1=skip 

    Sub71.OnPinResetInit();//sylee151221   //ACE400



    tStart322 = GetuSecond();//TESTDEBUG

    tStart323 = (tStart322 - tStart321);//TESTDEBUG


    nPinSetSkipVb = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee160803 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee160803 //ACE400    //son230127

    // Sub71.AOnReadVB1Run1(nVRel); //test

    if (nDebug11 == 1) {//sylee170618-test1 debugcode
        if (nDebug15 == 1 || nDebug16 == 1) {
        }
        else {
            //      str.Format(" DEBUG 301    HV  EROR  " );
                   // AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
//           LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug12 != 1) {
            //  str.Format(" DEBUG 302    HV  EROR  " );
              //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug13 != 1) {
            //      str.Format(" DEBUG 303    HV  EROR  " );
                 //   AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
    //       LogDebug2(str) ;    //SYLEE170618

        }
        if (nDebug14 != 1) {
            //  str.Format(" DEBUG 304    HV  EROR  " );
              //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
    }


    if (nDebug21 == 1) {//sylee170618-test1 debugcode
        if (nDebug25 == 1 || nDebug26 == 1) {
        }
        else {
            //  str.Format(" DEBUG 401    HV  EROR  " );
                //AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug22 != 1) {
            //  str.Format(" DEBUG 402    HV  EROR  " );
              //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug23 != 1) {
            //  str.Format(" DEBUG 403    HV  EROR  " );
                //AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug24 != 1) {
            //  str.Format(" DEBUG 404    HV  EROR  " );
                //AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
    }

    if (SysInfo05.m_nSp == 1) {//SYLEE171103-1
        if (SysInfo05.m_nSparkSet > 0) {
            Sub71.AOnVBSet1(5, 0); //1~ 100v set 가능   140428            
            Sub71.OnSparkOn(0); ////SPARK ON   //SYLEE130830    1=on   ext ==off               
            //  Sub71.Delay_100ns(1000); //1ms
        }
    }

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
    {
        //OnSparkFileLog1_I(nSparkMaxX+7, nSparkMaxY); //sylee200710  //all log
        if (g_nSpark1_Use == 1) {//SYLEE200721 
            On_SparkFileLog1_I(nSparkMaxX + 8, nSparkI1Po2); //sylee200710  //ng log
        }

        Sub71.OnSparkADC(0);//SYLEE200714

    //  On_SparkFileLog1_V(29,1000); //sylee200710

        nFlag_Spark_PinOn = 0; //sylee200710-1

    }

    nFlag_LeakDischarge1 = 0;//sylee200916

    if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n\n\n");
    if (Sub71.fpLeak)	fclose(Sub71.fpLeak);


    return 1;
}


// son 개별 piece 별 Leak 검사 
//SYLEE121028  DEFINE 
//son    nMod1      0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4:LV HR Short(LV)
//                  5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W
//son  m_nMode1     Calibration Mode
//son  nProRv1      raw RValue
//son  nPStep1      현재 test 진행 step 
//son  nProType     1:multi piece,  2:one piece ,   if(nProType == 2 || nProType == 3) 이면  i mode running
//
//son  return       0: HW error   1: Pass 
int CChildView7::ARun201_S2_SQ2_HV_Re_VB1(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
{
    /// debug code
    Sub71.fpLeak = NULL; // fopen("D:\\leak.log", "a+t");   //hdpark230425 
    CString   str, str1, strfName, strfName1;
    char  fName[200], fName1[200];
    int i, ik, j, n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1, nHVIADCFlag, nDischargeCount, nShRes1T;
    int ih, logno1, nSQCount1, nSQLastY1, nSQLastPin, tp1, t1;
    int nFailFlag1, nFailFlag2, nFailFlag3, nFailFlag4, nRetry1;

    int nSQ1Fail[200], nSh1Ret1[100], dPinVC[200], dPinVB[200];
    //son210401  100 -> MAX_SQUARE_N(200)  : Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
    int nSQNet1[MAX_SQUARE_N][MAX_SQUARE_N];// pin array//sylee120908
    double nISet, dVbR1, dVbR2, InterI;
    double nT[10];
    double nData[130][15], dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200];
    int nMSet1Flag, nMSet1Co, nMSet1CoT2, nSQStep1flag;
    int nIFilter, nHVOffSet, nHVGain, nDelayTime2, nIControl, tmp1, tmp2, Co, nHVTimeOutSet;
    int nPin1[1000], nPin2[1000];
    int nEstUse, nEt_StepSumTemp, ret1, nSparkUse, nErrorDelayTime1;
    int nProRv2, nProRv3, nProRv0, nErrorDelayFlag1, nErrorDelayTime2;//sylee141002 
    int nIGain, nErrorDelay1;//sylee150610 kushan
    int nDebug11;       //son 처음검사  (Y 방향)
    int nDebug12;       //son 두번째 검사
    int nDebug13, nDebug14, nDebug15, nDebug16;//sylee170618-test1 debugcode
    int nDebug21;       //son 처음검사 (X 방향)
    int nDebug22, nDebug23, nDebug24, nDebug25, nDebug26;//sylee170618-test1 debugcode
    int nSparkset;      //sylee200714 NEW_SPARK
    short nSparkFailNo[Def_SwitchMaxPin];//sylee200714 NEW_SPARK
    int  nSparkTmp;
	int nK1Start;
 

   if (nMod1 == TEST_LEAK2 ){     
       nLeakMode1=TEST_LEAK2;//sylee230822
   }
   else{  
       nLeakMode1=TEST_LEAK1; 
   } //sylee230822

    nFlagLeakMPin1=0;  //sylee230526  //sylee230817
	nLeakADCFlag1=0;//sylee230814-1 
	if( nMod1==5 ){//sylee230814-1
		if( nProStep1[TEST_LEAK1][1]>=300000000){
			nLeakADCFlag1=2;//sylee230814-1
		}
	}

	if( nMod1==6 ){//sylee230814-1
		if( nProStep1[TEST_LEAK2][1]>=300000000){
			nLeakADCFlag1=2;//sylee230814-1
		}
	} 

	nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    nSparkIPlus1 = 0;//SYLEE201027
    nFlag_LeakDischarge1 = 0;//sylee200916-1
    //son220927 if (nMod1 == 5 || nMod1 == 6) //sylee200916-1
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2) //sylee200916-1     //son220927
    {
        //  if(nProStep1[nMod1][1]>20000000){
        nFlag_LeakDischarge1 = 1;
        if (nMod1 == TEST_LEAK2) {  //son 6:TEST_LEAK2
            nLeakDischarge1AD0 = nLeakDischarge1AD2;
        }
        else {
            nLeakDischarge1AD0 = nLeakDischarge1AD1;
        }
        if (nLeakDischarge1AD0 < 300) {
            nLeakDischarge1AD0 = 300;
        }
        //  }
    }

    //sylee170725 
    nDebug11 = nDebug12 = nDebug13 = nDebug14 = nDebug15 = nDebug16 = 0;//sylee170618-test1 debugcode
    nDebug21 = nDebug22 = nDebug23 = nDebug24 = nDebug25 = nDebug26 = 0;//sylee170618-test1 debugcode

    if (SysSet13.m_nSparkMode == SPARK_NEW)
    {
        //////////////////////////////////////////////////////////////////////////////////
        nSparkV1Po2 = 0;//sylee200710 NEW_SPARK
        nSparkI1Po2 = 0;//sylee200710 NEW_SPARK
        nFlag_Spark_PinOn = 1;  //sylee200710-1 
        ::ZeroMemory(&dSparkV1, sizeof(dSparkV1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI1, sizeof(dSparkI1));//sylee200710 NEW_SPARK
        ::ZeroMemory(&dSparkI12, sizeof(dSparkI12));//sylee200710 NEW_SPARK
        ::ZeroMemory(&nSparkFailNo, sizeof(nSparkFailNo));//sylee200710 NEW_SPARK
        nSparkMaxY = 500;//sylee200710 NEW_SPARK

        if (SysSet19.m_nSet34 <= 0) {
            nSparkMaxX = 20;  //sylee200710   //MAX =50  NEW_SPARK
        }
        else {
            nSparkMaxX = SysSet19.m_nSet34;
            if (nSparkMaxX > 100) {
                nSparkMaxX = 100;
            }
        }
        nSparkGapMin = nSparkMaxX;
        nSparkMaxXSet = nSparkMaxX;//sylee210430

        if (SysSet19.m_nSet35 <= 0) {
            nSparkHWoffSet1 = 1;
        }
        else {
            nSparkHWoffSet1 = SysSet19.m_nSet35;
            if (nSparkHWoffSet1 > 500) {
                nSparkHWoffSet1 = 500;
            }
        }
        //////////////////////////////////////////////////////////////////////////////////

    }


    Sub71.OnRelay4W_OFF1();  //SYLEE181118

    // nProType=1;//sylee170617-3 test      //son nProType 1: multi piece, 2: One piece

    if (nProOneP_Flag1 == 3 && nProType == 2) {//sylee170306-1
        nProType = 3;   
    }
    if (nReSheetFlag1 == 1) { //sylee171011-1 //resheet
        nProType = 1;   //son 1: multi piece
    }
    ////////////////////////////////////////////////////////////////////////////
    ////sylee160807-1     

    int  nRunFlag1_HvShort1;    //son HV Short 개수

    nShort_Flag1 = __HV; //1:__LV  2:__HV  //sylee161026
    nRunFlag1_HvShort1 = 0;

    ipEnd = 0;
    int dutId = getDutId();     //son190704 nMulNetFlag = dutId
    //son220927 if (nMod1 == 5 || nMod1 == 6)
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)       //son220927
    {
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId]; //SYLEE180810-1-DUT16  //son190704-4WDUT16

        if (g_nPieceMax1 >= 1) {//PIECE
            ipEnd = g_nPieceMax1;
        }
    }


    //-----------------------------
    //son HV Short 개수 카운트

    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {

        //-----------------------
        //son muiti piece 케이스         
        //sylee170807-5 if(nProType==1)       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-5
        {

            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) {
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {  //son PASS
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                    continue;
                }
            }

			/*//sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex   open &short
                if (nManualStartFlag != 1) {
                    if (gRun05.m_nReCh > 0) {
                        if (nOpenSetFlag1 == 1) {
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {
                                if (nReFlagOpenCur[ip3] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {

                                if (nReFlagOpenOld[ip3] == 1) {
                                    continue;
                                }
                            }
                        }
                    }
                }
 
            } else {//syle170725-3
			*/ //sylee230420 
                if (nReFlagOpenOld[ip3] == 1) {///syle170725-3
                    continue;
                }

            //sylee230420 }


            if (nShortFail1[ip3] > 0) {
                continue;
            }

           //sylee230420  if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip3] == 1) {//sylee171120-1 
                continue;
            }//sylee171120-1
           //sylee230420  }

        }// if(nProType!=2)    //sylee170614-1

        nRunFlag1_HvShort1++;   //son HV Short 개수 카운트

    }

    if (nRunFlag1_HvShort1 < 1) {
        return 1;
    }



    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127
    nErrorDelay1 = 0;//sylee210205      3ms-> 0      //30000;//sylee150610  kushan 3mS

    tStart321 = GetuSecond();//TESTDEBUG
    //Sleep(1000);
    //return 1;//allpassing
    nRunMode_HV_LV = 1;//SYLEE150417-5  1= HV, 2=LV
    nErrorDelayTime1 = 1000;//1mS//sylee141001
    nErrorDelayTime2 = 100000;//500mS//sylee141002  //sylee150331  200mS->10ms =>   ok함 
    nErrorDelayFlag1 = 0;//sylee141002
 
    nProRv2 = (int)(nProRv1 * 1);
    nProRv3 = (int)(nProRv1 * 1); //sylee141001
//    nProRv2 = (int)(nProRv1 * 0.99); //sylee240507  //son240628 BH 고정 Short 문제때문에 sylee240507 원상복구
//    nProRv3 = (int)(nProRv1 * 0.99); //sylee240507

    if (nProRv3 < 10) { //sylee141001
        nProRv3 = 10;
    }

    nProRv0 = (int)nProRv1;//sylee150627

    if (nPinDa1H[1][2][0] < 100) {//sylee150627
        nProRv0 = (int)nProRv1;//sylee150627 
    }

    nEstUse = 0;  nFileCount = 0;
    logno1 = 0;   nShRes1T = 0; nStop = 0;  ipFlag = 0;
    n4Wire = 0;   nIControl = 0;
    nDelayTime2 = 20000;//sylee130716
    ipEnd = 1;//PIECE
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode    
    nDischargeCount = 20;//sylee2012083
    nHVIADCFlag = 1;//test

    nHVTimeOutSet = DEFINE_HVTIMEOUT1 * 3;

    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nSh1Ret1, sizeof(nSh1Ret1));
    ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));//sylee120907
    ::ZeroMemory(&IADClog1, sizeof(IADClog1));//sylee120907

    if (nFastHv1RunStep == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nFastHv1Piece, sizeof(nFastHv1Piece));//sylee150415
        nFastHv1PieceReturn = 0;//sylee150415
    }

    //sylee170411   if(SysSet13.m_nSet19==1){//sylee150417-1 
    if (SysInfo05.m_nProSpMode == 2 || SysInfo05.m_nProSpMode == 3 || SysInfo05.m_nProSpMode == 4) {   //sylee150417-1 
        if (SysSet16.m_nSet11 == 1) {//sylee130325  //sylee130404   //estimation
            if (nFlagEstModelMake == 1 && nFlagEstModelMakeSelect == 2) {
                nEstUse = 1;//sylee130325
            }
            else if (nFlagEstModelMake == 3) {
                nEstUse = 1;//sylee130325
            }
            if (nOpenUse1 != 1) {//sylee150627
                nEstUse = 0;
            }
            if (nEstUse == 1) {//sylee130325
                nEt_LogCount++;//sylee130219jo   ytech estimation
            }
        }
        nFileCount = 0;//sylee130219joytech-estimation
    }
    //sylee170411   }

    if (SysSet15.m_nSet1 < 1 || SysSet15.m_nSet2 < 1 || SysSet15.m_nSet3 < 1) {
        AfxMessageBox("  Maker Engineer Call!  HV 100M,50M,20M  DATA<1? ,   PROCESS SET  PARAMETOR   FILE LOAD ERROR!.  ERROR NO 5001 ,PROCESS FAIL. STOP. ", MB_OK);
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     
    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
    if( nFlagLeak12==1  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1  //sylee230807
	    nVRel=4; 
	}
 	if( nFlagLeak12==2  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1 //sylee230807
	    nVRel=4; 
	}
#endif  //son231122

    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];    //SYLEE150123          

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
    {
        dSparkLeakSet1 = nVSet / nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_I = (double)nISet;//sylee200710-1 NEW_SPARK 
        dSparkLeakSet1_V = (double)nVSet;
    }

    if (nVSet > 20) {//SYLEE141211
        if (nIR == 1) {
            AfxMessageBox("  Error  No 7101.  HV leak Mode,    I Range Mode 1 Use error.   Call bioptro! ", MB_OK);
            return 0;
        }
    }

    if (nProRv1 < 10) { //sylee141001
        nProRv1 = 10;
    }

    // hdpark230105 Spark begin
    if (Sub71.m_bSparkVerification)
    {
        if (nVSet < 250)
        {
            CString strMsg = "This voltage is not valid for spark validation voltage(250V)!";
            AfxMessageBox(strMsg);
            return 1;
        }
    }
    // hdpark230105 end

    // hdpark220715 begin
    if (nVSet >= 100.0) // 100 V 이상
    {
        nProRv2 = g_nProRv2[nMod1];  // hdpark220715, Cal 허용 편차 10 % 적용
        nProRv3 = g_nProRv3[nMod1];  // hdpark220715, Cal 허용 편차  5 % 적용
    }
    else
    {
        nProRv2 = nProRv1;
        nProRv3 = nProRv1;
    } // hdpark220715 end

    if (nVSet <= 50) {
        nICheckSet = 3;
    }
    else if (nVSet <= 100) {
        nICheckSet = 5;
    }
    else if (nVSet <= 150) {
        nICheckSet = 10;
    }
    else {
        nICheckSet = 20;
    }
    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7710, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }

    Sub71.nADCount1 = (int)dRec[m_nMode1][7];

	if(nLeakADCFlag1==2){ 	
	    Sub71.nADCount1 = 60;	//sylee230814-1
    }

    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock  
    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 1024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 



 //sylee230811-3

    Lo1 = 2000; //sylee200915  100->1000

Task101: 

    Sub71.AOnReadVB1Run1(nVRel);

    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2; 

    if (Simulator100 != 7) 
    {
        if (Sub71.V1 > 300) 
        {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();
            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1301,\n\n  고압전압 설정안되었습니다. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1301,\n\n   high voltage power set error. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }
            return 0;
        }

#ifdef _PC_TEST_
        Sub71.V1 = nVSet;       //son220927 PC_TEST에서 HW Check 에러 무시하기 위함.
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2)
        {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();

            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1313,\n \n\n 전압 설정이 안되었습니다.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1313,\n \n\n high voltage power  set  error.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            return 0;
        }
    }

 //sylee230811-2

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Sub71.FilterSet(nFil);//sylee130628 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on     
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.On4W_GainSet(1);
    Sub71.AOnReadV1Enable1(nVRel);
    Sub71.OnPinAllReset1(34678); //SYLEE150120
    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);
    //sylee170427    Sub71.Delay_100ns(100000); //10mS  //sylee151203  
    Sub71.Delay_100ns(50000); //10->5mS  //sylee170427 
    Sub71.OnPinAllReset1(34682); ///PIN ALL RESET //sylee20120118
    nLeakADhigh1=0;//sylee230907

	if( ( nMod1==5 && nLeakHighFlag1[1] > 1)  ||  ( nMod1==6 && nLeakHighFlag1[2] > 1) ){  //sylee230907  >= -> >
	      Sub71.Delay_100ns(3000000); //300mS  //sylee230814//sylee230811-2  //300M->290M
          nLeakADhigh1=1;//sylee230907
	}
	if( ( nMod1==5 && nLeakHighFlag1[1] == 1)  ||  ( nMod1==6 && nLeakHighFlag1[2] ==1) ){  //sylee230907
	      Sub71.Delay_100ns(100000); //10mS //sylee230907
	}

	nLeakHighFlag2=0;//sylee230830
	if( ( nMod1==5 && nLeakHighFlag1[1] >  1)  ||  ( nMod1==6 && nLeakHighFlag1[2] > 1) ){
	      nLeakHighFlag2=1;//sylee230830
	}
 

    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    //sylee140923   if( nMod1==2 || nMod1==3 || nMod1==4 || nMod1==5 )
    //son220927 if (nMod1 == 5 || nMod1 == 6)
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2)   //son220927
    {
        nRCount = nBDLData3[dutId][0][1];       //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];  //SYLEE150920

        if (g_nPieceMax1 > 1) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }
    }
    else {
        str.Format("Error No 7213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }

    nEt_StepSumTemp = 0;  //sylee130410
    nFlagLeakMPin1=1;  //sylee230526  //sylee230817
//=============================================================================================

    int  nDisable, nDisable2, nDisable3, ipEnd2;//sylee150611
    nDisable = 0; nDisable2 = 0; nDisable3 = 0;

    ipEnd2 = ipEnd;//sylee150611 

    if (nProOneP_RunFlag1 == 1)
    {
        //son nProOneP_Flag1 2:model make (BDL file 정상여부 체크중) 이거나,  
        //    nProOneP_Flag1 3:run  etc  disable  인 경우.
        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
        {
            for (int ip2 = 1; ip2 <= ipEnd2; ip2++) {
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {
                    if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {
                        nDisable = 1;
                    }
                }
            }

            if (nReSheetFlag1 != 1) { //sylee150611 
                if (nDisable == 0) {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0) {
                        if (nProType == 2 || nProType == 3) {//SYLEE130916  //i mode   running 
                            ipEnd = 1;
                            ipFlag = 0; //son multi piece 아니라고 표시
                            nHVIADCFlag = 1;
                        }
                    }
                }
                if ((ipFlag == 0) && (nProType != 0)) {//SYLEE131003
                    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
                }
            }

        }
    }

    nSparkset = 0;
    //son NEW_SPARK
    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200909 SPARK_NEW
    {
        //  nSparkRefV=SysInfo05.m_nSparkSet+SysInfo05.m_nSparkSet_B;//sylee200710-1 
        nSparkRefV = SysInfo05.m_nSparkSet;//sylee200808 NEW_SPARK
        g_nSpark1_Use = 0;//SYLEE200721 NEW_SPARK

        double dSetVolt = nSparkHWoffSet1 + nSparkRefV;
        nSparkUse = SetSparkDetectionVolt(dSetVolt);
    }
    //son OLD_SPARK
    else
    {
        if (SysInfo05.m_nSp == 1) {
            if (SysInfo05.m_nSparkSet > 0) {
                Sub71.AOnVBSet1(5, SysInfo05.m_nSparkSet); //1~ 100v set 가능   140428    
                Sub71.OnSparkOn(0);  //SYLEE200623-2
                Sub71.Delay_100ns(10000); //sylee200623 -2
                Sub71.OnSparkOn(1); ////SPARK ON   //SYLEE130830    1=on   ext ==off     
                nSparkUse = 1;
            }
        }
    }

    //====================================================================================================================================
    if (ipEnd == 1) {//sylee150615-import
        nAHV_EST1_MODEL_TYPE1 = 2;//sylee150615-import
    }
    else {
        nAHV_EST1_MODEL_TYPE1 = 1;//sylee150615-import
    }

    if (nAHV_EST1_MODEL_TYPE2 == 2 && ipEnd != 1) {//sylee150615-import nAHV_EST1_MODEL_TYPE2=2;  one piece
        if (nEstUse == 1) {
            nEstUse = 0;
        }
        //est giveup
    }
  
    //====================================================================================================================================
    for (int ip = 1; ip <= ipEnd; ip++)
    {
        //if((nProType!=1)&&(ipEnd!=1)){//sylee150610
        //sylee170307-2 if(nFastHv1RunStep==3){//sylee150415 fasthv
        //sylee170307-2     if( nFastHv1Piece[ip]!=1){  
        //sylee170307-2         continue;
        //sylee170307-2     }
        //sylee170307-2 }
        if (ipEnd != 1) {  //sylee160203-ITS
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS       //son220624
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece    <=============      //son220624
                    continue;
                }
            }
        }


        //sylee170807-6 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-6
        {

            //son220803 begin: 
            //son 메인장비에서 준 SkipPcs.txt 정보가 skip할 piece인 경우
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK //son220803
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece //son220803
                    continue;
                }
            }//son220803 end

#if 0       //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고, 계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {
                    continue;
                }
            }
#endif      //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                    continue;
                }
            }
			/* //sylee230420 

            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex
                if (nManualStartFlag != 1) {//SYLEE130221JOYTECH SETUP PRESS
                    if (gRun05.m_nReCh > 0) {//sylee121129
                        if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                            if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {//sylee121129 
                                if (nReFlagOpenCur[ip] != 1) {
                                    continue;
                                }
                            }
                            else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {
                                if (nReFlagOpenOld[ip] == 1) {
                                    continue;
                                }
                            }
                        }
                    }

                }//end if(nManualStartFlag!=1){//SYLEE130221JOYTECH SETUP PRESS

            }else {//syle170725-3
			*/ //sylee230420 
            if (nReFlagOpenOld[ip] == 1) {//syle170725-3  //SYLEE171120-2  IP3->IP
                continue;
            }

           //sylee230420  }

            if (nShortFail1[ip] > 0) {//sylee120921
                continue;
            }

            //sylee230420 if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip] == 1) {//sylee171120-1   
                continue;
            }//sylee171120-1
           //sylee230420  }
        }//sylee170614-1 

        if (nOpenErrFlag[ip] == 1) {//move
            nOpenErrFlag[ip] = 2;
        }

        //   nCellNo= nBlockPieceNo1[nBlockCountP][ip];//nBlockPieceNo1[blockno][pieceno]==CELLNO
        //   if(nBlockRes[nCellNo]==BLOCK_RES_PASS || nBlockRes[nCellNo]==BLOCK_RES_OPEN){////0=init,  1=pass,2=open, 3 short, 4=o +s,7 기타 error

        //   if(nBlockRes[nCellNo]!=0){////0=no test,  1=pass,2=open, 3 short, 4=o +s,7 기타 error
        //       continue;
        //   }

        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;
        nECount = 0;
        nFailL1CoPiece = 0;
        nEt1 = 0;
        nShort2FailFlag1 = 0;

        //*******************************************************************************************************************************//
        //Task1: 

        if (ipFlag == 1)    //son multi piece면 g_pvBDLData31[dutId][ip]에서 nRCount를 가져 온다.
        {
            nRCount = (g_pvBDLData31[dutId][ip]->size() - 1); //SYLEE180810-1-DUT16 //son190704-4WDUT16

        }
        else {
            nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16 //son190704-4WDUT16
        }

        nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
        for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
        {                                  //           Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
            tp1 = i * i;
            if (tp1 >= nRCount) {
                //son SQMatrixdml size를 결정한다.
                nSQCount1 = i;//sylee120908
                break;
            }
        }

        //sylee170327-import  interlock
        if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
            //  if( (nSQCount1==0) )//sylee170327-1 import
            str.Format("Error No 7513-1 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }

        ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));

        //################################################################################################################################
        //SET 
        int nTmpPinNo1; //sylee160728-2

        //------------------------------------------
        //son nSQNet1[i][j]에 Short 대상 핀 배치
        for (ik = 1; ik <= nRCount; ik++)
        {
            i = (ik - 1) / nSQCount1 + 1;       //mok   //son row
            j = (ik - 1) - nSQCount1 * (i - 1); //na    //son col
            j = j + 1;

            //son ipFlag로 멀티 piece인지 파악. nProType만 가지고고 체크하지 않는다.
            if (ipFlag == 1) {//short   PIECE MULT.     
                nTmpPinNo1 = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin; // 1 VB,    =2VC,   //SYLEE180810-1-DUT16   //son190704-4WDUT16
            }
            else {
                nTmpPinNo1 = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16    //son190704-4WDUT16
            }

            for (int jk1 = 1; jk1 <= nOpen2Li1[ip][0][0]; jk1++) {//sylee160801-3
                if (nTmpPinNo1 == (nOpen2Li1[ip][jk1][0])) {    //sylee160816-1
                    nTmpPinNo1 = nOpen2Li1[ip][jk1][1]; //sylee160816-1
                }//sylee160728-2
            }//end of for( int jk1=1; jk1<=nOpen2Li1[ip2][0][0]; jk1++)

            nSQNet1[i][j] = nTmpPinNo1; //sylee160801-3

            if (ik == nRCount) {
                nSQLastPin = j;//sylee120908   ///last row , last col.
                nSQLastY1 = i;
            }
        }

        //sylee151109-3  if(SysSet13.m_nSet18!=1){//sylee150508  2n est
        if (nFlagEstModelMake == 1) {//sylee151109-2
            nEt_StepSumTemp = nEt_StepSumTemp + (nSQLastY1 - 1) + (nSQCount1 - 1);  //sylee130410 

            if (ip == ipEnd) {
                nEt_StepSum = nEt_StepSumTemp;//sylee130410
            }
        }

        //===================================================================================


       int iktmp, ikok;
        iktmp = 0; ikok = 0;

        //----------------------------------------------------------------------
        //son One Piece 통검사  케이스의 nSQNet1[i][j]에 Short 대상 핀 배치
        if (nProOneP_RunFlag1 == 1)
        {
            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
            {
                if (nProType == 3)
                {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0)
                    {
                        for (ik = 1; ik <= nRCount; ik++)
                        {
                            ikok = 0;
                            for (int k1 = 1; k1 <= nProOneP_Short1[0]; k1++)
                            {
                                //SYLEE180810-1-DUT16   //son190704-4WDUT16
                                if ((nProOneP_Short1[k1] + 1) == (nBDLData3[dutId][ik][1] + 1)) {
                                    ikok = 1;
                                }
                            }
                            if (ikok == 0)
                            {
                                iktmp++;
                                i = (iktmp - 1) / nSQCount1 + 1;//mok
                                j = (iktmp - 1) - nSQCount1 * (i - 1) + 1;//na                    

                                //son190704-4WDUT16
                                nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 
                                nSQLastPin = j;
                                nSQLastY1 = i;
                            }

                        }
                    }
                }
            }
        }

        //================================================================================================================
        //nEt_StepSum=(nSQLastY1-1)*2*ipEnd;  //sylee130219joytech //estimation
        //================================================================================================================


        //#2 second search    hv  adc           
        // 1000 point 

        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        //row

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;
        Sub71.OnPinAllReset1(35073); ///PIN ALL RESET 
        nRetry1 = 0;//SYLEE121103

        nHVDStopTime1 = (long)GetuSecond();//sylee121103

        //sylee170617   Task1Retry://SYLEE121103

        //hdpark220511 spark begin
        if (Sub71.m_bModifySparkMeas)
        {
            Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);
            Sub71.SetVBReadMode();
        }
        // spark end

        if (Sub71.fpLeak)
        {
            fprintf(Sub71.fpLeak, "\n &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& \n");

            for (int col = 1; col <= nSQCount1; col++)
            {
                for (int row = 1; row <= nSQCount1; row++)
                {
                    if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "%5d ", nSQNet1[col][row] + 1);
                }
                if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n");
            }
            if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n");
        }

		if(nLeakACMode1==2){//sylee241120-2
			nK1Start=0;//sylee241120-2
		}else{ 
			nK1Start=1;//sylee241120
		}

        for (ik = nK1Start; ik < nSQLastY1; ik++)     // FIRST LOOP //Y  VB   //sylee241120
        {

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                nFlag_Spark_PinOn = 1;  //sylee200710-1 NEW_SPARK
                //SYLEE121103  nRetry1=0; 
                //SYLEE121103  Task1Retry: 
                //SYLEE121103  if(ik==1  || nSQStep1flag==2 || nRetry1==1){

            if ( ik == nK1Start || nSQStep1flag == 2)    //SYLEE121103  //sylee241204
            {
                Sub71.OnPinAllReset1(35120); ///PIN ALL RESET  

                //son for row : 1 라인씩 쌓아가면서  모두 VB 설정
                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++)      
                {
					if(nLeakACMode1==2){//sylee241120-2
						if (ik2 ==(ik+1)) {//sylee241120-2
							continue;//sylee241120-2
						}//sylee241120-2						
					}else{//sylee241120-2
						if (ik2 > ik) {
							continue;
						}
					}

                    // hdpark220511 spark
                    if (Sub71.m_bModifySparkMeas)
                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                    //son for col
                    for (ih = 1; ih <= nSQCount1; ih++)     //X // Second LOOP   vc pin 
                    {
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        //son VB Pin 설정
                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb  

                        nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127
                        if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                            nPinSetSkipVb = 3; //sylee151005 //ACE400               //son230127
                        }

                        //son OPEN이 발생한 piece라면  
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            //son VB 설정한 대표핀의 Net에 Open 에러가 있다면 해당 Net 안의 Open pin위치도 VB로 같이 설정한다.  
                            if (nOpenErrList[tmp1][OPERR_START] > 0) {
                                for (int s1 = nOpenErrList[tmp1][OPERR_START]; s1 <= nOpenErrList[tmp1][OPERR_END]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }         

                    }
                }

                nSQStep1flag = 0;
            }
            else
            {//end of if(ik==1  || nSQStep1flag==2)

                Sub71.OnPinResetVC(35176);
                //              Sub71.Delay_100ns(100);//10uSEC  

                // hdpark220511 spark
                if (Sub71.m_bModifySparkMeas)
                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);    // 1'st row pin check


                for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                    if (ik == nSQLastY1) {  //LAST Y STEP
                        if (ih > nSQLastPin) {
                            break;//SKIP   
                        }
                    }

                    //son VB Pin 설정
                    Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 1); //=1VB,  

                    nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400               //son230127
                    }

                    //son OPEN이 발생한 piece라면  
                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ik][ih];
                        //son VB 설정한 대표핀의 Net에 Open 에러가 있다면 해당 Net 안의 Open pin위치도 VB로 같이 설정한다.  
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    }
 
                }


				if(nLeakACMode1==2){//sylee241120 
					for (ih = 1; ih <= nSQCount1; ih++) {  //SYLEE241120 
						if ((ik + 1) == nSQLastY1) {
							if (ih > nSQLastPin) {
								break;//SKIP
							}
						}
						Sub71.AOnPinReSet1(2, nSQNet1[ik + 1][ih], 1); 				 
                        tmp1 = nSQNet1[ik + 1][ih]; //SYLEE241217
                        if (nOpenErrList[tmp1][OPERR_START] > 0) {
                            for (int s1 = nOpenErrList[tmp1][OPERR_START]; s1 <= nOpenErrList[tmp1][OPERR_END]; s1++) {
                                Sub71.AOnPinReSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);    
                            }
                        }

					}
				} 


            }

            for (ih = 1; ih <= nSQCount1; ih++)   //X   // Second LOOP   vb pin  
            {
                if ((ik + 1) == nSQLastY1) {
                    if (ih > nSQLastPin) {
                        break;//SKIP
                    }
                } 


                /////////////////////////////////////////////////////////////////////////////////////////
                //----------------
                //son VC Pin 설정
                Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =1,VB,   all 

                nPinSetSkipVcCnt++; //sylee151005 //ACE400                  //son230127
                if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                    nPinSetSkipVc = 3; //sylee151005 //ACE400               //son230127
                }

                //--------------
                //son SPARK_NEW
                if (SysSet13.m_nSparkMode == SPARK_NEW)
                {
                    /////////////////////////////////////////////////////////////          
                    if (nSparkUse == 1 && nSparkDetect1 == 1) //SYLEE200714-2
                    {

                        if (nFailL1CoPiece < SysInfo05.m_nIsEr)   //SPARK
                        {
                            ret1 = Sub71.OnSparkStatus();
                            //  ret1=0;

                            if (ret1 == 1)//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                            {
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10000);  //1ms  
                                nSparkTmp = nSQNet1[ik + 1][ih] + 1;//syloee200714

                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                } //sylee230305 end

                                if (nSparkFailNo[nSparkTmp] != 1)//syloee200714
                                {
                                    if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih] + 1;//pin  vb

                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                        nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                        t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                        ////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////
                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                           nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                        nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                        nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                        nShortFlag = 1;//sylee120915
                                        Sub71.OnSparkOn(1);     //hdpark220412 
                                        Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                    }   //end of if(nFailL1Co<3000){ //SPARK    
                                }

                            }// if(ret1==1){

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                    }//end of  if(nSparkUse==1){

                //SPARK############################################################################################ 

                }

                //---------------
                //son SPARK_OLD
                else
                {
                    if (nSparkUse == 1) {
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                            ret1 = Sub71.OnSparkStatus();
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                //str.Format("Error No 7502,     Spark Detect   !  "   ); 
                                str.Format("Error No 7502,  Spark Detect!  Pin=%d ", nSQNet1[ik + 1][ih] + 1);
                                MyTrace(PRT_BASIC, str);     //son221104_2
                                m_list1.AddString(str);
                                nlist1++;

                                //sylee230305 begin
                                t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no 
                                t1 = nPinToPiece(t1);//sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                }
                                //sylee230305 end

                                //SPARK############################################################################################

                                if (nFailL1Co < 3000) {////SPARK

                                    /*  if(nProOneP_RunFlag1==1){//sylee131221
                                        if(nReSheetFlag1!=1){//sylee140429-1
                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                        nProOneP_RunFlag1=0;
                                        goto TaskEnd100;
                                        }
                                        }
                                        }
                                    */

                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                    //log buffer
                                    nFailL1Co++;
                                    nFailL1CoPiece++;
                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                    nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih] + 1;//pin  vb
                                    nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                    t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no    

                                    //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                    nFailL1[nFailL1Co][9] = nVSet;
                                    nFailL1[nFailL1Co][10] = nISet;
                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                    nFailL1[nFailL1Co][12] = -1;//Sub71.V1;//VB
                                    nFailL1[nFailL1Co][13] = -1;//Sub71.X1;//VC
                                    nFailL1[nFailL1Co][14] = -1;//Sub71.Y1;//I
                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                    nShortFlag = 1;//sylee120915
                                    Sub71.OnSparkOn(1); // hdpark220412

                                    /* //sylee150618
                                        if(nProOneP_RunFlag1==1){//sylee140514
                                        if(nReSheetFlag1!=1){//sylee140514
                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                        nProOneP_RunFlag1=0;
                                        goto TaskEnd100;
                                        }
                                        }
                                        }

                                    */

                                    Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  


                                }   //end of if(nFailL1Co<3000){ //SPARK

                                //SPARK############################################################################################                                 


                            }// if(ret1==1){

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                    }//end of  if(nSparkUse==1){

                }   //end of SPARK_OLD



                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ik + 1][ih];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                    Sub71.Delay_100ns(10000); //1ms
                    Sub71.AOnReadV1I1_ADC_I();

                    if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(); ///PIN ALL RESET //test
                            Sub71.Delay_100ns(1000); //1ms
                    }
                */

            } // ih

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

            //////////////////////////////////////////////////////////////////////////////////



            if (nHVIADCFlag == 1) 
            {

                //#1-1                 
                if (nFastHv1RunStep == 1) {//sylee150415 fasthv                  
                    nFastHv1AdRun = 1;//sylee150415 fasthv                               
                }
                else {
                    nFastHv1AdRun = 0;//sylee150415 fasthv  
                }

                if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {//sylee130325   //sylee150407                  
                    AHV_ADCI_Read1_EST1(nProRv2, nDelay10);  //sylee130107  //estimation
                }
                else {
                    AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);//sylee150227
                }
                //  Sub71.R1= dIADC1  ;//ADC
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv2);
            }

            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
            {
                 ret1 = Sub71.OnSparkStatus();
                 if (ret1 == 1)
                 {
                     nSpark1_Detect2 = g_nSparkWaitingEnable;   //hdpark231121//hdpark230712 waiting에서 spark 검출, 
																// hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                     Sub71.OnSparkOn(0);
                     Sub71.Delay_100ns(10000);  //1ms  
                     Sub71.OnSparkOn(1);
                     if (Sub71.fpSpark)	
                        fprintf(Sub71.fpSpark, ", r@, %d, %.1f, %.1f \n", nSQNet1[ik + 1][ih] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg);  //hdpark231121
                 }
                 else
                 {
                     nSpark1_Detect2 = 0; //hdpark230705
                 }

                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                {
                    if (nFailL1CoPiece < SysInfo05.m_nIsEr) 
                    {   
                        ih = 1;         // hdpark230712 waiting 시 첫번째 핀번호로 설정
                        nSparkTmp = nSQNet1[ik + 1][ih] + 1;
                        if (nSparkFailNo[nSparkTmp] != 1) 
                        {
                            srand((unsigned int)time(NULL));
                            double dTemp1 = (rand() % 3);					// ~ 3 V

                            if (nFailL1Co < 3000) 
                            {                                                               

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                //log buffer
                                nFailL1Co++;
                                nFailL1CoPiece++;
                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih] + 1;//pin  vb

                                nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                ////////////////////////////////////////////////////////////////////////////////
                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                //////////////////////////////////////////////////////////////////////////////////////
                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                nFailL1[nFailL1Co][9] = nVSet;
                                nFailL1[nFailL1Co][10] = nISet;
                                nFailL1[nFailL1Co][11] = m_nMode1;
                                //hdpark231121.
                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                nShortFlag = 1;//sylee120915
                            }   //end of if(nFailL1Co<3000) //SPARK    
                        }

                        //  }// if(ret1==1)

                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                }//end of  if(nSparkUse==1)
            }

            IADClog1[ip][ik] = Sub71.R1;///logging 
            if (nHVIADCFlag == 1) {
                if (Sub71.R1 <= nProRv2) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

                   /*//sylee170617-1     ok
                   if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;

                       Sub71.OnPinAllReset1(); ///PIN ALL RESET
                       Sub71.Delay_100ns(2000000);  //200ms  //SYLEE121103 10->200

                       goto Task1Retry;
                   }
                   */
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    nSQStep1flag = 2;

                }


            }
            else {
                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

/* //sylee170617  
                   if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;
                       Sub71.OnPinAllReset1(); ///PIN ALL RESET
                       Sub71.Delay_100ns(nErrorDelayTime1);  //10ms
                       goto Task1Retry; //sylee170617-test
                   }
*/

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    nSQStep1flag = 2;
                }
            }


            if (nFlagEstModelMakeSelect == 2) {//sylee130325    //estimation
                nFailFlag1 = 0;  // ALLPASS
            }


            if (nFastHv1RunStep == 1) {//sylee150415 fasthv
                if (nFastHv1AdRun == 1) {
                    if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                        nFailFlag1 = 0;  // ALLPASS
                        nFastHv1Piece[ip] = 1;
                        nFastHv1PieceReturn = 1;//sylee150415
                        goto TaskEnd300;
                    }
                }
            }

            //==============================================================================================================================
            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block   y

            if (nFailFlag1 == 1) {  //if error  

                BOOL bAllPassFlag = TRUE;  // hdpark231205
                nDebug11 = 1;//sylee170618-test1 debugcode
                nFastHv1AdRun = 0;//sylee150415 fasthv
                Sub71.OnPinResetVB(35643);   //sylee121029 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //V                    

                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;


			    	if(nLeakACMode1==2){//sylee241120-2
						if (ik2 ==(ik+1)) {//sylee241120-2
							continue;//sylee241120-2
						}//sylee241120-2						
					}else{//sylee241120-2
						if (ik2 > ik) { //doublecheck#2 
					    	continue;
						}
					}


                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }

                    //=====================================================================================================================

                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610 


                    if (nHVIADCFlag == 1) {
                        AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 2);//sylee150227
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                    }

                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                    {
                        nSparkTmp = nSQNet1[ik + 1][1] + 1;
                        ret1 = Sub71.OnSparkStatus();
                        if (ret1 == 1)
                        {
                            nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121//hdpark230712 waiting에서 spark 검출,  
                                                                        // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                            Sub71.OnSparkOn(0);
                            Sub71.Delay_100ns(10);  //1us  
                            Sub71.OnSparkOn(1);
                            if (Sub71.fpSpark)
                                fprintf(Sub71.fpSpark, ", r@@, %d, %.1f, %.1f \n", nSparkTmp, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                        }
                        else
                        {
                            nSpark1_Detect2 = 0; //hdpark230705
                        }

                        if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                        {
                            if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                            {
                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                } //sylee230305 end

                                if (nSparkFailNo[nSparkTmp] != 1)
                                {
                                    srand((unsigned int)time(NULL));
                                    double dTemp1 = (rand() % 3);					// ~ 3 V

                                    if (nFailL1Co < 3000)
                                    {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                        nFailL1[nFailL1Co][5] = nSparkTmp;//pin  vb

                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                        nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                        t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                        ////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////
                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        // hdpark231121 
                                        nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                        nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                        nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                        nShortFlag = 1;//sylee120915
                                    }   //end of if(nFailL1Co<3000) //SPARK    
                                }

                                //  }// if(ret1==1)

                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                        }//end of  if(nSparkUse==1)
                    }


                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    BOOL bProgressiveFault = FALSE;            // hdpark231205

                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv2) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                            if (Sub71.R1 > (nProRv3 * 2))     // hdpark231205, 판정 값보다 많이 차이가 나면 진행성 불량 조건으로 판정
                            {
                                bProgressiveFault = TRUE;
                            }
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV      // hdpark220715 nProRv2 -> nProRv1
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 

                    //=====================================================================================================================
                    //##################################################################################################################################

                    //one line & one line  search
                    if (nFailFlag2 == 1) {

                        nDebug12 = 1;//sylee170618-test1 debugcode
                        BOOL bAllPassFlag = TRUE;  // hdpark231205

                        // Leak VC Pin Search
                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih6 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }
                            Sub71.OnPinResetVB(35839);//SYLEE121016***** all reset                                   
                            // Sub71.Delay_100ns(100);//10uSEC   


                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=1VB,                                    
                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ik2][ih6];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }
                            //=====================================================================================================================

                            //sylee210205   Sub71.Delay_100ns(10000);//sylee150302   1mS   
                            Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                            if (nHVIADCFlag == 1) {
                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 3);//sylee150227   // hdpark220715 nProRv2 -> nProRv3
                               //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {

                                Sub71.Delay_100ns(nDelay10);
                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                }

                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }

                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }

                            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                            {
                                nSparkTmp = nSQNet1[ik + 1][1] + 1;
                                ret1 = Sub71.OnSparkStatus();
                                if (ret1 == 1)
                                {
                                    nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121//hdpark230712 waiting에서 spark 검출,  
                                                                                // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                    Sub71.OnSparkOn(0);
                                    Sub71.Delay_100ns(10);  //1us  
                                    Sub71.OnSparkOn(1);
                                    if (Sub71.fpSpark)
                                        fprintf(Sub71.fpSpark, ", r@@@, %d, %.1f, %.1f \n", nSparkTmp, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                                }
                                else
                                {
                                    nSpark1_Detect2 = 0; //hdpark230705
                                }

                                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                                {
                                    if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                    {
                                        //sylee230305 begin
                                        t1 = nPinToPiece(nSparkTmp); //sylee230305
                                        if (SysInfo19.m_nUse == 1) {
                                            if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                        }
                                        if (g_nSkipPieceFlag1 == 1) {
                                            if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                        } //sylee230305 end

                                        if (nSparkFailNo[nSparkTmp] != 1)
                                        {
                                            srand((unsigned int)time(NULL));
                                            double dTemp1 = (rand() % 3);					// ~ 3 V

                                            if (nFailL1Co < 3000)
                                            {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                nFailL1[nFailL1Co][5] = nSparkTmp;//pin  vb

                                                nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                ////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////
                                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                // hdpark231121 
                                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                nFailL1[nFailL1Co][13] = nVSet      ;      // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                nShortFlag = 1;//sylee120915
                                            }   //end of if(nFailL1Co<3000) //SPARK    
                                        }

                                        //  }// if(ret1==1)

                                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                }//end of  if(nSparkUse==1)
                            }

                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv3) {// ok//HV // hdpark220715, nProRv2 -> nProRv3
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                    bAllPassFlag = FALSE;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                    bAllPassFlag = FALSE;
                                }
                            }//line & line  


                            //=====================================================================================================================
                            //################################################################################################################################
                            ///one point  & one point search

                            if (nFailFlag3 == 1) {

                                nDebug13 = 1;//sylee170618-test1 debugcode

                                // Leak VB Pin Search
                                for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin                                             

                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih2 > nSQLastPin) {

                                            break;//SKIP
                                        }
                                    }

                                    Sub71.OnPinResetVC(36017); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    if (nErrorDelayFlag1 == 1) {//sylee141002
                                        nErrorDelayFlag1 = 0;//sylee141002
                                        Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all

                                    /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ik + 1][ih2] + 1;//syloee200714

                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1); //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                }// if(ret1==1){

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                                        }//end of  if(nSparkUse==1){

                                    //SPARK############################################################################################ 


                                    }

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }


                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610                                                      
                                    //$$$$$$$$$$$$$$$$$$$ HV #1-4                                               
                                    if (nHVIADCFlag == 1) {
                                        // Sub71.Delay_100ns(nDelay10);//SYLEE141001
                                        //SYLEE141001
                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150227
                                        //     Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ  //sylee141016
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                        }

                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }

                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }

                                    }

                                    //hdpark230712 begin waiting 상태에서 spark check
                                    if (SysSet13.m_nSparkMode == SPARK_NEW)
                                    {
                                        ret1 = Sub71.OnSparkStatus();
                                        if (ret1 == 1)
                                        {
                                            nSpark1_Detect2 = g_nSparkWaitingEnable;  //hdpark231121 //hdpark230712 waiting에서 spark 검출, 
                                                                                      // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                            Sub71.OnSparkOn(0);
                                            Sub71.Delay_100ns(10000);  //1ms  
                                            Sub71.OnSparkOn(1);
                                            if (Sub71.fpSpark)
                                                fprintf(Sub71.fpSpark, ", r@@@@, %d, %.1f, %.1f \n", nSQNet1[ik + 1][ih2] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231205
                                        }
                                        else
                                        {
                                            nSpark1_Detect2 = 0; 
                                        }

                                        if (nSparkUse == 1 && nSpark1_Detect2 == 2)
                                        {
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                            {
                                                nSparkTmp = nSQNet1[ik + 1][ih2] + 1;

                                                //sylee230305 begin
                                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                if (SysInfo19.m_nUse == 1) {
                                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                }
                                                if (g_nSkipPieceFlag1 == 1) {
                                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                } //sylee230305 end

                                                if (nSparkFailNo[nSparkTmp] != 1)
                                                {
                                                    srand((unsigned int)time(NULL));
                                                    double dTemp1 = (rand() % 3);					// ~ 3 V

                                                    if (nFailL1Co < 3000)
                                                    {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                                        //log buffer
                                                        nFailL1Co++;
                                                        nFailL1CoPiece++;
                                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb

                                                        nSparkFailNo[nSparkTmp] = 1;
                                                        nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                        t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                        t1 = nPinToPiece(t1);
                                                        nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no 
                                                        nShortFail1[t1]++;
                                                        nShortCo1Spark[nBlockCountP][t1]++;
                                                        nShortFail1Flag1 = 1;
                                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                        nFailL1[nFailL1Co][9] = nVSet;
                                                        nFailL1[nFailL1Co][10] = nISet;
                                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                                        //hdpark231121 임의로 spark 값을 정함.
                                                        nFailL1[nFailL1Co][12] = g_dWaitingSparkV;  // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                        nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                        nFailL1[nFailL1Co][14] = nISet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                        nShortFlag = 1;
                                                    }   //end of if(nFailL1Co<3000) //SPARK    
                                                }

                                                //  }// if(ret1==1)

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                        }//end of  if(nSparkUse==1)
                                    }
                                    // hdpark230712 end

                                    //*********************************************//
                                    nHVDStopTime2 = (long)GetuSecond();
                                    nHVDStopTime3 = (nHVDStopTime2 - nHVDStopTime1);
                                    if (nHVDStopTime3 > nHVTimeOutSet) { //15sec
                                        nHVDStopFlag = 1;//sylee121009
                                        Sub71.R1 = 20000;
                                        nFailL1CoPiece = 3000;
                                    }
                                    //************************************************//

								  	if (Sub71.R1 > nProRv1){//sylee241224-2
									    if((int)nProStep1[nMod1][1]>=200000000){//sylee241224-2
										     if( Sub71.R1<(nProRv1*1.10)){//sylee241224-2 
												 nLeakNearFlag1=1;//sylee241226
											     nLeakNearPin1=(nSQNet1[ik + 1][ih2] + 1);//sylee241226
												 nLeakNearPin2=(nSQNet1[ik2][ih6] + 1);//sylee241226
												 Sub71.Delay_100ns(100000);  //10ms 
											 	 AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1);//sylee241226
			  								     nLeakNearFlag1=0;//sylee241226
											}
										}
									} 

                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV // hdpark220715, nProRv3 -> nProRv1
                                        }
                                        else {//fail

                                            nFailFlag4 = 1;
                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {//sylee130107
                                                if ((nFailL1[iq1][4] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //   if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }
                                    //=====================================================================================================================



                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ik2][ih6];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }
                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;

                                    }  //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1 




                                    if (nFailFlag4 == 1) {


                                        nDebug14 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;


                                        nErrorDelayFlag1 = 1;//sylee141002
                                        //sylee170620 ray    Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS

                                        //if((nOpenErrList[tmp1][0]<=0)&&(nOpenErrList[tmp2][0]<=0)){ 

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1)) {


                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                if (nProOneP_RunFlag1 == 1) {//sylee131221
                                                    if (nReSheetFlag1 != 1) {//sylee140429-1
                                                        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {//sylee131221
                                                            nProOneP_RunFlag1 = 0;
                                                            //sylee150616-import    goto TaskEnd100;
                                                        }
                                                    }
                                                }

                                                /*  //sylee150618
                                                if(nProOneP_RunFlag1==1){//sylee131221
                                                    if(nReSheetFlag1!=1){//sylee140429-1
                                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                                            nProOneP_RunFlag1=0;
                                                            goto TaskEnd100;
                                                        }
                                                    }
                                                }
                                                */

                                                if (nSparkUse == 1) {
                                                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                        break;// complete  error 
                                                    }
                                                }


                                                //####################################################################################//SYLEE150624
                                                /*    //sylee170613 

                                                                int iSum5,iCo5,iSet5;//sylee150627
                                                                iSum5=0;iCo5=0;//sylee150627


                                                                if(nPinDa1H[1][2][0]<100){//sylee150627

                                                                    iSet5=1;//SYLEETESTMODE-1
                                                                    if(Sub71.R1<340){//sylee150627
                                                                        iSet5=30;  //sylee150629   20->30
                                                                    }
                                                                    if(Sub71.R1<500){//sylee150627
                                                                        iSet5=10;
                                                                    }

                                                                }else{
                                                                    iSet5=1;
                                                                    if(Sub71.R1<340){//sylee150627
                                                                        iSet5=3;
                                                                    }
                                                                }

                                                                for(int k5=1;k5<=iSet5;k5++){//sylee150627

                                                                    Sub71.OnPinAllReset1(); ///PIN ALL RESET

                                                                    if(k5==1){//sylee150627
                                                                        Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC
                                                                    }

                                                                    Sub71.AOnPinSet1(2,nSQNet1[ik+1][ih2], 2) ;  // =2VC  all
                                                                    Sub71.AOnPinSet1(2,nSQNet1[ik2][ih6], 1);   // =1,VB,   all

                                                                    if(k5==1){
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627
                                                                    }
                                                                    AHV_ADCI_Read1_OneToM(nProRv3,nDelay10);//sylee150627

                                                                    if(Sub71.R1<700.){//sylee150627
                                                                        iSum5=iSum5+(int)Sub71.R1;//sylee150627
                                                                        iCo5++;//sylee150627
                                                                    }//sylee150627

                                                                    if(Sub71.R1>=700){//sylee150627
                                                                        break;
                                                                    }

                                                                }//sylee150627

                                                                if(iCo5>1){//sylee150627
                                                                    Sub71.R1=iSum5/iCo5;//sylee150627
                                                                }//sylee150627

                                                                if(nPinDa1H[1][2][0]<100){//sylee150627
                                                                    nProRv3=nProRv0;
                                                                }

                                                                if( Sub71.R1<=nProRv3){//sylee150627
                                                                    break;
                                                                }



                                                */  //sylee170613 

                                                //##############################################################################  //sylee150627

                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block 

									            if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
													   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1  
													if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
														nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
													}
													else {
														nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
														nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
													}
												}else{

													if( (ik+1) < ik2 ){//sylee241204-2
													    nFailL1[nFailL1Co][F_AC]=0;
													}else{
													    nFailL1[nFailL1Co][F_AC]=1;
													}
													nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
													nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc

                                                	for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
														if ((nFailL1[i5][5] == (nSQNet1[ik2][ih6] + 1)) && (nFailL1[i5][4] == (nSQNet1[ik + 1][ih2] + 1))) {  
															nFailL1[i5][F_AC] =0;
															nFailL1[nFailL1Co][F_AC]=0;
														}
													} 

												} 


                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }

                                                t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no   

                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                nShortFlag = 1;//sylee120915 
                                                nDebug15 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000){//array size nFailL1[



                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC   

                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }


                                        }   //endof if((nPin1[0]<1)&&(nPin2[0]<1)){ 




                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(36512); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(36517); //VbCall reset    


                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923
                                                
                                    //hdpark231121 begin waiting 상태에서 spark check
                                                if (SysSet13.m_nSparkMode == SPARK_NEW)
                                                {
                                                    ret1 = Sub71.OnSparkStatus();
                                                    if (ret1 == 1)
                                                    {
                                                        //nSpark1_Detect2 = g_nSparkWaitingEnable;   //hdpark230829 waiting에서 spark 검출, 2->0, spark 다발로 검출 안되도록 함.
                                                        Sub71.OnSparkOn(0);
                                                        Sub71.Delay_100ns(10000);  //1ms  
                                                        Sub71.OnSparkOn(1);
                                                        if (Sub71.fpSpark)	fprintf(Sub71.fpSpark, ", r@@@@@, %d, %.1f, %.1f \n", nSQNet1[ik + 1][ih2] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg);
                                                    }
                                                    else
                                                    {
                                                        nSpark1_Detect2 = 0;
                                                    }

                                                    if (nSparkUse == 1 && nSpark1_Detect2 == 2)
                                                    {
                                                        if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                                        {
                                                            nSparkTmp = nSQNet1[ik + 1][ih2] + 1;

                                                            //sylee230305 begin
                                                            t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                            if (SysInfo19.m_nUse == 1) {
                                                                if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                            }
                                                            if (g_nSkipPieceFlag1 == 1) {
                                                                if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                            } //sylee230305 end

                                                            if (nSparkFailNo[nSparkTmp] != 1)
                                                            {
                                                                srand((unsigned int)time(NULL));
                                                                double dTemp1 = (rand() % 3);					// ~ 3 V

                                                                if (nFailL1Co < 3000)
                                                                {
																	MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
																					__LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);
                                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                                    //log buffer
                                                                    nFailL1Co++;
                                                                    nFailL1CoPiece++;
                                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                                    nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb

                                                                    nSparkFailNo[nSparkTmp] = 1;
                                                                    nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                                    t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                                    t1 = nPinToPiece(t1);
                                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no 
                                                                    nShortFail1[t1]++;
                                                                    nShortCo1Spark[nBlockCountP][t1]++;
                                                                    nShortFail1Flag1 = 1;
                                                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                                    nFailL1[nFailL1Co][10] = nISet;
                                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                                    // hdpark230829 
                                                                    nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                                    nFailL1[nFailL1Co][13] = nVSet;                 // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                                    nFailL1[nFailL1Co][14] = nISet;                  // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                                    nShortFlag = 1;
                                                                }   //end of if(nFailL1Co<3000) //SPARK    
                                                            }

                                                            //  }// if(ret1==1)

                                                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                                    }//end of  if(nSparkUse==1)
                                                }
                                                // hdpark231121 end

                                                if (Sub71.R1 <= nProRv3) {// ok//HV   line & one
                                                }
                                                else {//fail                    

                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(36609); ///PIN ALL RESET 
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                        AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923

                                                        //####################################################################################//SYLEE150624
                                                        if (Sub71.R1 > nProRv3) {


                                                            int iSum5, iCo5, iSet5;//sylee150627
                                                            iSum5 = 0; iCo5 = 0;//sylee150627


                                                            if (nPinDa1H[1][2][0] < 100) {//sylee150627

                                                                iSet5 = 1;//SYLEETESTMODE-1
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 30;  //sylee150629   20->30
                                                                }
                                                                if (Sub71.R1 < 500) {//sylee150627
                                                                    iSet5 = 10;
                                                                }
                                                            }
                                                            else {
                                                                iSet5 = 1;
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 3;
                                                                }
                                                            }

                                                            for (int k5 = 1; k5 <= iSet5; k5++) {//sylee150627

                                                                Sub71.OnPinAllReset1(36642); ///PIN ALL RESET 

                                                                if (k5 == 1) {//sylee150627
                                                                    Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC   
                                                                }

                                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all

                                                                if (k5 == 1) {
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627                                                                    
                                                                }
                                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150627   // hdpark220715, nProRv3 -> nProRv1

                                                                if (Sub71.R1 < 700.) {//sylee150627
                                                                    iSum5 = iSum5 + (int)Sub71.R1;//sylee150627
                                                                    iCo5++;//sylee150627
                                                                }//sylee150627

                                                                if (Sub71.R1 >= 700) {//sylee150627
                                                                    break;
                                                                }


                                                            }//sylee150627

                                                            if (iCo5 > 1) {//sylee150627
                                                                Sub71.R1 = iSum5 / iCo5;//sylee150627
                                                            }//sylee150627

                                                        }



                                                        if (nPinDa1H[1][2][0] < 100) {//sylee150627                                                                                  
                                                            nProRv3 = nProRv0;
                                                        }
                                                        //####################################################################################  //sylee150627
                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one // hdpark220715, nProRv3 -> nProRv1
                                                        }
                                                        else {//fail
                                                            if (Sub71.R1 < nProRv1) {//sylee141001
                                                                for (int ir = 1; ir < 4; ir++) {
                                                                    Sub71.R1 = Sub71.R1 * 1.1;//sylee141001
                                                                    if (Sub71.R1 > nProRv1) {
                                                                        break;
                                                                    }
                                                                }
                                                            }


                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            //sylee151208-1-import      nSQNet1[ik+1][ih2]=nPin1[st1];
                                                            //sylee151208-1-import      nSQNet1[ik2][ih6]=nPin2[st2];                                                                       


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                if(nProOneP_RunFlag1==1){//sylee131221
                                                                    if(nReSheetFlag1!=1){//sylee140429-1
                                                                        if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                                                            nProOneP_RunFlag1=0;
                                                                            goto TaskEnd100;
                                                                        }
                                                                    }
                                                                }
                                                                */

                                                                nFailCount[nMod1] = nFailCount[nMod1]++;

                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                /*//sylee151208-1-import
                                                                    if( nSQNet1[ik+1][ih2]<nSQNet1[ik2][ih6]){
                                                                        nFailL1[nFailL1Co][5]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                        nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                    }else{
                                                                        nFailL1[nFailL1Co][4]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                        nFailL1[nFailL1Co][5]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                    }
                                                                */ 

																if(nLeakACMode1!=2){//sylee241120-2  //sylee241204

																	nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1

																	if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
																	}
																	else {//sylee151208-1-import
																		nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
																	}//sylee151208-1-import
																}else{

																	if( (ik+1) < ik2 ){//sylee241204-2
																		nFailL1[nFailL1Co][F_AC]=0;
																	}else{
																		nFailL1[nFailL1Co][F_AC]=1;
																	}
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc 

                                                	               for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
																		if ((nFailL1[i5][5] == (nPin2[st2] + 1)) && (nFailL1[i5][4] == (nPin1[st1] + 1))) {  
																			nFailL1[i5][F_AC] =0;
																			nFailL1[nFailL1Co][F_AC]=0;
																		}
																   }   

																} 


                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }

                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc

                                                                //sylee151208-1-import  t1=nSQNet1[ik+1][ih2]+1;//PIECE  pin no 
                                                                t1 = nPin1[st1] + 1;//PIECE  pin no  //sylee151208-1-import 

                                                                //  }else{
                                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                    //}


                                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314 

                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w


                                                                nShortFlag = 1;//sylee120915 
                                                                nDebug16 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000)//array size nFailL1[



                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC 

                                                            //      Sub71.Delay_100ns(30000);//3mSEC  //sylee150904-3 //ace400

                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1){}else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++){ 

                                                }//end if }else{//fail  if( Sub71.R1<=nProRv1){// ok//HV   line & one

                                                Sub71.OnPinAllReset1(36820); ///PIN ALL RESET 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }



                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++){     


                                        } //end of   if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ){ //vb                                                         




                                    }   //if(nFailFlag4==1){ 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++){  //X   // Second LOOP   vb pin  

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)

                                if (bAllPassFlag == TRUE && bProgressiveFault == TRUE) // hdpark231205, leak fail -> pass 발생 처리, 진행성 불량, 영풍.
                                {
                                    if (nFailL1Co < 3000)
                                    {
                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1; //nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                        nFailL1[nFailL1Co][5] = -1;//pin  vc


                                        t1 = (int)nFailL1[nFailL1Co][4];
                                        if ((t1 > 0) && (t1 < 16384)) {
                                            nErrPin1S0[t1] = 1;
                                        }
                                        t1 = (int)nFailL1[nFailL1Co][5];
                                        if ((t1 > 0) && (t1 < 16384)) {
                                            nErrPin1S0[t1] = 1;
                                        }

                                        t1 = nSQNet1[ik2][ih6] + 1;//nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no  
                                        t1 = nPinToPiece(t1);
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   

                                        nShortFail1[t1]++;
                                        nShortCo1[nBlockCountP][t1]++;
                                        nShortFail1Flag1 = 1;

                                        nFailL1[nFailL1Co][6] = Sub71.R1;
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                        nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                        nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                        nShortFlag = 1;
                                    }
                                }
#endif
                                //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC(36897);

                                // hdpark221117 add, VB Mode로 인한 Leak 오류 수정
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                                for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  
                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih3 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                             
                                    /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ik + 1][ih3] + 1;//syloee200714

                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih3] + 1;//pin  vb

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ik + 1][ih3] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1); //hdpark220412
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                }// if(ret1==1){

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK 

                                        }//end of  if(nSparkUse==1){

                                    }
                                    //SPARK############################################################################################ 

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih3];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }
                                }

                            }// if(nFailFlag3==1){ 

                            // hdpark220511 spark
                            if (Sub71.m_bModifySparkMeas)
                                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);


                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################


                        }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 


                    //=====================================================================================================================
                    }// end of  if(nFailFlag2==1){   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++){     // FIRST LOOP //Y   //Vc

            }//end of  if(nFailFlag1==1){


            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }

        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++)     // FIRST LOOP //Y  VB


        //==============================================================================================================================
        //################################################################################################################################

        Sub71.OnPinAllReset1(37051); 	if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, " --------------------------------------------------------------- \n");





        //================================================================================================================
        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        // Y 
        //세로 

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;
        nRetry1 = 0;    //SYLEE121103   
        nHVDStopTime1 = (long)GetuSecond();//sylee121103

	   if(nLeakACMode1==2){//sylee241120-2
			nK1Start=0;//sylee241120-2
		}else{ 
			nK1Start=1;//sylee241120
		}

            //sylee170617   Task2Retry:  //SYLEE121103

        for (  ik = nK1Start; ik < nSQCount1; ik++)      // FIRST LOOP //Y  VB   //sylee241204
        {
            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908
                nFlag_Spark_PinOn = 1;  //sylee200710-1 NEW_SPARK
            //SYLEE121103  nRetry1=0;            

            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                break;// complete  error                                                 
            }

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);   // 2'nd col pin check

            //SYLEE121103 Task2Retry:

            if ( ik == nK1Start  || nSQStep1flag == 2) {    //SYLEE121103  //sylee241204

                //SYLEE121103  if(ik==1  || nSQStep1flag==2  || nRetry1==1){  

                Sub71.OnPinAllReset1(37096); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {

				   if(nLeakACMode1==2){//sylee241120-2
						if (ik2 ==(ik+1)) {//sylee241120-2
							continue;//sylee241120-2
						}//sylee241120-2						
					}else{//sylee241120-2
					   if (ik2 > ik) {  
					    	continue;
						}
					}

                    for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=1vb

                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////
                        /* //debug
                        Sub71.Delay_100ns(10000); //1ms
                        Sub71.AOnReadV1I1_ADC_I();

                        if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(); ///PIN ALL RESET //test
                        Sub71.Delay_100ns(1000); //1ms
                        }
                        */
                        //////////////////////////////////////////////////////////////////////////////////

                    }
                }

                nSQStep1flag = 0;



            }
            else {//end of if(ik==1  || nSQStep1flag==2){


                Sub71.OnPinResetVC(37143);
                //   Sub71.Delay_100ns(100);//10uSEC  

                for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                    if (ih == nSQLastY1) {  //LAST Y STEP
                        if (ik > nSQLastPin) {
                            break;//SKIP   
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ih][ik], 1); // 1=vb     
                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ih][ik];
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////
                    /* //debug
                    Sub71.Delay_100ns(10000); //1ms
                    Sub71.AOnReadV1I1_ADC_I();

                    if( Sub71.R1>1000){// ok//HV
                    // Sub71.OnPinAllReset1(); ///PIN ALL RESET //test
                    Sub71.Delay_100ns(1000); //1ms
                    }
                    */
                    //////////////////////////////////////////////////////////////////////////////////

                }

                if(nLeakACMode1==2){//sylee241120-3
					for (ih = 1; ih <= nSQLastY1; ih++) {  //X   // Second LOOP   vb pin  
						if (ih == nSQLastY1) {
							if ((ik + 1) > nSQLastPin) {
								break;//SKIP
							}
						}
						Sub71.AOnPinReSet1(2, nSQNet1[ih][ik + 1], 1);  
					  
                        tmp1 = nSQNet1[ih][ik + 1]; //SYLEE241217
                        if (nOpenErrList[tmp1][OPERR_START] > 0) {
                            for (int s1 = nOpenErrList[tmp1][OPERR_START]; s1 <= nOpenErrList[tmp1][OPERR_END]; s1++) {
                                Sub71.AOnPinReSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1);    
                            }
                        }

					}
				} 


            }

            for (ih = 1; ih <= nSQLastY1; ih++) {  //X   // Second LOOP   vb pin  
                if (ih == nSQLastY1) {
                    if ((ik + 1) > nSQLastPin) {
                        break;//SKIP
                    }
                }


				if (Sub71.m_bModifySparkMeas)
				{
					if (!Sub71.m_bSetVBRead)
					{
                        // spark 발생시 vb mode off 된 것을 다시 on 시킴. 연속 pin 등록일 경우.
						Sub71.SendCmdToDigitizer(__LINE__, ih, SPARK_TRG_ON);	// hdpark230504
					}
				}

                Sub71.AOnPinSet1(2, nSQNet1[ih][ik + 1], 2);   // =2,Vc   


                //--------------
                //son SPARK_NEW
                if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                {
                    /////////////////////////////////////////////////////////////////////////////////////////////
                    if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {    //SPARK 
                            ret1 = Sub71.OnSparkStatus();
                            //ret1=0;
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10000);  //1ms  

                                nSparkTmp = nSQNet1[ih][ik + 1] + 1;//syloee200714

                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                } //sylee230305 end

                                if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714


                                    if (nFailL1Co < 3000) {////SPARK

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                        nFailL1[nFailL1Co][5] = nSQNet1[ih][ik + 1] + 1;//pin  vb

                                        // hdpark220511 spark
                                        if (Sub71.m_bModifySparkMeas)
                                            Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                        nSparkTmp = nSQNet1[ih][ik + 1] + 1;//syloee200714
                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                        nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                        t1 = nSQNet1[ih][ik + 1] + 1;//PIECE  pin no    

                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                           nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                        nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                        nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                        nShortFlag = 1;//sylee120915

                                        Sub71.OnSparkOn(1); //hdpark220412


                                    }   //end of if(nFailL1Co<3000) //SPARK
                                }

                            }

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                        // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                        if (Sub71.m_bModifySparkMeas)
//<                            Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);

                    }// end of if(nSparkUse==1){

                /////////////////////////////////////////////////////////////////////////////////////////////////

                }

                //----------------
                //son SPARK_OLD
                else
                {
                    if (nSparkUse == 1)
                    {
                        if (nFailL1CoPiece < SysInfo05.m_nIsEr) {    //SPARK 
                            ret1 = Sub71.OnSparkStatus();
                            if (ret1 == 1) {
                                Sub71.OnSparkOn(0);
                                str.Format("Error No 7503,  Spark Detect!  Pin=%d ", nSQNet1[ih][ik + 1] + 1);
                                MyTrace(PRT_BASIC, str);     //son221104_2
                                m_list1.AddString(str);
                                nlist1++;

                                //sylee230305 begin
                                t1 = nSQNet1[ih][ik + 1] + 1;//PIECE  pin no    
                                t1 = nPinToPiece(t1);//sylee230305

                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }
                                }//sylee230305
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }
                                }//sylee230305
//sylee230305 end

//SPARK############################################################################################

                                if (nFailL1Co < 3000) {////SPARK

                                /*  if(nProOneP_RunFlag1==1){//sylee131221
                                if(nReSheetFlag1!=1){//sylee140429-1
                                if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee131221
                                nProOneP_RunFlag1=0;
                                goto TaskEnd100;
                                }
                                }
                                }
                                */

                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                    //log buffer
                                    nFailL1Co++;
                                    nFailL1CoPiece++;
                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                    nFailL1[nFailL1Co][5] = nSQNet1[ih][ik + 1] + 1;//pin  vb
                                    nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                    t1 = nSQNet1[ih][ik + 1] + 1;//PIECE  pin no    

                                    //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                    nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                    nFailL1[nFailL1Co][9] = nVSet;
                                    nFailL1[nFailL1Co][10] = nISet;
                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                    nFailL1[nFailL1Co][12] = -1;//Sub71.V1;//VB
                                    nFailL1[nFailL1Co][13] = -1;//Sub71.X1;//VC
                                    nFailL1[nFailL1Co][14] = -1;//Sub71.Y1;//I
                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                    nShortFlag = 1;//sylee120915

                                    Sub71.OnSparkOn(1); //hdpark220412


                                    /*//sylee150618
                                    if(nProOneP_RunFlag1==1){//sylee140514
                                    if(nReSheetFlag1!=1){//sylee140514
                                    if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                    nProOneP_RunFlag1=0;
                                    goto TaskEnd100;
                                    }
                                    }
                                    }
                                    */ 


                                }   //end of if(nFailL1Co<3000) //SPARK 

                                //SPARK############################################################################################   

                                //  Sub71.OnSparkOn(1);
                            }

                        }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 
                    //}
                    }// end of if(nSparkUse==1)
                }



                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ih][ik + 1];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                Sub71.Delay_100ns(10000); //1ms
                Sub71.AOnReadV1I1_ADC_I();

                if( Sub71.R1>1000){// ok//HV
                // Sub71.OnPinAllReset1(); ///PIN ALL RESET //test
                Sub71.Delay_100ns(1000); //1ms
                }
                */

            }

            // hdpark220511 spark
            if (Sub71.m_bModifySparkMeas)
                Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_OFF);

            //////////////////////////////////////////////////////////////////////////////////

            ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            if (nHVIADCFlag == 1) {
                if (nFastHv1RunStep == 1) {//sylee150415 fasthv                  
                    nFastHv1AdRun = 1;
                }
                else {
                    nFastHv1AdRun = 0;
                }
                //#2-1                 
                if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {//sylee130325  //sylee150407
                    AHV_ADCI_Read1_EST1(nProRv2, nDelay10);  //sylee130107
                }
                else {
                    AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);//sylee150227
                }
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv2);
            }


            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
            {

                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                if (nSparkUse == 1) {  //sylee200714-2 ok wait
                    ret1 = Sub71.OnSparkStatus();//sylee200713-

                    if (ret1 == 1) {
                        nSpark1_Detect2 = g_nSparkWaitingEnable;      //hdpark231121  //hdpark230712 waiting에서 spark 검출, 
																	// hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                        Sub71.OnSparkOn(0);
                        Sub71.Delay_100ns(10000);  //1ms  
                        Sub71.OnSparkOn(1);
                        if (Sub71.fpSpark)
                            fprintf(Sub71.fpSpark, ", c@, %d, %.1f, %.1f \n", nSQNet1[nSQLastY1][ik + 1] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                    }
                    else
                    {
                        nSpark1_Detect2 = 0;        // hdpark230712
                    }
                }
                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                {
                    if (nFailL1CoPiece < SysInfo05.m_nIsEr) 
                    {  
                        nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1; ;//syloee200714

                        //sylee230305 begin
                        t1 = nPinToPiece(nSparkTmp); //sylee230305
                        if (SysInfo19.m_nUse == 1) {
                            if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                        }
                        if (g_nSkipPieceFlag1 == 1) {
                            if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                        } //sylee230305 end

                        if (nSparkFailNo[nSparkTmp] != 1) 
                        {
                            srand((unsigned int)time(NULL));
                            double dTemp1 = (rand() % 3);					// ~ 3 V

                            if (nFailL1Co < 3000) 
                            {

MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                dSparkI1[nSparkI1Po2][nSparkMaxX + 6] = (float)nSQNet1[nSQLastY1][ik + 1] + 1; //fail  nSQNet1[ih][ik+1]  


                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                //log buffer
                                nFailL1Co++;
                                nFailL1CoPiece++;
                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                nFailL1[nFailL1Co][5] = nSQNet1[nSQLastY1][ik + 1] + 1;//pin  vb
                                nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1;//syloee200714
                                nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                t1 = nSQNet1[nSQLastY1][ik + 1] + 1;//PIECE  pin no 

                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                nFailL1[nFailL1Co][9] = nVSet;
                                nFailL1[nFailL1Co][10] = nISet;
                                nFailL1[nFailL1Co][11] = m_nMode1;

                                // hdpark231121 임의로 spark 값을 정함.
                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                nFailL1[nFailL1Co][13] = nVSet;                 // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                nShortFlag = 1;//sylee120915

                            }   //end of if(nFailL1Co<3000) //SPARK
                        }
                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 
                }// end of if(nSparkUse==1)
            }

            IADClog1[ip][ik] = Sub71.R1;///logging

            if (nHVIADCFlag == 1) 
            {
                if (Sub71.R1 <= nProRv2) 
                {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else 
                {//fail

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;

                }
            }
            else 
            {
                if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //   nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }
            }


            if (nFlagEstModelMakeSelect == 2) {//sylee130325    //estimation
                nFailFlag1 = 0;  // ALLPASS
            }

            if (nFastHv1RunStep == 1) {//sylee150415 fasthv 
                if (nFastHv1AdRun == 1) {
                    if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                        nFailFlag1 = 0;  // ALLPASS
                        nFastHv1Piece[ip] = 1;
                        nFastHv1PieceReturn = 1;//sylee150415
                        goto TaskEnd300;
                    }
                }
            }

            //==============================================================================================================================
            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block   x

            if (nFailFlag1 == 1) {  //if error  2차 

                nDebug21 = 1;//sylee170618-test1 debugcode
                nFastHv1AdRun = 0;//sylee150415 fasthv          
                Sub71.OnPinResetVB(37617);   //sylee121029                

                if (Sub71.fpLeak)
                {
                    fprintf(Sub71.fpLeak, " FFFFF(First) \n");
                }

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {     // FIRST LOOP //Y   //Vc                   

                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;

			       if(nLeakACMode1==2){//sylee241120-2
						if (ik2 ==(ik+1)) {//sylee241120-2
							continue;//sylee241120-2
						}//sylee241120-2						
					}else{//sylee241120-2
						if (ik2 > ik) { //doublecheck#2 
					    	continue;
						}
					}

                    for (ih = 1; ih <= nSQLastY1; ih++)    //X // Second LOOP   vc pin 
                    {
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //1=vb

                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }

                    //=====================================================================================================================

                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 2);//sylee150227
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }

                    }

                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                    {

                        ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        if (nSparkUse == 1) {  //sylee200714-2 ok wait
                            ret1 = Sub71.OnSparkStatus();//sylee200713-

                            if (ret1 == 1) {
                                nSpark1_Detect2 = g_nSparkWaitingEnable;      //hdpark231121  //hdpark230712 waiting에서 spark 검출, 
                                                                            // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                Sub71.OnSparkOn(0);
                                Sub71.Delay_100ns(10);  //1us  
                                Sub71.OnSparkOn(1);
                                if (Sub71.fpSpark)
                                    fprintf(Sub71.fpSpark, ", c@@, %d, %.1f, %.1f \n", nSQNet1[nSQLastY1][ik + 1] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                            }
                            else
                            {
                                nSpark1_Detect2 = 0;        // hdpark230712
                            }
                        }
                        ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                        if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                        {
                            if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                            {
                                nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1; ;//syloee200714

                                //sylee230305 begin
                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                if (SysInfo19.m_nUse == 1) {
                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                }
                                if (g_nSkipPieceFlag1 == 1) {
                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                } //sylee230305 end

                                if (nSparkFailNo[nSparkTmp] != 1)
                                {
                                    srand((unsigned int)time(NULL));
                                    double dTemp1 = (rand() % 3);					// ~ 3 V

                                    if (nFailL1Co < 3000)
                                    {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                        dSparkI1[nSparkI1Po2][nSparkMaxX + 6] = (float)nSQNet1[nSQLastY1][ik + 1] + 1; //fail  nSQNet1[ih][ik+1]  


                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        //log buffer
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                        nFailL1[nFailL1Co][5] = nSQNet1[nSQLastY1][ik + 1] + 1;//pin  vb
                                        nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1;//syloee200714
                                        nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                        // hdpark220511 spark
                                        if (Sub71.m_bModifySparkMeas)
                                            Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                        nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                        t1 = nSQNet1[nSQLastY1][ik + 1] + 1;//PIECE  pin no 

                                        //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                        t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                        nShortFail1[t1]++;//sylee20121018//100=piecemax
                                        nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                        nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
        //sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;

                                        // hdpark231121 임의로 spark 값을 정함.
                                        nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                        nFailL1[nFailL1Co][13] = nVSet;                 // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                        nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                        nShortFlag = 1;//sylee120915

                                    }   //end of if(nFailL1Co<3000) //SPARK
                                }
                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 
                        }// end of if(nSparkUse==1)
                    }

                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    BOOL bProgressiveFault = FALSE;             // hdpark231205

                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv2) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                            if (Sub71.R1 > (nProRv3 * 2))     // hdpark231205, 판정 값보다 많이 차이가 나면 진행성 불량 조건으로 판정
                            {
                                bProgressiveFault = TRUE;
                            }
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV  // hdpark220715 nProRv2 -> nProRv1
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 

                    //=====================================================================================================================
                    //##################################################################################################################################

                    //one line & one line  search


                    if (nFailFlag2 == 1) {// 3차 

                        nDebug22 = 1;//sylee170618-test1 debugcode
                        BOOL bAllPassFlag = TRUE;	//hdpark231205

                     //sylee230811 import   for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 
						   for (int ih6 = 1; ih6 < nSQCount1; ih6++) {    //X // Second LOOP   vc pin //sylee230811 import

                            /*//sylee131114
                            if( ik2==nSQLastY1){  //LAST Y STEP
                            if(ih6>nSQLastPin){
                            break;//SKIP
                            }
                            }
                            */

                            if (ih6 == nSQLastY1) {  //LAST Y STEP  //sylee131114
                                if (ik2 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            Sub71.OnPinResetVB(37851);//SYLEE121016***** all reset                                   
                            //  Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1);  //=1Vb,  //point 

                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ih6][ik2];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }

                            //=====================================================================================================================

                            //sylee210205  Sub71.Delay_100ns(10000);//sylee150302   1mS  
                            Sub71.Delay_100ns(nErrorDelay1);//sylee150610


                            if (nHVIADCFlag == 1) {
                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 3);//sylee150227
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {


                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                }


                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }


                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }

                            if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                            {

                                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                if (nSparkUse == 1) {  //sylee200714-2 ok wait
                                    ret1 = Sub71.OnSparkStatus();//sylee200713-

                                    if (ret1 == 1) {
                                        nSpark1_Detect2 = g_nSparkWaitingEnable;      //hdpark231121  //hdpark230712 waiting에서 spark 검출, 
                                                                                    // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                        Sub71.OnSparkOn(0);
                                        Sub71.Delay_100ns(10);  //1us  
                                        Sub71.OnSparkOn(1);
                                        if (Sub71.fpSpark)
                                            fprintf(Sub71.fpSpark, ", c@@@, %d, %.1f, %.1f \n", nSQNet1[nSQLastY1][ik + 1] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121
                                    }
                                    else
                                    {
                                        nSpark1_Detect2 = 0;        // hdpark230712
                                    }
                                }
                                ///%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


                                if (nSparkUse == 1 && nSpark1_Detect2 == 2)  //sylee200724
                                {
                                    if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                    {
                                        nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1; ;//syloee200714

                                        //sylee230305 begin
                                        t1 = nPinToPiece(nSparkTmp); //sylee230305
                                        if (SysInfo19.m_nUse == 1) {
                                            if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                        }
                                        if (g_nSkipPieceFlag1 == 1) {
                                            if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                        } //sylee230305 end

                                        if (nSparkFailNo[nSparkTmp] != 1)
                                        {
                                            srand((unsigned int)time(NULL));
                                            double dTemp1 = (rand() % 3);					// ~ 3 V

                                            if (nFailL1Co < 3000)
                                            {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);

                                                dSparkI1[nSparkI1Po2][nSparkMaxX + 6] = (float)nSQNet1[nSQLastY1][ik + 1] + 1; //fail  nSQNet1[ih][ik+1]  


                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                nFailL1[nFailL1Co][5] = nSQNet1[nSQLastY1][ik + 1] + 1;//pin  vb
                                                nSparkTmp = nSQNet1[nSQLastY1][ik + 1] + 1;//syloee200714
                                                nSparkFailNo[nSparkTmp] = 1;//syloee200714

                                                // hdpark220511 spark
                                                if (Sub71.m_bModifySparkMeas)
                                                    Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                nFailL1[nFailL1Co][4] = -1;//pin  vc                                                                     

                                                t1 = nSQNet1[nSQLastY1][ik + 1] + 1;//PIECE  pin no 

                                                //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                //sylee220725                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;

                                                // hdpark231121 임의로 spark 값을 정함.
                                                nFailL1[nFailL1Co][12] = g_dWaitingSparkV;    // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                nFailL1[nFailL1Co][14] = nISet;               // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                nShortFlag = 1;//sylee120915

                                            }   //end of if(nFailL1Co<3000) //SPARK
                                        }
                                    }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 
                                }// end of if(nSparkUse==1)
                            }

                            //                            BOOL bProgressiveFault = FALSE;             // hdpark231205
                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv3) {// ok//HV // hdpark220715, nProRv2 -> nProRv3
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                    bAllPassFlag = FALSE;	//hdpark231205

//                                    if (Sub71.R1 > (nProRv3 * 2))     // hdpark231205, 판정 값보다 많이 차이가 나면 진행성 불량 조건으로 판정
//                                    {
//                                        bProgressiveFault = TRUE;
//                                    }
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV      // hdpark220715 nProRv2 -> nProRv1
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                    bAllPassFlag = FALSE;	//hdpark231205

                                }
                            }//line & line  

                            //=====================================================================================================================
                            //################################################################################################################################
                            ///one point  & one point search
                            //$$$$$$$$$$$$$$$$$$$ HV #2-4
                            if (nFailFlag3 == 1) {  //4 차  세로

                                if (Sub71.fpLeak)
                                {
                                    fprintf(Sub71.fpLeak, " FFFFF(Second), nProRv3 = %d, bProgressiveFault = %d \n", nProRv3, bProgressiveFault);
                                }
                                nDebug23 = 1;//sylee170618-test1 debugcode
//                                BOOL bAllPassFlag = TRUE;	//hdpark231205

                                for (int ih2 = 1; ih2 <= nSQLastY1; ih2++) {  //X   // Second LOOP   vb pin  


                                    if (ih2 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    if (ih6 != ih2) {//sylee121025
                                        continue;		// hdpark231205, row에서 처리하지만...
                                    }



                                    Sub71.OnPinResetVC(38067);
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    if (nErrorDelayFlag1 == 1) {//sylee141002
                                        nErrorDelayFlag1 = 0;//sylee141002
                                        Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ih2][ik + 1], 2);   // =1,VB,   all

                                    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
                                    {
                                        /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ih2][ik + 1] + 1;//syloee200714

                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb

                                                            // hdpark220511 spark
                                                            if (Sub71.m_bModifySparkMeas)
                                                                Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1);     //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000) //SPARK    
                                                    }
                                                }// if(ret1==1)

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                        }//end of  if(nSparkUse==1)

                                        //SPARK############################################################################################ 

                                    }

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }

                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150610

                                    if (nHVIADCFlag == 1) {

                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150227

                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                        }
                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }


                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }
                                    }

                                    // hdpark230712 begin waiting 상태에서 spark check
                                    if (SysSet13.m_nSparkMode == SPARK_NEW)
                                    {
                                        ret1 = Sub71.OnSparkStatus();
                                        if (ret1 == 1)
                                        {
                                            nSpark1_Detect2 = g_nSparkWaitingEnable; //hdpark231121  //hdpark230712 waiting에서 spark 검출, 
                                                                                    // hdpark230721 2->0, spark 다발로 검출 안되도록 함.
                                            Sub71.OnSparkOn(0);
                                            Sub71.Delay_100ns(10000);  //1ms  
                                            Sub71.OnSparkOn(1);
                                            if (Sub71.fpSpark)
                                                fprintf(Sub71.fpSpark, ", @@@@, %d, %.1f, %.1f \n", nSQNet1[ih2][ik + 1] + 1, g_dWaitingSparkV, g_dWaitingSparkVOrg); //hdpark231121

                                        }
                                        else
                                        {
                                            nSpark1_Detect2 = 0;
                                        }

                                        if (nSparkUse == 1 && nSpark1_Detect2 == 2)
                                        {
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr)
                                            {
                                                nSparkTmp = nSQNet1[ih2][ik + 1] + 1; 

                                                //sylee230305 begin
                                                t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                if (SysInfo19.m_nUse == 1) {
                                                    if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                }
                                                if (g_nSkipPieceFlag1 == 1) {
                                                    if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                } //sylee230305 end

                                                if (nSparkFailNo[nSparkTmp] != 1)
                                                {
                                                    srand((unsigned int)time(NULL));
                                                    double dTemp1 = (rand() % 3);					// ~ 3 V

                                                    if (nFailL1Co < 3000)
                                                    {
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(nSpark1_Detect2==2)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", //son241115 nSpark1_Detect2 == 2 인 경우 
                __LINE__,  nSparkTmp, g_dWaitingSparkV, nVSet);
                                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                                        //log buffer
                                                        nFailL1Co++;
                                                        nFailL1CoPiece++;
                                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb

                                                        nSparkFailNo[nSparkTmp] = 1;
                                                        nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                        t1 = nSQNet1[ik + 1][ih] + 1;//PIECE  pin no
                                                        t1 = nPinToPiece(t1);
                                                        nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no 
                                                        nShortFail1[t1]++;
                                                        nShortCo1Spark[nBlockCountP][t1]++;
                                                        nShortFail1Flag1 = 1;
                                                        nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                        nFailL1[nFailL1Co][9] = nVSet;
                                                        nFailL1[nFailL1Co][10] = nISet;
                                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                                        //hdpark231121 임의로 spark 값을 정함.
                                                        nFailL1[nFailL1Co][12] = g_dWaitingSparkV;   // dSparkI1[nSparkI1Po2][nSparkMaxX + 2];     // drop volt
                                                        nFailL1[nFailL1Co][13] = nVSet;             // dSparkI1[nSparkI1Po2][nSparkMaxX + 4];     // occour volt
                                                        nFailL1[nFailL1Co][14] = nISet;      // dSparkI1[nSparkI1Po2][nSparkMaxX + 5];     // current
                                                        nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                        nShortFlag = 1;
                                                        Sub71.OnSparkOn(1); //hdpark220412
                                                        Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                    }   //end of if(nFailL1Co<3000) //SPARK    
                                                }

                                                //  }// if(ret1==1)

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                        }//end of  if(nSparkUse==1)
                                    }
                                    // hdpark230712 end

                                    //*********************************************//
                                    nHVDStopTime2 = (long)GetuSecond();
                                    nHVDStopTime3 = (nHVDStopTime2 - nHVDStopTime1);
                                    if (nHVDStopTime3 > nHVTimeOutSet) { //15sec
                                        nHVDStopFlag = 1;//sylee121009
                                        Sub71.R1 = 20000;
                                        nFailL1CoPiece = 3000;
                                    }
                                    //************************************************// 


									
								  	if (Sub71.R1 > nProRv1){//sylee241224-2
									    if((int)nProStep1[nMod1][1]>=200000000){//sylee241224-2
										     if( Sub71.R1<(nProRv1*1.10)){//sylee241224-2 
												 nLeakNearFlag1=1;//sylee241226
											     nLeakNearPin1=(nSQNet1[ih6][ik2] + 1);//sylee241226
												 nLeakNearPin2=(nSQNet1[ih2][ik + 1] + 1);//sylee241226
												 Sub71.Delay_100ns(100000);  //10ms  
												 AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1);//sylee241226											 
												 nLeakNearFlag1=0;//sylee241226
											}
										}
									} 

                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {  // hdpark220715, nProRv3 -> nProRv1
                                        }
                                        else {

                                            nFailFlag4 = 1;
                                            //                                            bAllPassFlag = FALSE;	//hdpark231205
                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ih6][ik2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ih2][ik + 1] + 1))) {      // hdpark240109
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ih6][ik2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ih2][ik + 1] + 1))) {      // hdpark240109
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;
                                            //                                           bAllPassFlag = FALSE;		// hdpark231205
                                        }
                                    }
                                    //===================================================================================================================== 

                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ih6][ik2];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;
                                    }  //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1  






                                    if (nFailFlag4 == 1) {

                                        nDebug24 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;

                                        nErrorDelayFlag1 = 1;//sylee141002
                                        //sylee170620   Sub71.Delay_100ns(nErrorDelayTime2);//sylee141002  100mS
                                        if (Sub71.fpLeak)
                                        {
                                            fprintf(Sub71.fpLeak, " FFFFF(Thrird) \n"); ///Sub71.OnPinAllReset1(38366); Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1);
                                        }

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1)) {

                                            if (nFailL1Co < 3000) {//array size nFailL1[                                                                                
                                                nFailCount[nMod1] = nFailCount[nMod1]++;
                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;
                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece
                                                //  if( ipFlag==1 ){//short   PIECE MULT.

                                                // hdpark220511 spark
                                                if (Sub71.m_bModifySparkMeas)
                                                    Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co; 


                                                if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
													   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1
			                                         if (nSQNet1[ih2][ik + 1] < nSQNet1[ih6][ik2]) {//SYLEE130201
														nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//pin  vc
													}
													else {
														nFailL1[nFailL1Co][4] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][5] = nSQNet1[ih6][ik2] + 1;//pin  vc
													}
 
												}else{

													if( (ik+1) < ik2 ){//sylee241204-2
													    nFailL1[nFailL1Co][F_AC]=0;
													}else{
													    nFailL1[nFailL1Co][F_AC]=1;
													}
														nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
														nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//pin  vc

                                                    for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
														if ((nFailL1[i5][5] == (nSQNet1[ih6][ik2]  + 1)) && (nFailL1[i5][4] == (nSQNet1[ih2][ik + 1] + 1))) {  
															nFailL1[i5][F_AC] =0;
															nFailL1[nFailL1Co][F_AC]=0;
														}
													} 

												}  

                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no  

                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16

                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;  //SYLEE140929-1
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                nShortFlag = 1;//sylee120915 

                                                nDebug25 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000){//array size nFailL1


                                            Sub71.Delay_100ns(nErrorDelayTime1);//10mSEC   
                                    //TESTSYLEE140929    Sub71.Delay_100ns(10000);//1mSEC   


                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }


                                        }// if((nPin1[0]<=1)&&(nPin2[0]<=1))  

                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(38456); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(38461); //VbCall reset                                                                  
                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610
                                                AHV_ADCI_Read1_OneToM(nProRv3, nDelay10, 4); //sylee140923

                                                if (Sub71.R1 <= nProRv3) {// ok//HV   line & one    
                                                }
                                                else {//fail
                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(38471); ///PIN ALL RESET 
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923  // hdpark220715, nProRv3 -> nProRv1


                                                        //####################################################################################  //kunshan move 151109
                                                        if (Sub71.R1 > nProRv1) {           // hdpark220715, nProRv3 -> nProRv1
                                                            int iSum5, iCo5, iSet5;//sylee150627
                                                            iSum5 = 0; iCo5 = 0;//sylee150627                                                                                
                                                            if (nPinDa1H[1][2][0] < 100) {//sylee150628

                                                                iSet5 = 1;//SYLEETESTMODE-1
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 30;  //sylee150629   20->30
                                                                }
                                                                if (Sub71.R1 < 500) {//sylee150627
                                                                    iSet5 = 10;
                                                                }
                                                            }
                                                            else {
                                                                iSet5 = 1;
                                                                if (Sub71.R1 < 340) {//sylee150627
                                                                    iSet5 = 3;
                                                                }
                                                            }

                                                            for (int k5 = 1; k5 <= iSet5; k5++) {//sylee150627

                                                                Sub71.OnPinAllReset1(38500); ///PIN ALL RESET 

                                                                if (k5 == 1) {//sylee150627
                                                                    Sub71.Delay_100ns(nErrorDelayTime1);//100mSEC   
                                                                }

                                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all


                                                                if (k5 == 1) {
                                                                    Sub71.Delay_100ns(nErrorDelay1);//sylee150627                                                                    
                                                                }
                                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4);//sylee150627   // hdpark220715, nProRv3 -> nProRv1

                                                                if (Sub71.R1 < 700.) {//sylee150627
                                                                    iSum5 = iSum5 + (int)Sub71.R1;//sylee150627
                                                                    iCo5++;//sylee150627
                                                                }//sylee150627

                                                                if (Sub71.R1 >= 700) {//sylee150627
                                                                    break;
                                                                }

                                                            }//sylee150627

                                                            if (iCo5 > 1) {//sylee150627
                                                                Sub71.R1 = iSum5 / iCo5;//sylee150627
                                                            }//sylee150627

                                                            //sylee150627   
                                                        }



                                                        if (nPinDa1H[1][2][0] < 100) {//sylee150627                                                                                  
                                                            nProRv3 = nProRv0;
                                                        }
                                                        //####################################################################################




                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one // hdpark220715, nProRv3 -> nProRv1
                                                        }
                                                        else {//fail
                                                       //error loggging

                                                            if (Sub71.R1 < nProRv1) {//sylee141001
                                                                for (int ir = 1; ir < 4; ir++) {
                                                                    Sub71.R1 = Sub71.R1 * 1.1;//sylee141001
                                                                    if (Sub71.R1 > nProRv1) {
                                                                        break;
                                                                    }
                                                                }
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            //sylee151208-1-import        nSQNet1[ih2][ik+1]=nPin1[st1];
                                                            //sylee151208-1-import        nSQNet1[ih6][ik2]=nPin2[st2];                                                                            


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                    if(nProOneP_RunFlag1==1){//sylee131003
                                                                        if(nReSheetFlag1!=1){//sylee140429-1
                                                                            if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                                                    nProOneP_RunFlag1=0;
                                                                                    goto TaskEnd100;
                                                                            }
                                                                        }
                                                                    }
                                                                */

                                                                if (nSparkUse == 1) {
                                                                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                                                        break;// complete  error 
                                                                    }
                                                                }

                                                                nFailCount[nMod1] = nFailCount[nMod1]++; 

                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;
                                                                nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                /*//sylee151208-1-import
                                                                        if( nSQNet1[ih2][ik+1]<nSQNet1[ih6][ik2]){//SYLEE130201
                                                                            nFailL1[nFailL1Co][5]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                            nFailL1[nFailL1Co][4]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                        }else{
                                                                            nFailL1[nFailL1Co][4]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                            nFailL1[nFailL1Co][5]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                        }
                                                                */

								 
																if(nLeakACMode1!=2){//sylee241120-2  //sylee241204
																	   nFailL1[nFailL1Co][F_AC]=0;  //sylee241205-1
																	if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
																	}
																	else {//sylee151208-1-import
																		nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
																	}//sylee151208-1-import 
																}else{

																	if( (ik+1) < ik2 ){//sylee241204-2
																		nFailL1[nFailL1Co][F_AC]=0;
																	}else{
																		nFailL1[nFailL1Co][F_AC]=1;
																	}
																		nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
																		nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc

                                                				   for (int i5 = 1; i5 < nFailL1Co; i5++) {//sylee241205
																		if ((nFailL1[i5][5] == ( nPin2[st2] + 1)) && (nFailL1[i5][4] == ( nPin1[st1] + 1))) {  
																			nFailL1[i5][F_AC] =0;
																			nFailL1[nFailL1Co][F_AC]=0;
																		}
																   }  

																}  
 

                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                } 

                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc

                                                                //sylee151208-1-import  t1=nSQNet1[ih2][ik+1]+1;//PIECE  pin no 
                                                                t1 = nPin1[st1] + 1;//PIECE  pin no //sylee151208-1-import 

                                                            //  }else{
                                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                //}

                                                            //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                                nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w


                                                                nShortFlag = 1;//sylee120915

                                                                nDebug26 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000){//array size nFailL1[



                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC   


                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1){}else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++) 

                                                }//end if else //fail  if( Sub71.R1<=nProRv1)// ok//HV   line & one

                                                Sub71.OnPinAllReset1(38686); ///PIN ALL RESET 

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }


                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++){     


                                        } //end of   if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ){ //vb

                                    }   //if(nFailFlag4==1){ 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++){  //X   // Second LOOP   vb pin  

#if defined(__YOUNPUNG__CUSTOMER) || defined(__YP_VIET_CUSTOMER)

                                if (bAllPassFlag == TRUE && bProgressiveFault == TRUE) // hdpark231205, leak fail -> pass 발생 처리
                                {

                                    if (nFailL1Co < 3000)
                                    {
                                        nFailCount[nMod1] = nFailCount[nMod1]++;
                                        nFailL1Co++;
                                        nFailL1CoPiece++;
                                        nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                        nFailL1[nFailL1Co][2] = nBlockCountP;//block

                                        nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//nSQNet1[ik2][ih6] + 1;//pin  vb
                                        nFailL1[nFailL1Co][5] = -1;//pin  vc


                                        t1 = (int)nFailL1[nFailL1Co][4];
                                        if ((t1 > 0) && (t1 < 16384)) {
                                            nErrPin1S0[t1] = 1;
                                        }
                                        t1 = (int)nFailL1[nFailL1Co][5];
                                        if ((t1 > 0) && (t1 < 16384)) {
                                            nErrPin1S0[t1] = 1;
                                        }

                                        t1 = nSQNet1[ih6][ik2] + 1;//PIECE  pin no  
                                        t1 = nPinToPiece(t1);
                                        nFailPiece[t1][nPStep1]++;////PIECE  error count 
                                        nFailL1[nFailL1Co][3] = t1;////PIECE  no   

                                        nShortFail1[t1]++;
                                        nShortCo1[nBlockCountP][t1]++;
                                        nShortFail1Flag1 = 1;

                                        nFailL1[nFailL1Co][6] = Sub71.R1;
                                        nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
                                        nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                        nFailL1[nFailL1Co][9] = nVSet;
                                        nFailL1[nFailL1Co][10] = nISet;
                                        nFailL1[nFailL1Co][11] = m_nMode1;
                                        nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                        nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                        nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                        nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                        nShortFlag = 1;
                                    }
                                }
#endif
                                //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC(38760);

                                //     Sub71.Delay_100ns(100);//10uSEC  

                                //SYLEE121107

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQLastY1, SPARK_TRG_ON);

                                for (int ih3 = 1; ih3 <= nSQLastY1; ih3++) {  //X   // Second LOOP   vb pin  
                                    /*    if(nSQPinCheck[nSQNet1[ik][ih]]==2){
                                    Sub71.AOnReadV1I1_ADC_I();      //debug
                                    if(Sub71.R1>2000){//debug
                                    Sub71.R1=Sub71.R1;//debug
                                    }
                                    }
                                    */
                                    if (ih3 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.AOnPinSet1(2, nSQNet1[ih3][ik + 1], 2);   // =1,VB,   all   

                                    if (SysSet13.m_nSparkMode == SPARK_NEW)
                                    {
                                        /////////////////////////////////////////////////////////////   //SYLEEE200803-1       
                                        if (nSparkUse == 1 && nSparkDetect1 == 1) { //SYLEE200714-2
                                            if (nFailL1CoPiece < SysInfo05.m_nIsEr) {     //SPARK
                                                ret1 = Sub71.OnSparkStatus();
                                                //  ret1=0;

                                                if (ret1 == 1) {//SYLEE200711-1    //  nSparkDetect1=1;//sylee200710-1
                                                    Sub71.OnSparkOn(0);
                                                    Sub71.Delay_100ns(10000);  //1ms  
                                                    nSparkTmp = nSQNet1[ih3][ik + 1] + 1;//syloee200714

                                                    //sylee230305 begin
                                                    t1 = nPinToPiece(nSparkTmp); //sylee230305
                                                    if (SysInfo19.m_nUse == 1) {
                                                        if (SysInfo19.m_nData[nBlockCountP][t1] == 1) { continue; }	//sylee230305
                                                    }
                                                    if (g_nSkipPieceFlag1 == 1) {
                                                        if (g_nSkipPieceInfo[t1] == 2) { continue; }	//sylee230305
                                                    } //sylee230305 end

                                                    if (nSparkFailNo[nSparkTmp] != 1) {//syloee200714

                                                        if (nFailL1Co < 3000) {////SPARK                                                                
MyTrace(PRT_BASIC, "Line_%d: Spark Detect!(ret1=%d)  Pin=%d, DropVolt=%.1f, OccurVolt=%.1f\n", __LINE__, ret1,     //son241115
                nSparkTmp, dSparkI1[nSparkI1Po2][nSparkMaxX + 2], dSparkI1[nSparkI1Po2][nSparkMaxX + 4]);

                                                            nFailCount[nMod1] = nFailCount[nMod1]++;
                                                            //log buffer
                                                            nFailL1Co++;
                                                            nFailL1CoPiece++;
                                                            nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                            nFailL1[nFailL1Co][2] = nBlockCountP;//block                                             
                                                            nFailL1[nFailL1Co][5] = nSQNet1[ih3][ik + 1] + 1;//pin  vb
                                                            // hdpark220511 spark
                                                            if (Sub71.m_bModifySparkMeas)
                                                                Sub71.m_tINFO[Sub71.m_nHWCnt - 1].nFailCol = nFailL1Co;

                                                            nSparkFailNo[nSparkTmp] = 1;//syloee200714
                                                            nFailL1[nFailL1Co][4] = -1;//pin  vc    
                                                            t1 = nSQNet1[ih3][ik + 1] + 1;//PIECE  pin no
                                                            //  t1=nPieceNoPin[1][t1];//PIECE  piece no
                                                            t1 = nPinToPiece(t1);//SYLEE171225-2    //son-4WDUT16-190704
                                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                            nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314
                                                            ////////////////////////////////////////////////////////////////////////////////
                                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                            nShortCo1Spark[nBlockCountP][t1]++;//sylee201224
                                                            nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                            //////////////////////////////////////////////////////////////////////////////////////
                                                            nFailL1[nFailL1Co][6] = -1;//Sub71.R1 
                                                            nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                               nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303                                                                  
                                                            nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                            nFailL1[nFailL1Co][9] = nVSet;
                                                            nFailL1[nFailL1Co][10] = nISet;
                                                            nFailL1[nFailL1Co][11] = m_nMode1;
                                                            nFailL1[nFailL1Co][12] = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];  //SPARK V1
                                                            nFailL1[nFailL1Co][13] = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1
                                                            nFailL1[nFailL1Co][14] = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I
                                                            nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                            nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                            nShortFlag = 1;//sylee120915
                                                            Sub71.OnSparkOn(1);     //hdpark220412 
                                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC  

                                                        }   //end of if(nFailL1Co<3000){ //SPARK    
                                                    }

                                                    // hdpark221117 delete, VB Mode로 인한 Leak 오류 수정
//<                                                    if (Sub71.m_bModifySparkMeas)
//<                                                        Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_ON);
                                                }// if(ret1==1)

                                            }//if( nFailL1CoPiece<SysInfo05.m_nIsEr)    //SPARK 

                                        }//end of  if(nSparkUse==1)

                                        //SPARK############################################################################################ 

                                    }

                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ih3][ik + 1];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }

                                }

                                // hdpark220511 spark
                                if (Sub71.m_bModifySparkMeas)
                                    Sub71.SendCmdToDigitizer(__LINE__, nSQCount1, SPARK_TRG_OFF);

                            }// if(nFailFlag3==1){ 

                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################

                        }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 

                    //=====================================================================================================================
                    }// end of  if(nFailFlag2==1){   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc



            }//end of  if(nFailFlag1==1){



            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }


        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++)     // FIRST LOOP //Y  VB


        //==============================================================================================================================
        //################################################################################################################################

        Sub71.OnPinAllReset1(38921); ///PIN ALL RESET 

        //      if( nFailL1CoPiece>=SysInfo05.m_nIsEr){   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
        //          break;// complete  error                                                 
        //      }



        //sylee121117-openshortlist
        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        //*******************************************************************************************************************************//
            //Task1:

        int nEnb1;


        if ((nFailL1CoOpen > 0) && (nOpShortLt1[ip][0][0] > 0)) {


            /*
                if(ipFlag==1){
                        nRCount=g_pvBDLData31[1][ip]->size() -1;
                }else{
                        nRCount=nBDLData3[1][0][1];
                }
            */

            if (ipFlag == 1)//sylee180810-1-DUT16
            {
                //nRCount=nBDLData31[dutId][ip][0]; //SYLEE180810-1-DUT16   //son-4WDUT16-190704
                nRCount = (g_pvBDLData31[dutId][ip]->size() - 1);   //son201118: vector구조로 변경
            }
            else
            {
                nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16 //son190704-4WDUT16
            }

            nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
            for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
            {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
                tp1 = i * i;
                if (tp1 >= nRCount) {
                    nSQCount1 = i;//sylee120908
                    break;
                }
            }

            if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
                str.Format("Error No 7513-2 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                return 0;
            }

            ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));


            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            //sylee121117-openshortlist


            int nOpShortPin[100];
            int nSQLastY2, nSQLastPin2, nOpCo, nOpFlag;

            nOpCo = 0;
            nOpFlag = 0;
            ::ZeroMemory(&nOpShortPin, sizeof(nOpShortPin));

            ///====================================================================


            for (ik = 1; ik <= nOpShortLt1[ip][0][0]; ik++) {
                if (ik > nSQCount1) {
                    break;
                }


                if (ik == 1) {
                    nOpShortPin[1] = nOpShortLt1[ip][1][0];
                    nOpCo = 1;
                }
                else {

                    nOpFlag = 0;

                    for (i = 1; i <= nOpCo; i++) {
                        if (nOpShortPin[i] == nOpShortLt1[ip][ik][0]) {
                            nOpFlag = 1;
                        }
                    }

                    if (nOpFlag == 0) {
                        nOpCo++;
                        nOpShortPin[nOpCo] = nOpShortLt1[ip][ik][0];
                    }
                }
            }

            nOpShortPin[0] = nOpCo;


            //==========================================================================
            int tmp3;

            tmp3 = nOpShortLt1[ip][0][0];

            for (ik = 1; ik <= (nOpShortLt1[ip][0][0] + nOpShortPin[0]); ik++) {
                if (ik > nSQCount1) {
                    break;
                }

                if (ik <= nOpShortLt1[ip][0][0]) {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortLt1[ip][ik][1];
                }
                else {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortPin[ik - tmp3];
                }
            }

            nSQLastY2 = nSQLastY1 + 1;

            if (nOpShortLt1[ip][0][0] < nSQCount1) {
                nSQLastPin2 = nOpShortLt1[ip][0][0] + nOpShortPin[0];
            }
            else {
                nSQLastPin2 = nSQCount1;
            }



            //################################################################################################################################
        //SET 


            for (ik = 1; ik <= nRCount; ik++)
            {
                i = (ik - 1) / nSQCount1 + 1;//mok
                j = (ik - 1) - nSQCount1 * (i - 1);//na
                j = j + 1;

                /*
                if( ipFlag==1 ){//short   PIECE MULT.
                   //nSQNet1[i][j]=nBDLData31[1][ip][ik] ; // 1 VB,    =2VC,
                   nSQNet1[i][j]= (*g_pvBDLData31[1][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }else{
                nSQNet1[i][j]=nBDLData3[1][ik][1] ;   // 1  VB,    =2VC,
                }
                */

                if (ipFlag == 1)//sylee180810-1-DUT16
                {
                    //nSQNet1[i][j]=nBDLData31[dutId][ip][ik] ; // 1 VB,    =2VC, //SYLEE180810-1-DUT16    //son-4WDUT16-190704
                    nSQNet1[i][j] = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin;   //son201118: vector구조로 변경
                }
                else
                {
                    nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16 //son190704-4WDUT16
                }

                if (ik == nRCount) {
                    nSQLastPin = j;//sylee120908   ///last row , last col.
                    nSQLastY1 = i;
                }
            }



            //#2 second search    hv  adc           
            // 1000 point 



            //################################################################################################################################
            //#1 FIRST-1  Line&Block
            //row

            ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
            nShort2FailFlag1 = 0;
            nSQStep1flag = 0;

            Sub71.OnPinAllReset1(39101); ///PIN ALL RESET 

            nRetry1 = 0;


            //Task1Retry:


            for (ik = nSQLastY1; ik <= nSQLastY1; ik++) {     // FIRST LOOP //Y  VB 



                Sub71.OnPinAllReset1(39113); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        nEnb1 = 0;

                        for (int ik7 = 1; ik7 <= nOpShortPin[0]; ik7++) {
                            if (nOpShortPin[ik7] == nSQNet1[ik2][ih]) {
                                nEnb1 = 1;
                            }
                        }

                        if (nEnb1 == 0) {
                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,  
                        }


                    }
                }

                nSQStep1flag = 0;


                for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                    if ((ik + 1) == nSQLastY2) {
                        if (ih > nSQLastPin2) {
                            break;//SKIP
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =2,Vc,   all      

                }
                //////////////////////////////////////////////////////////////////////////////////


                if (nHVIADCFlag == 1) {

                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);

                    //  Sub71.R1= dIADC1  ;//ADC
                }
                else {
                    Sub71.Delay_100ns(nDelay10);
                    AHV_ADCI_Read1(nProRv1);
                }

                IADClog1[ip][ik] = Sub71.R1;///logging

                if (nHVIADCFlag == 1) {
                    if (Sub71.R1 <= nProRv1) {// ok//HV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail 
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                    }


                }
                else {

                    if (Sub71.R1 >= nProRv1) {//ok//LV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail

                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        //   nFailFlag1=0;//test
                        nSQStep1flag = 2;
                    }

                }

                //  nFailFlag1=0;  // ALLPASS


                //==============================================================================================================================
                //################################################################################################################################
                //#2,  second search    hv  adc  
                // vc  m block 

                if (nFailFlag1 == 1) {  //if error      



                    Sub71.OnPinResetVB(39211);   //sylee121029  

                    for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //Vc


                        nMSet1Co = 0;
                        nMSet1Flag = 0;
                        nMSet1CoT2 = 0;

                        //sylee121029   Sub71.OnPinResetVB();
                        //  Sub71.Delay_100ns(100);//10uSEC   


                        if (ik2 > ik) { //doublecheck#2 
                            continue;
                        }

                        for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            nEnb1 = 0;

                            for (int ik8 = 1; ik8 <= nOpShortPin[0]; ik8++) {
                                if (nOpShortPin[ik8] == nSQNet1[ik2][ih]) {
                                    nEnb1 = 1;
                                }
                            }

                            if (nEnb1 == 0) {
                                Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                            }

                        }
                        //=====================================================================================================================
                        if (nHVIADCFlag == 1) {
                            //  AHV_ADCI_Read1(nProRv1); 
                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                            //  Sub71.R1= dIADC1  ;//ADC
                        }
                        else {

                            Sub71.Delay_100ns(nDelay10);

                            if (nCC == 2) {//cv
                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                            }
                            else {// cc                                      
                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }

                            }
                            else if (nCC == 2) {//CV   r=(vb/i)
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                }
                            }

                        }

                        //Sub71.Delay_100ns(10000);  
    //=====================================================================================================================
                        nFailFlag2 = 0;
                        if (nHVIADCFlag == 1) {
                            if (Sub71.R1 <= nProRv1) {// ok//HV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }
                        else {
                            if (Sub71.R1 >= nProRv1) {//ok//LV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }//line & line 

                            //=====================================================================================================================
                        //##################################################################################################################################

                        //one line & one line  search


                        if (nFailFlag2 == 1) {

                            for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 


                                if (ik2 == nSQLastY1) {  //LAST Y STEP  nSQLastY1=9  //sylee131114
                                    if (ih6 > nSQLastPin) {//  nSQLastPin=6
                                        break;//SKIP   
                                    }
                                }

                                Sub71.OnPinResetVB(39324);//SYLEE121016***** all reset                                   
                                // Sub71.Delay_100ns(100);//10uSEC   


                                nEnb1 = 0;

                                for (int ik9 = 1; ik9 <= nOpShortPin[0]; ik9++) {
                                    if (nOpShortPin[ik9] == nSQNet1[ik2][ih6]) {
                                        nEnb1 = 1;
                                    }
                                }

                                if (nEnb1 == 0) {
                                    Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=Vb
                                }

                                //=====================================================================================================================


                                if (nHVIADCFlag == 1) {
                                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                    //  Sub71.R1= dIADC1  ;//ADC
                                }
                                else {


                                    Sub71.Delay_100ns(nDelay10);

                                    if (nCC == 2) {//cv
                                        Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                    }
                                    else {// cc                                      
                                        Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                    }


                                    if (Sub71.Y1 < 0.0000001) {
                                        Sub71.Y1 = 0.0000001;
                                    }


                                    if (nCC == 1) { //CC    r= (vb-vc)/i
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                        }

                                    }
                                    else if (nCC == 2) {//CV   r=(vb/i)
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }

                                }

                                nFailFlag3 = 0;
                                if (nHVIADCFlag == 1) {
                                    if (Sub71.R1 <= nProRv1) {// ok//HV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }
                                else {
                                    if (Sub71.R1 >= nProRv1) {//ok//LV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }//line & line 

                                //=====================================================================================================================
                                //################################################################################################################################
                                ///one point  & one point search

                                if (nFailFlag3 == 1) {


                                    for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin  


                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih2 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }

                                        Sub71.OnPinResetVC(39417); //Vb all reset
                                        // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all


                                        if (nHVIADCFlag == 1) {
                                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                            //  Sub71.R1= dIADC1  ;//ADC
                                        }
                                        else {
                                            Sub71.Delay_100ns(nDelay10);
                                            if (nCC == 2) {//cv
                                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                            }
                                            else {// cc                                      
                                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                            }

                                            if (Sub71.Y1 < 0.0000001) {
                                                Sub71.Y1 = 0.0000001;
                                            }


                                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                                }

                                            }
                                            else if (nCC == 2) {//CV   r=(vb/i)
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }

                                        }


                                        nFailFlag4 = 0;
                                        if (nHVIADCFlag == 1) {
                                            if (Sub71.R1 <= nProRv1) {// ok//HV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                            }
                                        }
                                        else {
                                            //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                            if (Sub71.Y1 < 5) {//ok//LV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                            }
                                        }
                                        //=====================================================================================================================


                                        //*****************************************************************************//

                                        if (nFailFlag4 == 1) {

                                            if (nHVIADCFlag != 1) {//sylee20120715==> R READ
                                                //  if( Sub71.Y1< IT1 ){ 

                                                if (nFailL1Co < 3000) {//array size nFailL1[                                 
                                                    nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece
                                                    //  if( ipFlag==1 ){//short   PIECE MULT.


                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    //nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                        //nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                                                                       

                                                    //  }else{
                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                    //}

                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w

                                                    nShortFlag = 1;//sylee120915 

                                                }   //end of if(nFailL1Co<3000)//array size nFailL1 

                                                    //  Sub71.Delay_100ns(100000);//10mSEC 
                                                    //  Sub71.Delay_100ns(30000);//3mSEC  //sylee150904-3 //ace400

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error                                                 
                                                }
                                            }
                                            else {//if( nHVIADCFlag!=1)//sylee20120715                                                                                  
                                               // ====>  I  ADC  READ                            


                                                if (nFailL1Co < 3000) {//array size nFailL1[

                                                    nFailCount[nMod1] = nFailCount[nMod1]++;

                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;
                                                    nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece 

                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }


                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }


                                                    //  if( ipFlag==1 ){//short   PIECE MULT.
                                                    //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                    //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                                
                                                    //  }else{
                                                    //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                    //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                    //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                    //}


                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2    //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w


                                                    nShortFlag = 1;//sylee120915

                                                }   //end of if(nFailL1Co<3000){//array size nFailL1[

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }


                                            }// END OF  if( nHVIADCFlag!=1)//sylee20120715


                                        }   //if(nFailFlag4==1) 

                                    } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  

                                            //----------------------------------------------------------------------------------------------------------------------

                                    Sub71.OnPinResetVC(39654);
                                    //   Sub71.Delay_100ns(100);//10uSEC   

                                    for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  
                                        /*    if(nSQPinCheck[nSQNet1[ik][ih]]==2){
                                        Sub71.AOnReadV1I1_ADC_I();      //debug
                                        if(Sub71.R1>2000){//debug
                                        Sub71.R1=Sub71.R1;//debug
                                        }
                                        }
                                        */
                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih3 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }
                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                             
                                    }


                                }// if(nFailFlag3==1){ 

                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                    break;// complete  error 
                                }

                                //################################################################################################################################


                            }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 


                            //=====================================================================================================================
                        }// end of  if(nFailFlag2==1){   ///one line & one line  search


                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //sylee121016
                            break;// complete  error 
                        }


                        //#2
                    }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++){     // FIRST LOOP //Y   //Vc


                }//end of  if(nFailFlag1==1){

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                    break;// complete  error 
                }


            }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB



        }//if((nFailL1CoOpen>0)&&(nOpShortLt1[ip][0][0]>0)){    



    TaskEnd300://sylee150415 fasthv


        Sub71.OnPinAllReset1(39717); ///PIN ALL RESET



    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   


//TaskEnd100://sylee130927 one-piece//sylee131221

    if (nFastHv1RunStep == 1) {//sylee150415 fasthv   //sylee150428
        if (nFastHv1PieceReturn == 1) {
            nFastHv1RunStep = 2;//sylee150415 fasthv
        }
    }

    tStart1001 = GetuSecond();//SYLEE150426-2

 
 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    nFlagLeakMPin1=0;  //sylee230526  //sylee230817

    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720
    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704
    Sub71.AOnReadV1Enable1(5);

    Sub71.AIRangeOff();//sylee171204 //ACE400

    if (n4w_Sample_Enable == 1) {//sylee180912-1
        Sub71.OnDisCharge1();
    }


    //::ShellExecute(NULL,"close","EXCEL.EXE","d:\\LOG\\PRO1\\HVLEAK1.CSV","NULL",SW_SHOWNORMAL);
    nFlag_HV_SetEnd_Skip = 0;//sylee150427    0=idle, 1=skip 
    Sub71.OnPinResetInit();//sylee151221   //ACE400
    tStart322 = GetuSecond();//TESTDEBUG
    tStart323 = (tStart322 - tStart321);//TESTDEBUG
    nPinSetSkipVb = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee160803 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee160803 //ACE400    //son230127



    if (nDebug11 == 1) {//sylee170618-test1 debugcode
        if (nDebug15 == 1 || nDebug16 == 1) {
        }
        else {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug12 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug13 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug14 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
    }


    if (nDebug21 == 1) {//sylee170618-test1 debugcode
        if (nDebug25 == 1 || nDebug26 == 1) {
        }
        else {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug22 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug23 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
        if (nDebug24 != 1) {
            nShortRetestFlag1 = 1;//sylee170618-1
        }
    }

    if (SysInfo05.m_nSp == 1) {//SYLEE171103-1
        if (SysInfo05.m_nSparkSet > 0) {
            Sub71.AOnVBSet1(5, 0); //1~ 100v set 가능   140428            
            Sub71.OnSparkOn(0); ////SPARK ON   //SYLEE130830    1=on   ext ==off               
            //  Sub71.Delay_100ns(1000); //1ms
        }
    }

    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
    {
        //OnSparkFileLog1_I(nSparkMaxX+7, nSparkMaxY); //sylee200710  //all log
        if (g_nSpark1_Use == 1) {//SYLEE200721 
            On_SparkFileLog1_I(nSparkMaxX + 8, nSparkI1Po2); //sylee200710  //ng log
        }
        Sub71.OnSparkADC(0);//SYLEE200714
    //  On_SparkFileLog1_V(29,1000); //sylee200710
        nFlag_Spark_PinOn = 0; //sylee200710-1
    }

    nFlag_LeakDischarge1 = 0;//sylee200916

    if (Sub71.fpLeak)	fprintf(Sub71.fpLeak, "\n\n\n");
    if (Sub71.fpLeak)	fclose(Sub71.fpLeak);

    return 1;

}


//SYLEE121025

//son  AUTO LV Test
//son    nMod1      0:skip,  1:open,  2:uShort (LV), 3:Short(LV), 4: HR Short(LV)
//                  5:Leak1  (HV),    6:*Leak2 (HV), 7: *4W    => enum TEST_TYPE 사용
//son  m_nMode1     Calibration Mode
//son  nProRv1      raw RValue
//son  nPStep1      현재 test 진행 step
//son  nProType     1:multi piece,  2:one piece
//son  nLeakMode    0:정상 LV Test, 5(TEST_LEAK1): Leak Test에서 사전 HR test 하는 경우.  //son230202 bLeakTest default 매개변수 추가. 

//son230202 int CChildView7::ARun201_S2_SQ2_LV_Re_VB(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
int CChildView7::ARun201_S2_SQ2_LV_Re_VB(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType, int nLeakMode)	//son230202 
{

 
   //  return 1;//sylee230811-test   

    //  MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nMod1=%d, nProRv1Real=%d\n", __LINE__, nMod1, nProRv1Real);

    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];
    int i, ik, j, n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1;
    int nHVIADCFlag, nDischargeCount;
    int nShRes1T, ih, logno1, nSQCount1, nSQLastY1, nSQLastPin, tp1, t1;

    int nFailFlag1, nFailFlag2, nFailFlag3, nFailFlag4;
    int nSQ1Fail[200], nSh1Ret1[100], dPinVC[200], dPinVB[200];

    //son210401  100 -> MAX_SQUARE_N(200)  : Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
    int nSQNet1[MAX_SQUARE_N][MAX_SQUARE_N];// pin array//sylee120908

    int nMSet1Flag, nMSet1Co, nMSet1CoT2, nSQStep1flag, nIControl, nRetry1;
    int tmp1, tmp2, Co, nPin1[1000], nPin2[1000];//sylee130111
    int nIFilter, nHVOffSet, nHVGain, nIGain, nEstUse, nEt_StepSumTemp, nErrorDelay1;//sylee150614 kushan 
    int  nRunFlag1_LvShort1;

    double nISet, dVbR1, dVbR2, InterI;
    double nT[10], nData[130][15], dR1[11][200];
    double dVB1[11][200], dVC1[11][200], dI1[11][200];//sylee130225joytech  IADClog1[40][1000];


    int nDebug11, nDebug12, nDebug13, nDebug14, nDebug15, nDebug16;//sylee170618-test1 debugcode
    int nDebug21, nDebug22, nDebug23, nDebug24, nDebug25, nDebug26;//sylee170618-test1 debugcode

    nDebug11 = nDebug12 = nDebug13 = nDebug14 = nDebug15 = nDebug16 = 0;//sylee170618-test1 debugcode
    nDebug21 = nDebug22 = nDebug23 = nDebug24 = nDebug25 = nDebug26 = 0;//sylee170618-test1 debugcode

    nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    nProType = 1;//sylee200919

    //sylee220725 int nPrev_nProRv1Real = nProRv1Real;    //son220720  BH Leak1 50M인데 20M로 Error.txt 출력문제 보완. 
                                            //           기존  nProRv1Real(판정기준 real R)을 보관했다가 함수 탈출 시점에 원상복구한다.
    //son220729 nProRv1Real 변수사용부분 삭제.  
    //          Error.txt 출력시에  nProRv1Real 대신 nProStep1[testMode][1]로 출력하는 것을 수정됨.
    //          BH Leak1 50M인데 20M로 Error.txt 출력문제를 근본적으로 보완. 
    //if (nMod1 >= TEST_U_SHORT && nMod1 <= TEST_LEAK2) {
    //    nProRv1Real = (int)nProStep1[nMod1][1];  // R  RAW  REAL  //SYLEE180525-1
    //}




    //son230202 begin: Leak에서 사전 HR을 체크한 경우는 HR이 아니라 Leak로 출력해야.
    //    				 Fail 판정은 HR의 nProRv1(nProStep1[nb1][2])로 하고 출력만 Leak거로 한다.
    int prtTestMode = nMod1;
    if (nLeakMode != 0)	  //son LV가 아니라 Leak에서 사전 HR 체크를 위해 호출한 경우라면 
        prtTestMode = nLeakMode;
    //son230202 end


    if (nProOneP_Flag1 == 3 && nProType == 2) {//sylee170306-1
        nProType = 3;
    }
    if (nReSheetFlag1 == 1) { //sylee171011-1 //resheet
        nProType = 1;
    }


    nShort_Flag1 = __LV; //1:__LV  2:__HV  //sylee161026
    nRunFlag1_LvShort1 = 0;
    ipEnd = 0;


    int dutId = getDutId();                 //son190704-4WDUT16
    if (nMod1 == TEST_U_SHORT || nMod1 == TEST_SHORT || nMod1 == TEST_HR_SHORT || nMod1 == TEST_LEAK1)
    {
        nRCount = nBDLData3[dutId][0][1];         //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];
        if (g_nPieceMax1 >= 1) {//PIECE
            ipEnd = g_nPieceMax1;
        }
    }



    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {
        //sylee170807-5 if(nProType==1){       //sylee170727  (nProType!=2)
        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-5    
        {

            //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우.
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,      //son220803
                if (g_nSkipPieceInfo[ip3] == 2) {//skip disable piece  //son220803 
                    continue;
                }
            }


#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) {
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {
                    continue;
                }
            }
#endif  //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                    nProOneP_RunFlag1 = 0;
                    continue;
                }
            }

			/*//sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex
                if (nManualStartFlag != 1) {
                    if (gRun05.m_nReCh > 0) {
                        if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {
                            if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                                if (nReFlagOpenCur[ip3] != 1) {
                                    continue;
                                }
                            }
                        }
                        else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {
                            if (nReFlagOpenOld[ip3] == 1) {
                                continue;
                            }
                        }
                    }
                }//sylee130225

            }
            else {//syle170725-3
			*/ //sylee230420 
                if (nReFlagOpenOld[ip3] == 1) {//syle170725-3
                    continue;
                }

            //sylee230420 }


            if (nShortFail1[ip3] > 0) {//sylee120921
                continue;
            }


        //sylee230426-2    if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip3] == 1) {//sylee171120-1 
                continue;
            }//sylee171120-1
          //sylee230426-2   }


        }// if(nProType!=2){    //sylee170614-1



        if (nOpenErrFlag[ip3] == 1) {
            nOpenErrFlag[ip3] = 2;
        }


        nRunFlag1_LvShort1++;

    }


    if (nRunFlag1_LvShort1 < 1) {
        //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
        //      MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
        return 1;
    }

    ////////////////////////////////////////////////////////////////////
  //  int nTmpPinNo1;

    Sub71.OnPinAllReset1();//sylee190207-1
/*  //sylee210205
    nRCount=nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16

    for( ik=1; ik<=nRCount; ik++)//sylee190207-1
    {
        nTmpPinNo1=nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16

        int ret = Sub71.AOnPinSet1(2, nTmpPinNo1, 1); //=1Vb,
#if 1
        if (ret < 0)        //son-32KPIN-20200114:      nPin=PinMap[2][No] 가 -1이면 없는 카드.
        {
            //str.Format("ERROR NO 7002-9, \nSub71.AOnPinSet1(2, ...) Error! \n\n\nCan't find hwPin for jigPin_%d  ", nTmpPinNo1 );
            //AfxMessageBox(str);
            return 0;
        }
#endif
    }
    */
    //////////////////////////////////////////////////////////////////
    Sub71.OnDisCharge1(); //sylee170725-3 

    Sub71.OnPinAllReset1(__LINE__);//sylee190207-1


    nErrorDelay1 = 0;//sylee150614  kushan 3mS  //sylee151216-1  3m->0
    nErrorDelay1 = 10000;//sylee201029   import. 1ms

    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127
    nRunMode_HV_LV = 2;//SYLEE150417-5  1= HV, 2=LV

    nEstUse = 0; nFileCount_HR = 0;  //estimation //SYLEE150407

    logno1 = 0;    nShRes1T = 0;    nStop = 0;
    ipFlag = 0;   n4Wire = 0;   ipEnd = 1;
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode
    nDischargeCount = 20;//sylee20120830

    nHVIADCFlag = 1;//SYLEE121018   //waiting 
    nIControl = 0;

    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nSh1Ret1, sizeof(nSh1Ret1));
    ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));//sylee120907
    ::ZeroMemory(&nReFlagLvCur, sizeof(nReFlagLvCur));//SYLEE121129


    if (nFlag_HV_SetEnd_Skip == 1) {//sylee150427    0=idle, 1=skip 
        ARun201_S2_SQ2_HV_Re_VB_Finish();//sylee150427 
        nFlag_HV_SetEnd_Skip = 0;
        AfxMessageBox(" Error No 7911, \n   HV END Discharge  Skip   !,  LV Short Start Error!!!");
    }

    nFileCount_HR = 0;


    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;

    if (m_nMode1 > 205) {
        nDelay10 = 50000;//10mS//sylee140521   ->REAL 15mS OK   NEW   HR SHORT   lv  SHORT
    }

    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
//  n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  


    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7711, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }


    Sub71.nADCount1 = (int)dRec[m_nMode1][7];

    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock    

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 1024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
        //      MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
        //      MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 1025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
        //      MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
        return 0;
    }


    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 


    Lo1 = 3000; //sylee141114   //sylee170525   500->3000

    ///sylee140212   
    Sub71.AOnReadVB1Run1(nVRel);//sylee130802


Task101:


    Sub71.AOnReadVB1Run1(nVRel);

    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%  //SYLEE211118    5->10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;


    if (Simulator100 != 7) {
        if (Sub71.V1 > 300) {
            if (Lo1-- > 0) {
                //sylee121019  Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms  //sylee141114 
                goto Task101;
            }

            if (nG_Language != 2) {//SYLEE150707
                str.Format("Error No 1301,\n\n 전압 설정이 안되었습니다. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n  ,", (int)m_nMode1, nVSet, Sub71.V1);
            }
            else {
                str.Format("Error No 1301,\n\n  short  voltage set error. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n  ,", (int)m_nMode1, nVSet, Sub71.V1);
            }
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            nSelfTestHWError1 = 1;
            //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
            //          MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
            return 0;
        }

        //  Sub71.V1=0.0;//debug
#ifdef _PC_TEST_
        Sub71.V1 = nVSet;      //son PC 테스트용 임시설정. HW없이 테스트시에 HW error 넘어가기 위함
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
            if (Lo1-- > 0) {
                //sylee121019  Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(1000);  //0.1ms                           
                goto Task101;
            }

            if (nSelfTestHWError1 != 1) {
                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1314,\n \n\n 전압설정이 안되었습니다. 계측보드 전원 확인하십시요. \n\n\n VB Set=%.2f, VB Read =%.2f ,\n  ,", nVSet, Sub71.V1);
                }
                else {
                    str.Format("Error No 1314,\n \n\n   LV  Short   voltage set error.   bbt controller  power check! \n\n\n VB Set=%.2f, VB Read =%.2f ,\n  ,", nVSet, Sub71.V1);
                }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            Sub71.OnPinAllReset1(__LINE__);
            Sub71.ARunoff1();
            Sub71.AOnRelayOffSel(nVRel);
            Sub71.FilterSet(0);
            Sub71.I_Filter(0);
            Sub71.AOnReadV1Enable1(5);
            Sub71.OnPinResetInit();

            //   nProcessFail1=1;//sylee170416
//sylee220725    nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
//          MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
            return 0;

        }
    }


    Sub71.AOnReadV1Enable1(nVRel); //SYLEE20120223   //VC SENSE INIT SET 

    Sub71.FilterSet(nFil);//sylee130702 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629      

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on        
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //vb RELAY ON
    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //sylee20120118


//--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    if (nMod1 == TEST_U_SHORT || nMod1 == TEST_SHORT || nMod1 == TEST_HR_SHORT || nMod1 == TEST_LEAK1)
    {
        nRCount = nBDLData3[dutId][0][1];         //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920

        if (g_nPieceMax1 > 1) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }

    }
    else {
        str.Format("Error No 7213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        //sylee220725    nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
        //      MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }

    nEt_StepSumTemp = 0;  //sylee150407    estimation

/*//sylee131221
    if(nProType==2){//SYLEE130915
        ipEnd=1;
        ipFlag=0;
        nHVIADCFlag=1;
    }
 */
 //sylee131221  


//====================================================================================================================================
//sylee131221   
/*
        int  nDisable;
        nDisable=0;
        if(nProOneP_RunFlag1==1){
           if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927

                for( int ip2=1; ip2<=ipEnd; ip2++ ){
                    if(SysInfo19.m_nUse==1){
                        if(SysInfo19.m_nData[nBlockCountP][ip2]==1){
                            nDisable=1;
                        }
                    }
                }
                if(nDisable==0){
                    if(nManualStartFlag!=1 && nAutoReTest[nBlockCountP]==0){
                        if(nProType==2 || nProType==3){//SYLEE130916  //i mode   running
                            ipEnd=1;
                            ipFlag=0;
                            nHVIADCFlag=1;
                        }
                    }
                }

                //sylee131003if(nProType!=1){//SYLEE130916  //i mode   running
                if((ipFlag==0) && (nProType!=0)){//SYLEE131003
                    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
                }
           }
        }
*///sylee150611
//=============================================================================================

    int  nDisable, nDisable2, nDisable3, ipEnd2;//sylee150611
    nDisable = 0; nDisable2 = 0; nDisable3 = 0;

    ipEnd2 = ipEnd;//sylee150611

    if (nProOneP_RunFlag1 == 1)
    {
        if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3)//sylee130927
        {
            for (int ip2 = 1; ip2 <= ipEnd2; ip2++) {
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nUse == 1) {
                    if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {
                        nDisable = 1;
                    }
                }
            }

            if (nReSheetFlag1 != 1) { //sylee150611 
                if (nDisable == 0) {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0) {
                        if (nProType == 2 || nProType == 3) {//SYLEE130916  //i mode   running 
                            ipEnd = 1;
                            ipFlag = 0;
                            nHVIADCFlag = 1;
                        }
                    }
                }
                if ((ipFlag == 0) && (nProType != 0)) {//SYLEE131003
                    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
                }
            }
        }
    }

    //-------------------------
/*
       if( nFastHv1RunStep==3){//sylee150415 fasthv
           for( int ip2=1; ip2<=ipEnd2; ip2++ ){
                if( nFastHv1Piece[ip2]!=1){
                    nDisable2=1;
                }
           }
        }
*/

/*
        if( nReSheetFlag1==1){ //sylee131127//resheet
              nReSheetCellNo= nBlockPieceNo1[nBlockCountP][ip];
              nReSheetCellStatus=nReSheetRes[nReSheetCellNo];
              if(nReSheetCellStatus==1){
                 // continue;//skip
              }
        }
*/

//////////////////////////////////////////

    //2019.11.11 : 상부, 하부 모두 존재하지 않고 케이블로 상부 하부를 변경하면서 테스트시에는 
    //             아래의 체크코드를 #if 0 으로 전환해서 막아놓고 수행해야 한다.  하부 박스만 있는데 
    //             상부 박스의 pin1~32를 확인하므로 진행이 불가함.
//#if 1
#ifndef _PC_TEST_

//son230217_2 begin:
    //-----------------------------------------------
    //son 1번 Scanner 카드 정상 체크 (SelfTest 활용) 
    //-----------------------------------------------
    int nPin11;//sylee141017-1
    int hwPin, jigPin;
    CString out;    

    //son  1~ 63의 random no.
    nPin11 = rand() % (64);  //SYLEE150210 //ACE380 

    //son hwPin 사용시
    //son230825 if (  SysSet13.m_nPinBlockType == PIN_BLK_32K_TRANS     //son230216_1
    //son230825         || SysSet13.m_nPinBlockType == PIN_BLK_32K_ORG   //son230216_1
    //son230825         || SysSet13.m_nPinBlockType ==PIN_BLK_S100_2_WIRE ) //sylee220725(SysSet13.m_nPinBlockType ==PIN_BLK_S100_2_WIRE)
    {
        //son 같은 pin에 VB, VC를 붙여서 SelfTest  상황을 만든다.
        
        //    HW적으로 pin 1~ 63 사이의 pin이 꽃혀 있는지를 확인하는 것이므로 
        //    HwPin 변환을 거치지 않고 고정값인 1~32를 써야 한다.  그래서  type 1로 호출함.
        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.AOnPinSet1(1, nPin11, 1); //=1Vb,  
        nPinSetSkipVb = 3; //sylee151007 //ACE400       //son230127
        Sub71.AOnPinSet1(1, nPin11, 2); //=1Vb,
        nPinSetSkipVc = 3; //sylee151007 //ACE400       //son230127

        hwPin = nPin11; 

        //son hwPin에 맞는 jigPin값을 찾아낸다.
        jigPin = nJigPinMap[hwPin]; //son230303
    }

    //son230825 s100-1에서 상부 첫번째 block이 없는 .CON을 가진 BDL일때 여기에 걸려서 7703 Pin Map 에러 다수 발생하고
    //   SW 죽여야 다시 사용할 수 있는 문제 발생. (230825) pin변환 없이 첫번째 block을 체크하고자 하는 것이므로  
    //   AOnPinSet1(1, nPin11, 1); 하는 코드만 남기고 아래 코드는 삭제.    
    //else //son jigPin 사용시
    //{
    //    Sub71.OnPinAllReset1(); ///PIN ALL RESET 
    //    Sub71.AOnPinSet1(2, nPin11, 1); //=1Vb,  
    //    nPinSetSkipVb = 3; //sylee151007 //ACE400       //son230127
    //    Sub71.AOnPinSet1(2, nPin11, 2); //=1Vb,
    //    nPinSetSkipVc = 3; //sylee151007 //ACE400       //son230127

    //    jigPin = nPin11;
    //    hwPin = PinMap[2][jigPin];
    //}

//son230217_2 end

    //son  Interlock.Disable이 On이면 수행하지 않는다.
    if (SysSet13.m_nSet20 != 1) //sylee170411  SHIN BU SUNG 
    {
        for (int j1 = 1; j1 <= 1000; j1++) 
        {
            Sub71.Delay_100ns(1000); //100us
            Sub71.AOnReadV1I1_ADC_I();
            if (Sub71.R1 > 1000) {
                break;
            }

            if (j1 == 1000) 
            {
                Sub71.OnPinAllReset1(); ///PIN ALL RESET 

//son230217_2 begin:
                int nCard, nCardPin;
                nCard = (int)(hwPin / 128) + 1;
                nCardPin = (int)(hwPin - (int)((nCard - 1) * 128)) + 1;

                PowerCheckError1();

                if (nG_Language != 2) {//SYLEE150707
                    str.Format("   *스위치카드장착?  스위치박스의  전원인가?  스위치카드 불량?  확인 바랍니다.    \n\n");
                    out = str;
                    str.Format("   *(스위치카드번호=%d, 스위치카드핀번호=%d)    \n\n", nCard, nCardPin);
                    out += str;
                    str.Format("    (지그핀 =%d) \n\n  셀프테스트로 확인 하십시요.  ", jigPin);
                    out += str;
                }
                else {
                    //str.Format("   \n\n Error No 7011.  *switch card  check?   switch card  box  power on?    etc. check!   \n\n   *(switch card no=%d, switch card  pin no=%d)    \n\n    (지그핀 =%d) \n\n   selftest check!  ", hwPin + 1, nCard, nCardPin);
                    
                    str.Format("   *Switch card  check? Switch card  box  power on?    etc. check!   \n\n");  
                    out = str;
                    str.Format("   *(Switch card no=%d, Switch card  pin no=%d)    \n\n", nCard, nCardPin);
                    out += str;
                    str.Format("    (jigpin =%d) \n\n   selftest check!  ", jigPin);
                    out += str;
                }

                //MyTrace(PRT_BASIC, out);     //son221104_2
                //AfxMessageBox(str, MB_OK);
                errMessageBox(7011, out);   
//son230217_2 end

                Sub71.OnPinAllReset1(); ///PIN ALL RESET
                nFailL1Co++;
                nFailL1CoPiece = 1;
                nFailL1CoOpen++;

                for (int ip = 1; ip <= ipEnd; ip++) {
                    nShortFail1[ip] = 1;
                }
                nSystemErrorFlag = 1;
                break;
            }
        }
    }

    nSystemErrorFlag = 0;//SYLEE151007 .//ACE400  TEST TEMP

    Sub71.OnPinAllReset1(); ///PIN ALL RESET 

#endif
 //////////////////////////////////////////



//------------------------------->

#if 0
////////////////////////////////////////////////////
////////////////////////////////////////////////////
//debug180810-1-dut16-1  file make  // DEBUGGING
    int nPinNo1; //sylee160728-2//nSQNet1[i][j]
    FILE* fp;
    str.Format("SHORTSETUPLIST_DUT%d-AUTO", nMulNetFlag);
    ::ZeroMemory(&fName, sizeof(fName));
    strcat(fName, str);
    fp = fopen(fName, "wt");
    if (fp == NULL) {
        str.Format("Error No 1014 :   .\\BDL\\ OPENSETUPLIST%d   file Data Saving Error !     file close!.", nMulNetFlag);
        AfxMessageBox(str, MB_OK);
        //return  ;
    }
    else {
        for (int ip = 1; ip <= ipEnd; ip++) {
            if (ipFlag == 1) {
                nRCount = g_pvBDLData31[nMulNetFlag][ip]->size() - 1;
                for (int ik3 = 1; ik3 <= nRCount; ik3++) {
                    nPinNo1 = (*g_pvBDLData31[nMulNetFlag][ip])[ik3].wFirstPin;
                    fprintf(fp, "    %d, \n", nPinNo1 + 1);
                }
            }
            else {
                nRCount = nBDLData3[nMulNetFlag][0][1];
                for (int ik3 = 1; ik3 <= nRCount; ik3++) {
                    nPinNo1 = nBDLData3[nMulNetFlag][ik3][1];
                    fprintf(fp, "    %d, \n", nPinNo1 + 1);
                }
            }
        }
        fclose(fp);
    }

    ///////////////////////////////////////////////////////
    ////////////////////////////////////////////////////

#endif




//====================================================================================================================================

    //str.Format(" **> nProType=%d,ipEnd=%d",nProType,ipEnd );//SYLEE20121117                 //SYLEE171120-1-DEBUG
    //m_Label112.SetCaption(str); //SYLEE171120-DEBUG


    for (int ip = 1; ip <= ipEnd; ip++)
    {

        if (ipEnd != 1) {   //sylee160203-ITS
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<=============//sylee160203-3        //son220624
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <=============     //son220624
                    continue;
                }
            }
        }
        //sylee170307-2 if( nFastHv1RunStep==2){//sylee150415 fasthv
        //sylee170307-2     if( nFastHv1Piece[ip]!=1){  
        //sylee170307-2         continue;
        //sylee170307-2     }
        //sylee170307-2 }

        //sylee170807-5 if(nProType==1){       //sylee170727  (nProType!=2)

        if ((nProType == 1) || ((nProType != 1) && (ipEnd > 1)))    //sylee170807-5
        {

            //son 메인장비에서 SkipPcs.txt로 skip할 piece를 알려준 경우.
            if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,       //son220803
                if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece     //son220803
                    continue;
                }
            }

#if 0   //son220803 begin: Sheet Retest 일때 이전 Pass Cell skip 기능 삭제.
            //   SkipPcs.txt 파일로만 piece skip을 결정하고,  계측기에서의  pass여부는 체크하지 말라는 메인 장비 요청.

            if (nReSheetFlag1 == 1) { //sylee131127//resheet
                nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
                nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
                //son 해당 piece가 PASS 상태인 Cell이면 테스트 Resheet 의미없음
                if (nReSheetCellStatus == 1) {
                    continue;
                }
            }
#endif  //son220803 end

            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nUse == 1) {
                if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                    nProOneP_RunFlag1 = 0;//sylee131221
                    continue;
                }
            }

			/*//sylee230420 
            if (SysSet13.m_nSet18 != 1) {//sylee170615-2    choi  bhflex
                if (nManualStartFlag != 1) {//SYLEE130221JOYTECH SETUP PRESS
                    if (gRun05.m_nReCh > 0) {//sylee121129 
                        if (nAutoReTest[nBlockCountP] < gRun05.m_nReCh) {//sylee121129 
                            if (nOpenSetFlag1 == 1) {//sylee131205 case open use
                                if (nReFlagOpenCur[ip] != 1) {
                                    continue;
                                }
                            }
                        }
                        else  if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) {
                            if (nReFlagOpenOld[ip] == 1) {
                                continue;
                            }
                        }
                    }
                }//sylee130225  
            }
            else {//syle170725-3
			*/ //sylee230420 
                if (nReFlagOpenOld[ip] == 1) {//syle170725-3   //SYLEE171120-2  IP3->IP
                    continue;
                }
            //sylee230420 }
            if (nShortFail1[ip] > 0) {//sylee120921
                continue;
            }
            //sylee230420 if (SysSet13.m_nSet18 == 1) {
            if (nPass2[ip] == 1) {//sylee171120-1  
                continue;
            }//sylee171120-1
           //sylee230420  }
        }//if(nProType!=2){ //sylee170614-1


        if (nOpenErrFlag[ip] == 1) {
            nOpenErrFlag[ip] = 2;
        }

        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;  nECount = 0;  nFailL1CoPiece = 0;
        nEt1 = 0; nShort2FailFlag1 = 0;

        //*******************************************************************************************************************************//
     //Task1:

        if (ipFlag == 1) {
            nRCount = g_pvBDLData31[dutId][ip]->size() - 1; //SYLEE180810-1-DUT16  //son190704-4WDUT16
        }
        else {
            nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16
        }

        nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
        for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
        {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
            tp1 = i * i;
            if (tp1 >= nRCount) {
                nSQCount1 = i;//sylee120908
                break;
            }
        }

        //sylee170327-1 import  
        if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
    //  if( (nSQCount1==0) ){//sylee170327-1
            str.Format("Error No 7513-3 ,  [SETUP]=>[PIECE POINT]=> PIECE COUNT?? ,   Short  pin <1 ?   ,    Piece pin no   set check?   HV SQUARE  COUNT = ZERO   n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            //sylee220725     nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
            //          MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
            return 0;
        }

        ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));

        //################################################################################################################################
       //SET 

        int nTmpPinNo1; //sylee160728-2//nSQNet1[i][j]

        for (ik = 1; ik <= nRCount; ik++)
        {
            i = (ik - 1) / nSQCount1 + 1;//mok
            j = (ik - 1) - nSQCount1 * (i - 1);//na
            j = j + 1;

            if (ipFlag == 1) {//short   PIECE MULT.
                nTmpPinNo1 = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin; // 1 VB,    =2VC, //SYLEE180810-1-DUT16   //son190704-4WDUT16
            }
            else {
                nTmpPinNo1 = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16
            }

            //openlist   
            for (int jk1 = 1; jk1 <= nOpen2Li1[ip][0][0]; jk1++) {//sylee160801-3
                if (nTmpPinNo1 == (nOpen2Li1[ip][jk1][0])) {    //sylee160816-1
                    nTmpPinNo1 = nOpen2Li1[ip][jk1][1];   //sylee160816-1 
                }//sylee160728-2
            }//end of for( int jk1=1; jk1<=nOpen2Li1[ip2][0][0]; jk1++){

            ///////////////////////////////////////////////////////////////
            nSQNet1[i][j] = nTmpPinNo1; //sylee160801-3

            if (ik == nRCount) {
                nSQLastPin = j;//sylee120908   ///last row , last col.
                nSQLastY1 = i;
            }
        }

        nEt_StepSumTemp = nEt_StepSumTemp + (nSQLastY1 - 1) + (nSQCount1 - 1);  //sylee150407 estimation

        //===================================================================================

        int iktmp, ikok;
        iktmp = 0; ikok = 0;

        if (nProOneP_RunFlag1 == 1)
        {
            if (nProOneP_Flag1 == 2 || nProOneP_Flag1 == 3) {//sylee130927
                if (nProType == 3) {
                    if (nManualStartFlag == 1 || nAutoReTest[nBlockCountP] == 0)
                    {
                        for (ik = 1; ik <= nRCount; ik++)
                        {
                            ikok = 0;
                            for (int k1 = 1; k1 <= nProOneP_Short1[0]; k1++)
                            {
                                if ((nProOneP_Short1[k1] + 1) == (nBDLData3[dutId][ik][1] + 1))//sylee131012
                                    ikok = 1;
                            }

                            if (ikok == 0)
                            {
                                iktmp++;
                                i = (iktmp - 1) / nSQCount1 + 1;//mok
                                j = (iktmp - 1) - nSQCount1 * (i - 1) + 1;//na                     

                                nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16
                                nSQLastPin = j;
                                nSQLastY1 = i;
                            }
                        }
                    }
                }
            }
        }

        //================================================================================================================


       //################################################################################################################################
       //#1 FIRST-1  Line&Block
       //row

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;
        nRetry1 = 0;

        //Task1Retry:


        for (ik = 1; ik < nSQLastY1; ik++)  // FIRST LOOP //Y  VB 
        {
            if (ik == 1 || nSQStep1flag == 2)
            {
                Sub71.OnPinAllReset1(); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    if (ik2 > ik) {
                        continue;
                    }
                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }
                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,  
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                        ///////////////////////////////////////////////////////////////////////////
                        //debug  
                        /*
                           Sub71.Delay_100ns(10000); //1ms
                           Sub71.AOnReadV1I1_ADC_I();

                           if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                        Sub71.Delay_100ns(1000); //1ms
                        }

    */
    //////////////////////////////////////////////////////////////////////////////////

                    }
                }

                nSQStep1flag = 0;

            }

            else//end of if(ik==1  || nSQStep1flag==2)
            {


                Sub71.OnPinResetVC();
                //              Sub71.Delay_100ns(100);//10uSEC  

                for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                    if (ik == nSQLastY1) {  //LAST Y STEP
                        if (ih > nSQLastPin) {
                            break;//SKIP   
                        }
                    }


                    Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 1); //=1  vb
                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ik][ih];
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////
                    //debug*
                    /*
                       Sub71.Delay_100ns(10000); //1ms
                       Sub71.AOnReadV1I1_ADC_I();
                       if( Sub71.R1>1000){// ok//HV
                    // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                    Sub71.Delay_100ns(1000); //1ms
                    }
                    */
                    //////////////////////////////////////////////////////////////////////////////////

                }
            }


            for (ih = 1; ih <= nSQCount1; ih++)  //X   // Second LOOP   vb pin  
            {
                if ((ik + 1) == nSQLastY1) {
                    if (ih > nSQLastPin) {
                        break;//SKIP
                    }
                }

                Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =2,Vc,   all        
                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ik + 1][ih];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }
                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                   Sub71.Delay_100ns(10000); //1ms
                   Sub71.AOnReadV1I1_ADC_I();

                   if( Sub71.R1>1000){// ok//HV
                // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                Sub71.Delay_100ns(1000); //1ms
                }
                */
            }
            //////////////////////////////////////////////////////////////////////////////////


            if (nHVIADCFlag == 1)
            {
                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1); //sylee140923  //sylee170612   ,1)         
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv1);
            }
            //  IADClog1[ip][ik]=Sub71.R1;///logging 
            if (nHVIADCFlag == 1)
            {
                if (Sub71.R1 <= nProRv1) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else//fail
                {

                    //                  Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test

                    /*  if( nRetry1==0  && Sub71.R1>=10000 ){
                        nRetry1=1;
                    //                      Sub71.OnPinResetVB();
                    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                    Sub71.Delay_100ns(2000000);  //200ms
                    goto Task1Retry;
                    }
                    */

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;

                }

            }
            else
            {
                if (Sub71.R1 >= nProRv1) {//ok//LV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

                   /*  if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;
                   //                      Sub71.OnPinResetVB();
                   Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                   Sub71.Delay_100ns(2000000);  //200ms
                   goto Task1Retry;
                   }
                   */
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //  nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }
            }


            //  nFailFlag1=0;  // ALLPASS


    //==============================================================================================================================
    //################################################################################################################################
    //#2,  second search    hv  adc  
    // vc  m block 

            if (nFailFlag1 == 1)  //if error  
            {
                nDebug11 = 1;//sylee170618-test1 debugcode
                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                Sub71.OnPinResetVB();   //sylee121029  

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc               
                {
                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;
                    //sylee121029   Sub71.OnPinResetVB();
                    //  Sub71.Delay_100ns(100);//10uSEC                    
                    if (ik2 > ik) { //doublecheck#2 
                        continue;
                    }

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ik2][ih];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }
                    //=====================================================================================================================
                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 2); //sylee140923  //sylee170612   ,1)
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else
                    {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }

                    }

                    //Sub71.Delay_100ns(10000);  
    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1)
                    {
                        if (Sub71.R1 <= nProRv1) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 

       //=====================================================================================================================
    //##################################################################################################################################

    //one line & one line  search


                    if (nFailFlag2 == 1)
                    {

                        nDebug12 = 1;//sylee170618-test1 debugcode

                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++)    //X // Second LOOP   vc pin
                        {
                            if (ik2 == nSQLastY1)  //LAST Y STEP
                            {
                                if (ih6 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }
                            Sub71.OnPinResetVB();//SYLEE121016***** all reset                                    
                            // Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=2VC,

                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ik2][ih6];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }

                            //=====================================================================================================================

                            if (nHVIADCFlag == 1)
                            {
                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 3); //sylee140923 //sylee170612   ,3)
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {
                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                }


                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }
                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }
                            }

                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv1) {// ok//HV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line                                   
       //=====================================================================================================================
     //################################################################################################################################
    ///one point  & one point search

                            if (nFailFlag3 == 1)
                            {

                                nDebug13 = 1;//sylee170618-test1 debugcode

                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                                for (int ih2 = 1; ih2 <= nSQCount1; ih2++)  //X   // Second LOOP   vb pin                                       
                                {
                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih2 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.OnPinResetVC(); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all
                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }
                                    if (nHVIADCFlag == 1) {
                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923 //sylee170612   ,4)
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                        }
                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }
                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }
                                    }


                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1)
                                    {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV
                                        }
                                        else {//fail
                                           //  if(ih2==ih6)
                                            nFailFlag4 = 1;

                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV
                                        }
                                        else {//fail
                                           //   if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }
                                    //=====================================================================================================================

                                    //*****************************************************************************//
                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ik + 1][ih2];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ik2][ih6];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;
                                    }

                                    //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1 
                                    //##########################################################################################################################################3


                                    if (nFailFlag4 == 1)//sylee130111 
                                    {
                                        Sub71.Delay_100ns(nErrorDelay1);//sylee201028

                                        nDebug14 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;

                                        //if((nOpenErrList[tmp1][0]<=0)&&(nOpenErrList[tmp2][0]<=0)) 

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1))
                                        {
                                            if (nFailL1Co < 3000) {//array size nFailL1[                                                                             

                                                /*//sylee150618
                                                  if(nProOneP_RunFlag1==1){//sylee131221
                                                      if(nReSheetFlag1!=1){//sylee140429-1
                                                          if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                          nProOneP_RunFlag1=0;
                                                          goto TaskEnd100;
                                                          }
                                                      }
                                                  }
                                                  */

                                                  //son230202 nFailCount[nMod1] = nFailCount[nMod1]++;
                                                nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202

                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;

                                                //son230202 nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][1] = prtTestMode; 	//son230202 

                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                    nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                    nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                }
                                                else {
                                                    nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                    nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                }

                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                              
                                                //  }else{
                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                //}
                                                /*
                                                   t2=nSQNet1[ik2][ih6]+1;//sylee170810-1

                                                   if(nErrPin1S2[t1]==0){
                                                   if(nErrPin1S[t1]<100000){
                                                   nErrPin1S[t1]++;//sylee170810-1
                                                   nErrPin1S2[t1]=1;
                                                   }
                                                   }
                                                   if(t1!=t2){//sylee170810-1
                                                   if(nErrPin1S2[t2]==0){
                                                   if(nErrPin1S[t2]<100000){
                                                   nErrPin1S[t2]++;//sylee170810-1
                                                   nErrPin1S2[t2]=1;
                                                   }
                                                   }
                                                   }
                                                   */
                                                   //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                nReFlagLvCur[ip] = 2;//SYLEE121129
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                //son230202 nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][8] = nProStep1[prtTestMode][1];	//son230202

                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP

                                                //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                nFailL1[nFailL1Co][16] = prtTestMode;  //son230202


                                                nShortFlag = 1;//sylee120915

                                                nDebug15 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000)  //array size nFailL1[


                                            //sylee170620    Sub71.Delay_100ns(10000);//1mSEC   

                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }


                                        }//endof   if((nPin1[0]<1)&&(nPin2[0]<1))      


                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(); //VbCall reset    
                                                Sub71.Delay_100ns(1000);//100uSEC  //sylee170620      
                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923 //sylee170612   ,4)
                                                if (Sub71.R1 <= nProRv1) {// ok//HV   line & one
                                                }
                                                else {//fail
                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(); ///PIN ALL RESET 
                                                        Sub71.Delay_100ns(1000);//100uSEC  //sylee170620    
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923  //sylee170612   ,4)
                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one
                                                        }
                                                        else {//fail
                                                           //error loggging
                                                           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                           //sylee151208-1-import     nSQNet1[ik+1][ih2]=nPin1[st1];
                                                           //sylee151208-1-import    nSQNet1[ik2][ih6]=nPin2[st2];  


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                  if(nProOneP_RunFlag1==1){//sylee131003  //sylee131221
                                                                  if(nReSheetFlag1!=1){//sylee140429-1
                                                                  if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                                  nProOneP_RunFlag1=0;
                                                                  goto TaskEnd100;
                                                                  }
                                                                  }
                                                                  }
                                                                  */

                                                                  //son230202 //nFailCount[nMod1] = nFailCount[nMod1]++;
                                                                nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202

                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;

                                                                //son230202 //nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][1] = prtTestMode; //son230202 

                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                /*//sylee151208-1-import
                                                                  if( nSQNet1[ik+1][ih2]<nSQNet1[ik2][ih6]){
                                                                  nFailL1[nFailL1Co][5]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                  }else{
                                                                  nFailL1[nFailL1Co][4]=nSQNet1[ik+1][ih2]+1 ;//pin  vb
                                                                  nFailL1[nFailL1Co][5]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                                  }

    */

                                                                if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
                                                                    nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
                                                                    nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
                                                                }
                                                                else {
                                                                    nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
                                                                    nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
                                                                }

                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }

                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc

                                                                //sylee151208-1-import  t1=nSQNet1[ik+1][ih2]+1;//PIECE  pin no                                              
                                                                t1 = nPin1[st1] + 1;//PIECE  pin no   //sylee151208-1-import


                                                                t2 = nSQNet1[ik2][ih6] + 1;//sylee170810-1


                                                                //  }else{
                                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                //}


                                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                nReFlagLvCur[ip] = 2;//SYLEE121129
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                //son230202 //nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][8] = nProStep1[prtTestMode][1];	//son230202

                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP

                                                                //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                                nFailL1[nFailL1Co][16] = prtTestMode; //son230202


                                                                nShortFlag = 1;//sylee120915

                                                                nDebug16 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000) //array size nFailL1[


                                                            //sylee170620    Sub71.Delay_100ns(10000);//1mSEC   

                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1)  else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++) 

                                                }//end if else{//fail  if( Sub71.R1<=nProRv1)// ok//HV   line & one

                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                Sub71.Delay_100ns(1000);//100uSEC  //sylee170620    

                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }



                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++)   


                                        } //end of      if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ) //vb                                                         


                                        //##########################################################################################################################################3
                                        //*****************************************************************************//


                                    }   //if(nFailFlag4==1) 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  


                                //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC();
                                //   Sub71.Delay_100ns(100);//10uSEC   

                                for (int ih3 = 1; ih3 <= nSQCount1; ih3++)  //X   // Second LOOP   vb pin  
                                {
                                    /* if(nSQPinCheck[nSQNet1[ik][ih]]==2){
                                              Sub71.AOnReadV1I1_ADC_I();        //debug
                                              if(Sub71.R1>2000){//debug
                                                 Sub71.R1=Sub71.R1;//debug
                                              }
                                          }
                                    */
                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih3 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }
                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                              
                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih3];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }
                                }


                            }// if(nFailFlag3==1) 



                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################


                        }//end of for( ih=1; ih<=nSQCount1; ih++)    //X // Second LOOP   vc pin 


    //=====================================================================================================================
                    }//   end of  if(nFailFlag2==1)   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {      //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc

            }//end of  if(nFailFlag1==1){


            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }


        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++)     // FIRST LOOP //Y  VB


    //==============================================================================================================================
    //################################################################################################################################

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 


    //================================================================================================================
    //################################################################################################################################
    //#1 FIRST-1  Line&Block
    // Y 

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;
        nRetry1 = 0;


        //Task2Retry:

        for (ik = 1; ik < nSQCount1; ik++)     // FIRST LOOP //Y  VB 
        {

            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                break;// complete  error                                                 
            }

            if (ik == 1 || nSQStep1flag == 2)
            {
                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 


                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {

                    if (ik2 > ik) {
                        continue;
                    }
                    for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }


                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=2VC,  
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }


                        ///////////////////////////////////////////////////////////////////////////
                        /* //debug
                           Sub71.Delay_100ns(10000); //1ms
                           Sub71.AOnReadV1I1_ADC_I();

                           if( Sub71.R1>1000){// ok//HV
                        // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                        Sub71.Delay_100ns(1000); //1ms
                        }
                        */
                        //////////////////////////////////////////////////////////////////////////////////

                    }
                }


                nSQStep1flag = 0;

            }
            else//end of if(ik==1  || nSQStep1flag==2)
            {

                Sub71.OnPinResetVC();
                //   Sub71.Delay_100ns(100);//10uSEC  



                for (ih = 1; ih <= nSQLastY1; ih++)    //X // Second LOOP   vc pin 
                {
                    if (ih == nSQLastY1) {  //LAST Y STEP
                        if (ik > nSQLastPin) {
                            break;//SKIP   
                        }
                    }


                    Sub71.AOnPinSet1(2, nSQNet1[ih][ik], 1); //=2VC, 

                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                        tmp1 = nSQNet1[ih][ik];
                        if (nOpenErrList[tmp1][0] > 0) {
                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////
                    /* //debug
                        Sub71.Delay_100ns(10000); //1ms
                        Sub71.AOnReadV1I1_ADC_I();

                        if( Sub71.R1>1000){// ok//HV
                            // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                            Sub71.Delay_100ns(1000); //1ms
                        }
                    */
                    //////////////////////////////////////////////////////////////////////////////////

                }

            }


            for (ih = 1; ih <= nSQLastY1; ih++)  //X   // Second LOOP   vb pin  
            {
                if (ih == nSQLastY1) {
                    if ((ik + 1) > nSQLastPin) {
                        break;//SKIP
                    }
                }

                Sub71.AOnPinSet1(2, nSQNet1[ih][ik + 1], 2);   // =1,VB,   all        
                if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                    tmp1 = nSQNet1[ih][ik + 1];
                    if (nOpenErrList[tmp1][0] > 0) {
                        for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                            Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                        }
                    }
                }

                ///////////////////////////////////////////////////////////////////////////
                //debug
                /*
                   Sub71.Delay_100ns(10000); //1ms
                   Sub71.AOnReadV1I1_ADC_I();

                   if( Sub71.R1>1000){// ok//HV
                // Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                Sub71.Delay_100ns(1000); //1ms
                }
                */

            }
            //////////////////////////////////////////////////////////////////////////////////

            if (nHVIADCFlag == 1) {
                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 1); //sylee140923     //sylee170612   ,1)         
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv1);
            }


            //  IADClog1[ip][ik]=Sub71.R1;///logging

            if (nHVIADCFlag == 1)
            {
                if (Sub71.R1 <= nProRv1) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else//fail
                {


                    //                  Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET //test
                    /*
                       if( nRetry1==0  && Sub71.R1>=10000 ){
                       nRetry1=1;
                    //                      Sub71.OnPinResetVB();
                    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                    Sub71.Delay_100ns(2000000);  //200ms
                    goto Task2Retry;
                    }
                    */

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }
            }
            else
            {
                if (Sub71.R1 >= nProRv1) {//ok//LV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //  nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }

                /*
                                if( nRetry1==0  && Sub71.R1>=10000 ){
                                nRetry1=1;
                //                    Sub71.OnPinResetVB();
                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET
                Sub71.Delay_100ns(2000000);  //200ms
                goto Task2Retry;
                }
                */

            }

            // nFailFlag1=0;  // ALLPASS


    //==============================================================================================================================
    //################################################################################################################################
    //#2,  second search    hv  adc  
    // vc  m block 

            if (nFailFlag1 == 1)  //if error  
            {
                nDebug21 = 1;//sylee170618-test1 debugcode

                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 
                Sub71.OnPinResetVB();//sylee121029   


                for (int ik2 = 1; ik2 <= nSQCount1; ik2++)     // FIRST LOOP //Y   //Vc               
                {
                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;

                    //sylee121029  Sub71.OnPinResetVB();
                     //Sub71.Delay_100ns(100);//10uSEC                      
                    if (ik2 > ik) { //doublecheck#2 
                        continue;
                    }

                    for (ih = 1; ih <= nSQLastY1; ih++)    //X // Second LOOP   vc pin 
                    {
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=2VC, 
                        if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                            tmp1 = nSQNet1[ih][ik2];
                            if (nOpenErrList[tmp1][0] > 0) {
                                for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                    Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                }
                            }
                        }
                    }

                    //=====================================================================================================================

                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 2); //sylee140923 //sylee170612   ,2)
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }
                    }

                    //Sub71.Delay_100ns(10000);  
    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv1) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 
       //=====================================================================================================================
    //##################################################################################################################################

    //one line & one line  search
                    if (nFailFlag2 == 1)
                    {

                        nDebug22 = 1;//sylee170618-test1 debugcode


                        Sub71.Delay_100ns(nErrorDelay1);//sylee150610 

                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++)    //X // Second LOOP   vc pin 
                        {
                            /*//sylee131112  trouble
                                 if( ik2==nSQLastY1){  //LAST Y STEP  nSQLastY1=9
                                      if(ih6>nSQLastPin){//  nSQLastPin=6
                                         break;//SKIP
                                      }
                                  }

                             */  //sylee131112 trouble 


                            if (ih6 == nSQLastY1) {  //LAST Y STEP  nSQLastY1=9  //???????????????????? //sylee131112 trouble 
                                if (ik2 > nSQLastPin) {//??????????????????????????  nSQLastPin=6
                                    break;//SKIP   
                                }
                            }


                            Sub71.OnPinResetVB();//SYLEE121016***** all reset                                    
                            //  Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1); //=2VC,
                            if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                tmp1 = nSQNet1[ih6][ik2];
                                if (nOpenErrList[tmp1][0] > 0) {
                                    for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                        Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                    }
                                }
                            }

                            //===================================================================================================================== 
                            if (nHVIADCFlag == 1) {
                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 3); //sylee140923 //sylee170612   ,3)
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {

                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                }


                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }


                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }


                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv1) {// ok//HV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line 

       //=====================================================================================================================
     //################################################################################################################################
    ///one point  & one point search

                            if (nFailFlag3 == 1)
                            {

                                nDebug23 = 1;//sylee170618-test1 debugcode

                                Sub71.Delay_100ns(nErrorDelay1);//sylee150610 


                                for (int ih2 = 1; ih2 <= nSQLastY1; ih2++)  //X   // Second LOOP   vb pin  
                                {

                                    if (ih2 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }


                                    if (ih6 != ih2) {//sylee121025
                                        continue;
                                    }


                                    Sub71.OnPinResetVC(); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    Sub71.AOnPinSet1(2, nSQNet1[ih2][ik + 1], 2);   // =1,VB,   all


                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 2); //=1Vb,    
                                            }
                                        }
                                    }



                                    if (nHVIADCFlag == 1) {
                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923 //sylee170612   ,4)
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                        }

                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }

                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }

                                    }


                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV
                                        }
                                        else {//fail

                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;
                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ih6][ik2] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ih6][ik2] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5))//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }
                                    //##########################################################################################################################################3
                                    if ((nFailFlag4 == 1) && (nOpenErrFlag[ip] == 2)) {//SYLEE130109-1 

                                        ::ZeroMemory(&nPin1, sizeof(nPin1));    ::ZeroMemory(&nPin2, sizeof(nPin2));
                                        tmp1 = nSQNet1[ih2][ik + 1];
                                        Co = 0;  Co++;    nPin1[0] = Co;   nPin1[Co] = tmp1;
                                        if (nOpenErrList[tmp1][0] > 0) { //vb
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Co++;    nPin1[0] = Co;   nPin1[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                        tmp2 = nSQNet1[ih6][ik2];//pin  vc
                                        Co = 0;  Co++;    nPin2[0] = Co;   nPin2[Co] = tmp2;
                                        if (nOpenErrList[tmp2][1] > 0) {
                                            for (int s1 = nOpenErrList[tmp2][0]; s1 <= nOpenErrList[tmp2][1]; s1++) {
                                                Co++;    nPin2[0] = Co;   nPin2[Co] = nOpenErrData[ip][s1][OP_TO_TEST_PIN];
                                            }
                                        }

                                    }
                                    else {
                                        nPin1[0] = 0;
                                        nPin2[0] = 0;

                                    }  //end of if( nOpenErrFlag[ip]==2){//SYLEE130109-1 
                                    //##########################################################################################################################################3

                                    if (nFailFlag4 == 1) {//sylee130111 

                                        Sub71.Delay_100ns(nErrorDelay1);//sylee201028

                                        nDebug24 = 1;//sylee170618-test1 debugcode

                                        int st1, st2;

                                        if ((nPin1[0] <= 1) && (nPin2[0] <= 1)) {

                                            if (nFailL1Co < 3000) {//array size nFailL1[ 

                                                /*//sylee150618
                                                  if(nProOneP_RunFlag1==1){//sylee131003  //sylee131221
                                                  if(nReSheetFlag1!=1){//sylee140429-1
                                                  if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                  nProOneP_RunFlag1=0;
                                                  goto TaskEnd100;
                                                  }
                                                  }
                                                  }
                                                  */

                                                  //son230202 //nFailCount[nMod1] = nFailCount[nMod1]++;
                                                nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202


                                                //log buffer
                                                nFailL1Co++;
                                                nFailL1CoPiece++;

                                                //son230202 //nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                nFailL1[nFailL1Co][1] = prtTestMode;  //son230202 

                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece


                                                if (nSQNet1[ih2][ik + 1] < nSQNet1[ih6][ik2]) {
                                                    nFailL1[nFailL1Co][5] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
                                                    nFailL1[nFailL1Co][4] = nSQNet1[ih6][ik2] + 1;//pin  vc
                                                }
                                                else {
                                                    nFailL1[nFailL1Co][4] = nSQNet1[ih2][ik + 1] + 1;//pin  vb
                                                    nFailL1[nFailL1Co][5] = nSQNet1[ih6][ik2] + 1;//pin  vc
                                                }

                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }
                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                if ((t1 > 0) && (t1 < 16384)) {
                                                    nErrPin1S0[t1] = 1;
                                                }


                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc
                                                t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no                                              
                                                //  }else{
                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                //}



                                                //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314



                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                nReFlagLvCur[ip] = 2;//SYLEE121129
                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                //son230202 //nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                nFailL1[nFailL1Co][8] = nProStep1[prtTestMode][1];	//son230202

                                                nFailL1[nFailL1Co][9] = nVSet;
                                                nFailL1[nFailL1Co][10] = nISet;
                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP

                                                //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                nFailL1[nFailL1Co][16] = prtTestMode;   //son230202


                                                nShortFlag = 1;//sylee120915

                                                nDebug25 = 1;//sylee170618-test1 debugcode

                                            }   //end of if(nFailL1Co<3000)//array size nFailL1[


                                            //sylee170620       Sub71.Delay_100ns(10000);//1mSEC   


                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                break;// complete  error 
                                            }

                                        }   //endof if((nPin1[0]<1)&&(nPin2[0]<1))                                                         



                                        if ((nPin1[0] > 1) || (nPin2[0] > 1)) {
                                            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 
                                            for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                            }
                                            for (st2 = 1; st2 <= nPin2[0]; st2++) {
                                                Sub71.OnPinResetVC(); //VbCall reset
                                                Sub71.Delay_100ns(1000);//100uSEC  //sylee170620    
                                                Sub71.AOnPinSet1(2, nPin2[st2], 2);  // =2VC  all
                                                //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923 //sylee170612   ,4)
                                                if (Sub71.R1 <= nProRv1) {// ok//HV   line & one
                                                }
                                                else {//fail
                                                    for (st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.OnPinResetVB(); ///PIN ALL RESET 
                                                        Sub71.Delay_100ns(1000);//100uSEC  //sylee170620           


                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                        //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                                        AHV_ADCI_Read1_OneToM(nProRv1, nDelay10, 4); //sylee140923 //sylee170612   ,4)

                                                        if (Sub71.R1 <= nProRv1) {// ok//HV   one & one
                                                        }
                                                        else {//fail
                                                           //error loggging
                                                           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                           //sylee151208-import       nSQNet1[ih2][ik+1]=nPin1[st1];
                                                           //sylee151208-import       nSQNet1[ih6][ik2]=nPin2[st2];                                                                             


                                                            if (nFailL1Co < 3000) {//array size nFailL1[

                                                                /*//sylee150618
                                                                  if(nProOneP_RunFlag1==1){//sylee131003
                                                                  if(nReSheetFlag1!=1){//sylee140429-1
                                                                  if( nProOneP_Flag1==2 || nProOneP_Flag1==3){//sylee130927
                                                                  nProOneP_RunFlag1=0;
                                                                  goto TaskEnd100;
                                                                  }
                                                                  }
                                                                  }
                                                                  */



                                                                  //son230202 //nFailCount[nMod1] = nFailCount[nMod1]++;
                                                                nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202

                                                                //log buffer
                                                                nFailL1Co++;
                                                                nFailL1CoPiece++;

                                                                //son230202 //nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                                nFailL1[nFailL1Co][1] = prtTestMode; //son230202 

                                                                nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                                //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece

                                                                /*
                                                                //sylee151208-1-import
                                                                if( nSQNet1[ih2][ik+1]<nSQNet1[ih6][ik2]){
                                                                nFailL1[nFailL1Co][5]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                nFailL1[nFailL1Co][4]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                }else{
                                                                nFailL1[nFailL1Co][4]=nSQNet1[ih2][ik+1]+1 ;//pin  vb
                                                                nFailL1[nFailL1Co][5]=nSQNet1[ih6][ik2]+1;//pin  vc
                                                                }
                                                                */

                                                                if (nPin1[st1] < nPin2[st2]) {//sylee151208-1-import
                                                                    nFailL1[nFailL1Co][5] = nPin1[st1] + 1;//pin  vb
                                                                    nFailL1[nFailL1Co][4] = nPin2[st2] + 1;//pin  vc
                                                                }
                                                                else {//sylee151208-1-import
                                                                    nFailL1[nFailL1Co][4] = nPin1[st1] + 1;//pin  vb
                                                                    nFailL1[nFailL1Co][5] = nPin2[st2] + 1;//pin  vc
                                                                }//sylee151208-1-1-import
                                                                t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }
                                                                t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                                if ((t1 > 0) && (t1 < 16384)) {
                                                                    nErrPin1S0[t1] = 1;
                                                                }

                                                                //  if( ipFlag==1 ){//short   PIECE MULT.
                                                                //  nFailL1[nFailL1Co][5]=nSQNet1[ik][ih2]+1 ;//pin  vb
                                                                //  nFailL1[nFailL1Co][4]=nSQNet1[ik2][ih6]+1;//pin  vc                                     


                                                                //sylee151208-1-import  t1=nSQNet1[ih2][ik+1]+1;//PIECE  pin no                                              

                                                                t1 = nPin1[st1] + 1;//PIECE  pin no   //sylee151208-1-import    


                                                                //  }else{
                                                                //  nFailL1[nFailL1Co][4]=nBDLData3[1][i3-1][1]+1;//pin
                                                                //  nFailL1[nFailL1Co][5]=nBDLData3[1][ik][1]+1;//pin
                                                                //  t1=nBDLData3[1][j3][1]+1;//PIECE  pin no
                                                                //}





                                                                //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                                t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                                nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                                nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                                nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                                nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                                nReFlagLvCur[ip] = 2;//SYLEE121129
                                                                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                                                nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                                nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                                   nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                                //son230202 //nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                                nFailL1[nFailL1Co][8] = nProStep1[prtTestMode][1];	//son230202

                                                                nFailL1[nFailL1Co][9] = nVSet;
                                                                nFailL1[nFailL1Co][10] = nISet;
                                                                nFailL1[nFailL1Co][11] = m_nMode1;
                                                                nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                                nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                                nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                                nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP

                                                                //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                                nFailL1[nFailL1Co][16] = prtTestMode;	//son230202


                                                                nShortFlag = 1;//sylee120915

                                                                nDebug26 = 1;//sylee170618-test1 debugcode

                                                            }   //end of if(nFailL1Co<3000) //array size nFailL1[


                                                            //sylee170620   Sub71.Delay_100ns(10000);//1mSEC   


                                                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                                break;// complete  error 
                                                            }

                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                                        }//end of   fail   if( Sub71.R1<=nProRv1)  else   one & one 

                                                    }//end of  for( int st1=1; st1<=nPin1[0]; st1++) 

                                                }//end if else  //fail  if( Sub71.R1<=nProRv1)   // ok//HV   line & one

                                                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                                                Sub71.Delay_100ns(1000);//100uSEC  //sylee170620    


                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {     //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }



                                                if (st2 < nPin2[0]) {
                                                    for (int st1 = 1; st1 <= nPin1[0]; st1++) {
                                                        Sub71.AOnPinSet1(2, nPin1[st1], 1);   // =1,VB,   all
                                                    }
                                                }

                                            }//end of for( int st2=1; st2<=nPin2[0]; st2++)   


                                        } //end of     if( (nOpenErrList[tmp1][0]>0) || (nOpenErrList[tmp2][0]>0) ) //vb                                                                       





                                    }   //if(nFailFlag4==1) 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  

    //----------------------------------------------------------------------------------------------------------------------
                                Sub71.OnPinResetVC();

                                //     Sub71.Delay_100ns(100);//10uSEC   
                                //SYLEE121107

                                for (int ih3 = 1; ih3 <= nSQLastY1; ih3++)  //X   // Second LOOP   vb pin  
                                {
                                    if (ih3 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }
                                    Sub71.AOnPinSet1(2, nSQNet1[ih3][ik + 1], 2);   // =1,VB,   all                                              
                                    if (nOpenErrFlag[ip] == 2) {//SYLEE130109-1 
                                        tmp1 = nSQNet1[ik + 1][ih];
                                        if (nOpenErrList[tmp1][0] > 0) {
                                            for (int s1 = nOpenErrList[tmp1][0]; s1 <= nOpenErrList[tmp1][1]; s1++) {
                                                Sub71.AOnPinSet1(2, nOpenErrData[ip][s1][OP_TO_TEST_PIN], 1); //=1Vb,    
                                            }
                                        }
                                    }

                                }


                            }// if(nFailFlag3==1) 



                            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                break;// complete  error 
                            }


                            //################################################################################################################################


                        }//end of for( ih=1; ih<=nSQCount1; ih++)    //X // Second LOOP   vc pin 


                        //=====================================================================================================================
                    }//   end of  if(nFailFlag2==1)   ///one line & one line  search


                    if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {      //sylee121016
                        break;// complete  error 
                    }

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc



            }//end of  if(nFailFlag1==1)

            if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                break;// complete  error 
            }

        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB



    //==============================================================================================================================
    //################################################################################################################################

        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

        //      if( nFailL1CoPiece>=SysInfo05.m_nIsEr){   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
        //          break;// complete  error                                                 
        //      }

    //#####################################################################################################################


    //sylee121117-openshortlist
    //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    //*******************************************************************************************************************************//
     //Task1:


        int nEnb1;



        if ((nFailL1CoOpen > 0) && (nOpShortLt1[ip][0][0] > 0))
        {

            /*  if(ipFlag==1){
                nRCount=g_pvBDLData31[1][ip]->size() -1;
                }else{
                nRCount=nBDLData3[1][0][1];
                }
                */
            if (ipFlag == 1)//sylee180810-1-DUT16
                nRCount = g_pvBDLData31[dutId][ip]->size() - 1; //SYLEE180810-1-DUT16  //son190704-4WDUT16
            else
                nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16


            nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)

            for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
            {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
                tp1 = i * i;
                if (tp1 >= nRCount) {
                    nSQCount1 = i;//sylee120908
                    break;
                }
            }

            if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
                str.Format("Error No 7513-4 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                //sylee220725   nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
                //              MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
                return 0;
            }

            ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));



            //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            //sylee121117-openshortlist

            int nOpShortPin[100];
            int nSQLastY2, nSQLastPin2, nOpCo, nOpFlag;

            nOpCo = 0;
            nOpFlag = 0;
            ::ZeroMemory(&nOpShortPin, sizeof(nOpShortPin));

            ///====================================================================


            for (ik = 1; ik <= nOpShortLt1[ip][0][0]; ik++) {
                if (ik > nSQCount1) {
                    break;
                }

                if (ik == 1) {
                    nOpShortPin[1] = nOpShortLt1[ip][1][0];
                    nOpCo = 1;
                }
                else {

                    nOpFlag = 0;

                    for (i = 1; i <= nOpCo; i++) {
                        if (nOpShortPin[i] == nOpShortLt1[ip][ik][0]) {
                            nOpFlag = 1;
                        }
                    }

                    if (nOpFlag == 0) {
                        nOpCo++;
                        nOpShortPin[nOpCo] = nOpShortLt1[ip][ik][0];
                    }
                }
            }

            nOpShortPin[0] = nOpCo;


            //==========================================================================
            int tmp3;

            tmp3 = nOpShortLt1[ip][0][0];

            for (ik = 1; ik <= (nOpShortLt1[ip][0][0] + nOpShortPin[0]); ik++) {
                if (ik > nSQCount1) {
                    break;
                }

                if (ik <= nOpShortLt1[ip][0][0]) {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortLt1[ip][ik][1];
                }
                else {
                    nSQNet1[nSQLastY1 + 1][ik] = nOpShortPin[ik - tmp3];
                }
            }

            nSQLastY2 = nSQLastY1 + 1;

            if (nOpShortLt1[ip][0][0] < nSQCount1) {
                nSQLastPin2 = nOpShortLt1[ip][0][0] + nOpShortPin[0];
            }
            else {
                nSQLastPin2 = nSQCount1;
            }


            //################################################################################################################################
            //SET 


            for (ik = 1; ik <= nRCount; ik++)
            {
                i = (ik - 1) / nSQCount1 + 1;//mok
                j = (ik - 1) - nSQCount1 * (i - 1);//na
                // if(i>1){
                j = j + 1;
                // }    

                if (ipFlag == 1)//sylee180810-1-DUT16
                    nSQNet1[i][j] = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin; // 1 VB,    =2VC, //SYLEE180810-1-DUT16   //son190704-4WDUT16
                else
                    nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16

                if (ik == nRCount) {
                    nSQLastPin = j;//sylee120908   ///last row , last col.
                    nSQLastY1 = i;
                }
            }


            //#2 second search    hv  adc           
            // 1000 point 

            //################################################################################################################################
            //#1 FIRST-1  Line&Block
            //row

            ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
            nShort2FailFlag1 = 0;
            nSQStep1flag = 0;

            Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

            nRetry1 = 0;

            //Task1Retry:

            for (ik = nSQLastY1; ik <= nSQLastY1; ik++)     // FIRST LOOP //Y  VB  
            {
                Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        nEnb1 = 0;

                        for (int ik7 = 1; ik7 <= nOpShortPin[0]; ik7++) {
                            if (nOpShortPin[ik7] == nSQNet1[ik2][ih]) {
                                nEnb1 = 1;
                            }
                        }

                        if (nEnb1 == 0) {
                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,  
                        }

                    }
                }

                nSQStep1flag = 0;


                for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                    if ((ik + 1) == nSQLastY2) {
                        if (ih > nSQLastPin2) {
                            break;//SKIP
                        }
                    }

                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =2,Vc,   all    
                }
                //////////////////////////////////////////////////////////////////////////////////



                if (nHVIADCFlag == 1) {
                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10); //sylee140923               
                }
                else {
                    Sub71.Delay_100ns(nDelay10);
                    AHV_ADCI_Read1(nProRv1);
                }


                //  IADClog1[ip][ik]=Sub71.R1;///logging

                if (nHVIADCFlag == 1) {
                    if (Sub71.R1 <= nProRv1) {// ok//HV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail 
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                    }

                }
                else {

                    if (Sub71.R1 >= nProRv1) {//ok//LV
                        nSQ1Fail[ik] = 1;
                        nFailFlag1 = 0;
                    }
                    else {//fail 
                        nSQ1Fail[ik] = 2;  // LAST ik=0;
                        nShort2FailFlag1 = 1;
                        nFailFlag1 = 1;
                        //   nFailFlag1=0;//test
                        nSQStep1flag = 2;
                    }

                }


                //  nFailFlag1=0;  // ALLPASS



                //################################################################################################################################
                //#2,  second search    hv  adc  
                // vc  m block 

                if (nFailFlag1 == 1) {  //if error                 


                    Sub71.OnPinResetVB();   //sylee121029  

                    for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //Vc


                        nMSet1Co = 0;
                        nMSet1Flag = 0;
                        nMSet1CoT2 = 0;


                        if (ik2 > ik) { //doublecheck#2 
                            continue;
                        }

                        for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            nEnb1 = 0;

                            for (int ik8 = 1; ik8 <= nOpShortPin[0]; ik8++) {
                                if (nOpShortPin[ik8] == nSQNet1[ik2][ih]) {
                                    nEnb1 = 1;
                                }
                            }

                            if (nEnb1 == 0) {
                                Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC, 
                            }

                        }


                        //=====================================================================================================================


                        if (nHVIADCFlag == 1) {
                            //  AHV_ADCI_Read1(nProRv1); 
                            //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10); //sylee140923
                            //  Sub71.R1= dIADC1  ;//ADC
                        }
                        else {

                            Sub71.Delay_100ns(nDelay10);

                            if (nCC == 2) {//cv
                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                            }
                            else {// cc                                      
                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                            }

                            if (Sub71.Y1 < 0.0000001) {
                                Sub71.Y1 = 0.0000001;
                            }

                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                }

                            }
                            else if (nCC == 2) {//CV   r=(vb/i)
                                if (nIR == 1 || nIR == 2) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                }
                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                }
                            }

                        }

                        //Sub71.Delay_100ns(10000);  
                        //=====================================================================================================================
                        nFailFlag2 = 0;
                        if (nHVIADCFlag == 1) {
                            if (Sub71.R1 <= nProRv1) {// ok//HV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }
                        else {
                            if (Sub71.R1 >= nProRv1) {//ok//LV
                            }
                            else {//fail
                                nFailFlag2 = 1;
                            }
                        }//line & line 



                        //##################################################################################################################################

                        //one line & one line  search


                        if (nFailFlag2 == 1)
                        {

                            for (int ih6 = 1; ih6 <= nSQCount1; ih6++)    //X // Second LOOP   vc pin 
                            {

                                if (ik2 == nSQLastY1) {  //LAST Y STEP
                                    if (ih6 > nSQLastPin) {
                                        break;//SKIP   
                                    }
                                }

                                Sub71.OnPinResetVB();//SYLEE121016***** all reset                                   
                                // Sub71.Delay_100ns(100);//10uSEC   


                                nEnb1 = 0;

                                for (int ik9 = 1; ik9 <= nOpShortPin[0]; ik9++) {
                                    if (nOpShortPin[ik9] == nSQNet1[ik2][ih6]) {
                                        nEnb1 = 1;
                                    }
                                }

                                if (nEnb1 == 0) {
                                    Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=Vb
                                }
                                //=====================================================================================================================


                                if (nHVIADCFlag == 1) {
                                    //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                    AHV_ADCI_Read1_OneToM(nProRv1, nDelay10); //sylee140923
                                    //  Sub71.R1= dIADC1  ;//ADC
                                }
                                else {


                                    Sub71.Delay_100ns(nDelay10);

                                    if (nCC == 2) {//cv
                                        Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                    }
                                    else {// cc                                      
                                        Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                    }


                                    if (Sub71.Y1 < 0.0000001) {
                                        Sub71.Y1 = 0.0000001;
                                    }


                                    if (nCC == 1) { //CC    r= (vb-vc)/i
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                        }

                                    }
                                    else if (nCC == 2) {//CV   r=(vb/i)
                                        if (nIR == 1 || nIR == 2) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                        }
                                        else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                            Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                        }
                                    }

                                }


                                nFailFlag3 = 0;
                                if (nHVIADCFlag == 1) {
                                    if (Sub71.R1 <= nProRv1) {// ok//HV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }
                                else {
                                    if (Sub71.R1 >= nProRv1) {//ok//LV
                                    }
                                    else {//fail
                                        nFailFlag3 = 1;
                                    }
                                }//line & line  
                                //=====================================================================================================================
                                //################################################################################################################################
                                ///one point  & one point search

                                if (nFailFlag3 == 1) {


                                    for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin  


                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih2 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }

                                        Sub71.OnPinResetVC(); //Vb all reset
                                        // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all


                                        if (nHVIADCFlag == 1) {
                                            //sylee140923   ALV_ADCI_Read1_OneToM(nProRv1,nDelay10);
                                            AHV_ADCI_Read1_OneToM(nProRv1, nDelay10); //sylee140923
                                            //  Sub71.R1= dIADC1  ;//ADC
                                        }
                                        else {
                                            Sub71.Delay_100ns(nDelay10);
                                            if (nCC == 2) {//cv
                                                Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ               
                                            }
                                            else {// cc                                      
                                                Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                  
                                            }

                                            if (Sub71.Y1 < 0.0000001) {
                                                Sub71.Y1 = 0.0000001;
                                            }


                                            if (nCC == 1) { //CC    r= (vb-vc)/i
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                                }

                                            }
                                            else if (nCC == 2) {//CV   r=(vb/i)
                                                if (nIR == 1 || nIR == 2) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                                }
                                                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                    Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                                }
                                            }

                                        }

                                        nFailFlag4 = 0;
                                        if (nHVIADCFlag == 1) {
                                            if (Sub71.R1 <= nProRv1) {// ok//HV
                                            }
                                            else {//fail
                                               //  if(ih2==ih6)
                                                nFailFlag4 = 1;

                                                for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                    if ((nFailL1[iq1][4] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ik2][ih6] + 1))) {
                                                        nFailFlag4 = 0; break;
                                                    }
                                                    if ((nFailL1[iq1][5] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ik2][ih6] + 1))) {
                                                        nFailFlag4 = 0; break;
                                                    }
                                                }

                                            }
                                        }
                                        else {
                                            //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                            if (Sub71.Y1 < 5) {//ok//LV
                                            }
                                            else {//fail
                                               //   if(ih2==ih6)
                                                nFailFlag4 = 1;
                                            }
                                        }

                                        //*****************************************************************************/


                                        if (nFailFlag4 == 1)
                                        {

                                            if (nHVIADCFlag != 1)//sylee20120715==> R READ
                                            {
                                                //  if( Sub71.Y1< IT1 ){                                                                     


                                                if (nFailL1Co < 3000) {//array size nFailL1[                                 
                                                    //son230202 //nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202 

                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;

                                                    //son230202 //nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][1] = prtTestMode;  //son230202 

                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece
                                                    //  if( ipFlag==1 ){//short   PIECE MULT.


                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }

                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }


                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no 

                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314

                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    nReFlagLvCur[ip] = 2;//SYLEE121129


                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                    nFailL1[nFailL1Co][16] = prtTestMode;	//son230202

                                                    nShortFlag = 1;//sylee120915 

                                                }   //end of if(nFailL1Co<3000){//array size nFailL1



                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error                                                 
                                                }



                                            }

                                            else//if( nHVIADCFlag!=1){//sylee20120715
                                            {
                                                // ====>  I  ADC  READ                                           



                                                if (nFailL1Co < 3000) {//array size nFailL1[

                                                    //son230202 //nFailCount[nMod1] = nFailCount[nMod1]++;
                                                    nFailCount[prtTestMode] = nFailCount[prtTestMode]++;	//son230202

                                                    //log buffer
                                                    nFailL1Co++;
                                                    nFailL1CoPiece++;

                                                    //son230202 //nFailL1[nFailL1Co][1] = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                                    nFailL1[nFailL1Co][1] = prtTestMode;  //son230202 

                                                    nFailL1[nFailL1Co][2] = nBlockCountP;//block
                                                    //  nFailL1[nFailL1Co][3]=nBDLData3[1][i][4];//pin;//piece




                                                    if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }
                                                    else {
                                                        nFailL1[nFailL1Co][4] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                        nFailL1[nFailL1Co][5] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                    }

                                                    t1 = (int)nFailL1[nFailL1Co][4];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }
                                                    t1 = (int)nFailL1[nFailL1Co][5];//sylee180510-1
                                                    if ((t1 > 0) && (t1 < 16384)) {
                                                        nErrPin1S0[t1] = 1;
                                                    }

                                                    t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                              



                                                    //t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                                    t1 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                                    nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                                    nFailL1[nFailL1Co][3] = t1;////PIECE  no   //sylee20120314



                                                    nShortFail1[t1]++;//sylee20121018//100=piecemax
                                                    nShortCo1[nBlockCountP][t1]++;//sylee201224
                                                    nShortFail1Flag1 = 1;//sylee20120921//100=piecemax
                                                    nReFlagLvCur[ip] = 2;//SYLEE121129


                                                    nFailL1[nFailL1Co][6] = Sub71.R1;//Sub71.R1 
                                                    nFailL1[nFailL1Co][17] = nProRv1;//nProRv1 판정 R  
//sylee220725                                       nFailL1[nFailL1Co][7] = nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                                    //son230202 //nFailL1[nFailL1Co][8] = nProStep1[nMod1][1];
                                                    nFailL1[nFailL1Co][8] = nProStep1[prtTestMode][1];	//son230202

                                                    nFailL1[nFailL1Co][9] = nVSet;
                                                    nFailL1[nFailL1Co][10] = nISet;
                                                    nFailL1[nFailL1Co][11] = m_nMode1;
                                                    nFailL1[nFailL1Co][12] = Sub71.V1;//VB
                                                    nFailL1[nFailL1Co][13] = Sub71.X1;//VC
                                                    nFailL1[nFailL1Co][14] = Sub71.Y1;//I
                                                    nFailL1[nFailL1Co][F_STEP] = nPStep1;//sylee231016 //son 18:F_STEP
                                                    //son230202 //nFailL1[nFailL1Co][16] = nMod1;//I  //open ushort short hr hv   4w
                                                    nFailL1[nFailL1Co][16] = prtTestMode;//son230202


                                                    nShortFlag = 1;//sylee120915

                                                }   //end of if(nFailL1Co<3000){//array size nFailL1[



                                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {   //block 단위로 잘못 되어  piece 단위 하기 위해 막음 .
                                                    break;// complete  error 
                                                }





                                            }// END OF  if( nHVIADCFlag!=1){//sylee20120715


                                        }   //if(nFailFlag4==1){ 

                                    } //for( int ih2=1; ih2<=nSQCount1; ih2++){  //X   // Second LOOP   vb pin  

                                    //----------------------------------------------------------------------------------------------------------------------

                                    Sub71.OnPinResetVC();
                                    //   Sub71.Delay_100ns(100);//10uSEC   

                                    for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  


                                        if ((ik + 1) == nSQLastY2) {
                                            if (ih3 > nSQLastPin2) {
                                                break;//SKIP
                                            }
                                        }
                                        Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                             
                                    }

                                }// if(nFailFlag3==1){ 


                                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                                    break;// complete  error 
                                }

                                //################################################################################################################################


                            }//end of for( ih=1; ih<=nSQCount1; ih++){    //X // Second LOOP   vc pin 


                            //=====================================================================================================================
                        }// end of  if(nFailFlag2==1){   ///one line & one line  search


                        if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {    //sylee121016
                            break;// complete  error 
                        }

                        //#2
                    }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++){     // FIRST LOOP //Y   //Vc

                }//end of  if(nFailFlag1==1){

                if (nFailL1CoPiece >= SysInfo05.m_nIsEr) {
                    break;// complete  error 
                }

            }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++){     // FIRST LOOP //Y  VB


        }//if((nFailL1CoOpen>0)&&(nOpShortLt1[ip][0][0]>0)){


        Sub71.OnPinAllReset1(__LINE__); ///PIN ALL RESET 

        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


        if (nReFlagLvCur[ip] != 2) {
            nReFlagLvCur[ip] = 1;//SYLEE121129
        }
        else {

            int tmp1;
            tmp1 = nBlockPieceNo1[nBlockCountP][ip];

            if (GraphDisplay1[tmp1] == 0) {
                GraphDisplay1[tmp1] = 1;
            }
        }

    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   


 

    tStart1001 = GetuSecond();//SYLEE150426-2

    Sub71.OnPinAllReset1(__LINE__); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720
    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704    
    Sub71.AOnReadV1Enable1(5); //sylee130711
    Sub71.OnPinResetInit();//sylee151221   //ACE400
    Sub71.AIRangeOff();//sylee171204 //ACE400

 

 //::ShellExecute(NULL,"close","EXCEL.EXE","d:\\LOG\\PRO1\\HVLEAK1.CSV","NULL",SW_SHOWNORMAL);
  ////////////////////////////////////////////////////////////////////////////////

    if (nFastHv1RunStep == 2) {//sylee150415 fasthv        
        for (int ip = 1; ip <= ipEnd; ip++) {
            if ((nFastHv1Piece[ip] == 1) && (nShortFail1[ip] > 0)) {
                nFastHv1Piece[ip] = 2;
            }
        }
        for (ip = 1; ip <= ipEnd; ip++) {
            if (nFastHv1Piece[ip] == 1) {
                nFastHv1RunStep = 3;
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////


    nPinSetSkipVb = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee160803 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee160803 //ACE400    //son230127


    if (nDebug11 == 1) {//sylee170618-test1 debugcode
        if (nDebug15 == 1 || nDebug16 == 1) {
        }
        else {
            //      str.Format(" DEBUG 101    LV  EROR  " );
                  //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
    //       LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug12 != 1) {
            //  str.Format(" DEBUG 102    LV  EROR  " );
            //   AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug13 != 1) {
            //  str.Format(" DEBUG 103    LV  EROR  " );
            //    AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug14 != 1) {
            //  str.Format(" DEBUG 104    LV  EROR  " );
             //   AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
    }


    if (nDebug21 == 1) {//sylee170618-test1 debugcode
        if (nDebug25 == 1 || nDebug26 == 1) {
        }
        else {
            //  str.Format(" DEBUG 201    LV  EROR  " );
              //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug22 != 1) {
            //  str.Format(" DEBUG 202    LV  EROR  " );
              //  AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
        if (nDebug23 != 1) {
            //  str.Format(" DEBUG 203    LV  EROR  " );
            nShortRetestFlag1 = 1;//sylee170618-1
        //       LogDebug2(str) ;    //SYLEE170618
           // AfxMessageBox(str, MB_OK);
        }
        if (nDebug24 != 1) {
            //  str.Format(" DEBUG 204    LV  EROR  " );
               // AfxMessageBox(str, MB_OK);
            nShortRetestFlag1 = 1;//sylee170618-1
        //   LogDebug2(str) ;    //SYLEE170618
        }
    }



    //sylee220725     nProRv1Real = nPrev_nProRv1Real;    //son220720  원상복구 코드 추가
    //  MyTrace(PRT_BASIC, "ARun201_S2_SQ2_LV_Re_VB()Line_%d: nProRv1Real=%d\n", __LINE__, nProRv1Real);
    return 1;

}



int  CChildView7::ALV_ADCI_Read1_Avg1(double nProRv1, double nTimeOutSet1, int nntype) //sylee201205  BOSS
{

    int delay_time, delay_time2;
    long TimeT1;
    double nOldAdc1, diff1;
    __int64   tStart1, tStart2, tStart3;
    int nLoopSet1, nLoop1, nBuf1Sum, nAvg;
    int nBuf1[100];
    int nRVal[10];//sylee150415 fasthv
    int nRValCo1;//sylee150415 fasthv
    double nADSum1;//sylee200917
    int nNo1;//sylee200917
    int nADFlag;//sylee210205

    nOldAdc1 = 0;
    diff1 = 0;
    TimeT1 = 0;
    nLoop1 = 0;
    nBuf1Sum = 0;
    nAvg = 0;
    Sub71.R1 = 0.0;//sylee140823 
    ::ZeroMemory(&nBuf1, sizeof(nBuf1));

    ////////////////////////////////////////////////////////////////////
    if (nFastHv1AdRun == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nRVal, sizeof(nRVal));
        nRValCo1 = 0;
        nFastHv1AdReturn = 0;
    }
    //////////////////////////////////////////////////////////////////// 
    nLoopSet1 = 6;
    delay_time = 200;//  20uS 

    if (nntype == 1) { //sylee151117
        nTimeOutSet1 = SysSet19.m_nSet1;  //50mS 
        delay_time2 = 200;//  20uS 
    }
    else if (nntype == 2) {
        nTimeOutSet1 = SysSet19.m_nSet2;  //40mS 
        delay_time2 = 5000;//sylee210205   20uS-> 500uS 
    }
    else if (nntype == 3) {
        nTimeOutSet1 = SysSet19.m_nSet3;  //30mS 
        delay_time2 = 5000;//sylee210205   20uS-> 500uS 
    }
    else if (nntype == 4) {
        nTimeOutSet1 = SysSet19.m_nSet4;  //30mS 
        delay_time2 = 5000;//sylee210205   20uS-> 500uS 
    }
    else {
        nTimeOutSet1 = SysSet19.m_nSet4;  //30mS
        delay_time2 = 5000;//sylee210205   20uS-> 500uS 
    }

    if (nTimeOutSet1 < 1) {  //mS //sylee161026
        nTimeOutSet1 = 1;
    }
    if (nTimeOutSet1 > 300) {   //sylee161026
        nTimeOutSet1 = 300;
    }


   
	nTimeOutSet1 = nTimeOutSet1 * 10000;  //mS->100uS//sylee161026



    //============================================================================
    Sub71.Delay_100ns(delay_time2);
    TimeT1 = delay_time;
    tStart1 = GetuSecond();
    Sub71.AOnReadV1I1_ADC_I();
    tStart2 = GetuSecond();
    tStart3 = (tStart2 - tStart1) * 10;
    TimeT1 = TimeT1 + (long)(tStart3);
    //###################################################################
    nADFlag = 0;//sylee210205




    for (int nK1 = 1; nK1 < 500000; nK1++)
    {
        //sylee201204  DELETE CODE
        if ((nntype == 4) && (nK1 > 6) && (Sub71.R1 < 1000)) {//sylee200917 
            nADFlag = 1;//sylee210205
            nNo1 = 10;//sylee200917
            nADSum1 = 0.0;
            // ::ZeroMemory(&nAD, sizeof(nAD));
            for (int ik1 = 1; ik1 <= nNo1; ik1++) {
                Sub71.AOnReadV1I1_ADC_I();
                Sub71.Delay_100ns(5000); //500uS
               // nAD[ik1][0]=dIADC1;
                nADSum1 = nADSum1 + Sub71.R1;
            }
            Sub71.R1 = nADSum1 / nNo1;
        }
        else {
            nADFlag = 0;//sylee210205
            Sub71.AOnReadV1I1_ADC_I();
        }

        /////////////////////////////////////////////////////////////
        if (nFastHv1AdRun == 1 && nRunMode_HV_LV == 1) {//sylee150415 fasthv //SYLEE150417-5  1= HV, 2=LV
            if (nLVshortUse1 == 1) {//sylee150622   
                if (nK1 > 100) { //sylee150509  3->6  //SYLEE151109  5->100
                    if (Sub71.R1 > 50000) {
                        nFastHv1AdReturn = 1;
                        break;
                    }
                }
            }

            if (nK1 >= 1) {//sylee150415 fasthv //sylee150416
                if (nRValCo1 <= 3) {
                    nRValCo1++;
                }
                else {
                    nRValCo1 = 1;
                }
                nRVal[nRValCo1] = (int)Sub71.R1;
                nRVal[0] = (nRVal[1] + nRVal[2] + nRVal[3]) / 3;
            }
        }
        //////////////////////////////////////////////////////////////
        //sylee210201    tStart2=GetuSecond();//100nS//sylee201117
        //sylee210201   tStart3=(tStart2-tStart1)*10 ;//sylee201117
        if (nADFlag == 0) {//sylee210205
            TimeT1 = TimeT1 + (long)(tStart3);
        }
        else {
            TimeT1 = TimeT1 + (long)((tStart3 + 500) * 10); //sylee210205
        }

        if (nLoop1 < nLoopSet1) {
            nLoop1++;
        }
        else {
            nLoop1 = 1;
        }
        nBuf1[nLoop1] = (int)Sub71.R1;
        nBuf1Sum = 0;

        for (int i = 1; i <= nLoopSet1; i++) {
            nBuf1Sum = nBuf1Sum + nBuf1[i];
        }

        if (nK1 > 6) {
            Sub71.R1 = nBuf1Sum / nLoopSet1;//avg            
        }

        //log   bb[nK1]=Sub71.R1;//log
        if (nK1 != 1) {
            diff1 = (double)(nOldAdc1 - Sub71.R1);
            if (diff1 <= 0) diff1 = -diff1;
            nOldAdc1 = Sub71.R1;
        }

        double percent;
        percent = diff1 / nProRv1 * 100.;

        if (Sub71.R1 < 10) {//sylee201117
            Sub71.R1 = 99999;
        }
        //sylee200916   if( (diff1>=0  && diff1<10) && (Sub71.R1<nProRv1) ){//<=======    percent = diff1/nProRv1*100.
        if ((percent >= 0 && percent < 5) && (Sub71.R1 < nProRv1) && (nK1 > 6)) {//<pass//sylee200916 
            break;
        }
        /////////////////////////////////////////////////////// 
             //SYLEE201207 delete 
        ///////////////////////////////////////////////////////
        if (TimeT1 > nTimeOutSet1) {//sylee121005   5sec->1.5sec 
            break;
        }
        if ((TimeT1 > 800000) && (Sub71.R1 > 10000)) {//sylee121028   80msec 
            break;
        }

        Sub71.Delay_100ns(delay_time); //1ms
        TimeT1 = TimeT1 + delay_time;
    }

    /////////////////////////////////////////////////////////////////////////////
    /*

              FILE *fp;
              char  fName[200];
              CString ;
              ::ZeroMemory(&fName, sizeof(fName));
              strcat( fName , "d:\\01log.txt" );
              fp = fopen(fName,"wt");
              if(fp == NULL){
              AfxMessageBox(" Error No 2001 !\n\\SETUP\\SysSet01.ini.  file Data Saving Error !     file close!", MB_OK); //error messege
              return 0;
              }

              for( int i=1; i<nK1 ; i++){
              fprintf(fp, "%10d,\n",bb[i]);
              }
              fclose(fp);

   */

   //////////////////////////////////////////////////////////////////////////////

    return 1;


}


//SYLEE121108  BH125 MOVE

//int AHV_ADCI_Read1(double nProRv1 , int  nHVIADCFlag,  int nVRel) //sylee120919 
int  CChildView7::AHV_ADCI_Read1_Avg1(double nProRv1, double nTimeOutSet1, int nntype) //sylee121016
{

    int delay_time, delay_time2;
    long TimeT1;
    double nOldAdc1, diff1;
    __int64   tStart1, tStart2, tStart3;
    int nLoopSet1, nLoop1, nBuf1Sum, nAvg;
    int nBuf1[100];
    int nRVal[10];//sylee150415 fasthv
    int nRValCo1, Ret;//sylee150415 fasthv
    double nADSum1;//sylee200917
    int nNo1;//sylee200917
    int nADFlag;
	int nMoreCo1;//sylee230325
	int nCo2;  //sylee230325
	int nMin,nMax;
	int nADCCount1;//sylee240119
	int nADC1[7001];//sylee240119 
	int nDebugAD[3001];//sylee241226
	int nADCo1;//sylee241226

	nADCo1=0;//sylee241226
   ::ZeroMemory(&nDebugAD, sizeof(nDebugAD));//sylee241226

#if 0 //son240628 BH 고정 Short 문제때문에 sylee240507 원상복구  
	int nRefR2,	nADPassCo1,nOldR1 ;//sylee240507

	nRefR2=5000; //sylee240507
	nOldR1=60000; //sylee240507
#endif  //son240628

	nADCCount1=0;//sylee240119
	nMoreCo1=0;//sylee230325
    nOldAdc1 = 0;
    diff1 = 0;
    TimeT1 = 0;
    nLoop1 = 0;
    nBuf1Sum = 0;
    nAvg = 0;
    Sub71.R1 = 0.0;//sylee140823 
    ::ZeroMemory(&nBuf1, sizeof(nBuf1));
	::ZeroMemory(&nADC1, sizeof(nADC1));//sylee240119 
 
    ////////////////////////////////////////////////////////////////////
    if (nFastHv1AdRun == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nRVal, sizeof(nRVal));
        nRValCo1 = 0;
        nFastHv1AdReturn = 0;
    }


    ////////////////////////////////////////////////////////////////////
    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
    {
        Ret = Sub71.OnSparkStatus(); //sparktest     
        if (Ret == 1) { //sparktest 
            Sub71.OnSparkOn(0);
            Sub71.Delay_100ns(10000);
            Sub71.OnSparkOn(1);
        }
        //hdpark240116 waiting시 spark 검출, spark detecting voltage 재설정
        double dSetVolt = nSparkHWoffSet1 + nSparkRefV + 5;
        SetSparkDetectionVolt(dSetVolt, FALSE); // FALSE : 적용 안함
        nSpark1_Detect2 = 0;
    }
    nLoopSet1 = 6;
    delay_time = 200;//20us
    if (nntype == 1) { //sylee151117
        nTimeOutSet1 = SysSet19.m_nSet5;  //50mS 
        delay_time2 = 200;//20us
    }
    else if (nntype == 2) {
        nTimeOutSet1 = SysSet19.m_nSet9;  //40mS 
        delay_time2 = 10000;//1mS //sylee210205 
    }
    else if (nntype == 3) {
        nTimeOutSet1 = SysSet19.m_nSet21;  //30mS   
        delay_time2 = 10000;//1mS //sylee210205 
    }
    else if (nntype == 4) {
        nTimeOutSet1 = SysSet19.m_nSet22;  //30mS  
        delay_time2 = 10000;//1mS //sylee210205 
    }
    else {
        nTimeOutSet1 = SysSet16.m_nSet12;  //30mS  
        delay_time2 = 10000;//1mS //sylee210205 
    }

    if (nTimeOutSet1 < 1) {  //mS //sylee161026
        nTimeOutSet1 = 1;
    }
    if (nTimeOutSet1 > 300) {   //sylee161026
        nTimeOutSet1 = 300;
    }

	if(nLeakNearLimit>2){
		nLeakNearFlag1=0;		
	}//sylee241226

	if( nLeakNearFlag1==1 ){  //sylee241226
		nLeakNearLimit++;//sylee241226
		nTimeOutSet1 = 3000;  //3sec        
	}
    nTimeOutSet1 = nTimeOutSet1 * 10000;  //mS->100uS//sylee161026 

    //=====================================================================
    Sub71.Delay_100ns(delay_time2);
   //sylee230814  TimeT1 = delay_time;
    tStart1 = GetuSecond();
   //sylee230814   Sub71.AOnReadV1I1_ADC_I();
   //sylee230814  tStart2 = GetuSecond();
   //sylee230814  tStart3 = (tStart2 - tStart1) * 10;
   //sylee230814 TimeT1 = TimeT1 + (long)(tStart3);

#if 0		// hdpark240116 추후 주석 처리 예정
    if (SysSet13.m_nSparkMode == SPARK_NEW) //son200908 NEW_SPARK
    {
        //if  spark on
        if (SysSet19.m_nSet12 != 1) {//SYLEE201024-1  //SPARK NEW BOARD 
            if (g_nSpark1_Use == 1) {//SYLEE200721 
                Sub71.AOn_Spark_Wait_ReadV1_I1_init();//SYLEE200721
            }
        }
        nSpark1Po1_Start = 0;
        nSpark1_Detect2 = 0;//sylee200721
        nSpark1_Detect2Co = 0;
    }
#endif

    //###################################################################
    nADFlag = 0;//sylee210205
	Sub71.AOnReadV1I1_ADC_I();	//sylee230830
	//son240628 nADPassCo1=0;//sylee240408 //son240628 BH 고정 Short 문제 때문에 sylee240408 원상복구

    for (int nK1 = 1; nK1 < 500000; nK1++)
    {
     //sylee201204  DELETE CODE	
 	 //sylee230830-1 if ((nntype == 4) && (nK1 > 6) && (Sub71.R1 < 1000)) { //sylee230830-1 //sylee200917 // point  to point  measure  :  eject  noise
 	 //sylee230829	if (  Sub71.R1 < 70000 ) { //sylee230815 

	     if (  (nK1 > 6) && (Sub71.R1 < 1000)) {	 //sylee230829  ==>OK   //OK  NEW2 //SYLEE230829   
            nADFlag = 1;//sylee210205
           //sylee230830  nNo1 = 10;//sylee200917
			if( nLeakADhigh1==1 ){//sylee230907
				nNo1 = 2;//sylee200917
			}else{
		        nNo1 = 1;//sylee230830    //sylee230907  3->1 
			}
            nADSum1 = 0.0;			
			nCo2=0;//sylee230325



Task100:  //sylee230325

		     //sylee230814	Sub71.AOnReadV1I1_ADC_I();	
            for (int ik1 = 1; ik1 <= nNo1; ik1++) { 
                Sub71.AOnReadV1I1_ADC_I();

				if( nLeakNearFlag1==1 ){  //sylee241226
					Sub71.Delay_100ns(200000);  //20ms 
					nADCo1++;//sylee241226
					nDebugAD[nADCo1]= Sub71.R1;//sylee241226
				}

				if( ik1 == 1 ){     nMin=Sub71.R1;	 nMax=Sub71.R1;	} //sylee230814 
				else{
					if( nMin>Sub71.R1) nMin=Sub71.R1; //sylee230814 
					if( nMax<Sub71.R1) nMax=Sub71.R1; //sylee230814 
				}            

				if( nLeakADhigh1==1 ){//sylee230907
				    Sub71.Delay_100ns(2000); //200uS
				} 
                // nAD[ik1][0]=dIADC1;
                nADSum1 = nADSum1 + Sub71.R1;
            }
          //sylee230814  Sub71.R1 = nADSum1 / nNo1;

			if(nNo1>=3){
			   Sub71.R1 = (nADSum1-nMin-nMax)/ (nNo1-2);
			}
			
			if(nADCCount1<7000){ 	nADCCount1++;	nADC1[nADCCount1]=(int)Sub71.R1 ; } //sylee240119		
			
			if(Sub71.R1<2){	 //sylee230325     
				if(nCo2++<20){//sylee230325
					nK1++;
					goto Task100;
				} 
			}

        }
        else {

            nADFlag = 0;//sylee210205
			nCo2=0;//sylee230325

Task200:  //sylee230325

			Sub71.AOnReadV1I1_ADC_I();	

			if(nADCCount1<7000){ 	nADCCount1++;	nADC1[nADCCount1]=(int)Sub71.R1 ; } //sylee240119
			
			if(Sub71.R1<2){	 //sylee230325     
		    	if(nCo2++<20){//sylee230325			 
					nK1++;
					goto Task200;
				} 
			}
        }
 
        /////////////////////////////////////////////////////////////

        if (nFastHv1AdRun == 1 && nRunMode_HV_LV == 1) {//sylee150415 fasthv //SYLEE150417-5  1= HV, 2=LV
            if (nLVshortUse1 == 1) {//sylee150622   
                if (nK1 > 100) { //sylee150509  3->6  //SYLEE151109  5->100
                    if (Sub71.R1 > 50000) {
                        nFastHv1AdReturn = 1;
                         break;
                    }
                }
            }

            if (nK1 >= 1) {//sylee150415 fasthv //sylee150416
                if (nRValCo1 <= 3) {
                    nRValCo1++;
                }
                else {
                    nRValCo1 = 1;
                }
                nRVal[nRValCo1] = (int)Sub71.R1;
                nRVal[0] = (nRVal[1] + nRVal[2] + nRVal[3]) / 3;
            }

        }
     //////////////////////////////////////////////////////////////
     //sylee210201   tStart2=GetuSecond();//100nS//sylee201117
     //sylee210201   tStart3=(tStart2-tStart1)*10 ;//sylee201117
     //sylee230814   if (nADFlag == 0) {//sylee210205
		tStart2 = GetuSecond();//sylee230814 
        tStart3 = (tStart2 - tStart1) * 10;//sylee230814 
        TimeT1 =   (long)(tStart3);//sylee230814 
     //sylee230814     TimeT1 = TimeT1 + (long)(tStart3);
     //sylee230814   }
     //sylee230814    else {
     //sylee230814       TimeT1 = TimeT1 + (long)((tStart3 + 500) * 10); //sylee210205
     //sylee230814   }
        if (nLoop1 < nLoopSet1) {
            nLoop1++;
        }
        else {
            nLoop1 = 1;
        }
        nBuf1[nLoop1] = (int)Sub71.R1;
        nBuf1Sum = 0;
        for (int i = 1; i <= nLoopSet1; i++) {
            nBuf1Sum = nBuf1Sum + nBuf1[i];
        }
        if (nK1 > 6) {
            Sub71.R1 = nBuf1Sum / nLoopSet1;//avg            
        }
        //log   bb[nK1]=Sub71.R1;//log
        if (nK1 != 1) {
            diff1 = (double)(nOldAdc1 - Sub71.R1);
            if (diff1 <= 0) diff1 = -diff1;
            nOldAdc1 = Sub71.R1;
        }
        double percent;
        percent = diff1 / nProRv1 * 100.;
        if (Sub71.R1 < 10) {//sylee201117
            Sub71.R1 = 99999;
        }
        //sylee200916   if( (diff1>=0  && diff1<10) && (Sub71.R1<nProRv1) ){//<=======    percent = diff1/nProRv1*100.
        if ((percent >= 0 && percent < 5) && (Sub71.R1 < nProRv1) && (nK1 > 10)) {//<pass//sylee200916 //sylee230814  6->10
            break;
        }
/*      // hdpark230712 측정 시간이 너무 많이 걸리므로 삭제.
		if(TimeT1>nTimeOutSet1){ //sylee230325
			 if((Sub71.R1-nProRv1)<100){	 
                 if( (nMoreCo1++)<500){ //sylee230325
					continue;
				 }
			  }
		  }
 */


#ifdef __BH__CUSTOMER  //sylee240614-1   BH고객사 우선 적용 
        //son SST의 BH용 생산장비 190M Short 불량 다발 현상때문에 추가됨. 
		if(TimeT1>nTimeOutSet1){ //sylee230325           //sylee240614-1
			if(Sub71.R1> nProRv1){//sylee241226-2
			    if( nLeakNearFlag1!=1 ){  //sylee241226
					if((Sub71.R1-nProRv1)<100){	                 //sylee240614-1
						 if( (nMoreCo1++)<500){ //sylee230325    //sylee240614-1
							continue;                            //sylee240614-1
						 }                                       
					}
				}
			}
		  }
#endif

//#############################################################################
#if 0  //son240628 BH 고정 Short 문제 때문에 sylee240517 원상복구
//sylee240507	 
		if( (Sub71.R1>nProRv1)  && (Sub71.R1<=nRefR2) &&  ( abs(nOldR1-Sub71.R1)< (Sub71.R1*0.03) )  ){ //sylee240507
		      nADPassCo1++; //sylee240507             
		}else{
			  nADPassCo1=0;//sylee240507		 
		}
		nOldR1=Sub71.R1; //sylee240507
	    if(Sub71.R1>nProRv1){	
			if( nADPassCo1>5){ //sylee240507
				break;
			}
		}
#endif //son240628
//############################################################################# 
    
        ///////////////////////////////////////////////////////
        if (TimeT1 > nTimeOutSet1) {//sylee121005   5sec->1.5sec   100nS        
            break;
        }
        if (  (TimeT1 > 800000) && (Sub71.R1 > 10000) &&( nK1>100) ) {//sylee121028   80msec  //sylee230325   &&( nK1>100)
            break;
        }

	 	if(  (TimeT1>30000)&& (Sub71.R1>65000) &&( nK1>100) ){//sylee230325   
			if(nntype==1){ 
        	     break;
			 }
		}

        //son NEW_SPARK 
        if (SysSet13.m_nSparkMode == SPARK_NEW)   //son200908 NEW_SPARK  //sylee201204
        {
            if (SysSet19.m_nSet12 != 1) {//SYLEE201024-1  //SPARK NEW BOARD 
                if (nSparkV1Po1 >= nSparkMaxX) {//sylee200804 
                    Sub71.Delay_100ns(delay_time); //20uS
                }
            }
        }
        else 
            Sub71.Delay_100ns(delay_time); //1ms	 
           //sylee2341226 TimeT1 = TimeT1 + delay_time;
 
    }

    /////////////////////////////////////////////////////////////////////////////
  /*
           FILE *fp;
           char  fName[200];
           CString ;
           ::ZeroMemory(&fName, sizeof(fName));
           strcat( fName , "d:\\01log.txt" );
           fp = fopen(fName,"wt");
           if(fp == NULL){
           AfxMessageBox(" Error No 2001 !\n\\SETUP\\SysSet01.ini.  file Data Saving Error !     file close!", MB_OK); //error messege
			return 0;
           }
           for( int i=1; i<nK1 ; i++){
			fprintf(fp, "%10d,\n",bb[i]);
           }
           fclose(fp);
*/

	if(nLeakADCPer1>0){ //sylee230822
		if( nLeakMode1== TEST_LEAK1 ){ //sylee230822
			if( Sub71.R1 <=nLeak1ADC_100M){
				Sub71.R1=Sub71.R1*(1.0+(nLeakADCPer1/100.)); 
			}
		}else if( nLeakMode1== TEST_LEAK2 ){ //sylee230822
			if( Sub71.R1 <=nLeak2ADC_100M){
				Sub71.R1=Sub71.R1*(1.0+(nLeakADCPer1/100.)); 
			}
		}
	}

    //////////////////////////////////////////////////////////////////////////////
    //hdpark240116 waiting 이 끝나면 다시 핀등록 설정으로 spark detection volt 원복시킴
    double dSetVolt = nSparkHWoffSet1 + nSparkRefV;
    SetSparkDetectionVolt(dSetVolt, FALSE); // FALSE : 적용 안함.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//sylee240119 
    FILE *fp; 
    CFile file;
    CString str;  
    char fName[200]; 
    int nSum1,nMin1,nMax1,nError1;
    float dAver1,dError1Rate;

    if( SysSet19.m_nSet14 == 1) { //sylee240119 
        nADC1[0]=Sub71.R1;    
        ::ZeroMemory(&fName, sizeof(fName));
        str.Format("d:\\log\\LeakADC.csv");
        strcat( fName , str );//sylee240116-1
        fp = fopen(fName,"at");
        if(fp == NULL){ 
            str.Format("   0LEAK-ADC.CSV      file Data Saving Error !     file close!.");   AfxMessageBox(str, MB_OK);
            return  0;
        }  
        nLeakADCCo1++;//sylee240119 
        //=========================================================================================
        nSum1=0;  nMin1=999999, nMax1=0, dAver1=0.0;  dError1Rate=0.0;
        for(int i=nADCCount1; i>(nADCCount1-5); i--){	
            nSum1=nSum1+nADC1[i];
            if(nMin1>nADC1[i])nMin1= nADC1[i];
            if(nMax1<nADC1[i])nMax1= nADC1[i];
        }
        dAver1=nSum1/5.0;
        nError1=nMax1-nMin1;
        dError1Rate=nError1/dAver1*100.0;
        fprintf(fp, " %.2f , %.2f, %d  ,%d  ,%d  , #%d, ,",dError1Rate, dAver1,nError1,nMax1,nMin1 ,nLeakADCCo1  );   
        //=========================================================================================

        for( i=nADCCount1; i>(nADCCount1-10); i--){
            if(i<1) continue; //sylee240119
            fprintf(fp, " %d  ,",nADC1[i]);   
        }
        fprintf(fp," \n"  );  	fclose(fp);

    }
//================================================================================

//##################################################################################


if( nLeakNearFlag1==1 ){  //sylee241226
    CTime curTime = CTime::GetCurrentTime(); //sylee241226
	::ZeroMemory(&fName, sizeof(fName));
	str.Format("d:\\log\\0LeakNearError_%02dY%02dM02dD_%02dH.csv",curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour());
	strcat( fName , str );//sylee240116-1
	fp = fopen(fName,"at");
	if(fp == NULL){ //sylee241226
		str.Format("   d:\\log\\0LeakNearError.csv     file Data Saving Error !     file close!.");   AfxMessageBox(str, MB_OK);		 
	}else{ 
		fprintf(fp, " %02dY,%02dM,%02dD,_%02dH,%02dM,%02dS ,  ,",curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(),curTime.GetMinute(),curTime.GetSecond() ); 		
     	fprintf(fp, "    , *Tcount=,%05d  , ,*mSec=  ,%05d  ,  ,",nADCo1,  nADCo1*20 ); 
     	fprintf(fp, "    , *PinA=,%05d  , ,*PinB=  ,%05d  ,  ,",nLeakNearPin1,  nLeakNearPin2 ); 
     	fprintf(fp, "    ,  ,*Last ADC =,%05d  , ,   ,",nDebugAD[nADCo1] );  
	
		for( int i=1; i<=nADCo1 ; i++){ 
			fprintf(fp, " %d  ,",nDebugAD[i]); //sylee241226  
		}
		fprintf(fp," \n"  );  	fclose(fp);
	}

}

//##################################################################################


     return 1;

}


 
int  CChildView7::AHV_ADCI_Read1_Avg2()  //sylee230811
{

	int nNo1, nADSum1;
	int nMax1;
	int nADC1[1001];//sylee230814-log
	int nADC1Po1;//sylee230814-log
	int nMin,nMax;
//	 FILE *fp;

    ::ZeroMemory(&nADC1, sizeof(nADC1));//sylee230814-log
	nADC1Po1=0;//sylee230814-log
    nNo1 = 20;//sylee200917
    nADSum1 = 0.0;   
    Sub71.Delay_100ns(100000); //10ms
	nMax1=0;

	for (int ik1 = 1; ik1 <= nNo1; ik1++) {

            Sub71.AOnReadV1I1_ADC_I();

			if( ik1 == 1 ) {  nMin=Sub71.R1;  nMax=Sub71.R1;  }//sylee230814
			else{
				if(nMin>Sub71.R1)  nMin=Sub71.R1;//sylee230814
				if(nMax<Sub71.R1)  nMax=Sub71.R1;//sylee230814
			}            
			Sub71.Delay_100ns(5000); //500uS          
            nADSum1 = nADSum1 + Sub71.R1;
			if( Sub71.R1>nMax1){
				nMax1=Sub71.R1;
			}
			nADC1Po1++;//sylee230814-log
			nADC1[nADC1Po1]=Sub71.R1;//sylee230814-log
	}
   //sylee230814  Sub71.R1 = nADSum1 / nNo1;
	 Sub71.R1 = (nADSum1-nMin-nMax) / (nNo1-2);//sylee230814 

//==============================================================================

  /*  str.Format("d:\\0debug.csv"); 
    ::ZeroMemory(&fName, sizeof(fName));
    strcat( fName , str );

    fp = fopen(fName,"at");
    if(fp == NULL){         
    }else{ 
		for(int i=1; i<=nNo1; i++){   
			fprintf(fp, "    %5d,  ", nADC1[i]  );
		}
		fprintf(fp, "  \n");
		fclose(fp);
	}
	*/
//==============================================================================


if(nLeakADCPer1>0){ //sylee230822
	if( nLeakMode1== TEST_LEAK1 ){ //sylee230822
		if( Sub71.R1 <=nLeak1ADC_100M){
			Sub71.R1=Sub71.R1*(1.0+(nLeakADCPer1/100.)); 
		}
	}else if( nLeakMode1== TEST_LEAK2 ){ //sylee230822
		if( Sub71.R1 <=nLeak2ADC_100M){
			Sub71.R1=Sub71.R1*(1.0+(nLeakADCPer1/100.)); 
		}
	}
}
 
    return 1;


}




int dEtADC[700];  //estmation start
float dEtADCTime[700];
float dEtADC_Avg[500][700];
float dEtADCTime_Avg[500][700];

int dEtADC_HR[700];  //estmation  //SYLEE150407
float dEtADCTime_HR[700];  //estmation  //SYLEE150407
float dEtADC_Avg_HR[500][700];  //estmation  //SYLEE150407
float dEtADCTime_Avg_HR[500][700]; //estmation  //SYLEE150407


int  CChildView7::AHV_ADCI_Read1_EST1(double nProRv1, double nTimeOutSet1) //sylee121016 //estimation
{

    if (nFlagEstModelMake == 1 && nFlagEstModelMakeSelect == 2) {
        nFastHv1AdRun = 0;//sylee150415 fasthv
        if (nAHV_EST1_MODEL_TYPE1 == 2) {//sylee150615
            nAHV_EST1_MODEL_TYPE2 = 2;//sylee150615
        }
        else {
            nAHV_EST1_MODEL_TYPE2 = 1;//sylee150615
        }
        AHV_EST1_MODEL(nProRv1, 2); //MODEL//sylee130325
    }
    else if (nFlagEstModelMake == 3) {
        AHV_EST1_RUN_1(nProRv1, 1); //run//sylee130325
    }

    return 1;
}



int  CChildView7::AHV_EST1_SET1()  //estimation
{

    int a;

    a = FileSysInfo01.LoadSaveSet16(2);//load 
    if (a != 1) {
        AfxMessageBox(" Error No 1212, \n\n  SysSet16.ini  Load ERROR !  \n    file Read Error !!!\n\n  Process Parametor set error!.  \n\n ");
        return 0;
    }

    if (SysSet16.m_nSet12 == 1) {
        nEtFileLog = 1;//1=logging  0=not use
    }
    else {
        nEtFileLog = 0;//1=logging  0=not use
    }


    // nEtFileLog=1;//1=logging  0=not use  
    if (SysSet16.m_nSet1 > 0) {//sampling time
        nEtSamplingTime = (int)(SysSet16.m_nSet1);// 1000uS   ;
    }
    else {
        nEtSamplingTime = (int)(0);// 1000uS   ex(20*10)=20us     ex (5*10)=5uS ,   (unit 100nS)
    }
    dEtPer1 = nEtSamplingTime / 1000000.;//sylee130118

    if (SysSet16.m_nSet2 > 0) {   //start adc
        dEtADCSTart = SysSet16.m_nSet2;
    }
    else {
        dEtADCSTart = 1000;
    }

    if (SysSet16.m_nSet3 > 0) {   //Weight  B 
        Weight_B = SysSet16.m_nSet3 / 100.;
    }
    else {
        Weight_B = 0.0;//30% variation
    }


    if (SysSet16.m_nSet4 > 0) {    //Weight  C 
        Weight_C = SysSet16.m_nSet4 / 100.;
    }
    else {
        Weight_C = 0.0;//30% variation
    }


    if (SysSet16.m_nSet6 > 0) {   //Endtime
        dEt_EndTime1 = SysSet16.m_nSet6;
    }
    else {
        dEt_EndTime1 = 1; //time sec    data count=100
    }

    dEt_LastPer1 = SysSet16.m_nSet6 / 100.;
    if (SysSet16.m_nSet8 != 0) {   //offset
        dEtEndOffSet1 = 1 + (SysSet16.m_nSet8 / 100.);
    }
    else {
        dEtEndOffSet1 = 1;
    }
    if (SysSet16.m_nSet9 > 0) {
        nInter1 = SysSet16.m_nSet9;
    }
    else {
        nInter1 = 0;
    }
    if (SysSet16.m_nSet5 >= 0) {   //offset
        nEtCount1 = SysSet16.m_nSet5;
    }
    else {
        nEtCount1 = 0;
    }

    nFileLoop = nInter1; //step count

    return 1;


}





//data 6   //sylee130130
int  CChildView7::AHV_EST1_RUN_1(double nProRv1, int nType1) // 1= run ,    //estimation
{

    //SYLEE130329   FILE *fp; 
    CString  str, str2;

    double diff1, nOldAdc1, dPerTime1, dADC_End1, dADC_End1St;//,dEtT_ADC[10][5];
    __int64 TimeT1, TimeT2, tStartOld1, nStartNoStep, tStart1;

    int nK, nStartFlag, nStartNo, nTStep1;
    int nDetailLog1, nDetailLog2;
    int nLoopSet1, nBuf1Sum, nLoop1, nBuf1[100];

    int nRVal[10];//sylee150415 fasthv
    int nRValCo1;//sylee150415 fasthv

    double nCSetCo;//sylee150610-1  100->10


    nCSetCo = 10.0;//sylee150610-1  100->10

    nStartFlag = 0;   nTStep1 = 0;       nStartNoStep = 0;
    nOldAdc1 = 0.;    dPerTime1 = 0.;    dADC_End1 = 0.;
    TimeT1 = 0;       TimeT2 = 0;        nBuf1Sum = 0;       nLoop1 = 0;

    if (nFileCount == 0) {//sylee130329
        ::ZeroMemory(&dEtT_ADC, sizeof(dEtT_ADC));
    }

    ::ZeroMemory(&nBuf1, sizeof(nBuf1));


    ////////////////////////////////////////////////////////////////////
    if (nFastHv1AdRun == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nRVal, sizeof(nRVal));
        nRValCo1 = 0;
        nFastHv1AdReturn = 0;
    }
    ////////////////////////////////////////////////////////////////////


    nLoopSet1 = 20;

    //sylee150614   nTimeOutSet1=5000000;   nK 463
    nTimeOutSet1 = 10000000; //100mS

    nDetailLog1 = 0;   nDetailLog2 = 1;
    nFileCount++;

    tStartOld1 = Get_uSecond1();//uS   // start time

    tStart5002 = Get_uSecond1();//uS   //sylee150509-1
    tStart5003 = tStart5002 - tStart5001;//uS   //sylee150509-1

    for (nK = 1; nK <= 30000; nK++) {

        Sub71.AOnReadV1I1_ADC_I();


        tStart5002 = Get_uSecond1();//uS   //sylee150509-1
        tStart5003 = tStart5002 - tStart5001;//uS   //sylee150509-1


        ///////////////////////////////////////////////////////////// 
        if (nFastHv1AdRun == 1 && nRunMode_HV_LV == 1) {//sylee150415 fasthv //SYLEE150417-6  1= HV, 2=LV


            if (nLVshortUse1 == 1) {//sylee150622    
                if (nK > 100) {//sylee150520  //SYLEE150605  10  //sylee151109
                    if (Sub71.R1 > 50000) {
                        nFastHv1AdReturn = 1;
                        break;
                    }
                }
            }

            if (nK >= 1) {//sylee150415 fasthv //sylee150416
                if (nRValCo1 <= 3) {
                    nRValCo1++;
                }
                else {
                    nRValCo1 = 1;
                }
                nRVal[nRValCo1] = (int)Sub71.R1;
                nRVal[0] = (nRVal[1] + nRVal[2] + nRVal[3]) / 3;
            }


        }
        //////////////////////////////////////////////////////////////


        if (nLoop1 < nLoopSet1) {
            nLoop1++;
        }
        else {
            nLoop1 = 1;
        }
        nBuf1[nLoop1] = (int)Sub71.R1;
        nBuf1Sum = 0;
        for (int i = 1; i <= nLoopSet1; i++) {
            nBuf1Sum = nBuf1Sum + nBuf1[i];
        }

        if (nK > nLoopSet1) {
            Sub71.R1 = nBuf1Sum / nLoopSet1;//avg
        }
        else {
            Sub71.R1 = nBuf1Sum / nK;//avg
        }

        diff1 = (double)(nOldAdc1 - Sub71.R1);
        if (diff1 <= 0) diff1 = -diff1;
        nOldAdc1 = Sub71.R1;

        tStart1 = Get_uSecond1();//uS   // start time

        if (nStartFlag == 0) {
            if (nK > 10) {
                if (Sub71.R1 <= dEtADCSTart) {
                    nStartFlag = 1;
                    nStartNo = nK;
                }
            }
            TimeT1 = TimeT1 + (tStart1 - tStartOld1);
            tStartOld1 = tStart1;
        }
        else {
            TimeT2 = TimeT2 + (tStart1 - tStartOld1);
            TimeT1 = TimeT1 + TimeT2;//?
            tStartOld1 = tStart1;
        }

        if (nStartFlag != 2) {
            if ((dEsModel[nFileCount][3] <= 0) || (dEsModel[nFileCount][4] <= 0) || (dEsModel[nFileCount][5] <= 0)) {//sylee130410
                nTStep1 = 2;
                dEtT_ADC[nFileCount][2][3] = 2;
                nStartFlag = 2;
            }
        }


        if (nStartFlag == 1) {//start        

            dPerTime1 = (double)(TimeT2 / 1000000.);
            nStartNoStep = nK - nStartNo + 1;

            if (nTStep1 == 0) {
                if (dPerTime1 > (dEsModel[nFileCount][6] * 0.5)) {
                    dEtT_ADC[nFileCount][1][4] = (float)nStartNoStep;
                    dADC_End1 = dEsModel[nFileCount][3] * exp(-dEsModel[nFileCount][4] * (1. - Weight_B) * (dPerTime1)) + dEsModel[nFileCount][5] * (1. + Weight_C);
                    dADC_End1St = dEsModel[nFileCount][3] * exp(-dEsModel[nFileCount][4] * (dPerTime1)) + dEsModel[nFileCount][5];
                    nTStep1 = 1;
                    dEtT_ADC[nFileCount][1][0] = (float)dPerTime1; dEtT_ADC[nFileCount][1][1] = (float)Sub71.R1;
                    dEtT_ADC[nFileCount][1][2] = (float)dADC_End1; dEtT_ADC[nFileCount][1][6] = (float)dADC_End1St;


                    if (Sub71.R1 < dADC_End1) {//pass
                        dEtT_ADC[nFileCount][1][3] = 1;
                    }
                    else {//fail
                        dEtT_ADC[nFileCount][1][3] = 2;
                    }
                }
            }
            else if (nTStep1 == 1) {
                if (dPerTime1 > dEsModel[nFileCount][6]) {
                    dEtT_ADC[nFileCount][2][4] = (float)nStartNoStep;//sylee130326   []->[2]
                    dADC_End1 = dEsModel[nFileCount][3] * exp(-dEsModel[nFileCount][4] * (1. - Weight_B) * (dPerTime1)) + dEsModel[nFileCount][5] * (1. + Weight_C);
                    dADC_End1St = dEsModel[nFileCount][3] * exp(-dEsModel[nFileCount][4] * (dPerTime1)) + dEsModel[nFileCount][5];
                    nTStep1 = 2;  dEtT_ADC[nFileCount][2][0] = (float)dPerTime1; dEtT_ADC[nFileCount][2][1] = (float)Sub71.R1;
                    dEtT_ADC[nFileCount][2][2] = (float)dADC_End1;    dEtT_ADC[nFileCount][2][6] = (float)dADC_End1St;

                    if (Sub71.R1 < dADC_End1) {//pass
                        dEtT_ADC[nFileCount][2][3] = 1;
                    }
                    else {//fail
                        dEtT_ADC[nFileCount][2][3] = 2;
                    }
                    if (dEtT_ADC[nFileCount][1][3] == 1 && dEtT_ADC[nFileCount][2][3] == 1) {//pass
                        Sub71.R1 = 10.0;
                        break;
                    }

                }

            }

        }//end of if(nStartFlag==1){


        if (((diff1 >= 0 && diff1 < 10) && (Sub71.R1 <= nProRv1))) {  //pass
            break;
        }
        if (TimeT1 > nTimeOutSet1) {//  time out fail
            break;
        }
        if ((TimeT1 > 800000) && (Sub71.R1 > 10000)) {//sylee121028   80msec   short fail
            break;
        }
        //}

    } //end of for(int nK=1; nK<=nFileLoop; nK++){ 



    return 1;

}

//data 6   //sylee130130
int  CChildView7::AHV_EST1_MODEL(double nProRv1, int nType1) // 1= run ,  2=model  //estimation
{
    FILE* fp, * fp2, * fp3, * fp4, * fp5, * fp6, * fp7;
    CString  str, str2, str3;

    __int64   tStart1, tStart2, tStart3, Sum1, TimeT1; //sylee20111013-2 

    int  nBuf1[100], nTi1[3000];//sylee150609

    int nStartFlag, nStartNo, nStartNoStep;
    int dTime2, nPass, nADCResult, nLoop1, nBuf1Sum, nAvg;
    int dEtCo1, dEtSelFlag1, dEtCo11, nRunFlag1, nDateFlag1;
    int nSumC, nHalfTime1, Et_EndTime;
    int logTo2, GetCount, nLoopSet1, nFileDetaillog;
    int nFile1, nFile2, nFile3, nFile4, nFile5, nModelFlag;

    double dEtADC21[2000], dEtADC2[2000], dEtADC3[2000];
    double dEtModel[2000][15];

    double dPerTime1, dADC_End1, dADC_Model1, dADC_Model2, dADC_Model3, dADC_Half1;
    double dEt_A, dEt_B, dEt_C, dEt_ADC1, dEt_ADC2, dEt_ADC3;
    double nOldAdc1, diff1, dSumC, dFirstHalf1, dTime1;
    double dAvg1, dStDev1, dStDevPer, dMin, dMax, dMinPer, dMaxPer, dAvg1Time;
    double dSinMa1, dSinMa2;
    double nCSetCo;//sylee150610-1  100->10 

    nCSetCo = 10.0;//sylee150614   10->50 

    dEt_A = 0;           dEt_B = 0;            dEt_C = 0;            nFileDetaillog = 0;
    dEtCo1 = 0;          dEtSelFlag1 = 0;      dTime1 = 0;           dTime2 = 0;
    nOldAdc1 = 0;        diff1 = 0;            TimeT1 = 0;
    nLoop1 = 0;          nBuf1Sum = 0;         nAvg = 0;             nSumC = 0;
    dEt_ADC1 = 0;        dEt_ADC2 = 0;         dEt_ADC3 = 0;
    dEtCo11 = 0;         nHalfTime1 = 0;       dFirstHalf1 = 0.0;    dSumC = 0.0;
    nPass = 0;           nADCResult = 0;       Et_EndTime = 0;
    nRunFlag1 = 0;       nDateFlag1 = 0;       Sum1 = 0;             nStartFlag = 0;
    nStartNo = 0;        nStartNoStep = 0;     dADC_End1 = 0.0;      nModelFlag = 0;

    nFile1 = 1;          nFile2 = 1;           nFile3 = 1;
    nFile4 = 1;          nFile5 = 1;

    ::ZeroMemory(&dEtADC2, sizeof(dEtADC2));    ::ZeroMemory(&dEtADC3, sizeof(dEtADC3));
    ::ZeroMemory(&dEtADC, sizeof(dEtADC));      ::ZeroMemory(&dEtADCTime, sizeof(dEtADCTime));
    ::ZeroMemory(&dEtModel, sizeof(dEtModel));
    ::ZeroMemory(&nBuf1, sizeof(nBuf1));
    ::ZeroMemory(&nTi1, sizeof(nTi1));    //nTi1[6][3000];//sylee150609

    nLoopSet1 = 20;

    nTimeOutSet1 = 50000;

    logTo2 = 2;

    if (SysSet16.m_nSet9 >= 5 && SysSet16.m_nSet9 <= 10) { //sylee130325
        GetCount = SysSet16.m_nSet9;//sylee130325
    }
    else {
        GetCount = 5;//sylee130325
    }
    GetCount = 3;//test//sylee150605  kunshan

    CString str5;
    str5.Format("d:\\Log\\");///estimation
    _mkdir((char*)(LPCTSTR(str5)));

    str5.Format("%s\\Model\\", (SysInfoView01).m_pStrFileDri1);///estimation
    _mkdir((char*)(LPCTSTR(str5)));


    CTime curTime = CTime::GetCurrentTime();


    if ((nEt_LogCount >= GetCount) && ((nFileCount + 1) == nEt_StepSum)) {//sylee150509
        if (SysSet16.m_nSet11 == 1 && nFile5 == 1) {//sylee130408  12->11
            //str.Format("d:\\log\\Model.txt");
            ::ZeroMemory(&dEtADC_Avg, sizeof(dEtADC_Avg));
            ::ZeroMemory(&dEtADCTime_Avg, sizeof(dEtADCTime_Avg));
        }
    }

    nHalfTime1 = 0;         nSumC = 0;
    nEtFileLog = 1;
    nFileCount++;

    int nnn;

    nnn = 0;

    for (int nK = 1; nK <= 30000; nK++)
    {


    Task1000:



        nnn++;


        Sub71.AOnReadV1I1_ADC_I();

        if (nnn < 2) {
            goto Task1000;
        }
        else {
            nnn = 0;
        }

        if (nLoop1 < nLoopSet1) {
            nLoop1++;
        }
        else {
            nLoop1 = 1;
        }

        nBuf1[nLoop1] = (int)Sub71.R1;
        nBuf1Sum = 0;
        for (int i = 1; i <= nLoopSet1; i++) {
            nBuf1Sum = nBuf1Sum + nBuf1[i];
        }

        if (nK > nLoopSet1) {
            Sub71.R1 = nBuf1Sum / nLoopSet1;//avg
        }
        else {
            Sub71.R1 = nBuf1Sum / nK;//avg
        }

        diff1 = (double)(nOldAdc1 - Sub71.R1);
        if (diff1 <= 0) diff1 = -diff1;
        nOldAdc1 = Sub71.R1;


        if (nStartFlag == 0) {
            if (nK > 10) {
                if (Sub71.R1 <= dEtADCSTart) {
                    nStartFlag = 1;
                    nStartNo = nK;
                    tStart1 = Get_uSecond1();//uS   // start time
                }
            }
        }


        if (nStartFlag == 1) {//start

            if (nType1 == 1) {
                if (Sub71.R1 <= nProRv1) {
                    nStartFlag = 3;// int pass
                        //fclose(fp);
                    break;
                }
            }

            nStartNoStep = nK - nStartNo + 1;

            if (nStartNoStep < 5000) {
                dEtADC[nStartNoStep] = (int)Sub71.R1;
            }
            if (nStartNoStep == nEtCount1) {
                nStartFlag = 2;
                tStart2 = Get_uSecond1();//uS   // end time
                dPerTime1 = (double)(tStart2 - tStart1) / (double)(nEtCount1 - 1.0);
                for (int i = 1; i <= nStartNoStep; i++) {
                    dEtADCTime[i] = (((float)dPerTime1 * (i - 1))) / (float)1000000.0;
                }
                //####################################################################################################################################
                // dEt_A ;//  A dEt_B= ;//  B   dEt_C= ;//  C
                //dEt_C= ;//  C

                  //sylee150610  for(   i=(nEtCount1-99);  i<=nEtCount1; i++){ //syle130104    
                for (i = (nEtCount1 - (int)(nCSetCo)+1); i <= nEtCount1; i++) { //syle130104    //sylee150610-1  100->10
                    nSumC = nSumC + dEtADC[i];
                }

                dEt_C = (int)(nSumC / (int)nCSetCo);  //sylee150611 kunshan  //sylee140614-1


            //----------------------------------------------------------------------------------------
                for (i = 1; i <= nEtCount1; i++) { //syle130104                                   
                    dEtADC21[i] = dEtADC[i] - dEt_C;   // N= ADC- AVEGRAGE
                    if (i == 1) {
                        dFirstHalf1 = dEtADC21[i] / 2.0;
                    }
                    if (nHalfTime1 == 0) {
                        if (dEtADC21[i] <= dFirstHalf1) {
                            nHalfTime1 = i;   //dEtADCTime[nHalfTime1]
                        }
                    }
                }
                //-----------------------------------------------------------------------------------------
                 // dEt_B= ;//  B  //  B=   ln(2)/tau
                //-----------------------------------------------------------------------------------------
                dEt_B = log(2) / dEtADCTime[nHalfTime1];
                //-----------------------------------------------------------------------------------------
                // dEt_A   //A=1000-C=1000-532
                dEt_A = 1000 - dEt_C;
                //-----------------------------------------------------------------------------------------
                //D line/ basic  =  A*(EXP(-B*ADC(t1))+C        
                for (i = 1; i <= nEtCount1; i++) {
                    dEtADC2[i] = dEt_A * (exp(-dEt_B * dEtADCTime[i])) + dEt_C;
                }
                //-----------------------------------------------------------------------------------------
                //E line                
                //     =  A*(EXP(-B*(1- B weight)*ADC(t1))+C*(1+ C weight)                              
                //     =  $F$3*EXP(-$I$3*(1-$I$4)*$B6)+$L$3*I938    
                for (i = 1; i <= nEtCount1; i++) {
                    dEtADC3[i] = dEt_A * (exp(-dEt_B * (1. - Weight_B) * dEtADCTime[i])) + dEt_C * (1. + Weight_C);
                }
                //======================================================================================================= 


                for (i = 1; i <= nEtCount1; i++) {
                    nEtLog[nFileCount][nEt_LogCount][i] = dEtADC[i];//step,count,time //sylee130408   
                    nEtLogTime[nFileCount][nEt_LogCount][i] = (float)dEtADCTime[i];//step,count,time      //sylee130408
                }


            }//end of if(nK==nEtCount1){


        }//end of if(nStartFlag==1){



        if (nStartFlag == 2) {   //estimation final  
            //Sub71.R1= dEt_A*exp(-dEt_B*(1-Weight_B)*dEtADCTime[dEt_EndTime1])+dEt_C*(1+Weight_C);
            dADC_End1 = dEt_A * exp(-dEt_B * (1. - Weight_B) * (dEt_EndTime1 / 1000.0)) + dEt_C * (1. + Weight_C);
            if (dADC_End1 <= nProRv1) {
                nStartFlag = 5;
                break;
            }
            else {
                nStartFlag = 4;
            }

        }//end of  if( nStartFlag==2){   //estimation final



        if (nStartFlag == 3 || nStartFlag == 4) {// 2=  running pass,  4=est fail
            tStart3 = Get_uSecond1();//uS   // start time
            TimeT1 = tStart3 - tStart1;//uS 


            if (((diff1 >= 0 && diff1 < 10) && (Sub71.R1 <= nProRv1))) {  //pass
                break;
            }


            if (TimeT1 > nTimeOutSet1) {//  time out fail     
                break;
            }
            if ((TimeT1 > 800000) && (Sub71.R1 > 10000)) {//sylee121028   80msec   short fail
                break;
            }


        }

    } //end of for(int nK=1; nK<=nFileLoop; nK++){ 



    //nTask100: //SYLEE150616

    //////////////////////////////////////////////////////////////////////////////////////////
        //sylee150509 move

    if (SysSet16.m_nSet12 == 1 && nFileDetaillog == 1) {

        //  CTime curTime = CTime::GetCurrentTime();
        ::ZeroMemory(&fName, sizeof(fName));

        //  str.Format("%s\\model\\log\\LOG_ET_%02dM%02dD_%02dH%02dM%02dS_%04d.txt", (SysInfoView01).m_pStrFilePathBDL,curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(),nFileCount+1); //SYLEE130325    
        str.Format("d:\\log\\LOG_ETM_%02dM%02dD_%02dH%02dM__%s_%d.CSV", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), (SysInfoView01).m_pStrFileBDLName, nFileCount + 1); //SYLEE130325 

        strcat(fName, str);
        fp = fopen(fName, "wt");
        if (fp == NULL) {
            AfxMessageBox("  Open File Reading Error No 8011 !.", MB_OK);
            return 0;
        }

        fprintf(fp, "\n");
    }



    // str.Format("%s\\model\\Model_C_%d.txt",  SysInfoView01.m_pStrFilePathBDL,nEt_LogCount);//SYLEE130325
    str.Format("d:\\log\\C1_%02dM%02dD_%02dH%02dM_MODEL_%s_C%d.CSV", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), SysInfoView01.m_pStrFileBDLName, nEt_LogCount); //SYLEE130325    

    ::ZeroMemory(&fName2, sizeof(fName2));
    strcat(fName2, str);
    if (nFileCount == 0) {
        fp2 = fopen(fName2, "wt");
    }
    else {
        fp2 = fopen(fName2, "at");
    }
    str.Format("%s,Open File Reading Error No 8012 !.", fName2);
    if (fp2 == NULL) {  // AfxMessageBox("  Open File Reading Error No 8005 !. \\model\\Model_Cur_%d.txt", MB_OK);         return 0;      }
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str, MB_OK);         return 0;
    }
    fprintf(fp2, "\n");



    //              CTime curTime = CTime::GetCurrentTime();
                     //str.Format("%s\\model\\M_Cl_%d.txt" ,(SysInfoView01).m_pStrFilePathBDL,nEt_LogCount);
    str.Format("d:\\log\\C2_%02dM%02dD_%02dH%02dM_MODEL_%s_%d.CSV", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), SysInfoView01.m_pStrFileBDLName, nEt_LogCount); //SYLEE130325    
    ::ZeroMemory(&fName3, sizeof(fName3));
    strcat(fName3, str);

    if (nFileCount == 0) {
        fp3 = fopen(fName3, "wt");
    }
    else {
        fp3 = fopen(fName3, "at");
    }

    if (fp3 == NULL) {
        AfxMessageBox("  Open File Reading Error No 8013!.", MB_OK);
        return 0;
    }
    fprintf(fp3, "\n");

    //////////////////////////////////////////////////////////////////////////////////////////


    if (nStartFlag == 3) {
        fprintf(fp2, "%d,    3,     0,     0,      0,       0,", nFileCount);
    }
    else  if (nStartFlag == 4) {
        fprintf(fp2, "%d,    2,    %.2f,   %.2f,   %.2f,     %.2f,", nFileCount, dEt_A, dEt_B, dEt_C, dADC_End1);
    }
    else if (nStartFlag == 5) {   //est running  pass                  ,
        fprintf(fp2, "%d,    1,    %.2f,   %.2f,   %.2f,     %.2f,", nFileCount, dEt_A, dEt_B, dEt_C, dADC_End1);
    }
    else {
        fprintf(fp2, "%d,    4,     0,     0,      0,       0, ", nFileCount, dEt_A, dEt_B, dEt_C, nStartFlag);
    }
    fclose(fp2);

    if (nStartFlag == 3) {
        fprintf(fp3, "NO=,%d,   A=,-,  B=,-,  C=,-,   running pass,   Count=,%d,    ADC=,%.2f, (<= ,%.2f,  ),  ", nFileCount, nK, Sub71.R1, nProRv1);
    }
    else  if (nStartFlag == 4) {
        fprintf(fp3, "NO=,%d,   A=,%.2f,  B=,%.2f,  C=,%.2f,   est. fail,  endadc=,%.2f,   end time=,%.2f,", nFileCount, dEt_A, dEt_B, dEt_C, dADC_End1, (dEt_EndTime1 / 1000.0));
    }
    else if (nStartFlag == 5) {   //est running  pass                  
        fprintf(fp3, "NO=,%d,   A=,%.2f,  B=,%.2f,  C=,%.2f,   est. pass, ", nFileCount, dEt_A, dEt_B, dEt_C);
    }
    else {
        fprintf(fp3, "NO=,%d,   A=,%.2f,  B=,%.2f,  C=,%.2f,   ect=,%d, ", nFileCount, dEt_A, dEt_B, dEt_C, nStartFlag);
    }
    fclose(fp3);



    if ((nEt_LogCount >= GetCount) && (nFileCount == nEt_StepSum)) {

        ::ZeroMemory(&dEtADC2, sizeof(dEtADC2));  ::ZeroMemory(&dEtADC3, sizeof(dEtADC3));
        ::ZeroMemory(&dEtADC, sizeof(dEtADC));    ::ZeroMemory(&dEtADCTime, sizeof(dEtADCTime));

        for (int jk = 1; jk <= nEt_StepSum; jk++) {  //nEt_StepSum=120 


            // str.Format("%s\\model\\log\\Et_Log_%02dM%02dD_%02dH%02dM_NO%d.csv" ,(SysInfoView01).m_pStrFilePathBDL,curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(),jk);
            str.Format("d:\\log\\Et_MODEL%S_%02dM%02dD_%02dH%02dM_NO%d.csv", (SysInfoView01).m_pStrFilePathBDL, curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), jk);
            ::ZeroMemory(&fName4, sizeof(fName4));
            strcat(fName4, str);
            fp4 = fopen(fName4, "wt");
            if (fp4 == NULL) { AfxMessageBox("  Open File Reading Error No 8009 !.", MB_OK);         return 0; }


            for (int jm = 1; jm <= nEtCount1; jm++) {//1003
//////////////////////////////////////////////////////////////////////////////////////////////
                dAvg1 = 0; dStDev1 = 0; dStDevPer = 0; dMin = 0; dMax = 0; dMinPer = 0; dMaxPer = 0; dAvg1Time = 0;
                dSinMa1 = 0; dSinMa2 = 0;
                //////////////////////////////////////////////////////////////////////////////////////////////
                for (int jp = 1; jp <= nEt_LogCount; jp++) {//10
                    if (jp == 1) {
                        dMin = nEtLog[jk][jp][jm];//no4
                        dMax = nEtLog[jk][jp][jm];//no5
                    }
                    else {
                        if (nEtLog[jk][jp][jm] < dMin) {
                            dMin = nEtLog[jk][jp][jm];//no4
                        }
                        if (nEtLog[jk][jp][jm] > dMax) {
                            dMax = nEtLog[jk][jp][jm];//no5
                        }
                    }
                    dAvg1 = dAvg1 + nEtLog[jk][jp][jm];
                    dAvg1Time = dAvg1Time + nEtLogTime[jk][jp][jm];
                    dSinMa1 = dSinMa1 + (nEtLog[jk][jp][jm] * nEtLog[jk][jp][jm]);
                    dSinMa2 = dSinMa2 + nEtLog[jk][jp][jm];
                }//END OF for(int jp=1; jp<=nEt_LogCount;jp++){//10



                if (nEt_LogCount >= 5) {//sylee130326
                    dAvg1 = (dAvg1 - dMin - dMax) / (nEt_LogCount - 2);//no1//sylee130326
                }
                else {
                    dAvg1 = dAvg1 / nEt_LogCount;//no1 //sylee130326
                }
                dAvg1Time = dAvg1Time / nEt_LogCount;

                dEtADC_Avg[jk][jm] = (float)dAvg1; //jk=step, jm=count
                dEtADCTime_Avg[jk][jm] = (float)dAvg1Time;

                dSinMa2 = dSinMa2 * dSinMa2;
                dStDev1 = (nEt_LogCount * dSinMa1 - dSinMa2) / (nEt_LogCount * (nEt_LogCount - 1));
                dStDev1 = sqrt(dStDev1);//no2
                dStDevPer = (dStDev1 / dAvg1) * 100.0;//no3

                dMinPer = -(dMin - dAvg1) * 100.0 / dMin;//no6
                dMaxPer = (dMax - dAvg1) * 100.0 / dAvg1;//no7

               // fprintf(fp4, "               %.2f              %.2f       %.2f            %.2f      %.2f           %.2f       %.2f           %.2f       ",dAvg1,dStDev1,dStDevPer,dMin,dMinPer, dMax,dMaxPer,dAvg1Time );      
//test               fprintf(fp4, " ,              %.2f,              %.2f,       %.2f,            %.2f,      %.2f,           %.2f,       %.2f,           %.2f,       ",dAvg1,dStDev1,dStDevPer,dMin,dMinPer, dMax,dMaxPer,dAvg1Time );      

                dEtModel[jm][1] = dAvg1; dEtModel[jm][6] = dStDev1; dEtModel[jm][7] = dStDevPer;
                dEtModel[jm][8] = dMin; dEtModel[jm][9] = dMinPer; dEtModel[jm][10] = dMax;
                dEtModel[jm][11] = dMaxPer; dEtModel[jm][12] = dAvg1Time;

                ////////////////////////////////////////////////////////////////////////////////////////////
                                //test              fprintf(fp4, " \n"  );      //nEtLog[200][11][2000];//step,count,time


            }//end of for(int jm=1; jm<=nEtCount1;jm++){//1003

//test          fclose(fp4);

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555

                             //test nEt_LogCount=0;


            nSumC = 0;   nHalfTime1 = 0;
            //####################################################################################################################################
            // dEt_A ;//  A dEt_B= ;//  B   dEt_C= ;//  C
            //==================================================================================================== 
            //-----------------------------------------------------------------------------------------
            //dEt_C= ;//  C
             //sylee150610-1  100->10    for(  int  i=(nEtCount1-100+1);  i<=nEtCount1; i++){ //syle130104    
            for (int i = (nEtCount1 - (int)(nCSetCo)+1); i <= nEtCount1; i++) { //syle130104    
                nSumC = nSumC + (int)dEtADC_Avg[jk][i];
            }

            //sylee150610-1  100->10  dEt_C=nSumC/100.0; // C=532
         //sylee150611kunshan     dEt_C=nSumC/nCSetCo; // C=532 //sylee150610-1  100->10 

         // if((nProStep1[TEST_LEAK1][1]==100000000.0)&&(nProStep1[TEST_LEAK1][2]<=700)){//sylee150611
        //      dEt_C= nEtc_Set;  //sylee150611kunshan
        //  }else{//sylee150611
            dEt_C = (int)(nSumC / (int)nCSetCo);  //sylee150611 kunshan
    //  }//sylee150611


     //sylee140614-1  dEt_C= nEtc_Set;  //sylee150613kunshan



    //----------------------------------------------------------------------------------------
            for (i = 1; i <= nEtCount1; i++) { //syle130104                                   
                dEtADC21[i] = dEtADC_Avg[jk][i] - dEt_C;   // N= ADC- AVEGRAGE
                if (i == 1) {
                    dFirstHalf1 = dEtADC21[i] / 2.0;
                }
                if (nHalfTime1 == 0) {
                    if (dEtADC21[i] <= dFirstHalf1) {
                        nHalfTime1 = i;   //dEtADCTime[nHalfTime1]
                        break;
                    }
                }
            }

            //-----------------------------------------------------------------------------------------
             // dEt_B= ;//  B  //  B=   ln(2)/tau
            //-----------------------------------------------------------------------------------------


            if (dEtADCTime_Avg[jk][nHalfTime1] == 0) {//sylee130408-1
                dEt_B = 0.0;
            }
            else {
                dEt_B = log(2) / dEtADCTime_Avg[jk][nHalfTime1];
            }
            //-----------------------------------------------------------------------------------------
            // dEt_A   //A=1000-C=1000-532
            dEt_A = 1000 - dEt_C;   //dEtADCSTart##################
      //-----------------------------------------------------------------------------------------
      //D line/ basic  =  A*(EXP(-B*ADC(t1))+C        
            for (i = 1; i <= nEtCount1; i++) {
                dEtADC2[i] = dEt_A * (exp(-dEt_B * dEtADCTime_Avg[jk][i])) + dEt_C;
            }
            //-----------------------------------------------------------------------------------------
            //E line                
            //     =  A*(EXP(-B*(1- B weight)*ADC(t1))+C*(1+ C weight)                              
            //     =  $F$3*EXP(-$I$3*(1-$I$4)*$B6)+$L$3*I938    
            for (i = 1; i <= nEtCount1; i++) {
                dEtADC3[i] = dEt_A * (exp(-dEt_B * (1. - Weight_B) * dEtADCTime_Avg[jk][i])) + dEt_C * (1. + Weight_C);
            }
            //======================================================================================================= 

            dADC_End1 = dEt_A * exp(-dEt_B * (1. - Weight_B) * (dEt_EndTime1 / 1000.0)) + dEt_C * (1. + Weight_C);



            for (int jm2 = 1; jm2 <= nEtCount1; jm2++) {//1003                               
                dADC_Model1 = dEt_A * exp(-dEt_B * (1. - Weight_B) * (dEtModel[jm2][12])) + dEt_C * (1. + Weight_C);
                dADC_Model2 = dEt_A * exp(-dEt_B * (1. + Weight_B) * (dEtModel[jm2][12])) + dEt_C * (1. - Weight_C);
                dADC_Model3 = dEt_A * exp(-dEt_B * (dEtModel[jm2][12])) + dEt_C;

                dADC_Half1 = dEtModel[jm2][1] - dEt_C;   //raw-C 

                ////////////////////////////////////////////////////////////////////
                for (int jp2 = 1; jp2 <= nEt_LogCount; jp2++) {//10                                                
                //sylee130408   fprintf(fp4, " %.2f ,",nEtLog[jk][jp2][jm2] );      //nEtLog[200][11][2000];//step,count,time
                    fprintf(fp4, " %d ,", nEtLog[jk][jp2][jm2]);   //nEtLog[200][11][2000];//step,count,time
//                                               fprintf(fp4, " %d ,", -,nTi1[jm2], -,);    //sylee150609//
                }


                if (jm2 == nHalfTime1) {//dADC_Half1  dEtADC21[jm2]  dEtADCTime_Avg[jk][jm2]
                   //sylee130408 fprintf(fp4, " %d,   %.2f,  %.2f, %.2f,%.2f,%.2f,<=halfTime ,  %.8f,    %.2f,       %.2f,            %.2f,      %.2f,           %.2f,       %.2f, ",jm2,dEtModel[jm2][1],dADC_Model3,dADC_Model1,dADC_Model2,dADC_Half1,dEtADCTime_Avg[jk][jm2],dEtModel[jm2][6],dEtModel[jm2][7],dEtModel[jm2][8],dEtModel[jm2][9],dEtModel[jm2][10],dEtModel[jm2][11] );       
                    fprintf(fp4, " %d,   %.2f,  %.2f, %.2f,%.2f,%.2f,<=halfTime ,   ", jm2, dEtModel[jm2][1], dADC_Model3, dADC_Model1, dADC_Model2, dADC_Half1);     //sylee130408 
                    fprintf(fp4, "  %.8f,    %.2f,       %.2f,            %.2f,      %.2f,           %.2f,       %.2f, ", dEtADCTime_Avg[jk][jm2], dEtModel[jm2][6], dEtModel[jm2][7], dEtModel[jm2][8], dEtModel[jm2][9], dEtModel[jm2][10], dEtModel[jm2][11]);     //sylee130408 

                }
                else {
                    fprintf(fp4, " %d,   %.2f,  %.2f, %.2f,%.2f,%.2f,           ,     ", jm2, dEtModel[jm2][1], dADC_Model3, dADC_Model1, dADC_Model2, dADC_Half1, dEtADCTime_Avg[jk][jm2]);      //sylee130408                                               
                    fprintf(fp4, "   %.8f,   %.2f,       %.2f,            %.2f,      %.2f,           %.2f,       %.2f,  ", dEtModel[jm2][6], dEtModel[jm2][7], dEtModel[jm2][8], dEtModel[jm2][9], dEtModel[jm2][10], dEtModel[jm2][11]);    //sylee130408                                                

                }

                if (jm2 == 1) {
                    fprintf(fp4, " halfAD=, *%.2f ", dFirstHalf1);
                }
                else if (jm2 == 2) {
                    fprintf(fp4, " Wei.B=, *%.2f,Wei.C=, *%.2f ", Weight_B, Weight_C);
                }
                else if (jm2 == 3) {
                    fprintf(fp4, " A=, *%.2f,B=, *%.2f,C=, *%.2f", dEt_A, dEt_B, dEt_C);
                }


                fprintf(fp4, " \n");      //nEtLog[200][11][2000];//step,count,time

            }//end of for(int jm=1; jm<=nEtCount1;jm++){//1003

            fclose(fp4);


        }//end of for(int jk=1; jk<=nEt_StepSum;jk++){  //nEt_StepSum=120

        ::ZeroMemory(&nEtLog, sizeof(nEtLog));//sylee130131



    }//if((nEt_LogCount>=GetCount)&&(nFileCount==nEt_StepSum)){


//#################################################################################################################

    if ((nEt_LogCount >= GetCount) && ((nFileCount) == nEt_StepSum)) {



        //sylee150509       if((nEt_LogCount>=GetCount)&&((nFileCount+1)==nEt_StepSum)){

        if (SysSet16.m_nSet11 == 1 && nFile5 == 1) {//sylee130408  12->11   //sylee150509 moved

            str.Format("%s\\model\\Model.ini", SysInfoView01.m_pStrFilePathBDL);//sylee130325
            ::ZeroMemory(&fName5, sizeof(fName5));
            strcat(fName5, str);


            fp5 = fopen(fName5, "wt");
            if (fp5 == NULL) {
                AfxMessageBox("  Open File Reading Error No 8015 !.", MB_OK);        return 0;
            }
            fprintf(fp5, "\n");


            str.Format("d:\\log\\A_MODEL_INI_%02dM%02dD_%02dH%02dM_%04d__%s_%d.CSV", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), nFileCount + 1, SysInfoView01.m_pStrFileBDLName, nEt_LogCount); //SYLEE130325 

            ::ZeroMemory(&fName6, sizeof(fName6));
            strcat(fName6, str);


            fp6 = fopen(fName6, "wt");
            if (fp6 == NULL) {
                AfxMessageBox("  Open File Reading Error No 8016 !.", MB_OK);        return 0;
            }
            fprintf(fp6, "\n");
        }
        //sylee150509   }

        nFlagEstModelMake = 2;//sylee130325
        nFlagEstModelMakeCount = 0;//sylee130325}
        nEt_LogCount = 0;


        for (int jk = 1; jk <= nEt_StepSum; jk++) {  //nEt_StepSum=120

            nSumC = 0; nHalfTime1 = 0;
            //####################################################################################################################################
            // dEt_A ;//  A dEt_B= ;//  B   dEt_C= ;//  C
            //==================================================================================================== 
            //-----------------------------------------------------------------------------------------
            //dEt_C= ;//  C
            //sylee150610-1  100->10       for(  int  i=(nEtCount1-100+1);  i<=nEtCount1; i++){ //syle130104    
            for (int i = (nEtCount1 - (int)nCSetCo + 1); i <= nEtCount1; i++) { //syle130104      //sylee150610-1  100->10
                nSumC = nSumC + (int)dEtADC_Avg[jk][i];
            }
            //sylee150610-1  100->10}     dEt_C=nSumC/100.0; // C=532
                  //sylee150611kunshan  dEt_C=nSumC/nCSetCo; // C=532                        

                 //  if((nProStep1[TEST_LEAK1][1]==100000000.0)&&(nProStep1[TEST_LEAK1][2]<=700)){//sylee150611
               //      dEt_C= nEtc_Set;  //sylee150611kunshan
               //  }else{//sylee150611
            dEt_C = (int)(nSumC / (int)nCSetCo);  //sylee150611 kunshan
    //}//sylee150611

//sylee150614-1 dEt_C= nEtc_Set;  //sylee150613kunshan

//----------------------------------------------------------------------------------------
            for (i = 1; i <= nEtCount1; i++) { //syle130104                                   
                dEtADC21[i] = dEtADC_Avg[jk][i] - dEt_C;   // N= ADC- AVEGRAGE
                if (i == 1) {
                    dFirstHalf1 = dEtADC21[i] / 2.0;
                }
                if (nHalfTime1 == 0) {
                    if (dEtADC21[i] <= dFirstHalf1) {
                        nHalfTime1 = i;   //dEtADCTime[nHalfTime1]
                        break;
                    }
                }
            }

            //-----------------------------------------------------------------------------------------
             // dEt_B= ;//  B  //  B=   ln(2)/tau
            //-----------------------------------------------------------------------------------------
            dEt_B = log(2) / dEtADCTime_Avg[jk][nHalfTime1];
            //-----------------------------------------------------------------------------------------
            // dEt_A   //A=1000-C=1000-532
            dEt_A = 1000 - dEt_C;////dEtADCSTart##################
      //-----------------------------------------------------------------------------------------
      //D line/ basic  =  A*(EXP(-B*ADC(t1))+C        
            for (i = 1; i <= nEtCount1; i++) {
                dEtADC2[i] = dEt_A * (exp(-dEt_B * dEtADCTime_Avg[jk][i])) + dEt_C;
            }
            //-----------------------------------------------------------------------------------------
            //E line                
            //     =  A*(EXP(-B*(1- B weight)*ADC(t1))+C*(1+ C weight)                              
            //     =  $F$3*EXP(-$I$3*(1-$I$4)*$B6)+$L$3*I938    
            for (i = 1; i <= nEtCount1; i++) {
                dEtADC3[i] = dEt_A * (exp(-dEt_B * (1. - Weight_B) * dEtADCTime_Avg[jk][i])) + dEt_C * (1. + Weight_C);
            }
            //======================================================================================================= 

            dADC_End1 = dEt_A * exp(-dEt_B * (1. - Weight_B) * (dEt_EndTime1 / 1000.0)) + dEt_C * (1. + Weight_C);

            if (dADC_End1 <= nProRv1) {
                fprintf(fp5, "%d,    1,    %.2f,   %.2f, ", jk, dEt_A, dEt_B);
                fprintf(fp5, " %.2f,     %.7f,  %.2f,   ", dEt_C, dEtADCTime_Avg[jk][nHalfTime1], dADC_End1);
            }
            else {
                fprintf(fp5, "%d,    2,    %.2f,   %.2f,  ", jk, dEt_A, dEt_B);
                fprintf(fp5, "  %.2f,     %.7f,  %.2f,   ", dEt_C, dEtADCTime_Avg[jk][nHalfTime1], dADC_End1);
            }
            fprintf(fp5, "\n");


            if (dADC_End1 <= nProRv1) {
                fprintf(fp6, "%d,    1,    %.2f,   %.2f,  ", jk, dEt_A, dEt_B);
                fprintf(fp6, " %.2f,     %.7f,  %.2f,   ", dEt_C, dEtADCTime_Avg[jk][nHalfTime1], dADC_End1);
            }
            else {
                fprintf(fp6, "%d,    2,    %.2f,   %.2f,  ", jk, dEt_A, dEt_B);
                fprintf(fp6, " %.2f,     %.7f,  %.2f,   ", dEt_C, dEtADCTime_Avg[jk][nHalfTime1], dADC_End1);
            }
            fprintf(fp6, "\n");

            if ((dEt_A <= 0) || (dEt_B <= 0) || (dEt_C <= 0)) {//SYLEE130410
                nModelFlag = 1;
            }

        }//end of for(int jk=1; jk<=nEt_StepSum;jk++){  //nEt_StepSum=120



        if (nModelFlag == 1) {//SYLEE130410
            fprintf(fp6, "************> modeling fail ");

            str.Format("d:\\log\\Model_Fail_%02dM%02dD_%02dH%02dM_MODEL_%s.CSV", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), SysInfoView01.m_pStrFileBDLName); //SYLEE130325  

            ::ZeroMemory(&fName7, sizeof(fName7));
            strcat(fName7, str);
            if (nFileCount == 0) {
                fp7 = fopen(fName7, "wt");
            }
            else {
                fp7 = fopen(fName7, "at");
            }
            str.Format("%s,  Modelfaillogfile, Open File Reading Error No 8017 !.", fName7);
            if (fp7 == NULL) {  // AfxMessageBox("  Open File Reading Error No 8005 !. \\model\\Model_Cur_%d.txt", MB_OK);         return 0;      }
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str, MB_OK);
                return 0;
            }
            fprintf(fp7, "\n");
            fclose(fp7);

        }


        fclose(fp5);
        fclose(fp6);

        Sleep(100);


        FileSysInfo01.LoadSave_Model_Load1(2); //sylee130131

    }

    Sub71.R1 = 10.;


    return 1;
}




int CChildView7::ARun201_LV_OneModel(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)
{


    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];
    int i, ik, j, n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1;
    int nHVIADCFlag, nDischargeCount;
    int nShRes1T, ih, logno1, nSQCount1, nSQLastY1, nSQLastPin, tp1;

    double nISet, dVbR1, dVbR2, InterI;

    int nFailFlag1, nFailFlag2, nFailFlag3, nFailFlag4;

    //  short nShRes1[33000];
    int nSQ1Fail[200], nSh1Ret1[100], dPinVC[200], dPinVB[200];

    //son210401  100 -> MAX_SQUARE_N(200)  : Short 1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
    int nSQNet1[MAX_SQUARE_N][MAX_SQUARE_N];// pin array//sylee1209

    double nT[10], nData[130][15], dR1[11][200];
    double dVB1[11][200], dVC1[11][200], dI1[11][200];//sylee130225joytech  IADClog1[40][1000];
//  double nCardOffSetHV1;//sylee120915  

    int nMSet1Flag, nMSet1Co, nMSet1CoT2;
    int nSQStep1flag, nIControl, nRetry1;
    int nPin1[1000], nPin2[1000];//sylee130111
    int nIFilter, nHVOffSet, nHVGain;//sylee130629    
    int tmpOne2, t1, t2, t3, nIGain;//,n4wGain;//SYLEE150123 


 ////////////////////////////////////////////////////////////////////
    int nTmpPinNo1;

    Sub71.OnPinAllReset1();//sylee190207-1

    int dutId = getDutId();                 //son190704-4WDUT16
    nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16

    for (ik = 1; ik <= nRCount; ik++)//sylee190207-1
    {
        nTmpPinNo1 = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16
        int ret = Sub71.AOnPinSet1(2, nTmpPinNo1, 1); //=1Vb, 
#if 1
        if (ret < 0)        //son-32KPIN-20200114:      nPin=PinMap[2][No] 가 -1이면 없는 카드. 
        {
            str.Format("ERROR NO 7002-9, \nSub71.AOnPinSet1(2, ...) Error! \n\n\nCan't find hwPin for jigPin_%d  ", nTmpPinNo1);
            AfxMessageBox(str);
            return 0;
        }
#endif

    }
    //////////////////////////////////////////////////////////////////
    Sub71.OnDisCharge1(); //sylee170725-3 
    Sub71.OnPinAllReset1();//sylee190207-1

    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127

    m_nMode1 = 207;//SYLEE150523
  // nProRv1=3000;//sylee131011  ok

    logno1 = 0;    nShRes1T = 0;    nStop = 0;
    ipFlag = 0;   n4Wire = 0;   ipEnd = 1;
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode
    nDischargeCount = 20;//sylee20120830

    nHVIADCFlag = 1;//SYLEE121018   //waiting 
    nIControl = 0;
    tmpOne2 = 0;

    nProOneP_Short1_Co = 0;


    //  ::ZeroMemory (&nShRes1, sizeof(nShRes1));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nSh1Ret1, sizeof(nSh1Ret1));
    ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));//sylee120907
    ::ZeroMemory(&IADClog1, sizeof(IADClog1));//sylee120907
    ::ZeroMemory(&nReFlagLvCur, sizeof(nReFlagLvCur));//SYLEE121129

    nFailCount[TEST_SHORT] = 0;       //son210331 enum

//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//mode ( 1~65)
//step ( open, ㅏushort, short, hr, hv  4w)


    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;

    //sylee180917-1      nProRv1=30000;//sylee131011  //sylee150721 1000->5000
    //sylee180917-1   nDelay10=3000;//sylee181025

    //sylee181025 nProRv1=nLvModelRealR; //sylee181005-1
    //sylee181025  nDelay10=50000;//sylee150525 0.5m  x3    =1.5mS   //sylee150721   5000->3000

    nProRv1 = 3000;      nDelay10 = 5000; //good  //sylee181025


    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629         
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];   //SYLEE130629
    nIGain = (int)dRec[m_nMode1][12];        //SYLEE150123     
    //   n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  

    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7712, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }


    //ADC COUNT
    Sub71.nADCount1 = (int)dRec[m_nMode1][7];


    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock    

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 11024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 11025, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 11025, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }


    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 


     //sylee130903  Lo1=200;

    Lo1 = 100;//sylee130903  200nS-> 1sec

    Sub71.AOnReadVB1Run1(nVRel);//sylee130802




Task101:

    Sub71.AOnReadVB1Run1(nVRel);

    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;


    if (Simulator100 != 7)
    {
        if (Sub71.V1 > 300) {
            if (Lo1-- > 0) {
                //sylee121019   Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   
                goto Task101;
            }
            str.Format("Error No 11301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
            AfxMessageBox(str);
            return 0;
        }

#ifdef _PC_TEST_
        Sub71.V1 = nVSet;      //son PC 테스트용 임시설정. HW없이 테스트 시 HW error 넘어가기 위함
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
            if (Lo1-- > 0) {
                //sylee121019   Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   
                goto Task101;
            }

            PowerCheckError1();


            if (nG_Language != 2) {//SYLEE150707
                str.Format("Error No  1315,\n \n\n 전압 설정이 안되었습니다.   Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
            }
            else {
                str.Format("Error No  1315,\n \n\n .    Voltage power  set  error.    Power Check? \n\n  lv short  model. \n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);

            }
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);


            return 0;
        }
    }


    //sylee130708   Sub71.AOnReadV1Enable1(nVRel); //SYLEE20120223   //VC SENSE INIT SET 
    Sub71.AOnReadV1Enable1(nVRel); //SYLEE20120223   //VC SENSE INIT SET 

    Sub71.FilterSet(nFil);//sylee130702 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 12023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629



//**********************************************************//

    //   int nIGain,n4wGain;//SYLEE150123       
    //*******************************************************                   
    // nIGain = (int)dRec[m_nMode1][12];     //SYLEE150123     
    // n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  
    //****************************************************** 

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on        
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    /*  if( n4Wire==4 ){   //ACE380
            if(n4wGain==2){
                Sub71.On4W_GainSet(2);
            }else  if(n4wGain==3){
                Sub71.On4W_GainSet(3);
            }else  if(n4wGain==4){
                Sub71.On4W_GainSet(4);
            }else{
                Sub71.On4W_GainSet(1);
            }
        }else{
            Sub71.On4W_GainSet(1);
        }
        */
        //**********************************************************//


    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);//SYLEE20111213     //vb RELAY ON   
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118 

//--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    //son220927 if (nMod1 == 2 || nMod1 == 3 || nMod1 == 4 || nMod1 == 5)
    if (nMod1 == TEST_U_SHORT || nMod1 == TEST_SHORT || nMod1 == TEST_HR_SHORT || nMod1 == TEST_LEAK1) //son220927
    {
        /*          if((nMulNetFlag==2) && (nMultyNetTotal>=2)){//SYLEE150817  //sylee150920
                           nRCount=nBDLData3[2][0][1];
                           g_nPieceMax1=SysInfoPieceRange.m_nPieceCount[2]; //SYLEE150920
                    }else if((nMulNetFlag==3) && (nMultyNetTotal>=3)){//SYLEE150817
                           nRCount=nBDLData3[3][0][1];
                           g_nPieceMax1=SysInfoPieceRange.m_nPieceCount[3]; //SYLEE150920
                    }else if((nMulNetFlag==4) && (nMultyNetTotal>=4)){//SYLEE150817
                           nRCount=nBDLData3[4][0][1];
                           g_nPieceMax1=SysInfoPieceRange.m_nPieceCount[4]; //SYLEE150920
        */
        nRCount = nBDLData3[dutId][0][1];         //SYLEE180810-1-DUT16   //son190704-4WDUT16
        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920

        if (g_nPieceMax1 > 1) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }
    }
    else
    {
        str.Format("Error No 17213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }


    if (nProType == 2) {//SYLEE130916  //i mode   running 
        ipEnd = 1;
        ipFlag = 0;
        nHVIADCFlag = 1;
    }

    if (nProType != 1) {//SYLEE130916  //i mode   running 
        ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));
    }


    //====================================================================================================================================
    for (int ip = 1; ip <= ipEnd; ip++)
    {


        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                continue;
            }
        }

        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;  nECount = 0;  nFailL1CoPiece = 0;
        nEt1 = 0; nShort2FailFlag1 = 0;

        //*******************************************************************************************************************************//
        //Task1:

        if (ipFlag == 1) {
            nRCount = g_pvBDLData31[dutId][ip]->size() - 1;    //SYLEE180810-1-DUT16   //son190704-4WDUT16
        }
        else {
            nRCount = nBDLData3[dutId][0][1]; //SYLEE180810-1-DUT16   //son190704-4WDUT16
        }

        nSQCount1 = 0;//sylee120908   //SQRT( SQUARE ROOT)
        for (i = 1; i < MAX_SQUARE_N; i++) //son210401  200 -> MAX_SQUARE_N  (200)
        {                             // Short     1만개 넘는 BDL 로딩 후 Leak테스트시 다운현상관련 수정
            tp1 = i * i;
            if (tp1 >= nRCount) {
                nSQCount1 = i;//sylee120908
                break;
            }
        }

        if ((nSQCount1 == 0) || (nRCount < 1)) {//sylee121018
            str.Format("Error No 7513-4 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }

        ::ZeroMemory(&nSQNet1, sizeof(nSQNet1));

        //################################################################################################################################
        //SET 


        for (ik = 1; ik <= nRCount; ik++)
        {
            i = (ik - 1) / nSQCount1 + 1;//mok
            j = (ik - 1) - nSQCount1 * (i - 1);//na
            // if(i>1){
            j = j + 1;
            // }                     

            if (ipFlag == 1) {//short   PIECE MULT.  //sylee150920
                nSQNet1[i][j] = (*g_pvBDLData31[dutId][ip])[ik].wFirstPin; // 1 VB,    =2VC, //SYLEE180810-1-DUT16   //son190704-4WDUT16
            }
            else {      //sylee150920                
                nSQNet1[i][j] = nBDLData3[dutId][ik][1];   // 1  VB,    =2VC, //SYLEE180810-1-DUT16  //son190704-4WDUT16
            } //sylee150920

            if (ik == nRCount) {
                nSQLastPin = j;//sylee120908   ///last row , last col.
                nSQLastY1 = i;
            }
        }

        //================================================================================================================

        //#2 second search    hv  adc           
        // 1000 point 

        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        //row

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;

        Sub71.OnPinAllReset1(); ///PIN ALL RESET 

        nRetry1 = 0;


        //Task1Retry:


        for (ik = 1; ik < nSQLastY1; ik++)     // FIRST LOOP //Y  VB 
        {

            if (ik == 1 || nSQStep1flag == 2) {

                Sub71.OnPinAllReset1(); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {

                    if (ik2 > ik) {
                        continue;
                    }
                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }
                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=1Vb,   

                    }
                }

                nSQStep1flag = 0;

            }
            else {//end of if(ik==1  || nSQStep1flag==2){

                Sub71.OnPinResetVC();
                //              Sub71.Delay_100ns(100);//10uSEC  
                for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                    if (ik == nSQLastY1) {  //LAST Y STEP
                        if (ih > nSQLastPin) {
                            break;//SKIP   
                        }
                    }
                    Sub71.AOnPinSet1(2, nSQNet1[ik][ih], 1); //=1  vb 
                }

            }



            for (ih = 1; ih <= nSQCount1; ih++) {  //X   // Second LOOP   vb pin  
                if ((ik + 1) == nSQLastY1) {
                    if (ih > nSQLastPin) {
                        break;//SKIP
                    }
                }


                Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih], 2);   // =2,Vc,   all        

            }
            //////////////////////////////////////////////////////////////////////////////////


            if (nHVIADCFlag == 1) {
                //  AHV_ADCI_Read1(nProRv1); 
                ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                //  Sub71.R1= dIADC1  ;//ADC
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv1);
            }


            IADClog1[ip][ik] = Sub71.R1;///logging

            if (nHVIADCFlag == 1) {
                if (Sub71.R1 <= nProRv1) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }


            }
            else {
                if (Sub71.R1 >= nProRv1) {//ok//LV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail 

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //  nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }

            }



            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block 

            if (nFailFlag1 == 1) {  //if error   

                Sub71.OnPinResetVB();   //sylee121029  

                for (int ik2 = 1; ik2 <= nSQLastY1; ik2++) {     // FIRST LOOP //Y   //Vc 

                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;


                    if (ik2 > ik) { //doublecheck#2 
                        continue;
                    }

                    for (ih = 1; ih <= nSQCount1; ih++) {    //X // Second LOOP   vc pin 
                        if (ik2 == nSQLastY1) {  //LAST Y STEP
                            if (ih > nSQLastPin) {
                                break;//SKIP   
                            }
                        }
                        Sub71.AOnPinSet1(2, nSQNet1[ik2][ih], 1); //=2VC,  
                    }

                    //=====================================================================================================================

                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else {
                        Sub71.Delay_100ns(nDelay10);
                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }

                    }


                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv1) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 



                    //##################################################################################################################################

                    //one line & one line  search


                    if (nFailFlag2 == 1) {
                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 
                            if (ik2 == nSQLastY1) {  //LAST Y STEP
                                if (ih6 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            Sub71.OnPinResetVB();//SYLEE121016***** all reset                                    
                            // Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ik2][ih6], 1); //=2VC,                                    
                            //=====================================================================================================================
                            if (nHVIADCFlag == 1) {
                                ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {

                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                }
                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }
                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }

                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv1) {// ok//HV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line 

                            //################################################################################################################################
                            ///one point  & one point search

                            if (nFailFlag3 == 1) {
                                for (int ih2 = 1; ih2 <= nSQCount1; ih2++) {  //X   // Second LOOP   vb pin                                           

                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih2 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    Sub71.OnPinResetVC(); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017
                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih2], 2);   // =1,VB,   all

                                    if (nHVIADCFlag == 1) {
                                        ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                        }

                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }

                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }

                                    }


                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV
                                        }
                                        else {//fail
                                           //  if(ih2==ih6)
                                            nFailFlag4 = 1;


                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ik + 1][ih2] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ik2][ih6] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }

                                            //  Sleep(10);//sylee131011

                                        }
                                    }
                                    else {

                                        if (Sub71.Y1 < 5) {//ok//LV
                                        }
                                        else {//fail                                                        
                                            nFailFlag4 = 1;
                                        }
                                    }

                                    nPin1[0] = 0;
                                    nPin2[0] = 0;


                                    if (nFailFlag4 == 1) {//sylee130111                                  

                                        if (nProOneP_Short1_Co < 3000) {//array size nFailL1[
                                            t1 = nSQNet1[ik + 1][ih2] + 1;//PIECE  pin no                                                                      
                                            t2 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                            t1 = nSQNet1[ik2][ih6] + 1;//PIECE  pin no                                                                       
                                            t3 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                            if (nProOneP_Short1_Co == 0) {
                                                // Sleep(100);//SYLEE150522 
                                            }

                                            if (t2 != t3) {
                                                nProOneP_Short1_Co++;
                                                tmpOne2++;
                                                nProOneP_Short1_Li[0][0]++;
                                                if (nSQNet1[ik + 1][ih2] < nSQNet1[ik2][ih6]) {
                                                    nProOneP_Short1_Li[tmpOne2][1] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                    nProOneP_Short1_Li[tmpOne2][0] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                }
                                                else {
                                                    nProOneP_Short1_Li[tmpOne2][0] = nSQNet1[ik + 1][ih2] + 1;//pin  vb
                                                    nProOneP_Short1_Li[tmpOne2][1] = nSQNet1[ik2][ih6] + 1;//pin  vc
                                                }
                                            }

                                        }   //end of if(nFailL1Co<3000)//array size nFailL1[


                                        //  Sub71.Delay_100ns(10000);//1mSEC 

                                        //##########################################################################################################################################3


                                    }   //if(nFailFlag4==1) 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  


                                //----------------------------------------------------------------------------------------------------------------------

                                Sub71.OnPinResetVC();
                                //   Sub71.Delay_100ns(100);//10uSEC   

                                for (int ih3 = 1; ih3 <= nSQCount1; ih3++) {  //X   // Second LOOP   vb pin  

                                    if ((ik + 1) == nSQLastY1) {
                                        if (ih3 > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }
                                    Sub71.AOnPinSet1(2, nSQNet1[ik + 1][ih3], 2);   // =1,VB,   all                                              

                                }

                            }// if(nFailFlag3==1)         

                        }//end of for( ih=1; ih<=nSQCount1; ih++)    //X // Second LOOP   vc pin 


                        //=====================================================================================================================
                    }//   end of  if(nFailFlag2==1)   ///one line & one line  search
                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc

            }//end of  if(nFailFlag1==1)

        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++)     // FIRST LOOP //Y  VB

        Sub71.OnPinAllReset1(); ///PIN ALL RESET 

        //================================================================================================================
        //################################################################################################################################
        //#1 FIRST-1  Line&Block
        // Y 

        ::ZeroMemory(&nSQ1Fail, sizeof(nSQ1Fail));
        nShort2FailFlag1 = 0;
        nSQStep1flag = 0;

        nRetry1 = 0;


        //Task2Retry:

        for (ik = 1; ik < nSQCount1; ik++)     // FIRST LOOP //Y  VB 
        {
            if (ik == 1 || nSQStep1flag == 2)
            {

                Sub71.OnPinAllReset1(); ///PIN ALL RESET 

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {

                    if (ik2 > ik) {
                        continue;
                    }
                    for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=2VC, 
                    }
                }



                nSQStep1flag = 0;



            }
            else//end of if(ik==1  || nSQStep1flag==2)
            {

                Sub71.OnPinResetVC();
                //   Sub71.Delay_100ns(100);//10uSEC   

                for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                    if (ih == nSQLastY1) {  //LAST Y STEP
                        if (ik > nSQLastPin) {
                            break;//SKIP   
                        }
                    }
                    Sub71.AOnPinSet1(2, nSQNet1[ih][ik], 1); //=2VC,   

                }

            }


            for (ih = 1; ih <= nSQLastY1; ih++)  //X   // Second LOOP   vb pin  
            {
                if (ih == nSQLastY1) {
                    if ((ik + 1) > nSQLastPin) {
                        break;//SKIP
                    }
                }

                Sub71.AOnPinSet1(2, nSQNet1[ih][ik + 1], 2);   // =1,VB,   all 

            }
            //////////////////////////////////////////////////////////////////////////////////

            if (nHVIADCFlag == 1) {
                //  AHV_ADCI_Read1(nProRv1); 
                ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                //  Sub71.R1= dIADC1  ;//ADC
            }
            else {
                Sub71.Delay_100ns(nDelay10);
                AHV_ADCI_Read1(nProRv1);
            }



            IADClog1[ip][ik] = Sub71.R1;///logging

            if (nHVIADCFlag == 1) {
                if (Sub71.R1 <= nProRv1) {// ok//HV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail

                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //nFailFlag1=0;//test
                    nSQStep1flag = 2;

                }
            }
            else {
                if (Sub71.R1 >= nProRv1) {//ok//LV
                    nSQ1Fail[ik] = 1;
                    nFailFlag1 = 0;
                }
                else {//fail
                    nSQ1Fail[ik] = 2;  // LAST ik=0;
                    nShort2FailFlag1 = 1;
                    nFailFlag1 = 1;
                    //  nFailFlag1=0;//test
                    nSQStep1flag = 2;
                }

            }

            // nFailFlag1=0;  // ALLPASS


            //==============================================================================================================================
            //################################################################################################################################
            //#2,  second search    hv  adc  
            // vc  m block 

            if (nFailFlag1 == 1) {  //if error

                Sub71.OnPinResetVB();//sylee121029 

                for (int ik2 = 1; ik2 <= nSQCount1; ik2++) {     // FIRST LOOP //Y   //Vc


                    nMSet1Co = 0;
                    nMSet1Flag = 0;
                    nMSet1CoT2 = 0;


                    //sylee121029   Sub71.OnPinResetVB();
                    //Sub71.Delay_100ns(100);//10uSEC   


                    if (ik2 > ik) { //doublecheck#2 
                        continue;
                    }

                    for (ih = 1; ih <= nSQLastY1; ih++) {    //X // Second LOOP   vc pin 
                        if (ih == nSQLastY1) {  //LAST Y STEP
                            if (ik2 > nSQLastPin) {
                                break;//SKIP   
                            }
                        }

                        Sub71.AOnPinSet1(2, nSQNet1[ih][ik2], 1); //=2VC,  

                    }


                    //=====================================================================================================================


                    if (nHVIADCFlag == 1) {
                        //  AHV_ADCI_Read1(nProRv1); 
                        ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                        //  Sub71.R1= dIADC1  ;//ADC
                    }
                    else {

                        Sub71.Delay_100ns(nDelay10);

                        if (nCC == 2) {//cv
                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                        }
                        else {// cc                                      
                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                        }

                        if (Sub71.Y1 < 0.0000001) {
                            Sub71.Y1 = 0.0000001;
                        }

                        if (nCC == 1) { //CC    r= (vb-vc)/i
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                            }

                        }
                        else if (nCC == 2) {//CV   r=(vb/i)
                            if (nIR == 1 || nIR == 2) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                            }
                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                            }
                        }

                    }

                    //Sub71.Delay_100ns(10000);  
                    //=====================================================================================================================
                    nFailFlag2 = 0;
                    if (nHVIADCFlag == 1) {
                        if (Sub71.R1 <= nProRv1) {// ok//HV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }
                    else {
                        if (Sub71.R1 >= nProRv1) {//ok//LV
                        }
                        else {//fail
                            nFailFlag2 = 1;
                        }
                    }//line & line 



                    //=====================================================================================================================
                    //##################################################################################################################################

                    //one line & one line  search


                    if (nFailFlag2 == 1)
                    {

                        for (int ih6 = 1; ih6 <= nSQCount1; ih6++) {    //X // Second LOOP   vc pin 


                            //  if( ik2==nSQLastY1){  //LAST Y STEP
                            //     if(ih6>nSQLastPin){
                            if (ih6 == nSQLastY1) {  //LAST Y STEP
                                if (ik2 > nSQLastPin) {
                                    break;//SKIP   
                                }
                            }

                            Sub71.OnPinResetVB();//SYLEE121016***** all reset                                    
                            //  Sub71.Delay_100ns(100);//10uSEC   

                            Sub71.AOnPinSet1(2, nSQNet1[ih6][ik2], 1); //=2VC,



                            //=====================================================================================================================

                            if (nHVIADCFlag == 1) {
                                ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                //  Sub71.R1= dIADC1  ;//ADC
                            }
                            else {


                                Sub71.Delay_100ns(nDelay10);

                                if (nCC == 2) {//cv
                                    Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                }
                                else {// cc                                      
                                    Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                }


                                if (Sub71.Y1 < 0.0000001) {
                                    Sub71.Y1 = 0.0000001;
                                }


                                if (nCC == 1) { //CC    r= (vb-vc)/i
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                    }

                                }
                                else if (nCC == 2) {//CV   r=(vb/i)
                                    if (nIR == 1 || nIR == 2) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                    }
                                    else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                        Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                    }
                                }

                            }




                            nFailFlag3 = 0;
                            if (nHVIADCFlag == 1) {
                                if (Sub71.R1 <= nProRv1) {// ok//HV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }
                            else {
                                if (Sub71.R1 >= nProRv1) {//ok//LV
                                }
                                else {//fail
                                    nFailFlag3 = 1;
                                }
                            }//line & line 



                            //=====================================================================================================================
                            //################################################################################################################################
                            ///one point  & one point search

                            if (nFailFlag3 == 1)
                            {

                                for (int ih2 = 1; ih2 <= nSQLastY1; ih2++) {  //X   // Second LOOP   vb pin  


                                    if (ih2 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }

                                    if (ih6 != ih2) {//sylee121025
                                        continue;
                                    }

                                    Sub71.OnPinResetVC(); //Vb all reset
                                    // Sub71.Delay_100ns(100);//10uSEC   //SYLEE121017

                                    Sub71.AOnPinSet1(2, nSQNet1[ih2][ik + 1], 2);   // =1,VB,   all


                                    if (nHVIADCFlag == 1) {
                                        ALV_ADCI_Read1_OneToM(nProRv1, nDelay10);
                                        //  Sub71.R1= dIADC1  ;//ADC
                                    }
                                    else {
                                        Sub71.Delay_100ns(nDelay10);
                                        if (nCC == 2) {//cv
                                            Sub71.AOnReadV1I1(7);     // CV MODE   //  I READ                
                                        }
                                        else {// cc                                      
                                            Sub71.AOnReadV1I1(nVRel); // CC MODE   //  V I READ                                   
                                        }

                                        if (Sub71.Y1 < 0.0000001) {
                                            Sub71.Y1 = 0.0000001;
                                        }


                                        if (nCC == 1) { //CC    r= (vb-vc)/i
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1 - Sub71.X1) / Sub71.Y1 * 1000000.0;
                                            }

                                        }
                                        else if (nCC == 2) {//CV   r=(vb/i)
                                            if (nIR == 1 || nIR == 2) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000.0;
                                            }
                                            else if (nIR == 3 || nIR == 4 || nIR == 5) {
                                                Sub71.R1 = (Sub71.V1) / Sub71.Y1 * 1000000.0;
                                            }
                                        }

                                    }


                                    nFailFlag4 = 0;
                                    if (nHVIADCFlag == 1) {
                                        if (Sub71.R1 <= nProRv1) {// ok//HV
                                        }
                                        else {//fail

                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;

                                            for (int iq1 = 1; iq1 <= nFailL1Co; iq1++) {
                                                if ((nFailL1[iq1][4] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][5] == (nSQNet1[ih6][ik2] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                                if ((nFailL1[iq1][5] == (nSQNet1[ih2][ik + 1] + 1)) && (nFailL1[iq1][4] == (nSQNet1[ih6][ik2] + 1))) {
                                                    nFailFlag4 = 0; break;
                                                }
                                            }

                                            // Sleep(10);//sylee131011

                                        }
                                    }
                                    else {
                                        //if( (Sub71.R1>=nProRv1)&&( Sub71.Y1>5)){//ok//LV
                                        if (Sub71.Y1 < 5) {//ok//LV

                                        }
                                        else {//fail
                                           //if(ih2==ih6)
                                            nFailFlag4 = 1;
                                        }
                                    }


                                    nPin1[0] = 0;
                                    nPin2[0] = 0;

                                    if (nFailFlag4 == 1) {//sylee130111                          
                                        if (nProOneP_Short1_Co < 3000) {//array size nFailL1[
                                            t1 = nSQNet1[ih2][ik + 1] + 1;//PIECE  pin no   //sylee131011
                                            //  t2=g_nPinPieceNo[1][t1];//PIECE  piece no   //sylee131011
                                            t2 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                            t1 = nSQNet1[ih6][ik2] + 1;//PIECE  pin no   //sylee131011
                                            //  t3=g_nPinPieceNo[1][t1];//PIECE  piece no  //sylee131011
                                            t3 = nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16

                                            //sylee131015   if( t1!=t3){
                                            if (t2 != t3) {
                                                nProOneP_Short1_Co++;
                                                tmpOne2++;
                                                nProOneP_Short1_Li[0][0]++;
                                                if (nSQNet1[ih2][ik + 1] < nSQNet1[ih6][ik2]) {
                                                    nProOneP_Short1_Li[tmpOne2][1] = nSQNet1[ih2][ik + 1] + 1;//pin  vb  //sylee131011
                                                    nProOneP_Short1_Li[tmpOne2][0] = nSQNet1[ih6][ik2] + 1;//pin  vc  //sylee131011
                                                }
                                                else {
                                                    nProOneP_Short1_Li[tmpOne2][0] = nSQNet1[ih2][ik + 1] + 1;//pin  vb  //sylee131011
                                                    nProOneP_Short1_Li[tmpOne2][1] = nSQNet1[ih6][ik2] + 1;//pin  vc  //sylee131011
                                                }
                                            }

                                        }   //end of if(nFailL1Co<3000)//array size nFailL1[

                                    }   //if(nFailFlag4==1) 

                                } //for( int ih2=1; ih2<=nSQCount1; ih2++)  //X   // Second LOOP   vb pin  

                                //----------------------------------------------------------------------------------------------------------------------
                                Sub71.OnPinResetVC();
                                //     Sub71.Delay_100ns(100);//10uSEC  

                                //SYLEE121107
                                for (int ih3 = 1; ih3 <= nSQLastY1; ih3++) {  //X   // Second LOOP   vb pin  
                                    if (ih3 == nSQLastY1) {
                                        if ((ik + 1) > nSQLastPin) {
                                            break;//SKIP
                                        }
                                    }
                                    Sub71.AOnPinSet1(2, nSQNet1[ih3][ik + 1], 2);   // =1,VB,   all                
                                }
                            }// if(nFailFlag3==1)             

                        }//end of for( ih=1; ih<=nSQCount1; ih++)    //X // Second LOOP   vc pin  

                        //=====================================================================================================================
                    }//   end of  if(nFailFlag2==1)   ///one line & one line  search

                    //#2
                }//end of for( int ik2=1; ik2<=nSQLastY1; ik2++)     // FIRST LOOP //Y   //Vc

            }//end of  if(nFailFlag1==1)

        }  //=> line & block   first    for( ik=1; ik<=nSQLastY1; ik++)     // FIRST LOOP //Y  VB


        Sub71.OnPinAllReset1(); ///PIN ALL RESET 

        if (nReFlagLvCur[ip] != 2) {
            nReFlagLvCur[ip] = 1;//SYLEE121129
        }


    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   



     // Delay_100ns(100000);//10mSEC  ok

    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720
    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704 
    Sub71.AOnReadV1Enable1(5); //sylee130711    
    Sub71.OnPinResetInit();//sylee151221   //ACE400



/////////////////////////////////////
//short list make 

    int nListTotal1, nX1, nY1, nSam1, ntm1;
    short nListUse[3000];

    nListTotal1 = nProOneP_Short1_Li[0][0];
    ::ZeroMemory(&nListUse, sizeof(nListUse));
    nY1 = 0;

    if (nListTotal1 > 0)
    {
        //nProOneP_ShortPin[20][1000];
        nY1++;

        nProOneP_ShortPin[0][0] = nY1;  // current net  
        nProOneP_ShortPin[nY1][0] = 2;  //list 별  total count
        nProOneP_ShortPin[nY1][1] = nProOneP_Short1_Li[1][0] - 1;//sylee131006 -1
        nProOneP_ShortPin[nY1][2] = nProOneP_Short1_Li[1][1] - 1;//sylee131006 -1

        nX1 = 2;

        for (int k1 = 1; k1 <= nX1; k1++)
        {
            for (int y1 = 1; y1 <= nListTotal1; y1++) {//y
                for (int x1 = 0; x1 <= 1; x1++) {
                    if (nProOneP_ShortPin[nY1][k1] == (nProOneP_Short1_Li[y1][x1] - 1)) {//sylee131011-1
                        if (nListUse[y1] != 1) {
                            nListUse[y1] = 1; //  y search
                            nListUse[0]++;
                        }
                    }
                }//enn of for( int j1=1; j1<=nTotal1; j1++){
            }//end of for( int i1=1; i1<=nTotal1; i1++){ 


            for (y1 = 1; y1 <= nListTotal1; y1++)//y                   
            {
                if (nListUse[y1] == 1) {
                    for (int x1 = 0; x1 <= 1; x1++) {
                        nSam1 = 0;
                        for (int kk1 = 1; kk1 <= nX1; kk1++) {
                            if (nProOneP_ShortPin[nY1][kk1] == (nProOneP_Short1_Li[y1][x1] - 1)) {//sylee131011-1
                                nSam1 = 1;
                            }
                        }
                        if (nSam1 == 0) {
                            ntm1 = nX1++;
                            nProOneP_ShortPin[nY1][0] = ntm1;
                            nProOneP_ShortPin[nY1][ntm1] = (nProOneP_Short1_Li[y1][x1] - 1);//sylee131011-1
                        }
                    }
                }//enn of for( int j1=1; j1<=nTotal1; j1++)
            }//end of for( int i1=1; i1<=nTotal1; i1++)

        }//end of for( int k1=1; k1<=nX1; k1++)

    }//end of   if( nListTotal1>0)



//  END :: ONE PIECE SHORT,  OPEN LIST MAKING   
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//open list 

    int nNetCount, nCo1, nCo2;


    nNetCount = 0;//SYLEE161212
    nCo1 = 0;//SYLEE161212
    nCo2 = 0;//SYLEE161212

    if (nListTotal1 > 0)
    {
        nNetCount = nProOneP_ShortPin[0][0];
        nCo1 = 0;
        nCo2 = 0;
        for (int a1 = 1; a1 <= nNetCount; a1++) {
            for (int b1 = 2; b1 <= nProOneP_ShortPin[a1][0]; b1++) {
                nCo1++;
                nProOneP_Open1[nCo1][0] = nProOneP_ShortPin[a1][1];
                nProOneP_Open1[nCo1][1] = nProOneP_ShortPin[a1][b1];
                nCo2++;//shortlist
                nProOneP_Short1[nCo2] = nProOneP_ShortPin[a1][b1];//process               
            }
        }
        nProOneP_Open1[0][0] = nCo1;//total open list
        nProOneP_Short1[0] = nCo2;// total short list
        //nProOneP_Open1[3000][2];           
        //    str.Format(" ShortCount=%d ", nCo2);
        //    AfxMessageBox(str, MB_OK);  
    }


    int tmp3;
    tmp3 = 0;
    for (int a1 = 1; a1 <= nNetCount; a1++) {
        tmp3 = tmp3 + nProOneP_ShortPin[a1][0];
    }

    str.Format(" Model End,S=%d ", tmp3);       
    Label102_Cycle_SetCaption(str); //son240712 

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////


    if ((nProOneP_ShortPin[0][0] == 1) && (nProOneP_ShortPin[1][0] > 0)) {//sylee181030
        nProOneP_Short1[0] = nProOneP_ShortPin[1][0];
        for (i = 1; i <= nProOneP_Short1[0]; i++) {
            nProOneP_Short1[i] = nProOneP_ShortPin[1][i];
        }
    }

    ///////////////////////////////////


    /*
            FILE *fp;

            ::ZeroMemory(&fName, sizeof(fName));
            strcat( fName , "d:\\nSHORT_list1.TXT" );
            fp = fopen(fName,"wt");
            if(fp == NULL){
                    str.Format("Error No 1014 :  d:\\nSHORT_list1      file Data Saving Error !     file close!.");
                    AfxMessageBox(str, MB_OK);
                    return 0 ;
            }

            fprintf(fp, "*totol= %d  ea\n\n",   nProOneP_Short1[0] );

            for(i=1; i<= nProOneP_Short1[0]; i++){
                 fprintf(fp, "%d\n",   nProOneP_Short1[i]+1 );
            }

            fclose(fp);

    */


    return 1;

}



void CChildView7::OnRecipeErrorCheck()//sylee140127             
{
    int nStatus, n4WNetCnt;

    int  n4Wcheck1;

    n4Wcheck1 = 0;

    //son200312-4WDUT16
    int dutIdx = get4wDutIdx();         // g_s4WNet의 index. 0부터 시작함.  //son190704-4WDUT16

    for (int i = 1; i <= 7; i++)  //sylee20111210          
    {

        nStatus = SysInfo05.m_nStep[i];   //open, ushort, short, hr, hv         

        char  fName[200];  //sylee160731-2   //sylee160801-6
        CString str;

        ::ZeroMemory(&fName, sizeof(fName));  //sylee160731-2
        str.Format("%s\\4W.INI", SysInfoView01.m_pStrFilePathBDL);
        strcat(fName, str);

        //son 4W.ini 가 존재하고 NetCount가 0보다 크다면  4W 가 step에 있는지 확인한다.
        //    step 4, 5, 6, 7 중의 하나에는 반드시 4W step이 있어야 한다.
        if (FileExists(fName) != FALSE)//sylee160731-2   //sylee160801-6
        {
            n4WNetCnt = (int)g_s4WNet[dutIdx].wCount;        //son190704-4WDUT16     
            if (n4WNetCnt > 0)
            {
                if (i == 4) {
                    if (nStatus != 7) {//sylee141113 
                        n4Wcheck1++;
                    }
                }
                if (i == 5) {
                    if (nStatus != 7) {//sylee141113 
                        n4Wcheck1++;
                    }
                }
                if (i == 6) {   //sylee180418-1          
                    if (nStatus != 7) {//sylee141113 
                        n4Wcheck1++;
                    }
                }
                if (i == 7) {   //son210715 추가
                    if (nStatus != 7) {//sylee141113 
                        n4Wcheck1++;
                    }
                }

                //sylee180418-1  if(n4Wcheck1==2 && n4Wcheck1Mes1==0){//sylee161101-2
                //if(n4Wcheck1==3 && n4Wcheck1Mes1==0){//sylee161101-2  //sylee180418-1 
                if (n4Wcheck1 == 4 && n4Wcheck1Mes1 == 0) {  //son210715
                    if (nFlagAutoPress1 != 2) {//sylee150413
                        n4Wcheck1Mes1 = 1;//sylee161101-2
                        AfxMessageBox(" \n WARNING !!!  \n\n  NO7701-2.    [4W] Select check ?     [RECIPE] Step4? Step5? Step6? or Step7?  ", MB_OK);
                    }
                }
            }
        }


    }



}




int CChildView7::PowerCheckError1()//sylee141029                
{


    BYTE Buf;
    int nChk1, nErrCount1;
    CString str1;

    //son MapDisplay->Set1:  Selftest System Off
    if (SysSet13.m_nSet4 == 1) {//sylee170502  shin.
        return 1;
    }


    nSelfTestHWError1 = 0;
    nChk1 = 0;
    nErrCount1 = 0;

    //int nChk1,i;

    //son CONTECT SwitchCard
#ifdef DEF_CARD_A1  //sylee170328

#ifndef _PC_TEST_
    int Ret;
    for (int i = 0; i < 8; i++)
    {
        Ret = DioInpByte(pDIO.hDrv2, i, &Buf);
        if (Ret != 0) {
            str1.Format("  [DioInpByte, %d]  Com. Error!!! ", i);
            AfxMessageBox(str1);
            return  0;
        }
        if (Buf == 255) {
            nChk1++;
        }
    }
#endif

    //son ICP_DAS switchCard 
#else  //#ifdef DEF_CARD_A1   

    int Ret;
    int nOnCo1;//sylee170328
    nOnCo1 = 0;
    Ret = d64h_di_readport(pDIO_D64.m_bCardID, &pDIO_D64.dwDIStatus);  //
    if (Ret != 0) {
        AfxMessageBox("  Card64H1_DI32() Error!!!");
    }
    else
    {
        if ((pDIO_D64.dwDIStatus & 0x00000001) != 0)    nOnCo1++;    //son D64H BD0 DI00 ADC_A_D0 
        if ((pDIO_D64.dwDIStatus & 0x00000002) != 0)    nOnCo1++;    //son D64H BD0 DI01 ADC_A_D1  
        if ((pDIO_D64.dwDIStatus & 0x00000004) != 0)    nOnCo1++;    //son D64H BD0 DI02 ADC_A_D2
        if ((pDIO_D64.dwDIStatus & 0x00000008) != 0)    nOnCo1++;    //son D64H BD0 DI03 ADC_A_D3 
        if ((pDIO_D64.dwDIStatus & 0x00000010) != 0)    nOnCo1++;    //son D64H BD0 DI04 ADC_A_D4  
        if ((pDIO_D64.dwDIStatus & 0x00000020) != 0)    nOnCo1++;    //son D64H BD0 DI05 ADC_A_D5 
        if ((pDIO_D64.dwDIStatus & 0x00000040) != 0)    nOnCo1++;    //son D64H BD0 DI06 ADC_A_D6  
        if ((pDIO_D64.dwDIStatus & 0x00000080) != 0)    nOnCo1++;    //son D64H BD0 DI07 ADC_A_D7  

        if ((pDIO_D64.dwDIStatus & 0x00000100) != 0)    nOnCo1++;    //son D64H BD0 DI08 ADC_A_D8 
        if ((pDIO_D64.dwDIStatus & 0x00000200) != 0)    nOnCo1++;    //son D64H BD0 DI09 ADC_A_D9 
        if ((pDIO_D64.dwDIStatus & 0x00000400) != 0)    nOnCo1++;    //son D64H BD0 DI10 ADC_A_D10 
        if ((pDIO_D64.dwDIStatus & 0x00000800) != 0)    nOnCo1++;    //son D64H BD0 DI11 ADC_A_D11 
        if ((pDIO_D64.dwDIStatus & 0x00001000) != 0)    nOnCo1++;    //son D64H BD0 DI12 ADC_A_D12 
        if ((pDIO_D64.dwDIStatus & 0x00002000) != 0)    nOnCo1++;    //son D64H BD0 DI13 ADC_A_D13 
        if ((pDIO_D64.dwDIStatus & 0x00004000) != 0)    nOnCo1++;    //son D64H BD0 DI14 ADC_A_D14 
        if ((pDIO_D64.dwDIStatus & 0x00008000) != 0)    nOnCo1++;    //son D64H BD0 DI15 ADC_A_D15 

        if ((pDIO_D64.dwDIStatus & 0x00010000) != 0)    nOnCo1++;    //son D64H BD0 DI16 ADC_B_D0  
        if ((pDIO_D64.dwDIStatus & 0x00020000) != 0)    nOnCo1++;    //son D64H BD0 DI17 ADC_B_D1  
        if ((pDIO_D64.dwDIStatus & 0x00040000) != 0)    nOnCo1++;    //son D64H BD0 DI18 ADC_B_D2  
        if ((pDIO_D64.dwDIStatus & 0x00080000) != 0)    nOnCo1++;    //son D64H BD0 DI19 ADC_B_D3  
        if ((pDIO_D64.dwDIStatus & 0x00100000) != 0)    nOnCo1++;    //son D64H BD0 DI20 ADC_B_D4  
        if ((pDIO_D64.dwDIStatus & 0x00200000) != 0)    nOnCo1++;    //son D64H BD0 DI21 ADC_B_D5  
        if ((pDIO_D64.dwDIStatus & 0x00400000) != 0)    nOnCo1++;    //son D64H BD0 DI22 ADC_B_D6  
        if ((pDIO_D64.dwDIStatus & 0x00800000) != 0)    nOnCo1++;    //son D64H BD0 DI23 ADC_B_D7  

        if ((pDIO_D64.dwDIStatus & 0x01000000) != 0)    nOnCo1++;    //son D64H BD0 DI24 ADC_B_D8  
        if ((pDIO_D64.dwDIStatus & 0x02000000) != 0)    nOnCo1++;    //son D64H BD0 DI25 ADC_B_D9  
        if ((pDIO_D64.dwDIStatus & 0x04000000) != 0)    nOnCo1++;    //son D64H BD0 DI26 ADC_B_D10 
        if ((pDIO_D64.dwDIStatus & 0x08000000) != 0)    nOnCo1++;    //son D64H BD0 DI27 ADC_B_D11 
        if ((pDIO_D64.dwDIStatus & 0x10000000) != 0)    nOnCo1++;    //son D64H BD0 DI28 ADC_B_D12 
        if ((pDIO_D64.dwDIStatus & 0x20000000) != 0)    nOnCo1++;    //son D64H BD0 DI29 ADC_B_D13 
        if ((pDIO_D64.dwDIStatus & 0x40000000) != 0)    nOnCo1++;    //son D64H BD0 DI30 ADC_B_D14 
        if ((pDIO_D64.dwDIStatus & 0x80000000) != 0)    nOnCo1++;    //son D64H BD0 DI31 ADC_B_D15 
    }

    Ret = d64h_di_readport(pDIO_D64.m_bCardID2, &pDIO_D64.dwDIStatus);
    if (Ret != 0) {
        AfxMessageBox("  Card64H2_DI32() Error!!!");
    }
    else {

        if ((pDIO_D64.dwDIStatus & 0x00000001) != 0)    nOnCo1++;  //son D64H BD1 DI-00 SPARK_ON
        if ((pDIO_D64.dwDIStatus & 0x00000002) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000004) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000008) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000010) != 0)    nOnCo1++;  //son D64H BD1 DI-04 DTHV   0: ERROR, 1: 정상  
        if ((pDIO_D64.dwDIStatus & 0x00000020) != 0)    nOnCo1++;  //son D64H BD1 DI-05 DT24V  0: ERROR, 1: 정상
        if ((pDIO_D64.dwDIStatus & 0x00000040) != 0)    nOnCo1++;  //son D64H BD1 DI-06 DT5V   0: ERROR, 1: 정상
        if ((pDIO_D64.dwDIStatus & 0x00000080) != 0)    nOnCo1++;  //son D64H BD1 DI-07 DT12V  0: ERROR, 1: 정상

        if ((pDIO_D64.dwDIStatus & 0x00000100) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000200) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000400) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00000800) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00001000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00002000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00004000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00008000) != 0)    nOnCo1++;

        if ((pDIO_D64.dwDIStatus & 0x00010000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00020000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00040000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00080000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00100000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00200000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x00400000) != 0)    nOnCo1++;   //son D64H BD1 DI-22 DT_BOT_BOX : 하부박스 Detection 
        if ((pDIO_D64.dwDIStatus & 0x00800000) != 0)    nOnCo1++;   //son D64H BD1 DI-23 DT_TOP_BOX : 상부박스 Detection 

        if ((pDIO_D64.dwDIStatus & 0x01000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x02000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x04000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x08000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x10000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x20000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x40000000) != 0)    nOnCo1++;
        if ((pDIO_D64.dwDIStatus & 0x80000000) != 0)    nOnCo1++;
    }


    if (nOnCo1 > 60) {//sylee170328
        nChk1 = 8;
    }

#endif  //#ifdef DEF_CARD_A1 



    if (nChk1 >= 7) {
        nErrCount1++;
        if (nG_Language != 2) {//SYLEE150707
            str1.Format(" ERROR! System Power off. 계측기 전원 켜주세요!", MB_OK);
        }
        else {
            str1.Format(" ERROR! System Power off. BBT CONTROLLER  Power  on  check !", MB_OK);
        }
        nSelfTestHWError1 = 1;

        AfxMessageBox(str1);
    }

    if (nErrCount1 > 0) {
        goto  Task1;
    }



    //-------------------------------------------------------------------------------               

#ifdef DEF_CARD_A1  //sylee170328
    DioInpBit(pDIO.hDrv2, 32, &Buf);
#else  //#ifdef DEF_CARD_A1   

    //son D64H BD1 DI-07 DT12V  is ON?  (Detection Main Power 12V. 0 : ERROR, 1: 정상 )
    if ((pDIO_D64.dwDIStatus & 0x000000080) != 0) {
        Buf = 1;  //son Main 12V 정상
    }
    else {
        Buf = 0;  //son Main 12V Error
    }
#endif  //#ifdef DEF_CARD_A1        
    if (Buf == 0) {
        nSelfTestHWError1++;
        AfxMessageBox("  ERROR 7701 ::  TESTER,   MAIN 12V POWER OFF  ", MB_OK);
    }



#ifdef DEF_CARD_A1  //sylee170328
    DioInpBit(pDIO.hDrv2, 33, &Buf);
#else  //#ifdef DEF_CARD_A1   

    //son D64H BD1 DI-06 DT5V is ON?  0: ERROR, 1: 정상
    if ((pDIO_D64.dwDIStatus & 0x00000040) != 0) {
        Buf = 1;  //son Main 5V 정상
    }
    else {
        Buf = 0;  //son Main 5V Error 
    }
#endif  //#ifdef DEF_CARD_A1        
    if (Buf == 0) {
        nSelfTestHWError1++;
        AfxMessageBox("  ERROR 7701 ::  TESTER,    MAIN 5V POWER OFF  ", MB_OK);
    }



#ifdef DEF_CARD_A1  //sylee170328
    DioInpBit(pDIO.hDrv2, 34, &Buf);
#else  //#ifdef DEF_CARD_A1   
    //son D64H BD1 DI-05 DT24V is ON? 0: ERROR, 1: 정상  
    if ((pDIO_D64.dwDIStatus & 0x00000020) != 0) {
        Buf = 1;  //son Main 24V 정상
    }
    else {
        Buf = 0;  //son Main 24V Error 
    }
#endif  //#ifdef DEF_CARD_A1        
    if (Buf == 0) {
        nSelfTestHWError1++;
        AfxMessageBox("  ERROR 7701 ::  TESTER,    MAIN 24V POWER OFF  ", MB_OK);
    }


    //-------------------------------------------------------------------------------               

    //extern CSysSet12  SysSet12;  //Pin SETUP              

#if 0
//son210202 nBoxCount, nPinTotMax, nPinBoxMax, nStart, nEnd 사용하는 부분이 없어서 막았음.

    int nBoxCount, nPinTotMax, nPinBoxMax, nStart, nEnd;

    if (SysSet12.m_nPinTotMax == PIN_TOT_4K)
    {
        nPinTotMax = 4;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_8K)
    {
        nPinTotMax = 8;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_8K_LOW_STPIN) //son-8K4097-20200605: 8K 구형 하부시작핀 사용시
    {
        //son 8K 구형.  상부 4box, 하부 1box로 구동하고,  상부 뒤쪽  b,c,d box는 skip 해서 상부 1, 하부 1만 사용한다. 
        nPinTotMax = 20;      // 
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_16K)
    {
        nPinTotMax = 16;
    }
    else  if (SysSet12.m_nPinTotMax == PIN_TOT_20K_UP_TR       //son-32KPIN-20191223: 20K 추가 //son230216_1
        || PIN_TOT_20K_U12K_L4K_UP_TRANS)        //son210603
    {
        nPinTotMax = 20;
    }
    else  if (SysSet12.m_nPinTotMax == PIN_TOT_24K_UP_TR    //son-32KPIN-20191223: 24K 추가           //son230216_1
        || SysSet12.m_nPinTotMax == PIN_TOT_24K_TRANS       //son-32KPIN-20200120: 24K FullTrans 추가 //son230216_1
        || SysSet12.m_nPinTotMax == PIN_TOT_16K_TRANS)      //son-32KPIN-20200228: 16K_FullTrans 추가 //son230216_1
    {
        nPinTotMax = 24;
    }
    else if (SysSet12.m_nPinTotMax == PIN_TOT_32K_TRANS) { //son230216_1
        nPinTotMax = 32;
    }
    else if (SysSet12.m_nPinTotMax < PIN_TOT_4K) {
        AfxMessageBox("  ERROR 7702  ::   [PIN]  MAX PIN  <  List NO 1 (4k) ", MB_OK);
        nPinTotMax = 4;
    }
    else {
        AfxMessageBox("  ERROR 7702  ::   [PIN]  MAX PIN  >  List NO 4 (32k) ", MB_OK);
        nPinTotMax = 4;
    }


    if (SysSet12.m_nPinBoxMax == 1) {           //son BoxType: 1=2K     
        nPinBoxMax = 2;
    }
    else if (SysSet12.m_nPinBoxMax == 2) {      //son BoxType: 2=4K 
        nPinBoxMax = 3;
    }
    else if (SysSet12.m_nPinBoxMax < 1) {
        AfxMessageBox("  ERROR 7702  ::   [PIN]  BOX PIN  <  List NO 1 (2k) ", MB_OK);
        nPinBoxMax = 2;
    }
    else {
        AfxMessageBox("  ERROR 7702  ::   [PIN]  BOX PIN  >  List NO 2 (4k) ", MB_OK);
        nPinBoxMax = 2;
    }


    nBoxCount = nPinTotMax / nPinBoxMax;

    if (nBoxCount == 1) {//1       
        nStart = 54, nEnd = 55;
    }
    else  if (nBoxCount == 2) {
        nStart = 52, nEnd = 55;
    }
    else  if (nBoxCount == 3) {
        nStart = 50, nEnd = 55;
    }
    else  if (nBoxCount == 4) {
        nStart = 48, nEnd = 55;
    }
    else { //8      
        nStart = 48, nEnd = 63;
    }
#endif


#ifdef DEF_CARD_A1  //sylee170328
    DioOutByte(pDIO.hDrv, 13, 0);
#else  //#ifdef DEF_CARD_A1  //sylee170328  

    // son BD1(2번째 D64H) _VC_ENA write
    Ret = d64h_do_writeport(pDIO_D64.m_bCardID2, 0x80000);  //
    if (Ret != 0) { AfxMessageBox("  Card64H2_DO32(0x80000 ) Error!!!"); return  0; }

#endif  //#ifdef DEF_CARD_A1 




Task1:


    return 1;
}




int CChildView7::ARun201_Short_Model1()  //sylee150622
{

    int nTo1, nTo1Co1;
    int nPin1, nPin2, nPin3, nPin4; //sylee150622  
    int nReShortPin1[5001][3];//sylee150611 
    int nShortPinRe1[5001];//sylee150611 
    int nShortPinRe1_N[5001];//sylee150622
    int nReShortPin1En[20000];//sylee150611    

    ::ZeroMemory(&nReShortPin1, sizeof(nReShortPin1));//sylee150611
    ::ZeroMemory(&nShortPinRe1, sizeof(nShortPinRe1));//sylee150611
    ::ZeroMemory(&nReShortPin1En, sizeof(nReShortPin1En));//sylee150611


    nTo1Co1 = 0;


    nShort_Flag1 = __HV; //1:__LV  2:__HV  //sylee161026

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               

    if (nProOneP_Flag1 == 3) {
        nTo1 = nProOneP_Short1_Li[0][0];
        if (nTo1 > 5000) {
            AfxMessageBox("    Error No 7301     Piece to Piece ,    Short Pin 5000 ea  over.", MB_OK);
        }
    }

    if (nProOneP_Flag1 == 3 && ((nTo1 > 0) && (nTo1 <= 5000))) {//sylee150611 

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               
//#1-1  //disble eject      

        for (int i1 = 1; i1 <= nTo1; i1++) {
            nTo1Co1++;
            nReShortPin1[nTo1Co1][0] = nProOneP_Short1_Li[i1][0];
            nReShortPin1[nTo1Co1][1] = nProOneP_Short1_Li[i1][1];

            nPin1 = nReShortPin1[nTo1Co1][0];
            nPin2 = nReShortPin1[nTo1Co1][1];
            if (nPin1 > nPin2) {
                nReShortPin1[nTo1Co1][1] = nPin1;
                nReShortPin1[nTo1Co1][0] = nPin2;
            }

            nReShortPin1[0][0] = nTo1Co1;
        }

        /////////////////////////////////////////////////////////////////

        int nTo2, nTo3P, nTo3P2, nTo3St;
        nTo1 = 0; nTo2 = 0; nTo3St = 0; nTo3P2 = 0;
        nTo1 = nReShortPin1[0][0];
        if ((nTo1 < 1) || (nTo1 > 2000)) {
            nTo1 = 0;
        }


        //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               
        //#2  //eject short pin list                 

        for (int i2 = 1; i2 <= nTo1; i2++) {
            nTo3P = nReShortPin1[i2][0];
            if (nReShortPin1En[nTo3P] == 1) {
                //skip
            }
            else {//select              
                nReShortPin1En[nTo3P] = 1;// select    
                nTo2++;
                nShortPinRe1[nTo2] = nTo3P;   ///short list     // remove pin list 
                nShortPinRe1[0] = nTo2;  //short list co
            }

            nTo3P2 = nReShortPin1[i2][1];
            if (nReShortPin1En[nTo3P2] == 1) {
                //skip
            }
            else {//select                              
                nReShortPin1En[nTo3P2] = 1;// select  
                nTo2++;
                nShortPinRe1[nTo2] = nTo3P2;   ///short list     // remove pin list 
                nShortPinRe1[0] = nTo2;  //short list co  <================
            }

        }//sylee150618  //end of for(int i3=1; i3<=nTo1;  i3++){

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        int nToCo1, nToCo2;

        ::ZeroMemory(&nShortPinRe1_N, sizeof(nShortPinRe1_N));//sylee150612

        nTo1 = nShortPinRe1[0];
        nTo2 = nReShortPin1[0][0];

        for (int i3 = 1; i3 <= nTo1; i3++) {//12
            nToCo2 = 0;
            if (i3 == 1) {
                nPin1 = nShortPinRe1[i3];
                nShortPinRe1_N[i3] = 1;
                nToCo1 = 1;
            }
            else {
                if (nShortPinRe1_N[i3] > 0) {
                    continue;
                }
                nPin1 = nShortPinRe1[i3];
                nToCo1++;
            }

            for (int i5 = 1; i5 <= nTo2; i5++) {//66

                nPin3 = nReShortPin1[i5][0];
                nPin4 = nReShortPin1[i5][1];

                if (nPin1 == nPin3) {
                    for (int i5 = 1; i5 <= nTo1; i5++) {//12
                        nPin2 = nShortPinRe1[i5];
                        if (nPin2 == nPin4) {
                            nShortPinRe1_N[i5] = nToCo1;
                        }
                        if (nToCo1 > 1) {//sylee150623
                            if (nToCo2 == 0) {//sylee150623
                                if (nPin2 == nPin3) {//sylee150623
                                    nShortPinRe1_N[i5] = nToCo1;//sylee150623
                                    nToCo2 = 1;
                                }
                            }
                        }
                    }
                }
            }
        }



        //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
        // multi short list piece
        //int nShortPinRe2[21][300];


        if (nToCo1 > 20) {
            AfxMessageBox(" Error 7501   Short Model list1  20ea over", MB_OK);
        }

        ::ZeroMemory(&nShortPinRe2, sizeof(nShortPinRe2));//sylee150612


        int nCo1;


        nShortPinRe2[0][0] = nToCo1;
        for (i1 = 1; i1 <= nToCo1; i1++) {// 1
            nCo1 = 0;
            for (int i2 = 1; i2 <= nTo1; i2++) {//12
                if (nShortPinRe1_N[i2] == i1) {
                    nCo1++;
                    if (nCo1 >= 300) {
                        AfxMessageBox(" Error 7501   Short Model list2 300ea over", MB_OK);
                        break;
                    }
                    nShortPinRe2[i1][nCo1] = nShortPinRe1[i2];
                    nShortPinRe2[i1][0] = nCo1;
                }
            }

        }

    }
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    return 1;
}




//SYLEE121028  DEFINE  
int CChildView7::ARun201_S2_HV_2N1(int nMod1, int m_nMode1, double nProRv1, int nPStep1, short nProType)  //sylee150423-3
{

    CString   str, str1, strfName, strfName1;

    int ik, n4Wire, nRCount, nDelay10, nEnd;
    int nLoop, ipEnd, ipFlag, Lo1, nECount, nEtemp1, nShort2FailFlag1;
    int nEt1, nFailL1CoPiece, nCDelay1, nFil, nDisChargeADC1, nHVIADCFlag, nDischargeCount, nShRes1T;
    int logno1;
    int nFailFlag1;
    double nISet, dVbR1, dVbR2, InterI;
    int nIFilter, nHVOffSet, nHVGain, nDelayTime2, nIControl, nHVTimeOutSet;
    int nEstUse, nEt_StepSumTemp;//sylee130325   //estimation
//  int nSparkUse;
    int nErrorDelayTime1;
    int nProRv2, nProRv3;//sylee140930
    int nErrorDelayFlag1, nErrorDelayTime2;//sylee141002
    int nIGain; //,n4wGain;//SYLEE150123 
    int nTmp1, n2N1_Loop, n2N1_Fail1;//sylee150423-1

    short nPinL[7001];//sylee150527-2
    short nPinL2[7001];//sylee150611
    int nDisableFlag2;//sylee150611; 
    int nDisableFlag1;//sylee150527-2



   if (nMod1 == TEST_LEAK2 ){     nLeakMode1=TEST_LEAK2;//sylee230822
   }else{  nLeakMode1=TEST_LEAK1; } //sylee230822}

    nFlagLeakMPin1=0;  //sylee230526  //sylee230817
    nShort_Flag1 = __HV; //1:__LV  2:__HV  //sylee161026
    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127
    nDisableFlag2 = 0;//sylee150611; 
    n2N1_Fail1 = 0;//sylee150423-1

    tStart321 = GetuSecond();//TESTDEBUG

    nRunMode_HV_LV = 1;//SYLEE150417-5  1= HV, 2=LV
    nErrorDelayTime1 = 1000;//1mS//sylee141001
    nErrorDelayTime2 = 100000;//500mS//sylee141002  //sylee150331  200mS->10ms =>   ok함 
    nErrorDelayFlag1 = 0;//sylee141002

    nEstUse = 0; logno1 = 0;    nShRes1T = 0; nStop = 0;  ipFlag = 0;
    n4Wire = 0; nFileCount = 0;  nIControl = 0;

    nDelayTime2 = 20000;//sylee130716
    ipEnd = 1;//PIECE
    nCDelay1 = 100;
    nDisChargeADC1 = 10;//testmode    
    nDischargeCount = 20;//sylee2012083
    nHVIADCFlag = 1;//test


    ::ZeroMemory(&nPinL, sizeof(nPinL));//sylee150527-2
    ::ZeroMemory(&nPinL2, sizeof(nPinL2));//sylee150611


//sylee181005-3  if( SysSet13.m_nSet1==1 ){//sylee121008
//sylee181005-3       nHVTimeOutSet=DEFINE_HVTIMEOUT1*5;
//sylee181005-3  }else{
    nHVTimeOutSet = DEFINE_HVTIMEOUT1 * 3;
    //sylee181005-3  }


    if (nFastHv1RunStep == 1) {//sylee150415 fasthv
        ::ZeroMemory(&nFastHv1Piece, sizeof(nFastHv1Piece));//sylee150415
        nFastHv1PieceReturn = 0;//sylee150415
    }


    //sylee170411   if(SysSet13.m_nSet19==1){//sylee150417-1 
    if (SysInfo05.m_nProSpMode == 2 || SysInfo05.m_nProSpMode == 3 || SysInfo05.m_nProSpMode == 4) {   //sylee150417-1 
        if (SysSet16.m_nSet11 == 1) {//sylee130325  //sylee130404   //estimation
            if (nFlagEstModelMake == 1 && nFlagEstModelMakeSelect == 2) {
                nEstUse = 1;//sylee130325
            }
            else if (nFlagEstModelMake == 3) {
                nEstUse = 1;//sylee130325
            }
            if (nEstUse == 1) {//sylee130325
                nEt_LogCount++;//sylee130219jo   ytech estimation
            }
        }
        nFileCount = 0;//sylee130219joytech-estimation
    }
    //sylee170411   }

    nEstUse = 0;//sylee150622





    if (SysSet15.m_nSet1 < 1 || SysSet15.m_nSet2 < 1 || SysSet15.m_nSet3 < 1) {
        AfxMessageBox("  Maker Engineer Call!  HV 100M,50M,20M  DATA<1? ,   PROCESS SET  PARAMETOR   FILE LOAD ERROR!.  ERROR NO 5001 ,PROCESS FAIL. STOP. ", MB_OK);
    }


    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     
    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];

#ifdef __QUAD_LEAK1_LEAK2__  //son231122
    if( nFlagLeak12==1  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1  //sylee230807
	    nVRel=4; 
	}
 	if( nFlagLeak12==2  &&  nMod1==nFlagLeak12_VoiNo ){//sylee230315-1 //sylee230807
	    nVRel=4; 
	}
#endif  //son231122


    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629         
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];   //SYLEE130629

    nIGain = (int)dRec[m_nMode1][12];        //SYLEE150123     
   // n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  



    if (nVSet > 20) {//SYLEE141211
        if (nIR == 1) {
            AfxMessageBox("  Error  No 7101.    HV leak  I Range mode1   use   error,    Call Bioptro. ", MB_OK);
            return 0;
        }
    }


    if (nVSet <= 50) {
        if (nProRv1 > 400) {
            nProRv1 = nProRv1 * 0.85;
        }
        else {
            nProRv1 = nProRv1 * 0.96;
        }
    }
    else {
        if (nProRv1 > 1500) {
            nProRv1 = nProRv1 * 0.85;
        }
        else {
            nProRv1 = nProRv1 * 0.97;
        }
    }


    if (nProRv1 < 10) { //sylee141001
        nProRv1 = 10;
    }
    nProRv2 = (int)nProRv1;
    nProRv3 = (int)nProRv1;


    if (nISet < 0.1) {
        AfxMessageBox(" Error No 7710, \n    I Set  ( <0.1 ) SET ERROR !,  Short Start Error!!!");
    }


    Sub71.nADCount1 = (int)dRec[m_nMode1][7];


    if (nIR == 5) {//uA
        InterI = 10.0;
    }
    else {
        InterI = nISet * 0.9;
    }

    //=========================================================================================
    //interlock    

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 1024, \n    CC CV MODE SET ERROR !,   Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 1025, \n    Voltage Set Range Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }

    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 1025, \n    Voltage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,    Run Start Error!!!");
        return 0;
    }



    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 

        //sylee130903 Lo1=200;
    Lo1 = 2000;    //sylee130903  200nS-> 1sec     //sylee201030  100 -> 2000

///sylee140212     Sub71.AOnReadVB1Run1(nVRel);//sylee130802


Task101:

    Sub71.AOnReadVB1Run1(nVRel);


    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;


    if (Simulator100 != 7) {
        if (Sub71.V1 > 300) {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();
            if (nSelfTestHWError1 != 1)
            {

                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1301,\n\n  고압전압 설정안되었습니다. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1301,\n\n  high voltage set error. Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }

                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            return 0;
        }

#ifdef _PC_TEST_
        Sub71.V1 = nVSet;       //son220927 PC_TEST에서 HW Check 에러 무시하기 위함.
#endif
        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
            if (Lo1-- > 0) {
                //SYLEE121019 Sub71.Delay_100ns(100000);  //10ms   
                Sub71.Delay_100ns(10000);  //1ms   //SYLEE121019
                goto Task101;
            }

            PowerCheckError1();

            if (nSelfTestHWError1 != 1) {

                if (nG_Language != 2) {//SYLEE150707
                    str.Format("Error No 1313,\n \n\n 전압 설정이 안되었습니다.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }
                else {
                    str.Format("Error No 1313,\n \n\n voltage set error.  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                }

                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
            }

            //       nProcessFail1=1;

            return 0;
        }
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     

    Sub71.FilterSet(nFil);//sylee130628 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629


    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on        
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.On4W_GainSet(1);

    Sub71.AOnReadV1Enable1(nVRel);    //VC SENSE INIT SET  //SYLEE130119  MOVE
    Sub71.OnPinAllReset1(); //SYLEE150120
    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);    //SYLEE150120 MOVE
    Sub71.Delay_100ns(50000); //SYLEE140212    5mS
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118

//--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    //sylee140923   if( nMod1==2 || nMod1==3 || nMod1==4 || nMod1==5 ){


    //son220927 if (nMod1 == 5 || nMod1 == 6) 
    if (nMod1 == TEST_LEAK1 || nMod1 == TEST_LEAK2) //son220927
    {
    }
    else {
        str.Format("Error No 7213 ,   SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    if (nVSet > 20) {
        nLoop = 1;
    }
    else {
        nLoop = 0;
    }

    nEt_StepSumTemp = 0;  //sylee130410

//=============================================================================================
    int  nDisable;
    nDisable = 0;

    for (int ip2 = 1; ip2 <= ipEnd; ip2++) {
        //son 해당 piece가 Disable이면  테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {
                nDisable = 1;
            }
        }
    }

    ipEnd = 1;
    ipFlag = 0;
    nHVIADCFlag = 1;
    nDisableFlag1 = 0;//sylee150527-2

    int nT1, nT2, nT3, ip3, nCo10;

    nT1 = nShortPinRe2[0][0];
    nShortPinRe3[0][0] = nShortPinRe2[0][0];

    if (nT1 > 0) {
        for (int i1 = 1; i1 <= nT1; i1++) {  //short net
            nT2 = nShortPinRe2[i1][0];  //

            nCo10 = 0;
            nShortPinRe3[i1][0] = nCo10;

            for (int i2 = 1; i2 <= nT2; i2++) {

                nT3 = nShortPinRe2[i1][i2] + 1;
                //ip3=g_nPinPieceNo[1][nT3];//PIECE  piece no

                ip3 = nPinToPiece(nT3);//SYLEE171225-2        //son190704-4WDUT16

                if (nDisable == 1) {
                    //son 해당 piece가 Disable이면  테스트 의미없음
                    if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                        continue;
                    }
                }
                nCo10++;
                nShortPinRe3[i1][nCo10] = nShortPinRe2[i1][i2];
                nShortPinRe3[i1][0] = nCo10;

            }
        }
    }



    int nShortPinRem1[2001];

    ::ZeroMemory(&nShortPinRem1, sizeof(nShortPinRem1));//sylee150622

//  int nT1,nT2,nT3,ip3,nCo10;
    nT1 = nShortPinRe3[0][0];
    nCo10 = 0;

    for (int i1 = 1; i1 <= nT1; i1++) {
        nT2 = nShortPinRe3[i1][0];
        for (int i2 = 2; i2 <= nT2; i2++) {
            nCo10++;
            nShortPinRem1[nCo10] = nShortPinRe3[i1][i2];
            nShortPinRem1[0] = nCo10;
        }
    }


    int  t1, t3, t7, t9, t5;//sylee150611-2
    t3 = 0;    t1 = 0;    t5 = 0;

    nRCount = nBDLData3[1][0][1];
    //t7=nShortPinRe1[0];
    for (int ik1 = 1; ik1 <= nRCount; ik1++) {

        nT3 = nBDLData3[1][ik1][1] + 1;
        //ip3=g_nPinPieceNo[1][nT3];//PIECE  piece no   

        ip3 = nPinToPiece(nT3);//SYLEE171225-2   //son190704-4WDUT16
        t9 = nShortPinRem1[0];
        t3 = 0;
        //  nT3=nT3-1;

        for (int i9 = 1; i9 <= t9; i9++) {
            t7 = nShortPinRem1[i9];
            if (nT3 == t7) {
                t3 = 1;
                break;
            }
        }

        if (t3 == 1) {
            t5++;
            continue;
        }

        if (nDisable == 1) {
            //son 해당 piece가 Disable이면  테스트 의미없음
            if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {
                continue;
            }
        }

        t1++;
        nPinL2[t1] = nBDLData3[1][ik1][1];
        nPinL2[0] = t1;


    }//end of for( int ik1=1; ik1<=nRCount; ik1++){


    nDisableFlag2 = 1;


    //====================================================================================================================================

    ipEnd = 1;//sylee150622
	nFlagLeakMPin1=1;  //sylee230526  //sylee230817
//====================================================================================================================================
    for (int ip = 1; ip <= ipEnd; ip++) {
        if (nRCount <= 0) {
            //ERROR DEBUG   PIECE=ip NO LIST.
            continue;//sylee20120402
        }

        nEtemp1 = 0;
        nECount = 0;
        nFailL1CoPiece = 0;
        nEt1 = 0;
        nShort2FailFlag1 = 0;

        if (nDisableFlag1 == 1) {//sylee150527-2
            nRCount = nPinL[0]; //sylee150527-2
        }
        else {//sylee150527-2
            nRCount = nBDLData3[1][0][1];
        }//sylee150527-2


        if (nDisableFlag2 == 1) {//sylee150611  //sylee150618  2->1
            nRCount = nPinL2[0]; //sylee150611             
        }//sylee150611 

        if (nRCount < 1) {//sylee150423-3
            str.Format("Error No 7513-5 ,   SET ERORR   Net List <1,  ,    piece pin no set check?   HV SQUARE  COUNT = ZERO   n");
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            return 0;
        }


        n2N1_Loop = 0;//sylee150423-3

        for (ik = 0; ik <= 200; ik++) {//sylee150423-3   
            if (ik > 0) {
                nTmp1 = nTmp1 * 2;
            }
            else {
                nTmp1 = 1;
            }
            if (nTmp1 > nRCount) {
                n2N1_Loop = ik;
                break;
            }
        }

        nEt_StepSumTemp = nEt_StepSumTemp + n2N1_Loop;  //sylee150423-3  //sylee150508  nEt_StepSumTemp+

        if (nFlagEstModelMake > 0) {  ///sylee151109-3 
            if (ip == ipEnd) {
                nEt_StepSum = nEt_StepSumTemp;//sylee130410
            }
        }///sylee151109-3 


        Sub71.OnPinAllReset1(); ///PIN ALL RESET 

        nHVDStopTime1 = (long)GetuSecond();//sylee121103


        int nCo1, nCoSum1, nCo1Tog;
        int nPin1, nPin2;
        int nDisable1, t1, t2;//sylee151120

        nDisable1 = 0;//sylee151120

        for (ip2 = 1; ip2 <= g_nPieceMax1; ip2++) {//sylee151120
            if (SysInfo19.m_nUse == 1) {
                //son 해당 piece가 Disable이면  테스트 의미없음
                if (SysInfo19.m_nData[nBlockCountP][ip2] == 1) {//sylee151120
                    nDisable1 = 1;//sylee151120 
                }
            }
        }

        for (int nStep = 1; nStep <= n2N1_Loop; nStep++) {    //X // Second LOOP   vc pin 

            nCoSum1 = (int)pow(2, (nStep - 1));



            for (int nk1 = 1; nk1 <= nRCount; nk1++) {

                //  if(nk1==76||nk1==147||nk1==218 || nk1==289){
                //     continue;//sylee150622//testmode
                //  }
                if (nk1 == 1) {
                    nCo1 = 0;
                    nCo1Tog = 0;
                }
                if (nCo1 <= nCoSum1) {
                    nCo1++;
                }
                if (nCo1 > nCoSum1) {
                    nCo1 = 1;
                    if (nCo1Tog == 0) {
                        nCo1Tog = 1;
                    }
                    else  if (nCo1Tog == 1) {
                        nCo1Tog = 0;
                    }
                }

                if (nCo1Tog == 0) {
                    if (nDisableFlag1 == 1) {//sylee150527-2
                        nPin1 = nPinL[nk1]; //sylee150527-2
                    }
                    else if (nDisableFlag2 == 1) {//sylee150611
                        nPin1 = nPinL2[nk1]; //sylee150611
                    }
                    else {//sylee150527-2
                        nPin1 = nBDLData3[1][nk1][1];
                    }//sylee150527-2

                    //sylee150622} 
                    if (nDisable1 == 1) {//sylee151120                             
                        t1 = nPin1 + 1;//PIECE  pin no
                       // t2=g_nPinPieceNo[1][t1];//PIECE  piece no
                        t2 = nPinToPiece(t1);//SYLEE171225-2 //son190704-4WDUT16

                        //son 해당 piece가 Disable이 아니면 pin 설정
                        if (SysInfo19.m_nData[nBlockCountP][t2] != 1) {//sylee151120
                            Sub71.AOnPinSet1(2, nPin1, 1); //=1Vb  
                        }
                        else {
                            nPin1 = nPin1;
                        }
                    }
                    else {
                        Sub71.AOnPinSet1(2, nPin1, 1); //=1Vb  
                    }

                    nPinSetSkipVbCnt++; //sylee151005 //ACE400                  //son230127
                    if (nPinSetSkipVbCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                        nPinSetSkipVb = 3; //sylee151005 //ACE400               //son230127
                    }
                }



                if (nCo1Tog == 1) {
                    //sylee150622
                     /*if( ipFlag==1 ){//short   PIECE MULT.
                            if(nDisableFlag2==1){//sylee150611
                                 nPin2=nPinL2[nk1]; //sylee150611 //sylee150618  1->2
                            }else{
                                 nPin2=(*g_pvBDLData31[1][ip])[nk1].wFirstPin ;
                            }
                      }else{
                     */
                    if (nDisableFlag1 == 1) {//sylee150527-2
                        nPin2 = nPinL[nk1]; //sylee150527-2
                    }
                    else if (nDisableFlag2 == 1) {//sylee150611
                        nPin2 = nPinL2[nk1];  //sylee150611
                    }
                    else {//sylee150527-2
                        nPin2 = nBDLData3[1][nk1][1];
                    }//sylee150527-2                    

                    //sylee150622} 
                    if (nDisable1 == 1) {//sylee151120                             
                        t1 = nPin2 + 1;//PIECE  pin no
                      //  t2=g_nPinPieceNo[1][t1];//PIECE  piece no
                        t2 = nPinToPiece(t1);//SYLEE171225-2 //son190704-4WDUT16

                        //son 해당 piece가 Disable이 아니면 핀 설정
                        if (SysInfo19.m_nData[nBlockCountP][t2] != 1) {//sylee151120
                            Sub71.AOnPinSet1(2, nPin2, 2); //=1Vb  
                        }
                        else {
                            nPin2 = nPin2;
                        }
                    }
                    else {
                        Sub71.AOnPinSet1(2, nPin2, 2); //=1Vb  
                    }

                    nPinSetSkipVcCnt++; //sylee151005 //ACE400                  //son230127
                    if (nPinSetSkipVcCnt == 1) {//sylee151005 //ACE400==2){     //son230127
                        nPinSetSkipVc = 3; //sylee151005 //ACE400               //son230127
                    }
                }

            }  //end of for( int nk1=1; nk1<=nRCount ; nk1++){
//=========================================================================================================
//=========================================================================================================


               //    if(SysInfo05.m_nSp==1){
               //    if(SysInfo05.m_nSparkSet>0){   
//SPARK############################################################################################        
/*                   if(nSparkUse==1){
                         if( nFailL1CoPiece<SysInfo05.m_nIsEr){   //SPARK
                                ret1=Sub71.OnSparkStatus();
                                if(ret1==1){
                                    Sub71.OnSparkOn(0);
                                    //str.Format("Error No 7502,     Spark Detect   !  "   );
                                     str.Format("Error No 7502,  2N- Spark Detect!  Pin=%d " ,nSQNet1[ik+1][ih]+1  );
                                     m_list1.AddString(str);
                                     nlist1++;
*/

//SPARK############################################################################################

    /*                              if(nFailL1Co<3000){////SPARK


                                            nFailCount[nMod1]=nFailCount[nMod1]++;
                                            //log buffer
                                            nFailL1Co++;
                                            nFailL1CoPiece++;
                                            nFailL1[nFailL1Co][1]=nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  //USHORT  SHORT  HR HV
                                            nFailL1[nFailL1Co][2]=nBlockCountP;//block

                                            nFailL1[nFailL1Co][5]=nSQNet1[ik+1][ih]+1 ;//pin  vb
                                            nFailL1[nFailL1Co][4]=-1;//pin  vc

                                            t1=nSQNet1[ik+1][ih]+1;//PIECE  pin no

                                        //  t1=g_nPinPieceNo[1][t1];//PIECE  piece no
                                            t1=nPinToPiece(t1);//SYLEE171225-2  //son190704-4WDUT16
                                            nFailPiece[t1][nPStep1]++;////PIECE  error count //sylee20120314
                                            nFailL1[nFailL1Co][3]=t1;////PIECE  no   //sylee20120314
                                            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            nShortFail1[t1]++;//sylee20121018//100=piecemax
                                            nShortFail1Flag1=1;//sylee20120921//100=piecemax
                                            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                            nFailL1[nFailL1Co][6]=-1 ;//Sub71.R1
                                            nFailL1[nFailL1Co][17]=nProRv1;//nProRv1 판정 R
                                            nFailL1[nFailL1Co][7]=nProRv1Real;//nProRv1 판정 R    //SYLEE20120303

                                            nFailL1[nFailL1Co][8]=nProStep1[nMod1][1];
                                            nFailL1[nFailL1Co][9]=nVSet;
                                            nFailL1[nFailL1Co][10]=nISet;
                                            nFailL1[nFailL1Co][11]=m_nMode1;
                                            nFailL1[nFailL1Co][12]=-1;//Sub71.V1;//VB
                                            nFailL1[nFailL1Co][13]=-1;//Sub71.X1;//VC
                                            nFailL1[nFailL1Co][14]=-1;//Sub71.Y1;//I
                                            nFailL1[nFailL1Co][16]=nMod1;//I  //open ushort short hr hv   4w

                                            nShortFlag=1;//sylee120915

                                            Sub71.OnSparkOn(1);


                                            if(nProOneP_RunFlag1==1){//sylee140514
                                                if(nReSheetFlag1!=1){//sylee140514
                                                    if( nProOneP_Flag1==2 || nProOneP_Flag1==3){
                                                         nProOneP_RunFlag1=0;
                                                         goto TaskEnd100;
                                                    }
                                                }
                                            }

                                            Sub71.Delay_100ns(nErrorDelayTime1);//1mSEC
                                    }   //end of if(nFailL1Co<3000){ //SPARK
*/
//SPARK############################################################################################                                 
/*

                                }// if(ret1==1){

                                }//if( nFailL1CoPiece<SysInfo05.m_nIsEr){    //SPARK

                            }//end of  if(nSparkUse==1){
*/
//SPARK############################################################################################

            if (nFastHv1RunStep == 1) {//sylee150415 fasthv                     
                nFastHv1AdRun = 1;//sylee150415 fasthv                               
            }
            else {
                nFastHv1AdRun = 0;//sylee150415 fasthv   
            }

            tStart5001 = Get_uSecond1();//uS   //sylee150509-1
          //#1-1 
            if (nEstUse == 1 && SysSet16.m_nSet11 == 1 && nEstEnableHv == 1) {//sylee130325     //sylee150407                  
                AHV_ADCI_Read1_EST1(nProRv2, nDelay10);  //sylee130107  //estimation
            }
            else {
                AHV_ADCI_Read1_OneToM(nProRv2, nDelay10, 1);//sylee150227
            }


            Sub71.OnPinAllReset1(); ///PIN ALL RESET 

            if (Sub71.R1 > nProRv2) {// FAIL
                n2N1_Fail1 = 1;//sylee150423-1
                //testmode
                goto TaskEnd100;
                //break;
            }


            if (nFastHv1RunStep == 1) {//sylee150415 fasthv
                if (nFastHv1AdRun == 1) {
                    if (nFastHv1AdReturn == 1) {//sylee150415 fasthv
                        nFailFlag1 = 0;  // ALLPASS
                        nFastHv1Piece[ip] = 1;
                        nFastHv1PieceReturn = 1;//sylee150415
                       // goto TaskEnd300;
                    }
                }
            }
            //TaskEnd300://sylee150415 fasthv
            Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        }//end of for( int nStep=1; nStep<=n2N1_Loop ; nStep++){    //X // Second LOOP   vc pin 


    }  //end of    for( int ip=1; ip<=ipEnd; ip++ ){   





TaskEnd100://sylee130927 one-piece//sylee131221


    tStart1001 = GetuSecond();//SYLEE150426-2


    if (nFastHv1RunStep == 1) {//sylee150415 fasthv
        if (nFastHv1PieceReturn == 1) {
            nFastHv1RunStep = 2;//sylee150415 fasthv
        }
    }

    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET    

//::ShellExecute(NULL,"close","EXCEL.EXE","d:\\LOG\\PRO1\\HVLEAK1.CSV","NULL",SW_SHOWNORMAL);

    tStart322 = GetuSecond();//TESTDEBUG
    tStart323 = (tStart322 - tStart321);//TESTDEBUG


    if (n2N1_Fail1 == 0 && nPStep1 == nFlag_HV_SetEnd) {
        //sylee170115-1nFlag_HV_SetEnd_Skip=1;//sylee150427    0=idle, 1=skip 
        nFlag_HV_SetEnd_Skip = 0;//sylee170115-1

        Sub71.Delay_100ns(30000); //sylee170115-1
        Sub71.OnDisChargeVB(1);//sylee170115-1
        Sub71.AVB_CheckOut1(1, 2);//sylee170115-1
        Sub71.OnDisChargeVB(0);//sylee170115-1

    }
    else {
        nFlag_HV_SetEnd_Skip = 0;//sylee150427    0=idle, 1=skip 

        Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
        Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720
        Sub71.FilterSet(0);//sylee130704 
        Sub71.I_Filter(0);//sylee130704
        Sub71.AOnReadV1Enable1(5);

        /*  //sylee170411
         if( (SysInfo05.m_nProSpMode !=4)  &&  (SysSet13.m_nSet17!=1)  ){//sylee150425-1
             Sub71.Delay_100ns(30000); //3mS  //sylee140823
             Sub71.OnDisChargeVB(1);//sylee140212 
             Sub71.AVB_CheckOut1(1);//SYLEE150210 //ACE380    FAIL =0  , PASS=1
             Sub71.OnDisChargeVB(0);//sylee140212 
         }else{//sylee150420-2
         *///sylee170411
        Sub71.OnDisChargeVB(1);

        if (n4WSetFlag1 == 1) {//sylee150721-3
            nFastHv1_HV_VSet = 15;
        }
        Sub71.AVB_CheckOut1(1, 101, nFastHv1_HV_VSet);  //SYLEE150420-2  
        Sub71.OnDisChargeVB(0);
        //  }//sylee150420-2

    }


    //sylee150426-1=====================================================

    if (n2N1_Fail1 == 1) {//SYLEE150423-3
        return 2;
    }

    // Sub71.AOnReadVB1Run1(nVRel); //test

    Sub71.OnPinResetInit();//sylee151221   //ACE400

    nPinSetSkipVb = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee160803 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee160803 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee160803 //ACE400    //son230127
    nFlagLeakMPin1=0;  //sylee230526  //sylee230817

    return 1;

}




int CChildView7::ARun201_S2_SQ2_HV_Re_VB_Finish()//sylee150427 
{

    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(3);//SYLEE20120720

    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704
    Sub71.AOnReadV1Enable1(5);

    Sub71.Delay_100ns(30000); //3mS  //sylee140823
    Sub71.OnDisCharge1(); //sylee170725-3 

    Sub71.OnPinResetInit();//sylee151221   //ACE400

    return 1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CChildView7::ARun201_O11_SetStart(int m_nMode1) //sylee150427
{

    double nISet, nISetPercentHigh, nVBSetPercentHigh, nVBSetPercentLow;
    double nISetPercentLow, dVbR1, dVbR2;
    int nDelay10, nFil, nIFilter, nHVOffSet, nHVGain, nIGain, n4wGain, nDelay20, Lo1;
    CString str;

    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];
    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629 

    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
    n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  

    nDelay20 = (int)dRec[m_nMode1][6] - 22; //sylee140407 

    nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
    nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914

    nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
    nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914


    //_ACE380_150128
    ///*******************************************************                 
    nIGain = (int)dRec[m_nMode1][12];       //ACE380 //SYLEE150123
    //if( nMod1==1 ){//sylee20120306
    if (nVSet > 20) {
        nVRel = 4;   //VB RELAY   4
    }
    //} 


    //ADC COUNT
    Sub71.nADCount1 = (int)dRec[m_nMode1][7];
    if (Sub71.nADCount1 < 1) {
        Sub71.nADCount1 = 1;
    }
    if (Sub71.nADCount1 > 100) {
        Sub71.nADCount1 = 100;
    }

    if (m_nMode1 < 1) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  <0 !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (m_nMode1 > 200) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  >200 !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 7704, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 7705, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }

    Lo1 = 200;//sylee130903  200nS-> 1sec

Task101:

    //SYLEE20111213 Sub71.AOnReadVB1(nVRel);   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
    Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
    if (nVSet <= 5) {
        dVbR2 = nVSet * (0.35);//35%
    }
    else {
        dVbR2 = nVSet * (0.1);//10%
    }
    dVbR1 = nVSet - dVbR2;
    dVbR2 = nVSet + dVbR2;
    if (Simulator100 != 7) {
        if (Sub71.V1 > 300) {
            if (Lo1-- > 0) {
                Sub71.Delay_100ns(10000);  //1ms //sylee121019  10->1mS  
                goto Task101;
            }
            str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            nSelfTestHWError1 = 1;
            return 0;
        }

        if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
            if (Lo1-- > 0) {
                Sub71.Delay_100ns(10000);  //1ms   //sylee121019  10->1mS   
                goto Task101;
            }
            str.Format("Error No 1311,\n \n\n  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str);
            if (nBlockCountP >= 1) {
                nBlockCountP = 1;
            }
            nSelfTestHWError1 = 1;
            return 0;
        }
    }


    if (nFil == 1 || nFil == 2) {//SYLEE130628
        Sub71.AOnReadV1Enable1(nVRel);
    }
    else {
        Sub71.AOnReadV1Enable1(5);
    }

    if (nFil == 3) {//hv open
        //sylee140226   Sub71.HV_OffSet(nHVOffSet); 
        //sylee140226   Sub71.HV_Gain(nHVGain); 
        Sub71.HV_OffSet_Gain(nHVOffSet, nHVGain);    //sylee140226
    }
    Sub71.FilterSet(nFil);//sylee130628 
    if (nIFilter == 3) {
        AfxMessageBox(" Errro No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
        nIFilter = 1;
    }
    Sub71.I_Filter(nIFilter);//sylee130629

    if (nIGain == 2) {//sylee150123 //ACE380
        Sub71.I_Gain(2);  //10x  =io on     
    }
    else {
        Sub71.I_Gain(1);  //1x  =io off
    }

    Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);


    int nPin11;//sylee141017-1

    //ACE380TESTMODE    nPin11=rand()%(128*10);
    nPin11 = rand() % (64);

    //son230825 if (SysSet13.m_nPinBlockType == PIN_BLK_32K_TRANS //son190902 32KPIN    //son230216_1
    //son230825         || SysSet13.m_nPinBlockType == PIN_BLK_32K_ORG)   //son230216_1
    {
        //son HW적으로 pin 1~ 64 사이의 pin이 꽃혀 있는지를 확인하는 것이므로 
        //    HwPin 변환을 거치지 않고 고정값인 1~64를 써야 한다.  그래서  type 1로 호출함.
        Sub71.OnPinAllReset1(); ///PIN ALL RESET 
        Sub71.AOnPinSet1(1, nPin11, 1); //=1Vb, 
        Sub71.AOnPinSet1(1, nPin11, 2); //=1Vb,
    }
    //son230825 s100-1에서 상부 첫번째 block이 없는 .CON을 가진 BDL일때 여기에 걸려서 7703 Pin Map 에러 다수 발생하고
    //   SW 죽여야 다시 사용할 수 있는 문제 발생. (230825) pin변환 없이 첫번째 카드 정상을 체크하고자 하는 것이므로  
    //   AOnPinSet1(1, nPin11, 1); 하는 코드만 남기고 아래 코드는 삭제.  
    //else
    //{
    //    Sub71.OnPinAllReset1(); ///PIN ALL RESET 
    //    Sub71.AOnPinSet1(2, nPin11, 1); //=1Vb, 
    //    Sub71.AOnPinSet1(2, nPin11, 2); //=1Vb,
    //}

    for (int j1 = 1; j1 <= 1000; j1++) {
        Sub71.Delay_100ns(1000); //100us
        Sub71.AOnReadV1I1_ADC_I();
        if (Sub71.R1 > 1000) {
            break;
        }
        if (j1 == 1000) {
            Sub71.OnPinAllReset1(); ///PIN ALL RESET 

            int nCard, nPin;
            nPin11 = PinMap[2][nPin11];
            nCard = (int)(nPin11 / 128) + 1;
            nPin = (int)(nPin11 - (int)((nCard - 1) * 128)) + 1;

            PowerCheckError1();

            if (nG_Language != 2) {//SYLEE150707
                str.Format(" Error No 7011.   임의의 핀으로  오픈 검사를 할수 없습니다.    \n\n  (지그핀 =%d)  \n\n  스위치카드번호=%d, 스위치카드핀번호=%d    \n\n 알려준 스위치카드를 확인 바람 (스위치카드 전원,장착,교체등으로 확인 )!  ", nPin11 + 1, nCard, nPin);
            }
            else {
                str.Format(" Error No 7011-13.    Error pin  can't open test!   \n\n  ( jig pin no=%d)  \n\n switch card no =%d, switch card pin no=%d    \n\n  switch card  check! ( power on?  change check? )!  ", nPin11 + 1, nCard, nPin);

            }
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str, MB_OK);

        }
    }


    Sub71.OnPinAllReset1(); ///PIN ALL RESET 


    return 1;


}


int CChildView7::ARun201_O11_Finish(int m_nMode1) //SYLEE20111212  //SETUPCALIBRATION
{

    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];

    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018

    Sub71.FilterSet(0);//sylee130704 
    Sub71.I_Filter(0);//sylee130704
    Sub71.ARunoff1();//sylee20111020//vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);//SYLEE20120720      

    if (nVSet > 20) {//SYLEE131221   
      /*//sylee170411
       if( (SysInfo05.m_nProSpMode !=4)  &&  (SysSet13.m_nSet17!=1)  ){//sylee150425-1
                Sub71.Delay_100ns(30000); //3mS  //sylee140823
                Sub71.OnDisChargeVB(1);//sylee140212 
                Sub71.AVB_CheckOut1(1);//SYLEE150210 //ACE380    FAIL =0  , PASS=1
                Sub71.OnDisChargeVB(0);//sylee140212 
        }else{//sylee150420-2
        *///sylee170411
        Sub71.OnDisChargeVB(1);
        Sub71.AVB_CheckOut1(1, 102, nFastHv1_HV_VSet);  //SYLEE150420-2  
        Sub71.OnDisChargeVB(0);
        //sylee170411}//sylee150420-2
    }
    Sub71.AOnReadV1Enable1(5); //sylee130711

    return 1;

}




/*
BOOL CheckDirExist(char *pn)
{
    CFileFind fn;
    char buf[FILE_PATH_SIZE];   //son210420 100-> FILE_PATH_SIZE
    int nextfile;

    sprintf(buf,"%s\\*.*", pn);

    if( !fn.FindFile(buf,0) )
    {
        return FALSE;
    }
    nextfile = fn.FindNextFile();
    while(1)
    {
        if( fn.IsDirectory() )
            if( !fn.IsDots() ) return FALSE;
        if(!nextfile) break;
        nextfile = fn.FindNextFile();
    }
    return TRUE;
}
*/

//son-RESHEET-20200225 신규추가
//son 맨 마지막 블록까지 도달했다면, 4W csv 로그를 출력한다.
void CChildView7::ifLastBlock_Log4WCsv(bool bUseTimer)
{
    if (n4WSetFlag1 != 1)
        return;

    if (nBlockMaxLast1 <= 1) {
        nBlockMaxLast1 = nBlockMax;
    }
    if (nBlockMaxLast1 > nBlockMax) {
        nBlockMaxLast1 = nBlockMax;
    }
    MyTrace(PRT_LEVEL2, "ifLastBlock_Log4WCsv(): nBlockMax=%d, nBlockMaxLast1=%d, nBlockCountP=%d\n",
            nBlockMax, nBlockMaxLast1, nBlockCountP);


    //son 맨 마지막 블록까지 도달한게 아니면 리턴
    if (nBlockCountP != nBlockMaxLast1)     //son220707 PieceDisable때문에 가용블록 수가 줄어들 수 있으므로 
        return;                             //          4W Csv 파일은  nBlockMax가 아니라 nBlockMaxLast1 기준으로 체크해야 한다.

    //son220804_2  begin: 
    //   RESHEET시에 이전 4W Csv 파일 삭제 기능을  Check_DIN_StartResheet()-> ifLastBlock_Log4WCsv()로 이동 
    //   블록 끝까지 테스트 안 끝났는데  START+TEST가  중간에 들어오는 예외 케이스를 고려해야 함.  
    //   이전에 Resheet 단계를 마지막 블록까지 가지 못해서 CSV 파일을 만들지 못했는데,  
    //   이전 4W CSV만  지워 버려서  4W CSV 하나를 잃어버리는 문제점 보완.

    //son Resheet 상태라면 바로 직전에 작성한 4W CSV 파일을 삭제하고 새로 만든다.
    if (nReSheetFlag1 == 1 && n4WSetFlag1 == 1 && n4w_Sample_Enable != 1) //son220804_2
    {
        //son210420 begin: RESHEET시에 이전 4W Csv 파일 삭제 기능 추가
        //   RESHEET가 수신되더라도 4W 로그는 1회만 남겨 달라는 영풍 요구사항 관련 수정안. 
        //   RESHEET 수신시 가장 최근의 4w Log file을  지운다.  d4W_Log1[][] 데이터는 지우지 않는다.
        //   Check_DIN_StartResheet() 이후 과정을 계속 진행하면 현재 d4W_Log1[][]에서  fail된 블록에 대해서만 
        //   TEST가 진행되고 해당 data로 "D:\\log4w\ " 하부의 4W Log가 업데이트 된다.
        if (SysSet13.m_n4wLogMode == _4W_LOG_COL) //son LogMode가 바이옵트로 전용 4w Csv 일때   //son230323
        {
            //son220624_3 RESHEET시에 이전 파일 삭제 기능은 현재 DUT에만 하는게 맞다.
            //            현재 DUT만 삭제하도록  1 DUT 구조로 원상복구 
            if (FileExists(g_LastD_Log4w_ResheetfName) != FALSE)
            {
                MyTrace(PRT_LEVEL1, "Delete for RESHEET PrevLast 4WLog %s\n", g_LastD_Log4w_ResheetfName);
                DeleteFile(g_LastD_Log4w_ResheetfName);
            }
        }
    }   //son210420 end
    //son220804_2 end


    //son210420  RESHEET와 상관 없이 마지막 블록이면  로그하고,  만약 RESHEET 수신되면 해당 로그를 지우고 다시 작성하기로 한다.
    //son 현재 블록이 맨 마지막 블록이므로 4W csv 로그를 생성한다.
    Log4WCsv(bUseTimer);

}


//son nDriveType   0: CSV_4W_ALL, 1: CSV_4W_Z_DRV, 2:CSV_4W_D_DRV
void CChildView7::Log4WCsv(bool bUseTimer, int  nDriveType) //son200821-RESHEET기능보완
{
    //son211215 MyTrace(PRT_LEVEL2, "Log4WCsv(DrvType=%s).........\n", 
    //                 (nDriveType == CSV_4W_ALL) ? "ALL":
    //                 (nDriveType == CSV_4W_Z_DRV) ? "Z_Drv": "D_Drv");

    //son-RESHEET-20200225 신규 추가
    //son bUseTimer true 설정시에는 100ms Delay를 주고 CSV log한다.
    if (bUseTimer == true)
        SetTimer(VIEW7_TIMER_4W_LOG, 100, NULL);

    else
        //son 4W data 결과 파일에 d4W_Log1[][]를 write
        //son     ex)  D:\\log4w\\Log4W_%04d%02d%02d_%02d%02d%02d_ALL_Ok.CSV  
        ARun201_4w_Logging2_Sheet(nDriveType);     //SYLEE150722        //son200821-RESHEET기능보완
}



//---------------------------------------------------
//son 4W data 결과 파일에 d4W_Log1[][]를 write
//---------------------------------------------------

//son200610 bZDriveOnly 체크 기능 추가
//     bZDriveOnly 를 defaut 매개변수 false 로 CChilView 클래스 헤더에 등록했으므로 
//     기존대로 ARun201_4w_Logging2_Sheet()로 호출하면 3가지 CSV 파일이 생성되고
//     ARun201_4w_Logging2_Sheet(CSV_4W_Z_DRV)로 호출하면 Z 드라이브용 CSV만 출력된다.
//
//son200821 bZDriveOnly를 nDriveType으로 변경하여 D 드라이브만 CSV 출력하는 기능을 추가함.
//         CSV_4W_ALL   : D, Z, Total 모두 생성
//         CSV_4W_Z_DRV : Z 드라이브만 생성 
//         CSV_4W_D_DRV : D 드라이브, Total 생성

//son nDriveType   0:CSV_4W_ALL, 1:CSV_4W_Z_DRV, 2:CSV_4W_D_DRV
//
//son return value 
//   -1: 비정상으로 바로 리턴
//    0: 정상인데 바로 리턴 
//    1: 함수 끝까지 진행하고 마지막에 리턴
int CChildView7::ARun201_4w_Logging2_Sheet(int nDriveType)     //SYLEE150722  //son200821-RESHEET기능보완
{


    //son200821 4W test가 설정이 안 된경우라면 log 안하도록 보완
    if (n4WSetFlag1 != 1)
        return -1;


    //    MyTrace(PRT_LEVEL3, "ARun201_4w_Logging2_Sheet(DrvType=%s).........\n",   //son220502 comment로 삭제. 프린트줄이기
    //            (nDriveType == CSV_4W_ALL) ? "ALL":
    //            (nDriveType == CSV_4W_Z_DRV) ? "Z_Drv": "D_Drv");


    int nEnd_nBlock;//sylee170417-1
    if (nBlockMaxLast1 <= 1) {//sylee170417-1
        nBlockMaxLast1 = nBlockMax;
    }
    if (nBlockMaxLast1 > nBlockMax) {//sylee170417-1
        nBlockMaxLast1 = nBlockMax;
    }

    nEnd_nBlock = nBlockMaxLast1;//sylee170417-1

    if (nEnd_nBlock != nBlockMax) {//sylee201023
        nEnd_nBlock = nBlockMax;
    }

    CString strfName1;

    //---------------------------------------
    // 1) D 드라이브 4W 기본 CSV 로그 출력   
    //---------------------------------------
    int ret;

    //son200708-4WDUT16 : bug Fix
    // "D:\\log4w\\" 폴더에 현재 dutIdx에 해당하는  4W CSV Log 를 생성한다.
    if (nDriveType == CSV_4W_ALL        // Z Drive에만 로그하는 옵션이 켜 있다면 기본 CSV 로그는 안한다.
        || nDriveType == CSV_4W_D_DRV)  //son200821-RESHEET기능보완 
    {
        ret = 1;
        if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE 
                || SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT)    //son220304  //son230704
            //son201209: 4W Log CSV 파일 재사용. 파일 하나에 READ사와 비슷하게  Line으로(가로방향) 누적. 
            ret = Log4WCsv_DDrive_LineWrite(nEnd_nBlock);
#ifdef __MST__CUSTOMER  
        else if (SysSet13.m_n4wLogMode == _4W_LOG_COL_V2_MST)    //son231026 for MST 유니텍
            ret = Log4WCsv_DDrive_ColumnWrite_MST(nEnd_nBlock);
#endif
#ifdef __NANOSYS__CUSTOMER  
        else if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_V2_NANO)    //son231026 for 나노시스 
            ret = Log4WCsv_DDrive_LineWrite_NANO(nEnd_nBlock);
#endif
        else
            //son201209: 4W Log CSV 파일 매번 새로 생성. 기존 바이옵트로 방식으로 Column으로(세로방향) 누적. 
            ret = Log4WCsv_DDrive_ColumnWrite(nEnd_nBlock);

        //son ret가 0 이하면 여기서 바로 리턴
        if (ret <= 0)
            return ret;

        //son ret가 1 이상이면  next 코드로 진행된다.
    }



    //-------------------------------
    // 2) Z 드라이브 CSV 로그 출력
    //-------------------------------


    if (nDriveType == CSV_4W_ALL || nDriveType == CSV_4W_Z_DRV)  //son200821-RESHEET기능보완 
    {
        ret = 1;

        //son MapDisplay->Set1:  IDD_MODE_SET13_SET1 Dialog "Z:\LogSheet4W.CSV" 옵션이 1일때 
        //    Z 공유드라이브로 메인장비에 4WLog를 전송해야 할 경우에 사용함.
        //    모든 step을 한번에 다 출력하므로 Multi DUT별로 쪼개서 저장할 필요는 없다.

 
        if (SysSet13.m_nSet2 == 1)
            ret = Log4WCSV_ZDrive(nEnd_nBlock,1);     //son210215 기존기능을 이 함수로 변경  //sylee241128

        //son MapDisplay->Set1:  IDD_MODE_SET13_SET1 Dialog "Z:\Ultlog.csv" 옵션이 1일때 
        //    Z 공유드라이브로 메인장비에 삼성전기 포맷의 4WLog (ULT Log)를 전송해야 할 경우에 사용함.
        else if (SysSet13.m_nSetUltLog == 1)
            ret = Log4WCSV_ZDrive_UltLog(nEnd_nBlock);       //son210215 삼성전기 포맷  4w Log 출력 

        //son  Map-> Set1-> "Z:\LogSheet4W.CSV", "Z:\Ultlog.csv"  옵션을 모두 끌 수 있어야 한다.

        //son ret가 0 이하면 여기서 바로 리턴
        //if (ret <= 0)       //son210215
        //    return ret;
    }



/*//SYLEE220630_2  영풍베트남 심재영부장 요청 기능. 현재 미사용이므로 삭제함.

    FILE *fp;
    char fName1[200];

    //---------------------------
    // 3) 4W Total CSV 로그 출력
    //---------------------------
    //son "D:\\log4W\\Total_4W_%04d%02d%02d_%02d%02d%02d.CSV"
    ::ZeroMemory(&fName1,sizeof(fName1)); //sylee170808-2 4w
    strcat( fName1 , fName71 );     //son fName71 전역변수

    n4WlogFlagCo1++;//sylee170808-2


    if(n4WlogFlagCo1>1000){
        n4WlogFlagCo1=0;//sylee170808-2
        CTime  curTime = CTime::GetCurrentTime();
        str71.Format("D:\\log4W\\Total_4W_%04d%02d%02d_%02d%02d%02d.CSV",
                            curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                            curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        ::ZeroMemory(&fName71,sizeof(fName71));
        strcat( fName71 , str71 );
    }

    //son210715 DUT 별로 4w.ini의 카운트수가 다를 수 있으므로 maximum 개수의 count로 설정한다.
    //          원칙은 DUT별로 파일을 따로 생성하는 것이 맞다. Pin 정보도 다르고 NetCount도 DUT마다 다를 수 있음.
    //          현재 상태로는 Pin 정보도 어느 DUT의 것인지 특정하기 어려우므로 maximum count인 DUT 정보로 일단 설정한다.
    //int dutIdx=    get4wDutIdx();         //son210715
    //int n4wNetCnt= (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16   //son21715
    int dutIdx = 0;
    int n4wNetCnt = (int)g_s4WNet[0].wCount;
    for (int dut = 0; dut < nMultyNetTotal; dut++)
    {
        if (g_s4WNet[dut].wCount > n4wNetCnt)
        {
            n4wNetCnt=(int)g_s4WNet[dut].wCount;
            dutIdx = dut;
        }
    }   //son210715

    // Z Drive에만 로그하는 옵션이 켜 있다면 Total CSV 로그는 안한다.
    //son Total CSV 로그는 영풍만 사용하는 기능으로 블록별로 4W.ini를 따로 만들어서 Multi DUT를 사용해서
    //    기본 CSV 는 DUT별로 따로 나오지만,  여기 Total Csv에는 모든 DUT를 합쳐서 로그해야 한다.
    //    영풍의 경우에 4W.ini 파일이 DUT별로 따로 있지만 실제로는 내용이 모두 같다.



    if (nDriveType != CSV_4W_Z_DRV)         //son200821-RESHEET기능보완
    {
        if( SysSet13.m_nSet8==1)//sylee171104-5
        {

            fp = fopen(fName1,"at");
            if(fp == NULL){
                //str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ",strfName1);
                str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ",fName1);  //son220701
                AfxMessageBox( str, MB_OK);
                return -1;
            }

            //son  헤더 출력
            //sylee170920   fprintf(fp, "    ,    ,Pin1 ,Pin2 ,Pin3 , Pin4 ,");
            fprintf(fp, "*Step ,%d ,Pin1 ,Pin2 ,Pin3 , Pin4 ,",n4WlogFlagCo1);      //sylee170920

            for(int  block=1; block<=nBlockMax; block++)
            {
                //son210715 현재 DUT에만 해당하는 block만 출력하게 되는 문제가 있어 삭제. Total DUT는 모두 출력해야 함.
                //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
                //if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16       //son210715 베트남 영풍문제점 때문에 삭제
                {
                    //fprintf(fp, "S=%d,   ",  block );
                    //son200525-4WLOG: 4WLog개선, Block에 해당하는 Step 번호 순서로 헤더를 출력한다.
                    fprintf(fp, "S=%d,   ",  g_Map3_BlockStep[block]);
                }

            }
            fprintf(fp, "  \n ");

            //son  Data 출력
            for (int net=1; net<=n4wNetCnt; net++)  //son190704-4WDUT16
            {
                fprintf(fp, "Net %d, Pin,   %d,  %d,    %d, %d,",
                        net,(int)g_s4WNet[dutIdx].saData[net-1].waPin[0], //son190705-DUT16
                        (int)g_s4WNet[dutIdx].saData[net-1].waPin[1],
                        (int)g_s4WNet[dutIdx].saData[net-1].waPin[2],
                        (int)g_s4WNet[dutIdx].saData[net-1].waPin[3]  );

                for( int block=1; block<=nEnd_nBlock; block++)  //  nBlockMax->nEnd_nBlock //sylee170417-1
                {
                    //son210715 현재 DUT에만 해당하는 block만 출력하게 되는 문제가 있어 삭제
                    //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
                    //if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16 //son210715 베트남 영풍 문제점 때문에 삭제
                    {
                        if(d4W_Log1[block][net]<=0.0){//sylee160524-1
                            if(d4W_Log1[block][net]==0.0){
                                d4W_Log1[block][net]=-999999.0;
                            }
                            fprintf(fp, "NG%11.2f, ", -d4W_Log1[block][net]  );   //4WNG//SYLEE181113-1 //son231205_2
                        }
                        else{

                            if(d4W_Log1[block][net]<200000.0){
                                fprintf(fp, "   %11.2f,   ", d4W_Log1[block][net]  );   //son231205_2
                            }
                            else{
                                fprintf(fp, "NG%11.2f, ", d4W_Log1[block][net]  );  //4WNG//SYLEE181113-1   //son231205_2
                            }
                        }
                    }
                }
                fprintf(fp, "  \n ");
            }

            fprintf(fp, "  \n ");
            fclose(fp);
        }//sylee171104-5
    }

*/


    return 1;

}

//son210215 기존 바이옵트로 방식으로 data를 세로로 Write.  "z:\\LogSheet4W.CSV" 이름 사용. 
//          Z드라이브 메인장비 전달용  4W Log CSV 파일 매번 새로 생성. 
//          메인 장비에서는 가져간 즉시  지우므로,  매번 새로 생성해서 write해야 한다.
int CChildView7::Log4WCSV_ZDrive(int nEnd_nBlock, int nType)   //sylee241128  nType
{

	int nStartBlockNo;

    // Map->Set1의  "z:\\LogSheet4W.CSV" 옵션이 On이면 SysSet13.m_nSet2이 설정된다.
    // SysSet13.m_nSet2이 설정되었을 때 하기 function을 수행한다.
    if (SysSet13.m_nSet2 == 0)
        return -1;

    //son210715 DUT 별로 4w.ini의 카운트수가 다를 수 있으므로 maximum 개수의 count로 설정한다.
    //          원칙은 DUT별로 파일을 따로 생성하는 것이 맞다. Pin 정보도 다르고 NetCount도 DUT마다 다를 수 있음.
    //          현재 상태로는 Pin 정보도 어느 DUT의 것인지 특정하기 어려우므로 maximum count인 DUT 정보로 일단 설정한다.
    //int    dutIdx= get4wDutIdx();         //son210715
    //int n4wNetCnt= (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16   //son21715
    int dutIdx = 0;
    int n4wNetCnt = (int)g_s4WNet[0].wCount;
    for (int dut = 0; dut < nMultyNetTotal; dut++)
    {
        if (g_s4WNet[dut].wCount > n4wNetCnt)
        {
            n4wNetCnt = (int)g_s4WNet[dut].wCount;
            dutIdx = dut;
        }
    }   //son210715

    CString strfName1;
    FILE* fp;
    char fName1[FILE_PATH_SIZE];//, fName2[FILE_PATH_SIZE]; 
 
	if(nType==2){   //sylee241128  nType
		strfName1.Format("z:\\4w.txt");//sylee241129  //BNTCH
		nStartBlockNo=nEnd_nBlock;//sylee241129  
	}else{
        strfName1.Format("z:\\LogSheet4W.CSV");
		nStartBlockNo=1;//sylee241129  
	} 

	::ZeroMemory(&fName1, sizeof(fName2));
    strcat(fName1, strfName1); 

    fp = fopen(fName1, "wt");    //sylee181214-1
    if (fp == NULL) {
        str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ", fName1); //son220701
        AfxMessageBox(str, MB_OK);
        return -1;
    }

    fprintf(fp, "    ,Pin1 ,Pin2 ,Pin3 , Pin4 ,  Min., Ref., Max.,");
    for (int block = nStartBlockNo; block <= nEnd_nBlock; block++)   // nBlockMax->nEnd_nBlock  
    {
        //son210715 현재 DUT에만 해당하는 block만 출력하게 되는 문제가 있어 삭제 
        //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
        //if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16   //son210715  삭제
        {
            //fprintf(fp, "S=%d,   ",  block );  

            //son200525-4WLOG: 4WLog개선, Block에 해당하는 Step 번호 순서로 헤더를 출력한다.  
            fprintf(fp, "S=%d,   ", g_Map3_BlockStep[block]);
        }
    }
    fprintf(fp, "  \n ");

    for (int net = 1; net <= n4wNetCnt; net++)   //son190704-4WDUT16
    {
        //son200804: 4W Piece 정보 추가
        //int firstPin1=0, piece1=0;
        //firstPin1  = g_s4WNet[dutIdx].saData[net-1].waPin[0];   //son (1~)
        //piece1     = g_nPinPieceNo[dutIdx+1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)

        fprintf(fp, "Net %d, %d,  %d,  %d, %d,  %11.2f, %11.2f, %11.2f,",   //son231205_2
            net,
            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3],
            g_s4WNet[dutIdx].saData[net - 1].dRefLow,     //son211005
            g_s4WNet[dutIdx].saData[net - 1].dRefAvg,     //son211005
            g_s4WNet[dutIdx].saData[net - 1].dRefHigh); //son211005

        for (int block = nStartBlockNo; block <= nEnd_nBlock; block++) //   nBlockMax->nEnd_nBlock      
        {
            //son210715 현재 DUT에만 해당하는 block만 출력하게 되는 문제가 있어 삭제
            //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
            //if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16       //son210715 삭제
            {
                //son 0이거나 마이너스이면 불량 R 값
                if (d4W_Log1[block][net] <= 0.0) {
                    if (d4W_Log1[block][net] == 0.0) {
                        d4W_Log1[block][net] = -999999.0;
                    }
                    fprintf(fp, "NG%11.2f,  ", -d4W_Log1[block][net]);  //4WNG //sylee181214-1  //son231205_2
                }
                else
                {
                    //son 양품 R 값으로 출력 
                    if (d4W_Log1[block][net] <= 200000.0) {  //sylee200828  100->200    
                        fprintf(fp, "   %11.2f,   ", d4W_Log1[block][net]); //son231205_2
                    }
                    //son R 값이 999999.0이면 역시 불량으로 출력.
                    else {
                        fprintf(fp, "NG%11.2f,  ", d4W_Log1[block][net]);  //4WNG //sylee181214-1   //son231205_2
                    }
                }

            }
        }
        fprintf(fp, "  \n ");
    }

    fprintf(fp, "  \n ");
    fclose(fp);   //sylee181214-1

    return 1;
}




//son210215 삼성전기 포맷의 4WLog를  "z:\\Ultlog.csv" 이름으로 메인장비에 전달한다.  
//          Z드라이브 메인장비 전달용  4W Log CSV 파일 매번 새로 생성. 
//          메인 장비에서는 가져간 즉시  지우므로,  매번 새로 생성해서 write해야 한다.
int CChildView7::Log4WCSV_ZDrive_UltLog(int nEnd_nBlock)
{

    // Map->Set1의  "z:\\Ultlog.csv" 옵션이 On이면 SysSet13.m_nSetUltLog가 설정된다.
    // SysSet13.m_nSet2이 설정되었을 때 하기 function을 수행한다.
    if (SysSet13.m_nSetUltLog == 0)
        return -1;


#if 1 //son231025_2 배준식차장과 협의후 당분간은 son210715 대로 DUT 하나 구조로 가기로 함.   

//son23210715 begin
    //son210715 DUT 별로 4w.ini의 카운트수가 다를 수 있으므로 maximum 개수의 count로 설정한다.
    //          원칙은 DUT별로 파일을 따로 생성하는 것이 맞다. Pin 정보도 다르고 NetCount도 DUT마다 다를 수 있음.
    //          현재 상태로는 Pin 정보도 어느 DUT의 것인지 특정하기 어려우므로 maximum count인 DUT 정보로 일단 설정한다.
    int dutIdx = 0;
    int n4wNetCnt = (int)g_s4WNet[0].wCount;
    for (int dut = 0; dut < nMultyNetTotal; dut++)
    {
        if (g_s4WNet[dut].wCount > n4wNetCnt)
        {
            n4wNetCnt = (int)g_s4WNet[dut].wCount;
            dutIdx = dut;
        }
    }   
//son210715 end
#endif

    CString strfName1;
    FILE* fp;
    char fName1[200];

#if 0 //son231025_2
    //son231025 DUT별로 Ultlog.csv를 따로 만들기로 한다.
    for (int dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++)   //son231025
#endif
    {

#if 0   //son231025_2 배준식차장과 협의후 당분간은 son210715 대로 DUT 하나 구조로 가기로 함.
        //              ULT 로그는 파일하나로 보내야 한다고 함
        if (dutIdx == 0)                                        //son231025
            strfName1.Format("z:\\Ultlog.csv");     
        else                                                    //son231025
            strfName1.Format("z:\\Ultlog_dut%d.csv", dutIdx+1); //son231025
#else
        strfName1.Format("z:\\Ultlog.csv");    //son210715 
#endif

        ::ZeroMemory(&fName1, sizeof(fName1));
        strcat(fName1, strfName1);

        fp = fopen(fName1, "wt");
        if (fp == NULL) {
            str.Format("Error      %s    file open failed!", fName1);
            AfxMessageBox(str, MB_OK);
            return -1;
        }

        //------------------------
        //son Piece 개수 출력
        int pieceCnt = SysInfoPieceRange.m_nPieceCount[dutIdx + 1];

        //son BlockCnt * PieceCnt 개수를 piece 개수로 출력해 준다.
        //    삼성전기 포맷에서의 picece 개수는 계측기입장에서 block * piece 개수이다.
        int block;
        int totPieceCnt = 0;
        for (block = 1; block <= nEnd_nBlock; block++)
        {
            //son 현재 dutIdx에 맞지 않는 블록은  piece count에서 제외한다.
            //son210715 if (g_d4W_Log1_nBlockDutInfo[block] != dutIdx)  //son200320-4WDUT16   //son210715 삭제 
            //son210614    continue;

            totPieceCnt += pieceCnt;
        }

#if 0   //son231025_2 배준식차장과 협의후 당분간은 son210715 대로 DUT 하나 구조로 가기로 함.
        fprintf(fp, "DUT_%d Total Piece Cnt,  %d\n", dutIdx+1, totPieceCnt); //son231025
#else
        fprintf(fp, "Total Piece Cnt,  %d\n", totPieceCnt); //son210715
#endif


        //------------------------
        //son Pin Info 헤더 출력

        int piece = 0;
        int net;
        int firstPin1 = 0, netPiece = 0;
        for (block = 1; block <= nEnd_nBlock; block++)
        {
            //son 현재 dutIdx에 맞는 block만 헤더 출력한다.
            //son210715 if (g_d4W_Log1_nBlockDutInfo[block] != dutIdx)  //son200320-4WDUT16   //son210715 삭제 
            //son210715     continue;

            for (piece = 0; piece < pieceCnt; piece++)
            {

                //son Pin 정보 출력 ex)  -FT_12/ST_13+FB_8264/SB_8265
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    //son 현재 piece에 맞는 net만 찾는다.
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if (netPiece != (piece + 1))
                        continue;

                    fprintf(fp, " -FT_%d/ST_%d+FB_%d/SB_%d,", (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3]);
                }
                //son 다음 piece로 넘어간다는 의미로 줄을 바꾼다.
                fprintf(fp, "\n");
            }

        }


        //------------------------------
        //son Reference Info 헤더 출력

        for (block = 1; block <= nEnd_nBlock; block++)
        {
            //son 현재 dutIdx에 맞는 block만 Reference 출력한다.
            //son210715 if (g_d4W_Log1_nBlockDutInfo[block] != dutIdx)  //son200320-4WDUT16   //son210715 삭제
            //son210715     continue;

            for (piece = 0; piece < pieceCnt; piece++)
            {
                //son Pin 정보 출력 ex)  -FT_12/ST_13+FB_8264/SB_8265
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    //son 현재 piece에 맞는 net만 찾는다.
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if (netPiece != (piece + 1))
                        continue;

                    //son Reference 값 출력
                    fprintf(fp, "    %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefAvg);   //son231205_2
                }

                //son 다음 piece로 넘어간다는 의미로 줄을 바꾼다.
                fprintf(fp, "\n");
            }
        }


        //------------------------------
        //son 4W 측정 data 출력


        firstPin1 = 0, netPiece = 0;
        for (block = 1; block <= nEnd_nBlock; block++)
        {
            //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
            //son210715 if (g_d4W_Log1_nBlockDutInfo[block] != dutIdx)  //son200320-4WDUT16   //son210715 삭제
            //son210715     continue;

            for (piece = 0; piece < pieceCnt; piece++)
            {
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    //son 현재 piece에 맞는 net만 찾는다.
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if (netPiece != (piece + 1))
                        continue;

                    //fprintf(fp, " %11.2f,", (int)g_s4WNet[dutIdx].saData[net-1].dRefAvg); //son231205_2

                    //son 0이거나 마이너스이면 불량 R 값
                    if (d4W_Log1[block][net] <= 0.0) {//sylee160524-1    
                        if (d4W_Log1[block][net] == 0.0) {//sylee160524-1   
                            d4W_Log1[block][net] = -999999.0;
                        }
                        fprintf(fp, "    NG%11.2f,", -d4W_Log1[block][net]);  //4WNG//SYLEE181113-1 //son231205_2
                    }
                    else
                    {
                        //son 양품 R 값으로 출력
                        if (d4W_Log1[block][net] <= 200000.0) {//sylee200828  100->200  
                            fprintf(fp, "    %11.2f,", d4W_Log1[block][net]);   //son231205_2
                        }

                        //son R 값이 999999.0이면 역시 불량으로 출력.
                        else {
                            fprintf(fp, "    NG%11.2f,", d4W_Log1[block][net]);  //4WNG//SYLEE181113-1  //son231205_2
                        }
                    }
                }

                // 다음 piece로 넘어간다는 의미로 줄을 바꾼다.
                fprintf(fp, "\n");
            }

        }


        fprintf(fp, "  \n ");
        fclose(fp);
    }

    return 1;
}


//son201209 4W Log CSV 파일 매번 새로 생성. 기존 바이옵트로 방식으로 column 누적. 
//
//son  "D:\\log4w\\" 폴더에 현재 dutIdx에 해당하는  4W CSV Log 를 생성한다.
//son   CSV 파일에 d4W_Log1[][]를 write
//son     ex)  D:\\log4w\\20170523_dsfi087422a01\\Log4W_%04d%02d%02d_%02d%02d%02d_ALL_Ok.CSV  
// return value  
//   -1: 비정상으로 바로 리턴
//    0: 정상인데 바로 리턴 
//    1: 함수 끝까지 진행하고 마지막에 리턴
int CChildView7::Log4WCsv_DDrive_ColumnWrite(int nEnd_nBlock)
{
    int ret = 1;    //son210715

    //--------------------------------
    //son Get BDL name (str1)
    int nEnd = 0;
    CString strBdlName;
    strBdlName.Format("%s", SysInfoView01.m_pStrFilePathBDL);  //son201209: m_pStrFilePathBDL으로 수정  
    for (int i3 = 1; i3 <= 10; i3++)
    {
        //son '\\'를 반복해서 찾다가 nEnd가 1<=0 인 시점에 멈춘다.
        //    결과적으로 "C:\\BDL\\10VGAxxxx" 라는 BDLpath면 '10VGAxxxx' 라는 BDL name 만 남는다.
        nEnd = strBdlName.Find('\\');
        if (nEnd > 1) {
            strBdlName = strBdlName.Mid(nEnd + 1);
        }
        else {
            break;
        }
    }

    //----------------------------------------------------------------
    //son  "D:\\log4w\\" + time 정보+ BdlName 으로 filePath를 만든다.  
    //     ex) "D:\\log4w\\20170519_dsfi087422a01"
    CString str3, strDateBdl, strbuf, strDirPath1;          //son210906
    CTime  curTime = CTime::GetCurrentTime();  //sylee161122 
    strDateBdl.Format("%04d%02d%02d_", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());     //son210906 "20170519_"
    strDateBdl += strBdlName;       //son210906 "20170519_dsfi087422a01"
	
    
	char    strBarCode[MAX_BARCODE_STR + 1];
    //son240622 ReadBarCode_fromHandlerDrive(strBarCode, g_strLotName);     //son220124
    GetBarCode(strBarCode);     //son240622 미리 저장된 strBarCode를 읽어와서 사용       

//son BH 이계왕 차장 요청. LotName Sub 폴더 밑에 4W log 기능 
#ifdef __BH__CUSTOMER //yskim 241218 BHVT define 제거(저항표시 ohm으로 통일하기 위해)

    if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
	{
		strDirPath1 = "d:\\log4w\\" + strDateBdl + "\\" + g_strLotName;  
	}else {
		strDirPath1 = "d:\\log4w\\" + strDateBdl;
	}   
			str3 = "d:\\log4w\\" + strDateBdl; 
#else
		if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
	{
		str3 = "d:\\log4w\\" + strDateBdl + "_" + g_strLotName; 
	}else {
		str3 = "d:\\log4w\\" + strDateBdl ;
	} 
#endif

    MyTrace(PRT_LEVEL1, "DDrive_ColumnWrite() : %s........\n", str3);

#ifdef __YP_VIET_CUSTOMER       //son211020

    //----------------------------------------------------------------------
    //son Multi DUT면 현재 filePath를 취합용 Lot 대표폴더로 간주하고 생성한다. (for 베트남 영풍)
    if (nMultyNetTotal > 1) //son210906
    {
        //son "d:\\Log4w\\20170523_dsfi087422a01"를 대표폴더로 삼아 생성한다.
        char buf[FILE_PATH_SIZE];
        sprintf(buf, "%s", str3);
        if (!FileExists(buf))    //son211222 CheckFileExist -> FileExists
        {
            if (!MakeNewDir(str3))
            {
                strbuf.Format("%s create Error!!", buf);
                AfxMessageBox(strbuf);
                return -1;    //son210906
            }
        }

        //son str3을 첫번째 DUT용 폴더이름으로 변경  "d:\\Log4w\\20170523_dsfi087422a01\\20170523_dsfi087422a01"
        //    날짜+LotName을 한번 더 써준다.
        if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
            str3 = str3 + "\\" + strDateBdl + "_" + g_strLotName;    //son220124
        else
            str3 = str3 + "\\" + strDateBdl;    //son210906  "d:\\log4w\\20170519_dsfi087422a01\\20170519_dsfi087422a01"

    }   //son210906
#endif  //son211020


    //----------------------------------
    //son filePath에 dutNo를 추가한다.
    //     ex) "D:\\log4w\\20170519_dsfi087422a01_DUT2"

    //son200320-4WDUT16: Multi DUT 구조로 수정.  

    // DUT : 같은 BDL을 쓰는 Block(=Step)의 집합
    //       Multi DUT는 같은 PCB내에서 여러개의 BDL을 사용하는 것. DUT별로 BDL 파일이 있어야 한다.
    //       일부 block은 DUT1, 일부 block은 DUT2 이런식으로 배치하며, DUT에 대한 block 배치는 
    //       장비에서 하므로 계측기는 수동적으로 장비에서 설정한 DUT id확인해서 동작한다.

    // Block이 4개라면 Step도 모두 4개 출력돼야 하지만,   
    // DUT가 여러개라면 각 DUT별로 Block(=Step)이 분산되어서 출력되어야 한다.
    //
    // ex)  Block1, 2, 는 DUT1,  Block 2, 3은 DUT2 라면 Log4W의 4W CSV 파일 생성시에 
    // 2개의 DUT용 폴더를 따로 만들고,  Block 1, 2는 DUT1 폴더의 각 시간별 파일에 Step 1, Step 2로, 
    // Block 3,4는 DUT1 폴더의 각 시간별 파일에 Step 3, Step 4로 나와야 한다. 

    //son 멀티 DUT 개수만큼 4W CSV 로그 여러개를 저장한다.  DUT 전용 폴더를 여러개 생성.
    // 20년 7월7일 GTS 위준명과장 문제점. DUT2번 선택중인데 4W CSV 로그가 Dut1, Dut2 양쪽으로 출력. 
    //          이 문제 때문에 muitl Dut를 모두 출력하던 코드를 현재 dutIdx에 대해서만 출력하게 고쳤었는데
    //          이때 문제점 F/U을 잘못 한 것으로 보임.
    //int   dutIdx = get4wDutIdx();     //son210715 삭제

    //son210715 영풍 베트남. 마지막 14개 DUT에서 마지막 DUT만 CSV 출력문제 관련  보완.  (son200320 코드를 복원)
    //          4W CSV는 마지막 블록에서 한번에 모든 block data를 출력해야 한다. 
    //          마지막 block의 CSV만 출력되지 않게 모든 DUT를 여기서 출력한다.  (DUT 별로 file이 나누어짐)
    //          DUT 별로 Net개수가 다르거나, pin 배치가 다를 수 있으므로 4W CSV 폴더를 분리해서 DUT별로 파일을 출력하는게 맞다.
    //          이게 안 된다면 적어도 Net 개수를 최대 큰 DUT 기준으로 맞춰서라도 출력해야 R 값이 빠지지 않는다.
    for (int dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++) //son210715 추가
    {

        //------------------------------------------------------------
        //son dutidx에 맞는 filePath가 존재하는지 확인하고 없다면 새로 만든다.
        //int nFolderMake1;
        CString strDutNo, str4, strDirPath2, strDirPath3;
        str4.Format("");
        if (dutIdx == 0)
            strDutNo.Format("");
        else    //son200320-4WDUT16: Multi DUT 구조로 수정.
            strDutNo.Format("_DUT%d", dutIdx + 1); //SYLEE150806
        str4 = str3 + strDutNo;
		strDirPath2 = strDirPath1 + strDutNo;
		strDirPath3 = "d:\\log4w\\" + strDateBdl + "\\" + g_strLotName + strDutNo;
        char buf[FILE_PATH_SIZE];//sylee161122  //son210420 255 -> FILE_PATH_SIZE
        sprintf(buf, "%s", str4);

		char buf2[FILE_PATH_SIZE];
        sprintf(buf2, "%s", strDirPath2);

		char buf3[FILE_PATH_SIZE];
        sprintf(buf3, "%s", strDirPath3);

//son BH 이계왕 차장 요청. LotName Sub 폴더 밑에 4W log 기능 
#ifdef __BH__CUSTOMER //yskim 241218 BHVT define 제거(저항표시 ohm으로 통일하기 위해)


		if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
		{
		// buf2 경로가 존재하지 않는 경우
		if (!CheckDirExist(buf))
		{
			MakeNewDir(str4);
			// buf 경로가 존재하지 않는 경우
		   if (!CheckDirExist(buf2))
			{
				// 새로운 디렉토리 생성 시도
				if (!MakeNewDir(strDirPath2))
				{
					strbuf.Format("%s create Error!!", str4);
					AfxMessageBox(strbuf);
					ret = -1;
					continue; // 루프를 반복하도록 continue 추가
				}
			}
        }
        // buf 경로가 존재하는 경우, buf2 경로를 다시 체크하고 디렉토리 생성 시도
			if (!CheckDirExist(buf2))
			{
				if (!MakeNewDir(strDirPath2))
				{
					strbuf.Format("%s create Error!!", buf2); // buf 대신 buf2로 수정
					AfxMessageBox(strbuf);
					ret = -1;
					continue; // 루프를 반복하도록 continue 추가
				}
			}
		
		}else {
			// buf2 경로가 존재하지 않는 경우
		if (!CheckDirExist(buf2))
		{
			// buf 경로가 존재하는 경우
		   if (CheckDirExist(buf))
			{
				// 새로운 디렉토리 생성 시도
				if (!MakeNewDir(strDirPath3))
				{
					strbuf.Format("%s create Error!!", buf2);
					AfxMessageBox(strbuf);
					ret = -1;
					continue; // 루프를 반복하도록 continue 추가
				}
			}
        
        // buf 경로가 존재하는 경우, buf2 경로를 다시 체크하고 디렉토리 생성 시도
		if (!CheckDirExist(buf3))
			{
		   if (!CheckDirExist(buf2))
				{
				if (!CheckDirExist(buf))
					{
				if (!MakeNewDir(strDirPath2))
					{
					strbuf.Format("%s create Error!!", buf2); // buf 대신 buf2로 수정
					AfxMessageBox(strbuf);
					ret = -1;
					continue; // 루프를 반복하도록 continue 추가
					}
					}
				}
			}
		}
		
		}


#else
		if (!CheckDirExist(buf))
        {
            if (!MakeNewDir(str4))
            {
                strbuf.Format("%s create Error!!", buf);
                AfxMessageBox(strbuf);
                //return -1;    //son210715 삭제
                ret = -1;   //son210715
                continue;   //son210715

                //str4.Format("D:\\log4W\\");
                //nFolderMake1=2;
            }
            else {
                //nFolderMake1=1;
            }
        }
#endif		
        /////////////////////////////////////////////////////////////////
        //son200320-4WDUT16
        if (n4w_Sample_Enable == 1)
        {
            if (n4w_Sample_RunCount[dutIdx] > n4w_Sample_SetCount) {
                //return 0; //son210715 삭제
                continue;   //son210715
            }
        }


        int n4wNetCnt = (int)g_s4WNet[dutIdx].wCount; //son190704-4WDUT16

        int n4WPassCount, nEndTotal;//syee160520-1
        n4WPassCount = 0;
        nEndTotal = 0;

        //son 파일 name에 ALL_OK를 붙일 것인지 판단하기 위해  4W Pass Count를 센다.
        int net;        //son190704-4WDUT16
        for (net = 1; net <= n4wNetCnt; net++)//syee160520-1     //son190704-4WDUT16
        {
            for (int block = 1; block <= nBlockMaxLast1; block++)  //nBlockMax->nBlockMaxLast1;//sylee170417-1
            {
                if ((d4W_Log1[block][net] > 0.0) && (d4W_Log1[block][net] <= MAX_4W_R)) { //sylee160521     //sylee200828  100->200         
                    n4WPassCount++;                                   //son230707 200000 -> MAX_4W_R      
                }
                nEndTotal++;        //son 최대 Net개수 * Block개수의 4W Net 개수
            }
        }

        //----------------------------------------------
        //son Auto Sampling 로그 일 경우 file Name. 
        CString   str, strfName1;
        if (n4w_Sample_Enable == 1)
        {
            if (n4WPassCount == 0) {
                strfName1.Format("Log4W_SAMPLE%d_%04d%02d%02d_%02d%02d%02d_NG_All.CSV",     //sylee200612
                    n4w_Sample_RunCount[dutIdx], curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

                MyTrace(PRT_LEVEL2, "dut_%d NG_ALL! Give up writing 4W Sampling CSV File.: %s\n", dutIdx, strfName1);   //son211215 추가    //son220317
                if (dutIdx == nMultyNetTotal)
                    MyTrace(PRT_LEVEL2, "\n\n");

                continue;       //son210715 4w Auto Sampling 로그는 NG_ALL 일때는 출력 안함.
            }
            //son Sampling은 ALL_OK 일 때에만 SAMPLE_ 파일을 write 한다.
            else if (nEndTotal == n4WPassCount) {//sylee161123
                strfName1.Format("Log4W_SAMPLE%d_%04d%02d%02d_%02d%02d%02d_ALL_Ok.CSV",     //sylee200612 //yskim 240919 insert lot name
                    n4w_Sample_RunCount[dutIdx], curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
            }
            //son 하나라도 fail이 있는 경우
            else {
                //son-RESHEET-20200226: Fault카운트 오류 수정
                //  (n4wNetCnt-n4WPassCount) -> (nEndTotal-n4WPassCount) 로 수정함.
                strfName1.Format("Ng_Log4W_SAMPLE%d_%04d%02d%02d_%02d%02d%02d_NG_Net_%d.CSV",     //sylee200612 //yskim 240919 insert lot name
                    n4w_Sample_RunCount[dutIdx], curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(),(nEndTotal - n4WPassCount));

//son231101_2 begin: NG가 하나라도 있는 경우에 4W sampling write 안 하도록 수정.
            //son  4W 측정값이 하나라도 NG 인 경우는 Sampling으로 write할 필요가 없다. 
                MyTrace(PRT_LEVEL2, "dut_%d NG_%d Exist! Give up writing 4w Sampling CSV File: %s \n", 
                                       dutIdx, (nEndTotal - n4WPassCount),  strfName1);   
                if (dutIdx == nMultyNetTotal)
                    MyTrace(PRT_LEVEL2, "\n\n");
                continue;   //son231101_2 현재 CSV 파일에 출력 안 한다.
//son231101_2
            }
        }

        //----------------------------------------------
        //son 일반 D:\4W Csv 로그일 경우 file Name
        else
        {
          
            if (n4WPassCount == 0) {  //sylee161122 strfName1=strfName1+str4;
                strfName1.Format("Log4W_%04d%02d%02d_%02d%02d%02d_NG_All.CSV",//yskim 240919 insert lot name
                    curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());//yskim 240919 insert lot name
            }
            else if (nEndTotal == n4WPassCount) {
                strfName1.Format("Log4W_%04d%02d%02d_%02d%02d%02d_ALL_Ok.CSV",  //yskim 240919 insert lotname
                    curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());   //yskim 240919 insert lot name
            }
            else {
                //son-RESHEET-20200226: Fault카운트 오류 수정
                //  (n4wNetCnt-n4WPassCount) -> (nEndTotal-n4WPassCount) 로 수정함.
                strfName1.Format("Log4W_%04d%02d%02d_%02d%02d%02d_NG_Net_%d.CSV",//yskim 240919 insert lot name
                    curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                    curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), (nEndTotal - n4WPassCount));//yskim 240919 insert lot name
            }
        }

        //----------------------------
        //son filePath(fName1) 완성
        //  ex) "D:\\log4w\\20170519_dsfi087422a01_DUT2\\Log4W_20170519_125515_NG_All.CSV"

        FILE* fp;
        char fName1[200];//, fName2[200]; 

//son BH 이계왕 차장 요청. LotName Sub 폴더 밑에 4W log 기능 
#ifdef __BH__CUSTOMER //yskim 241218 BHVT define 제거(저항표시 ohm으로 통일하기 위해)

		strfName1 = strDirPath2 + "\\" + strfName1;
#else
        strfName1 = str4 +"\\" +strfName1;//sylee161122
#endif
		::ZeroMemory(&fName1, sizeof(fName1));
        strcat(fName1, strfName1);


        fp = fopen(fName1, "wt");
        if (fp == NULL) {
            str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ", fName1);  //son220701
            AfxMessageBox(str, MB_OK);
            //return -1;    //son210715 삭제
            continue;   //son210715
        }
        MyTrace(PRT_LEVEL2, "4W CSV file write: %s\n\n\n", fName1); //son211215 추가

        //son210420 RESHEET 수신시 마지막 4w Log를 지우고 다시 작성하기 위한 'D:\\log4W의 file Name'을 저장
        if ((SysSet13.m_nSet12 != 1) && (SysSet211.m_nSet16 == 1)    //son RESHEET 관련 옵션이 모두 ON 이면
            && !(nDio[DIN_SKIP] == 1 && nBlockMax <= 1)     //son START+SKIP+ RESHEET를 받았는데 Block이 1개인 경우 제외
            && (n4w_Sample_Enable != 1)                     //son 4W Sampling인 경우 제외
            && (SysSet13.m_n4wLogMode == _4W_LOG_COL))     //son D:\\log4w 개별 vertical 타입.  //son230323
        {
            //son220624_3 strcpy(g_LastD_Log4w_ResheetfName[dutIdx], fName1);     //son210715 [dutIdx] 추가
            strcpy(g_LastD_Log4w_ResheetfName, fName1);     //son220624_3 
        }

        //--------------------
        //son  헤더 출력

#ifdef __GTS_4WLOG_PIECE__
        //son200804 GTS 유니텍 요구사항. 4WLog에 Piece 정보 추가
        fprintf(fp, "    ,Piece ,Pin1 ,Pin2 ,Pin3 ,Pin4 ,  Min., Ref., Max.,");   //son200804: 4W Piece 정보 추가  
#else
        //son200827 영풍에는 Piece가 출력되지 않도록 기존대로 처리
        fprintf(fp, "    ,  Pin1 ,Pin2 ,Pin3 , Pin4 ,  Min., Ref., Max.,");
#endif
        for (int block = 1; block <= nEnd_nBlock; block++)   // nBlockMax->nEnd_nBlock //sylee170417-1
        {
            //son 현재 dutIdx(0부터 시작)에 맞는 block만 Step값으로 출력한다.
            if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16
            {
                //fprintf(fp, "S=%d,   ",  block );  
                //son200525-4WLOG: 4WLog개선, Block에 해당하는 Step 번호 순서로 헤더를 출력한다.  
                fprintf(fp, "S=%d,   ", g_Map3_BlockStep[block]);

                //for debug
                MyTrace(PRT_LEVEL3, "Log4WCsv(DUT_%d): g_d4W_Log1_nBlockDutInfo[block_%d] = dutIdx_%d\n",
                    dutIdx, block, g_d4W_Log1_nBlockDutInfo[block]);
            }



        }
        fprintf(fp, "  \n ");



        //--------------------
        //son  Data 출력
        int firstPin1 = 0, piece1 = 0;
        for (net = 1; net <= n4wNetCnt; net++) //son  i: Net         //son190704-4WDUT16 
        {
#ifdef __GTS_4WLOG_PIECE__
            //son GTS 유니텍 요구사항. 4WLog에 Piece 정보 추가

            //son200804: 4W Piece 정보 추가
            firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
            piece1 = g_nPinPieceNo[dutIdx + 1][firstPin1];          //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
            fprintf(fp, "Net %d, %d, %d,  %d,  %d, %d,  %11.2f, %11.2f, %11.2f,",   //son231205_2
                net, piece1,        //son200804: 4W Piece 정보 추가 
#else
            //son200827 영풍에는 Piece가 출력되지 않도록 기존대로 처리
            fprintf(fp, "Net %d, %d,  %d,  %d, %d,  %11.2f, %11.2f, %11.2f,",   //son231205_2
                net,
#endif 
                (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
                (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3],
                g_s4WNet[dutIdx].saData[net - 1].dRefLow,     //son211005
                g_s4WNet[dutIdx].saData[net - 1].dRefAvg,     //son211005
                g_s4WNet[dutIdx].saData[net - 1].dRefHigh);   //son211005

            for (int block = 1; block <= nEnd_nBlock; block++)  //  nBlockMax->nEnd_nBlock //sylee170417-1      
            {
                // 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
                if (g_d4W_Log1_nBlockDutInfo[block] == dutIdx)  //son200320-4WDUT16
                {

                    //son 0이거나 마이너스이면 불량 R 값
                    if (d4W_Log1[block][net] <= 0.0) {//sylee160524-1    
                        if (d4W_Log1[block][net] == 0.0) {//sylee160524-1   
                            d4W_Log1[block][net] = -999999.0;
                        }
                        fprintf(fp, "NG%11.2f,  ", -d4W_Log1[block][net]);  //4WNG//SYLEE181113-1   //son231205_2
                    }
                    else
                    {
                        //son 양품 R 값으로 출력
                        if (d4W_Log1[block][net] <= 200000.0) {//sylee200828  100->200  
                            fprintf(fp, "   %11.2f,   ", d4W_Log1[block][net]); //son231205_2
                        }

                        //son R 값이 999999.0이면 역시 불량으로 출력.
                        else {
                            fprintf(fp, "NG%11.2f,  ", d4W_Log1[block][net]);  //4WNG//SYLEE181113-1    //son231205_2
                        }
                    }
                }
            }
            fprintf(fp, "  \n ");
        }

        fprintf(fp, "  \n ");
        fclose(fp);

    }   //son210715

    return ret; //son210715
}


//son231026 begin:   ACE1000의 son230707 기능을 231026일에 옮겨옴.
// 대만 MST 유니텍:  4W csv 로그를 MST 유니텍 요청 타입으로 출력한다.
// 특징: detail data가 추가됨. BarCode, SheetNo, ModelName, LotName, DataStatus, PJudge, 
int CChildView7::Log4WCsv_DDrive_ColumnWrite_MST(int nEnd_nBlock)
{

	int ret = 1;

    //--------------------------------
    //son Get BDL name (str1)
	int nEnd = 0;
	CString strBdlName;
	strBdlName.Format("%s", SysInfoView01.m_pStrFilePathBDL);  //son201209: m_pStrFilePathBDL으로 수정
	for (int i3 = 1; i3 <= 10; i3++)
	{
        //son '\\'를 반복해서 찾다가 nEnd가 1<=0 인 시점에 멈춘다.
        //    결과적으로 "C:\\BDL\\10VGAxxxx" 라는 BDLpath면 '10VGAxxxx' 라는 BDL name 만 남는다.
		nEnd = strBdlName.Find('\\');
		if (nEnd > 1) {
			strBdlName = strBdlName.Mid(nEnd + 1);
		}
		else {
			break;
		}
	}


    //-------------------------------------------------------------------------------
    //son strBarCode, g_strLotName, g_strModelName, g_strSheetNo, g_strTotalNo 획득
    char    strBarCode[MAX_BARCODE_STR + 1];
    ::ZeroMemory(strBarCode, sizeof(strBarCode));

    //son240622 ::ZeroMemory(g_strLotName, sizeof(g_strLotName));
    //son240622 ReadBarCode_fromHandlerDrive(strBarCode, g_strLotName); //son240622 획득 타임은 START+TEST 수신시로 변경
    GetBarCode(strBarCode);     //son240622 미리 저장된 strBarCode를 읽어와서 사용       

#ifdef __MST__CUSTOMER      //son240627
 	if(nBarcodefile_MC_Mode1 !=1){	
		return 1;	
	}//sylee240130
#endif   //son240627

    //----------------------------------------------------------------
    //son Date, Time 정보 획득
    CString strDate, strDate2, strTime, strTime2, strDateBdl;          
    CTime  curTime = CTime::GetCurrentTime();  
    strDate.Format("%04d%02d%02d", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());     //son "20230707"
    strDate2.Format("%04d-%02d-%02d", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());   //son "2023-07-07"

    strTime.Format("%02d%02d%02d", curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());  //son "232859"
    strTime2.Format("%02d:%02d:%02d", curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());  //son "23:28:59"

    strDateBdl = strDate + "_";       //son "20230707_"
    //son240109 strDateBdl += g_strModelName;     //son "20230707_dsfi087422a01"  (Model == BDL)
    strDateBdl += strBdlName;     //son240109 "20230707_dsfi087422a01"  계측기 BDL Name을 사용하도록 변경.

#if 0 //son240126

    //------------------------------------------------------------------------------------------
    //son  "Z:\\log4w\\" + date 정보+ ModelName + LotName 으로 4WCsv file folder Path를 만든다.  
    //     ex) "Z:\\log4w\\20170519_dsfi087422a01_Lotxxxx"
    CString strPath, str;          
//son240109    strPath = "d:\\log4w\\" + strDateBdl + "_" + g_strLotName;
    strPath = "z:\\log4w\\" + strDateBdl + "_" + g_strLotName;  //son240109  Z: 드라이브 공유폴더로 4W csv 로그 위치 변경. 대만 유니텍 요청


    //-------------------------
    //son 4W CSV folder 생성 
    char buf[FILE_PATH_SIZE];//sylee161122	//son210420 255 -> FILE_PATH_SIZE
    
//son240109 begin:
    //son z:\\log4w  폴더가 없으면 먼저 생성
    CString strZDrv = "z:\\log4w";
    sprintf(buf, "%s", strZDrv);  
    //son240110 if (!CheckDirExist(buf))    
    if (!PathIsDirectory(buf))   //son240110 CheckDirExist(buf)는 Sub 폴더가 있으면 
                                 //          False 리턴되는 문제가 있어서 PathIsDirectory(buf)로 교체
    {
        if (!MakeNewDir(strZDrv))
        {
            str.Format("%s create Error!!", strZDrv);
            AfxMessageBox(str);
            //return -1;    //son210715 삭제
        }
    }
//son240109 end.

    //son 4W CSV 폴더 생성 
    sprintf(buf, "%s", strPath);
    if (!CheckDirExist(buf))
    {
        if (!MakeNewDir(strPath))
        {
            str.Format("%s create Error!!", strPath);
            AfxMessageBox(str);
            //return -1;    //son210715 삭제
        }
    }

    //--------------------------------------------------------------------------
    //son 파일 name에 ALL_OK를 붙일 것인지 판단하기 위해  4W Pass Count를 센다.

    int n4WPassCount= 0, nEndTotal= 0;
    int block, n4wNetCnt, dutIdx, net;
    for (block = 1; block <= nBlockMaxLast1; block++)
    {
        dutIdx = g_d4W_Log1_nBlockDutInfo[block];
        n4wNetCnt = (int)g_s4WNet[dutIdx].wCount;

        for (net = 1; net <= n4wNetCnt; net++)
        {
            if ((d4W_Log1[block][net] > 0.0) && (d4W_Log1[block][net] <= MAX_4W_R))
                n4WPassCount++;

            nEndTotal++;        //son 최대 Net개수 * Block개수의 4W Net 개수
        }
    }

    //-------------------------------
    //son file Name 생성 및 fopen()
    
    CString   strfName1, strSample="", strSampleNo=""; 
	if (n4w_Sample_Enable == 1)
	{
		strSample.Format("%s", "_SAMPLE");
		strSampleNo.Format("%d", n4w_Sample_RunCount[dutIdx]);
		strSample = strSample + strSampleNo;
	}
		
    if (n4WPassCount == 0) {  
        strfName1.Format("Log4W%s_%s_%s_NG_All.CSV", strSample, strDate, strTime);
    }
    else if (nEndTotal == n4WPassCount) {
        strfName1.Format("Log4W%s_%s_%s_ALL_OK.CSV", strSample,  strDate, strTime);
    }
    else {
        strfName1.Format("Log4W%s_%s_%s_NG_Net_%d.CSV", strSample, strDate, strTime, (nEndTotal - n4WPassCount));
    }

#else //son240126 begin:
//son240126 대만 유니텍 요청으로 4W Csv 폴더, 파일 이름 규칙 변경. 
// Folder: "Z:\\Log4w\\MainModelName\\LotName\\"
// File  : "Log4w_Date_Time_MainModelName_LotName_SheetNo.csv" 



    //-------------------------
    //son "Z:\\Log4w" 폴더  생성 
    char buf[FILE_PATH_SIZE];//sylee161122	//son210420 255 -> FILE_PATH_SIZE
    
    //son z:\\log4w  폴더가 없으면 먼저 생성
    CString strZDrv = "z:\\Log4w";
    sprintf(buf, "%s", strZDrv);  
    //son240110 if (!CheckDirExist(buf))    
    if (!PathIsDirectory(buf))   //son240110 CheckDirExist(buf)는 Sub 폴더가 있으면 
                                 //          False 리턴되는 문제가 있어서 PathIsDirectory(buf)로 교체
    {
        if (!MakeNewDir(strZDrv))
        {
            str.Format("%s create Error!!", strZDrv);
            AfxMessageBox(str);
            //return -1;    //son210715 삭제
        }
    }
    //-------------------------------------------------------
    //son  "Z:\\Log4w\\MainModelName\\"  폴더 생성 
    CString strModelPath;
    strModelPath.Format("z:\\Log4w\\%s", g_strModelName);
    sprintf(buf, "%s", strModelPath);  
    if (!PathIsDirectory(buf))   
    {
        if (!MakeNewDir(strModelPath))
        {
            str.Format("%s create Error!!", strModelPath);
            AfxMessageBox(str);
            //return -1;    //son210715 삭제
        }
    }

    //-------------------------------------------------------
    //son  "Z:\\Log4w\\MainModelName\\LotName\\" 폴더 생성 
    CString strPath, str;          
    strPath.Format("z:\\Log4w\\%s\\%s",g_strModelName, g_strLotName);
    sprintf(buf, "%s", strPath);  
    if (!PathIsDirectory(buf))   
    {
        if (!MakeNewDir(strPath))
        {
            str.Format("%s create Error!!", strPath);
            AfxMessageBox(str);
            //return -1;    //son210715 삭제
        }
    }


    //-------------------------------
    //son file Name 생성 및 fopen()
    
    CString   strfName1, strSample="", strSampleNo=""; 
	if (n4w_Sample_Enable == 1)
	{
		strSample.Format("%s", "_SAMPLE");
		strSampleNo.Format("%d", n4w_Sample_RunCount[nMulNetFlag]); 
		strSample = strSample + strSampleNo;
	}

    //son File  : "Log4w_Date_Time_MainModelName_LotName_SheetNo.csv" 
	                // Sample여부, Date, Time, M-ModelName, LotName, SheetNo
    strfName1.Format("Log4W%s_%s_%s_%s_%s_%s.CSV",    
                      strSample, strDate, strTime,  g_strModelName, g_strLotName,  g_strSheetNo); 

    int block, n4wNetCnt, dutIdx, net;
#endif  //son240126 end.

    FILE* fp;
    char fName1[200];//, fName2[200]; 

    //son  ex) "Z:\\Log4w\\MainModelName\\LotName\\Log4w_Date_Time_MainModelName_LotName_SheetNo.csv"
    strfName1 = strPath + "\\" + strfName1;
    ::ZeroMemory(&fName1, sizeof(fName1));
    strcat(fName1, strfName1);

    fp = fopen(fName1, "wt");
    if (fp == NULL) {
        str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ", strfName1);
        AfxMessageBox(str, MB_OK);
        return -1;    
    }
    MyTrace(PRT_LEVEL2, "4W CSV file write: %s\n\n\n", fName1); 

    //--------------------
    //son 4W Csv 헤더 출력
    
    //son240109 fprintf(fp, "Date  ,Time ,Sheet No  ,2D BarCode,  Model Name  ,Lot Name  ,Result  ,Block  ,Piece  ,DUT  ,Net  ,"); 
    //son240109 fprintf(fp, "Pin1 ,Pin2 ,Pin3 ,Pin4 ,Meas  ,Ref.Low,  Ref.High\n");  
    
    //son240109 Main 장비 2W와 헤더형식 통일 
    //      : Total No 추가, Controller Model Name 추가 
    fprintf(fp, "Date  ,Time ,TotalNo ,SheetNo  ,2D BarCode  ,Controller Model Name  ,Main Model Name  ,Lot Number  ,");
    fprintf(fp, "BlockNo  ,PieceNo  ,DUT  ,NetNo ,PieceJudge ,SheetJudge ,\"Pin1 ,Pin2 \" ,\"Pin3 ,Pin4 \", Result ,Meas  ,Ref.Low,  Ref.High\n"); 
    

    //-----------------------------
    //son 4W Csv data 출력 
    for (block = 1; block <= nEnd_nBlock; block++)
    {

        dutIdx = g_d4W_Log1_nBlockDutInfo[block];
        n4wNetCnt = (int)g_s4WNet[dutIdx].wCount;

        int firstPin1 = 0, piece1 = 0;
        for (net = 1; net <= n4wNetCnt; net++) 
        {
            //son 0이거나 마이너스이면 불량 R 값
            char strMeas[GET_BUF_SMALL_SIZE];
            if (d4W_Log1[block][net] <= 0.0) {//sylee160524-1	 
                if (d4W_Log1[block][net] == 0.0) {//sylee160524-1	
                    d4W_Log1[block][net] = -999999.0;
                }
                sprintf(strMeas, "NG%10.2f", -d4W_Log1[block][net]);  
            }
            else
            {
                //son 양품 R 값으로 출력
                if (d4W_Log1[block][net] <= MAX_4W_R) //son230707 200000 -> MAX_4W_R
                    sprintf(strMeas, "   %10.2f", d4W_Log1[block][net]);
                
                //son R 값이 999999.0이면 역시 불량으로 출력.
                else 
                    sprintf(strMeas, "NG%10.2f", d4W_Log1[block][net]);
            }

			//son 4W Piece 정보 획득. 
			firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
			piece1 = g_nPinPieceNo[dutIdx + 1][firstPin1];          //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)

            //son ResultPass 상태 획득
            bool bNoTest = false;
            if (g_nSkipPieceInfo[piece1] == 2)  //son piece skip이면 true
                bNoTest = true;

            //son piece disable이면 true
            if ((SysInfo19.m_nUse == 1) && (SysInfo19.m_nData[block][piece1] == 1))
                bNoTest = true;

            //son231030 ng4WResult로 NO_TEST 표시하면 block이 여러개일때에는 값이 구분이 안되는 문제 있음. 추후 필요시 보완. 
            CString strPass;
			strPass.Format("%s", ((ng4WResult[net] == 2) ? "PASS" :
                                  (ng4WResult[net] == 3) ? "FAIL" : 
                                  ((bNoTest == true) ? "NO_TEST" : "NO_TEST2")));


//son240109 //son Date,Time ,SheetNo, BarCode, ModelName, LotName, Result, Block, Piece,DUT ,Net,  Pin1 ,Pin2 ,Pin3 ,Pin4 ,Meas,Ref.Low,Ref.High 
//son240109 fprintf(fp, "%s, %s, %s, %s, %s, %s, %s, %d, %d, %d, %d, %d, %d, %d, %d ,%s, %10.2f, %10.2f,\n",
//son240109         strDate2, strTime2, g_strSheetNo, strBarCode, g_strModelName, g_strLotName, strPass, block, piece1, dutIdx+1, net,
//son240109         (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
//son240109         (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
//son240109         (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
//son240109         (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3], 
//son240109         strMeas, g_s4WNet[dutIdx].saData[net - 1].dRefLow, g_s4WNet[dutIdx].saData[net - 1].dRefHigh);

//son240109 begin:
            //son Date,Time ,TotalNo ,SheetNo, BarCode, C-ModelName, M-ModelName, LotName, Block, Piece,DUT ,Net, 
            //    PieceJugde, SheetJudge, Pin1 ,Pin2 ,ResultUnit, Meas,Ref.Low, Ref.High 
            fprintf(fp, "%s, %s, %s, %s, %s, %s, %s, %s, %d, %d, %d, %d, %s, %s ,\"%d , %d \" ,\"%d , %d \" ,%s, %s, %10.2f, %10.2f,\n",
                    strDate2, strTime2, g_strTotalNo, g_strSheetNo, strBarCode, //son240109 g_strTotalNo 추가
                    strBdlName,  g_strModelName, g_strLotName,      //son240109 strBdlName 추가, 
                    block, piece1, dutIdx+1, net, "  ", "  ",       //son240109 PieceJugde, SheetJudge  추가
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3], 
                    strPass, strMeas,                               //son240109 Result 이동 
                    g_s4WNet[dutIdx].saData[net - 1].dRefLow, g_s4WNet[dutIdx].saData[net - 1].dRefHigh);
//son240109 end.

        }

    }

    fclose(fp);

    return ret;
}
//son231026 end 


// 나노시스:  4W csv 로그를 231026 나노시스 요청 타입으로 출력한다.
// 특징: detail data가 추가됨. BarCode, SheetNo, ModelName, LotName, DataStatus, PJudge, 
int CChildView7::Log4WCsv_DDrive_LineWrite_NANO(int nEnd_nBlock)
{

    //--------------------------------
    //son Get BDL name (str1)
    int nEnd = 0;
    CString strBdlName;
    strBdlName.Format("%s", SysInfoView01.m_pStrFilePathBDL);  //son201209: m_pStrFilePathBDL으로 수정
    for (int i3 = 1; i3 <= 10; i3++)
    {
        //son '\\'를 반복해서 찾다가 nEnd가 1<=0 인 시점에 멈춘다.
        //    결과적으로 "C:\\BDL\\10VGAxxxx" 라는 BDLpath면 '10VGAxxxx' 라는 BDL name 만 남는다.
        nEnd = strBdlName.Find('\\');
        if (nEnd > 1) {
            strBdlName = strBdlName.Mid(nEnd + 1);
        }
        else {
            break;
        }
    }

    //----------------------------------------------------------------
    //son  "D:\\log4w\\" + time 정보+ BdlName 으로 filePath를 만든다.  
    //     ex) "D:\\log4w\\20170519_dsfi087422a01"
    CString strBdlPath;
    CTime  curTime = CTime::GetCurrentTime();  //sylee161122 

    //----------------------------------------------------------------
    //son strBarCode, g_strLotName, g_strModelName, g_strSheetNo 획득
    char    strBarCode[MAX_BARCODE_STR + 1];
    ::ZeroMemory(strBarCode, sizeof(strBarCode));

    //son240622 ::ZeroMemory(g_strLotName, sizeof(g_strLotName));
    //son240622 ReadBarCode_fromHandlerDrive(strBarCode, g_strLotName); //son220124 //son240622 획득 타임은 START+TEST 수신시로 변경
    GetBarCode(strBarCode);     //son240622 미리 저장된 BardCode 정보를 가져온다.

    strBdlPath.Format("D:\\log4W\\%04d%02d%02d_", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());
    if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
        strBdlName = strBdlName + "_" + g_strLotName;    //son220124 for 제이텍. 4wLog 폴더명에 Lot Name추가 //son220304

    strBdlPath = strBdlPath + strBdlName; //son201209: str1을 strBdlName으로 수정   //son220304

    MyTrace(PRT_LEVEL1, "DDrive_LineWrite() : %s........\n", strBdlPath);

    //------------------------------------------------------------
    //son filePath가 존재하는지 확인하고 없다면 새로 만든다.
    //
    //son210715  ColumnWrite 케이스처럼 DUT 별로 폴더를 만들지는 않는다.  
    //           파일이름에 DUT 이름이 포함돼 있고, ColumWrite 처럼 파일 개수가 많지 않으므로. 
    char buf[FILE_PATH_SIZE];//sylee161122  //son210420 255 -> FILE_PATH_SIZE
    sprintf(buf, "%s", strBdlPath);
    if (!CheckDirExist(buf))
    {
        if (!MakeNewDir(strBdlPath))
        {
            CString strbuf;
            strbuf.Format("%s create Error!!", buf);
            AfxMessageBox(strbuf);
            //return -1;    //son220401_2  폴더가 존재하는데 CheckDirExist와 MakeNewDir()가 실패하는 문제시 파일write는 되도록 수정.
        }
    }

//son231027 begin
    //son DUT 별로 블록이 배치되면 DUT2 이후는 block 1이 첫번째 블록이 아닐 수 있으므로 
    //    DUT 별 첫번째 block 정보가 필요하다.
    int dutIdx;
    int block1;
    int first_block1[MAX_DUT];          //son231027 현재 dut의 첫번째 block 정보 (1부터 시작)
    ::FillMemory(first_block1, sizeof(first_block1), -1);   //son231027 
    for (dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++) 
    {
        for (block1 = 1; block1 <= nBlockMaxLast1; block1++)
        {
            if (first_block1[dutIdx] == -1
                 && g_d4W_Log1_nBlockDutInfo[block1] == dutIdx)
                first_block1[dutIdx] = block1;
        }
    }
//son231027 end

    //son210715 영풍 베트남 DUT 14개일때 마지막 DUT만 CSV 출력문제 관련 보완.
    //          4W CSV는 마지막 블록에서 한번에 모든 block data를 출력해야 한다. 
    //          마지막 block의 CSV만 출력되지 않게 모든 DUT를 여기서 출력한다.  (DUT 별로 file이 나누어짐)
    //          DUT 별로 Net개수가 다르거나, pin 배치가 다를 수 있으므로 4W CSV 폴더를 분리해서 DUT별로 파일을 출력하는게 맞다.
    //          이게 안 된다면 적어도 Net 개수를 최대 큰 DUT 기준으로 맞춰서라도 출력해야 R 값이 빠지지 않는다.
    //int   dutIdx = get4wDutIdx(); //son200320-4WDUT16

    //son210715 멀티 DUT 개수만큼 4W CSV 로그 여러개를 저장한다. 
    for (dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++) //son210715
    {

        //son210715 Multi DUT
        if (n4w_Sample_Enable == 1)
        {
            //son 4w Sampling이 이미 끝났다면
            if (n4w_Sample_RunCount[dutIdx] > n4w_Sample_SetCount) {
                continue;   //son210715
            }
        }//son210715

        //-------------------------------
        //son time & status 정보 생성

        int n4wNetCnt = (int)g_s4WNet[dutIdx].wCount; //son190704-4WDUT16
        int n4WPassCount, nEndTotal;//syee160520-1 
        n4WPassCount = 0;
        nEndTotal = 0;

//son230323 begin:
        int net;        //son190704-4WDUT16
        CString str, out;

        //son 엑셀 컬럼개수 제한 16384를 넘는 경우에는 경고  출력.
        //    추후 이런 경우가 실제로 발생하면  16374 이상의 4w data는 별도 파일로 출력하는 기능을 개발필요.
        if ((n4wNetCnt+10) > 16384)  
        {                           
            str.Format("4W Net Count=%d, The number of columns in the 4W file cannot exceed 16384 due to Excel limitations,"); 
            out = str;
            str.Format("so the number of columns in the 4W DATA should be limited to 16374.\n");
            out += str;
            errMessageBox(7401, out);

            //n4wNetCnt = (16384 -10); //4w 개수를 16374로 제한.  => 제한 기능은 보류
        }


//#ifdef _PC_TEST_        
#if 0
        //son simulation for "All_OK"
        for (net = 1; net <= n4wNetCnt; net++)
            for (block1 = 1; block1 <= nBlockMaxLast1; block1++)  
                d4W_Log1[block1][net] = 30;
#endif      

        int n4W_NgCnt[MAX_PIECE+2];
        memset(n4W_NgCnt, 0x00, sizeof(n4W_NgCnt));   
        
        //son 4W CSV  name을 NG로 해야 할지 OK로 해야 할지 결정하기 위해 NG 개수를 카운트한다.
        int firstPin1 = 0, netPiece = 0;        
        for (net = 1; net <= n4wNetCnt; net++)//syee160520-1     //son190704-4WDUT16
        {
            for (block1 = 1; block1 <= nBlockMaxLast1; block1++)  //nBlockMax->nBlockMaxLast1;//sylee170417-1
            {
                if ((d4W_Log1[block1][net] > 0.0) && (d4W_Log1[block1][net] <= MAX_4W_R)) { //sylee160521     //sylee200828  100->200         
                    n4WPassCount++;                                         //son230707 200000 -> MAX_4W_R 
                }
                else {
                    //son netPiece: 현재 4W Net의 첫번째 pin의 piece정보 (1~)         
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~) 
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];                    
                    n4W_NgCnt[netPiece]++;                                           
                }

                nEndTotal++;        //son 최대 Net개수 * Block개수의 4W Net 개수
            }
        }

        CString strTimeStatus, strTemp;     
        strTimeStatus.Format("%04d-%02d-%02d ,%02d:%02d:%02d",            
                            curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                            curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        if (n4WPassCount == 0) { 
            strTemp.Format(" ,NG_All");            

            //son 모든 4W 측정값이 NG 인 경우는 Sampling으로 write할 필요가 없다. 
            if (n4w_Sample_Enable == 1)
            {
                MyTrace(PRT_LEVEL2, "dut_%d NG_ALL! Give up writing 4w Sampling CSV File: %s \n", dutIdx, strTimeStatus);   //son211215 추가
                if (dutIdx == nMultyNetTotal)
                    MyTrace(PRT_LEVEL2, "\n\n");
                continue;   //son210715 현재 DUT는 csv 출력 넘어간다.
            }

        }
        else if (nEndTotal == n4WPassCount) {    
            strTemp.Format(" ,All_OK");            
        }
        else {
            if(SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE) //son230704
                strTemp.Format("");     //son Piece for문 내부에서 생성

            else    // _4W_LOG_LINE_DUT //son230704
                //son200226: Fault카운트 오류 수정. n4wNetCnt -> nEndTotal 
                strTemp.Format(" ,NG_%d", (nEndTotal - n4WPassCount));            
        }
        strTimeStatus += strTemp;       //son ex) 2023-10-19 ,21:48:36 ,NG_All
//son230323 end

        FILE* fp[MAX_PIECE];
        char fName1[200];
        CString strfName[MAX_PIECE];        //son piece 개수만큼의 file


        //son220304 1개 DUT 파일에 All Piece를 모드 write하는 기능 추가.    
        int pieceCnt = SysInfoPieceRange.m_nPieceCount[dutIdx + 1]; 
        if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT  //son230304 //son230704
                    || SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_V2_NANO)   //son231026 나노시스도 1개 DUT 파일에 모든 piece 추가
            pieceCnt = 1;   
        int piece;  
        for (piece = 0; piece < pieceCnt; piece++)
        {

            strfName[piece].Format("Log4W_%s_DUT%d_Piece%d.csv", strBdlName, dutIdx + 1, piece + 1);    //son230323
            if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT         //son220304  //son230704
                    || SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_V2_NANO)   //son231026
                strfName[piece].Format("Log4W_%s_DUT%d.csv", strBdlName, dutIdx + 1);   //son230323

            if (n4w_Sample_Enable == 1)
                strfName[piece] = "SAMPLE_" + strfName[piece];
            strfName[piece] = strBdlPath + "\\" + strfName[piece];


            //--------------------------------
            //son DUT, piece별 4WLOG CSV File 생성 

            //son DUT 곱하기  piece 개수 만큼 file을 만든다. 기존에 존재하는 경우에는 새로 만들지 않는다.
            //son 'at' 옵션사용해서 이미 존재한다면 뒤에 write하고, 존재하지 않으면 새로 fp를 생성한다.
            ::ZeroMemory(&fName1, sizeof(fName1));
            strcat(fName1, strfName[piece]);

            int fileExist = FileExists(fName1);
            fp[piece] = fopen(fName1, "at");
            if (fp[piece] == NULL) {
                str.Format("Log4WCsv_DDrive_LineWrite Error!\n %s    file open   ?  Error, Saving Error !     file close!   ", fName1);
                AfxMessageBox(str, MB_OK);
                return -1;
                //continue;   //son210722 continue만 하다가 디버그모드에서 SW 죽는 문제 있었음. 
                              //          fopen() 실패하면 아예 리턴하는게 안전함.
            }

            MyTrace(PRT_LEVEL2, "4W CSV file write for piece_%d: %s\n\n\n", piece, fName1); //son211215 추가

            //-----------------
            //son 헤더 출력 
            //-----------------

            //son 최초생성인 경우에는  PIN정보를 포함한  헤더 정보를 출력한다. 
            if (fileExist == FALSE)
            {
                //son 헤더 Line 1,2
                fprintf(fp[piece], "BDL_Name , %s \n", strBdlName); //son231026    
                fprintf(fp[piece], "DUT_NO , %d\n", dutIdx + 1);    //son231026 

                //son 헤더 Line 3 
                // ex) Date_Time_Status  SheetCode SheetNo PositionX(Block) PositionY(piece)  빈칸    Net 1   Net 2    Net 3   Net 4   Net 5   Net 6   Net 7...
                fprintf(fp[piece], "Date ,Time ,Status ,SheetCode ,SheetNo ,PositionX(Block) ,PositionY(Piece) ,    ,");   //son231026 
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))         //son220304 //son230704
                        continue;

                    fprintf(fp[piece], "Net%d ,", net);

                }
                fprintf(fp[piece], "\n");


                //son 헤더 Line 4 (Pin정보) ex)  -FT_12/ST_13+FB_8264/SB_8265     F(Forth, 전류감지),  S(Sense, 전압감지)
                fprintf(fp[piece], ",  ,  ,  ,  ,  ,  ,Point ,");          //son230323
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    //son 현재 piece에 맞는 net만 찾는다.
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))
                        continue;

                    fprintf(fp[piece], " -FT_%d/ST_%d+FB_%d/SB_%d,", (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                        (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3]);

                }
                //son 다음 piece로 넘어간다는 의미로 줄을 바꾼다.
                fprintf(fp[piece], "\n");


                //son  Line 5 Ref.Low 
                //  ex)         Ref.Low     0       0       0       0       0       0       0
                fprintf(fp[piece], ",  ,  ,  ,  ,  ,  ,Ref.Low ,");     //son211129 Min -> Ref.Low
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230704
                        continue;

                    fprintf(fp[piece], " %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefLow);     //son211005   //son231205_2
                }
                fprintf(fp[piece], "\n");

                //son  Line 6 Ref.High
                //  ex)         Ref.High    9.03    8.88    9.09    9.04    9.05    12.56   8.96 
                fprintf(fp[piece], ",  ,  ,  ,  ,  ,  ,Ref.High ,");        //son211129 Max -> Ref.High          //son230323
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230704
                        continue;

                    fprintf(fp[piece], " %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefHigh);    //son211005   //son231205_2
                }
                fprintf(fp[piece], "\n");
            }

            //-----------------------
            //son 4WData 출력
            //-----------------------
            
            //son piece별 Date_Time_Stauts 출력
            CString strTempPiece;                           //son230323
            CString strTimeStatus2 = strTimeStatus;     //son230323
            if (nEndTotal != n4WPassCount && n4WPassCount != 0
                 && SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE)    //son230323
            {
                strTempPiece.Format(",NG_%d", n4W_NgCnt[piece+1]);  //son230323
                strTimeStatus2 = strTimeStatus + strTempPiece;      //son230323  ex) 2023-10-19 ,21:48:36 ,NG_All
            }

            for (int block1 = 1; block1 <= nEnd_nBlock; block1++)   // nBlockMax->nEnd_nBlock //sylee170417-1
            {

                //son 맨 첫번째 block만 Date_Time_Status 정보를 출력하고 두번째 줄부터는 빈칸 한칸을 출력
                //son231027 if (block1 == 1) 
                if (block1 == first_block1[dutIdx])     //son231027
                {
                    //son210722 \n 추가. step이 전혀 없는 경우에 time string이 엉뚱한 곳에 찍히는 문제 수정
                    fprintf(fp[piece], "\n");
                    fprintf(fp[piece], "%s ,%s, %s,",   //son210722 ex) 2023-10-19 ,21:48:36 ,NG_All ,Sheet_aaa, 0, 
                           strTimeStatus2, strBarCode, g_strSheetNo);
                }
                else {
                    //son231027 빈 step이 존재할 경우, 다음 step부터 한칸씩 오른쪽으로 밀리는 문제 관련 수정. 
                    if (g_d4W_Log1_nBlockDutInfo[block1] != dutIdx)  //son200320-4WDUT16 //son230323
                        continue;
                    else
                        fprintf(fp[piece], ",  ,  ,  ,  ,  ");  
                }
                //son 현재 dutIdx에 맞는 block만 Step값으로 출력한다.
                if (g_d4W_Log1_nBlockDutInfo[block1] != dutIdx)  //son200320-4WDUT16 //son230323
                {
                    continue;
                }

                fprintf(fp[piece], "%d ,%d ,MEAS ,",  block1, piece+1 );  

                ////son200525-4WLOG: 4WLog개선, Block에 해당하는 Step 번호를 출력한다. 
                //if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE) 
                //    fprintf(fp[piece], "%d ,S=%d ,", piece+1, g_Map3_BlockStep[block1]);    //son230323
                //else
                //    fprintf(fp[piece], "   ,S=%d ,", g_Map3_BlockStep[block1]);    //son230323

                //----------------
                //son 측정값 출력
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230323 
                        continue;

                    //fprintf(fp[piece], " %11.2f,", (int)g_s4WNet[dutIdx].saData[net-1].dRefAvg);  //son231205_2

                    //son 0이거나 마이너스이면 불량 R 값
                    if (d4W_Log1[block1][net] <= 0.0) {//sylee160524-1    
                        if (d4W_Log1[block1][net] == 0.0) {//sylee160524-1   
                            d4W_Log1[block1][net] = -999999.0;
                        }
                        fprintf(fp[piece], "    NG%11.2f,", -d4W_Log1[block1][net]);  //4WNG//SYLEE181113-1 //son231205_2
                    }
                    else
                    {
                        //son 양품 R 값으로 출력
                        if (d4W_Log1[block1][net] <= 200000.0) {//sylee200828  100->200  
                            fprintf(fp[piece], "    %11.2f,", d4W_Log1[block1][net]);   //son231205_2
                        }

                        //son R 값이 999999.0이면 역시 불량으로 출력.
                        else {
                            fprintf(fp[piece], "    NG%11.2f,", d4W_Log1[block1][net]);  //4WNG//SYLEE181113-1  //son231205_2
                        }
                    }
                }
                fprintf(fp[piece], "\n ,  ,  ,  ,  ,  ,  ,Judge ,");
                //----------------
                //son 측정상태 출력
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230323 
                        continue;

                    //son ResultPass 상태 획득
                    bool bSkip = false;
                    if (g_nSkipPieceInfo[piece +1] == 2)  //son piece skip이면 true
                        bSkip = true;

                    //son piece disable이면 true
                    if ((SysInfo19.m_nUse == 1) && (SysInfo19.m_nData[block1][piece +1] == 1))
                        bSkip = true;

                    CString strPass;
                    strPass.Format("%s", ((ng4WResult[net] == 2) ? "PASS" :
                                          (ng4WResult[net] == 3) ? "FAIL" : 
                                          ((bSkip == true) ? "SKIP" : "NO_TEST")));

                    fprintf(fp[piece], " %s,", strPass);  //4WNG//SYLEE181113-1
                }
                fprintf(fp[piece], "\n");
            }

            fclose(fp[piece]);
        }


    }   //son210715


    return 1;
}


//son231026 end 



//son201209: 4W Log CSV 파일 재사용. 파일 하나에 READ사와 비슷하게  Line으로 누적. 
//           READ 사와의 분쟁을 대비해 완전히 똑같게 하지는 않는다. 
//           가로방향으로 쌓는다는 것만 READ와 비슷하게 맞춤
//
//son  "D:\\log4w\\" 폴더에 현재 dutIdx에 해당하는  4W CSV Log 를 생성한다.
// return value  
//   -1: 비정상으로 바로 리턴
//   0: 정상인데 바로 리턴 
//   1: 함수 끝까지 진행하고 마지막에 리턴
int CChildView7::Log4WCsv_DDrive_LineWrite(int nEnd_nBlock)
{
    //--------------------------------
    //son Get BDL name (str1)
    int nEnd = 0;
    CString strBdlName;
    strBdlName.Format("%s", SysInfoView01.m_pStrFilePathBDL);  //son201209: m_pStrFilePathBDL으로 수정
    for (int i3 = 1; i3 <= 10; i3++)
    {
        //son '\\'를 반복해서 찾다가 nEnd가 1<=0 인 시점에 멈춘다.
        //    결과적으로 "C:\\BDL\\10VGAxxxx" 라는 BDLpath면 '10VGAxxxx' 라는 BDL name 만 남는다.
        nEnd = strBdlName.Find('\\');
        if (nEnd > 1) {
            strBdlName = strBdlName.Mid(nEnd + 1);
        }
        else {
            break;
        }
    }

    //----------------------------------------------------------------
    //son  "D:\\log4w\\" + time 정보+ BdlName 으로 filePath를 만든다.  
    //     ex) "D:\\log4w\\20170519_dsfi087422a01"
    CString strBdlPath;
    CTime  curTime = CTime::GetCurrentTime();  //sylee161122 


    strBdlPath.Format("D:\\log4W\\%04d%02d%02d_", curTime.GetYear(), curTime.GetMonth(), curTime.GetDay());
    char    strBarCode[MAX_BARCODE_STR + 1];

    //son240622 ReadBarCode_fromHandlerDrive(strBarCode, g_strLotName); //son220124 //son240622 획득 타임은 START+TEST 수신시로 변경
    GetBarCode(strBarCode);     //son240622 미리 저장된 BardCode 정보를 가져온다.

    if (SysSet13.m_nSet_UseLotName_4wLog == 1 && strcmp(g_strLotName, "") != 0)
        strBdlName = strBdlName + "_" + g_strLotName;    //son220124 for 제이텍. 4wLog 폴더명에 Lot Name추가 //son220304

    strBdlPath = strBdlPath + strBdlName; //son201209: str1을 strBdlName으로 수정   //son220304

    MyTrace(PRT_LEVEL1, "DDrive_LineWrite() : %s........\n", strBdlPath);

    //------------------------------------------------------------
    //son filePath가 존재하는지 확인하고 없다면 새로 만든다.
    //
    //son210715  ColumnWrite 케이스처럼 DUT 별로 폴더를 만들지는 않는다.  
    //           파일이름에 DUT 이름이 포함돼 있고, ColumWrite 처럼 파일 개수가 많지 않으므로. 
    char buf[FILE_PATH_SIZE];//sylee161122  //son210420 255 -> FILE_PATH_SIZE
    sprintf(buf, "%s", strBdlPath);
    if (!CheckDirExist(buf))
    {
        if (!MakeNewDir(strBdlPath))
        {
            CString strbuf;
            strbuf.Format("%s create Error!!", buf);
            AfxMessageBox(strbuf);
            //return -1;    //son220401_2  폴더가 존재하는데 CheckDirExist와 MakeNewDir()가 실패하는 문제시 파일write는 되도록 수정.
        }
    }

//son231027 begin
    //son DUT 별로 블록이 배치되면 DUT2 이후는 block 1이 첫번째 블록이 아닐 수 있으므로 
    //    DUT 별 첫번째 block 정보가 필요하다.
    int dutIdx;
    int block1;
    int first_block1[MAX_DUT];          //son231027 현재 dut의 첫번째 block 정보 (1부터 시작)
    ::FillMemory(first_block1, sizeof(first_block1), -1);   //son231027 
    for (dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++) 
    {
        for (block1 = 1; block1 <= nBlockMaxLast1; block1++)
        {
            if (first_block1[dutIdx] == -1
                 && g_d4W_Log1_nBlockDutInfo[block1] == dutIdx)
                first_block1[dutIdx] = block1;
        }
    }
//son231027 begin

    //son210715 영풍 베트남 DUT 14개일때 마지막 DUT만 CSV 출력문제 관련 보완.
    //          4W CSV는 마지막 블록에서 한번에 모든 block data를 출력해야 한다. 
    //          마지막 block의 CSV만 출력되지 않게 모든 DUT를 여기서 출력한다.  (DUT 별로 file이 나누어짐)
    //          DUT 별로 Net개수가 다르거나, pin 배치가 다를 수 있으므로 4W CSV 폴더를 분리해서 DUT별로 파일을 출력하는게 맞다.
    //          이게 안 된다면 적어도 Net 개수를 최대 큰 DUT 기준으로 맞춰서라도 출력해야 R 값이 빠지지 않는다.
    //int   dutIdx = get4wDutIdx(); //son200320-4WDUT16

    //son210715 멀티 DUT 개수만큼 4W CSV 로그 여러개를 저장한다. 
    for (dutIdx = 0; dutIdx < nMultyNetTotal; dutIdx++) //son210715
    {

        //son210715 Multi DUT
        if (n4w_Sample_Enable == 1)
        {
            //son 4w Sampling이 이미 끝났다면
            if (n4w_Sample_RunCount[dutIdx] > n4w_Sample_SetCount) {
                continue;   //son210715
            }
        }//son210715

        //-------------------------------
        //son time & status 정보 생성

        int n4wNetCnt = (int)g_s4WNet[dutIdx].wCount; //son190704-4WDUT16
        int n4WPassCount, nEndTotal;//syee160520-1 
        n4WPassCount = 0;
        nEndTotal = 0;

//son230323 begin:
        int net;        //son190704-4WDUT16
        CString str, out;

        //son 엑셀 컬럼개수 제한 16384를 넘는 경우에는 경고  출력.
        //    추후 이런 경우가 실제로 발생하면  16374 이상의 4w data는 별도 파일로 출력하는 기능을 개발필요.
        if ((n4wNetCnt+10) > 16384)  
        {                           
            str.Format("4W Net Count=%d, The number of columns in the 4W file cannot exceed 16384 due to Excel limitations,"); 
            out = str;
            str.Format("so the number of columns in the 4W DATA should be limited to 16374.\n");
            out += str;
            errMessageBox(7401, out);

            //n4wNetCnt = (16384 -10); //4w 개수를 16374로 제한.  => 제한 기능은 보류
        }


//#ifdef _PC_TEST_        
#if 0
        //son simulation for "All_OK"
        for (net = 1; net <= n4wNetCnt; net++)
            for (block1 = 1; block1 <= nBlockMaxLast1; block1++)  
                d4W_Log1[block1][net] = 30;
#endif      

        int n4W_NgCnt[MAX_PIECE+2];
        memset(n4W_NgCnt, 0x00, sizeof(n4W_NgCnt));   
        
        //son 4W CSV  name을 NG로 해야 할지 OK로 해야 할지 결정하기 위해 NG 개수를 카운트한다.
        int firstPin1 = 0, netPiece = 0;        
        for (net = 1; net <= n4wNetCnt; net++)//syee160520-1     //son190704-4WDUT16
        {
            for (block1 = 1; block1 <= nBlockMaxLast1; block1++)  //nBlockMax->nBlockMaxLast1;//sylee170417-1
            {
                if ((d4W_Log1[block1][net] > 0.0) && (d4W_Log1[block1][net] <= MAX_4W_R)) { //sylee160521     //sylee200828  100->200         
                    n4WPassCount++;                                         //son230707 200000 -> MAX_4W_R 
                }
                else {
                    //son netPiece: 현재 4W Net의 첫번째 pin의 piece정보 (1~)         
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~) 
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];                    
                    n4W_NgCnt[netPiece]++;                                           
                }

                nEndTotal++;        //son 최대 Net개수 * Block개수의 4W Net 개수
            }
        }

        //son231101_2 Log4WCsv_DDrive_LineWrite()에 SAMPLE#_ 표시기능 추가
        CString   strSample="";                 //son231101_2
        if (n4w_Sample_Enable == 1)             //son231101_2
            strSample.Format("SAMPLE%d_", n4w_Sample_RunCount[dutIdx]); //son231101_2

        CString strTimeStatus, strState;        //son231101_2
        strTimeStatus.Format("%04d-%02d-%02d ,%02d:%02d:%02d",            
                            curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(),
                            curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        if (n4WPassCount == 0) { 
            strState.Format(" ,%sNG_All", strSample);      //son231101_2

            //son 모든 4W 측정값이 NG 인 경우는 Sampling으로 write할 필요가 없다. 
            if (n4w_Sample_Enable == 1)
            {
                MyTrace(PRT_LEVEL2, "dut_%d NG_ALL! Give up writing 4w Sampling CSV File: %s \n", dutIdx, strTimeStatus);   //son211215 추가
                if (dutIdx == nMultyNetTotal)
                    MyTrace(PRT_LEVEL2, "\n\n");
                continue;   //son210715 현재 DUT 파일에 csv 출력 안 한다.
            }

        }
        else if (nEndTotal == n4WPassCount) {    
            strState.Format(" ,%sAll_OK", strSample);                //son231101_2
        }

        //son 하나라도 fail이 있는 경우
        else 
        {  
//son231101_2 begin: NG가 하나라도 있는 경우에 4W sampling write 안 하도록 수정.
            //son  4W 측정값이 하나라도 NG 인 경우는 Sampling으로 write할 필요가 없다. 
            if (n4w_Sample_Enable == 1)
            {
                MyTrace(PRT_LEVEL2, "dut_%d NG_%d Exist! Give up writing 4w Sampling CSV File: %s \n", 
                                       dutIdx, (nEndTotal - n4WPassCount),  strTimeStatus);   
                if (dutIdx == nMultyNetTotal)
                    MyTrace(PRT_LEVEL2, "\n\n");
                continue;   //son231101_2 현재 DUT 파일에 csv 출력 안 한다.
            }
//son231101_2

            if(SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE) //son230704
                strState.Format("");     //son Piece for문 내부에서 생성    

            else    // _4W_LOG_LINE_DUT //son230704
                //son200226: Fault카운트 오류 수정. n4wNetCnt -> nEndTotal 
                strState.Format(" ,%sNG_%d", strSample, (nEndTotal - n4WPassCount));     //son231101_2

        }

        strTimeStatus += strState;   
//son230323 end

        FILE* fp[MAX_PIECE];
        char fName1[200];
        CString strfName[MAX_PIECE];        //son piece 개수만큼의 file


        //son220304 1개 DUT 파일에 All Piece를 모드 write하는 기능 추가.    
        int pieceCnt = SysInfoPieceRange.m_nPieceCount[dutIdx + 1]; 
        if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT)  //son230304 //son230704
            pieceCnt = 1;   
        int piece;  
        for (piece = 0; piece < pieceCnt; piece++)
        {

            strfName[piece].Format("Log4W_%s_DUT%d_Piece%d.csv", strBdlName, dutIdx + 1, piece + 1);    //son230323
            if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT)         //son220304  //son230704
                strfName[piece].Format("Log4W_%s_DUT%d.csv", strBdlName, dutIdx + 1);   //son230323

            if (n4w_Sample_Enable == 1)
                strfName[piece] = "SAMPLE_" + strfName[piece];
            strfName[piece] = strBdlPath + "\\" + strfName[piece];


            //--------------------------------
            //son DUT, piece별 4WLOG CSV File 생성 

            //son DUT 곱하기  piece 개수 만큼 file을 만든다. 기존에 존재하는 경우에는 새로 만들지 않는다.
            //son 'at' 옵션사용해서 이미 존재한다면 뒤에 write하고, 존재하지 않으면 새로 fp를 생성한다.
            ::ZeroMemory(&fName1, sizeof(fName1));
            strcat(fName1, strfName[piece]);

            int fileExist = FileExists(fName1);
            fp[piece] = fopen(fName1, "at");
            if (fp[piece] == NULL) {
                str.Format("Log4WCsv_DDrive_LineWrite Error!\n %s    file open   ?  Error, Saving Error !     file close!   ", fName1);
                AfxMessageBox(str, MB_OK);
                return -1;
                //continue;   //son210722 continue만 하다가 디버그모드에서 SW 죽는 문제 있었음. 
                              //          fopen() 실패하면 아예 리턴하는게 안전함.
            }

            MyTrace(PRT_LEVEL2, "4W CSV file write for piece_%d: %s\n\n\n", piece, fName1); //son211215 추가

            //-----------------
            //son 헤더 출력 
            //-----------------

            //son 최초생성인 경우에는  PIN정보를 포함한  헤더 정보를 출력한다. 
            if (fileExist == FALSE)
            {
                //son 1) 헤더 Line 1,2
                fprintf(fp[piece], "BDL_Name ,DUT_No\n");    //son220826
                fprintf(fp[piece], "%s ,DUT_%d\n", strBdlName, dutIdx + 1);    //son220304    //son220504_3

                //son 2) 헤더 Line 3 
                // ex) Date_Time_Status            Net 1   Net 2    Net 3   Net 4   Net 5   Net 6   Net 7...
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                //son220826 4W CSV에 BarCode 정보 추가 요청 from 제이텍            
                fprintf(fp[piece], "BarCode ,Date , Time ,Status ,Piece ,    ,");    //son220826    //son230323 
#else
                if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE) //son230704
                    fprintf(fp[piece], "Date ,Time ,Status ,Piece ,    ,");    //son210722  //son230323 piece 정보추가
                else
                    fprintf(fp[piece], "Date ,Time ,Status ,      ,    ,");    //son210722  //son230323 
#endif
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))         //son220304 //son230704
                        continue;

                    fprintf(fp[piece], "Net%d ,", net);

                }
                fprintf(fp[piece], "\n");


                //son 3) 헤더 Line 4 (Pin정보) 
                    //son211129 MST 요구사항.  Pin 번호를 한줄 헤더로 출력요청  (ex "1,2,8205,8206")
                    // ex)          Net1                 Net2                    Net3                Net4
                    //     Pin  " 1404,1406,53,55",  " 1404,1406,1392,1394", " 1404,1406,563,565,  " 1404,1406,636,638"
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                fprintf(fp[piece], ",  ,  ,  ,  ,Pin ,");  //son220826          //son230323
#else                
                fprintf(fp[piece], ",  ,  ,  ,Pin ,");          //son230323
#endif
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))  //son220304  //son230704
                        continue;

                    fprintf(fp[piece], "\"");
                    for (int pin = 0; pin < 4; pin++)
                    {
                        if (pin == 3)
                            fprintf(fp[piece], "%d\",", (int)g_s4WNet[dutIdx].saData[net - 1].waPin[pin]);
                        else
                            fprintf(fp[piece], "%d, ", (int)g_s4WNet[dutIdx].saData[net - 1].waPin[pin]);
                    }
                }
                fprintf(fp[piece], "\n");


                //son 4) Line 5 Ref.Low 
                //  ex)         Ref.Low     0       0       0       0       0       0       0
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                fprintf(fp[piece], ",  ,  ,  ,  ,Ref.Low ,");     //son220826
#else                
                fprintf(fp[piece], ",  ,  ,  ,Ref.Low ,");     //son211129 Min -> Ref.Low
#endif
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230704
                        continue;

                    fprintf(fp[piece], " %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefLow);     //son211005   //son231205_2
                }
                fprintf(fp[piece], "\n");

                //son 5) Line 6 Ref
                //  ex)         Ref.    0.8     0.7     0.9     0.9     0.9     1.3     0.8 
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                fprintf(fp[piece], ",  ,  ,  ,  ,Ref ,");     //son220826           //son230323
#else                
                fprintf(fp[piece], ",  ,  ,  ,Ref ,");          //son230323
#endif
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))  //son220304 //son230704
                        continue;

                    fprintf(fp[piece], " %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefAvg);   //son231205_2
                }
                fprintf(fp[piece], "\n");

                //son 6) Line 7 Ref.High
                //  ex)         Ref.High    9.03    8.88    9.09    9.04    9.05    12.56   8.96 
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                fprintf(fp[piece], ",  ,  ,  ,  ,Ref.High ,");     //son220826          //son230323
#else                
                fprintf(fp[piece], ",  ,  ,  ,Ref.High ,");        //son211129 Max -> Ref.High          //son230323
#endif
                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230704
                        continue;

                    fprintf(fp[piece], " %11.2f,", g_s4WNet[dutIdx].saData[net - 1].dRefHigh);    //son211005   //son231205_2
                }
                fprintf(fp[piece], "\n");
            }

            //-----------------------
            //son 4WData 출력
            //-----------------------
            
            //son piece별 Date_Time_Stauts 출력
            CString strStatePiece = "";                      //son230323 //son231101_2
            CString strTimeStatus2 = strTimeStatus;     //son230323
            if (nEndTotal != n4WPassCount && n4WPassCount != 0
                 && SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE)    //son230323
            {
                strStatePiece.Format(",%sNG_%d", strSample, n4W_NgCnt[piece+1]);  //son230323   //son231101_2
                strTimeStatus2 = strTimeStatus + strStatePiece;      //son230323    //son231101_2
            }

            for (block1 = 1; block1 <= nEnd_nBlock; block1++)   // nBlockMax->nEnd_nBlock //sylee170417-1
            {

                //son 맨 첫번째 block1만 Date_Time_Status 정보를 출력하고 두번째 줄부터는 빈칸 한칸을 출력
                //son231027 if (block1 == 1) 
                if (block1 == first_block1[dutIdx])     //son231027
                {
                    //son210722 \n 추가. step이 전혀 없는 경우에 time string이 엉뚱한 곳에 찍히는 문제 수정
                    fprintf(fp[piece], "\n");
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                    fprintf(fp[piece], "%s, %s ,", strBarCode, strTimeStatus2);  //son220826    
#else                
                    fprintf(fp[piece], "%s ,", strTimeStatus2);    //son210722  
#endif
                }
                else
                {
                    //son231027 빈 step이 존재할 경우, 다음 step부터 한칸씩 오른쪽으로 밀리는 문제 관련 수정. 
                    if (g_d4W_Log1_nBlockDutInfo[block1] != dutIdx)  //son200320-4WDUT16 //son230323
                        continue;
                    else
#if 0  //son 제이텍에서 비용지급할때까지 son220826기능은 봉인                 
//#ifdef __JTECH__CUSTOMER    
                        fprintf(fp[piece], ",  ,  ,  ,");  //son220826  
#else
                        fprintf(fp[piece], ",  ,  ,");  
#endif
                }
                //son 현재 dutIdx에 맞는 block1만 Step값으로 출력한다.
                if (g_d4W_Log1_nBlockDutInfo[block1] != dutIdx)  //son200320-4WDUT16 //son230323
                {
                    //son231027 fprintf(fp[piece], "\n");   
                    continue;
                }


                //son200525-4WLOG: 4WLog개선, Block에 해당하는 Step 번호를 출력한다. 
                //fprintf(fp, "S=%d ,",  block1 );  
                if (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE) 
                    fprintf(fp[piece], "%d ,S=%d ,", piece+1, g_Map3_BlockStep[block1]);    //son230323
                else
                    fprintf(fp[piece], "   ,S=%d ,", g_Map3_BlockStep[block1]);    //son230323

                for (net = 1; net <= n4wNetCnt; net++)
                {
                    firstPin1 = g_s4WNet[dutIdx].saData[net - 1].waPin[0];   //son (1~)
                    netPiece = g_nPinPieceNo[dutIdx + 1][firstPin1];        //son 현재 4W Net의 첫번째 pin의 piece정보 (1~)
                    if ((netPiece != (piece + 1))
                        && (SysSet13.m_n4wLogMode == _4W_LOG_LINE_DUT_PIECE))   //son220304 //son230323 
                        continue;

                    //fprintf(fp[piece], " %11.2f,", (int)g_s4WNet[dutIdx].saData[net-1].dRefAvg);  //son231205_2

                    //son 0이거나 마이너스이면 불량 R 값
                    if (d4W_Log1[block1][net] <= 0.0) {//sylee160524-1    
                        if (d4W_Log1[block1][net] == 0.0) {//sylee160524-1   
                            d4W_Log1[block1][net] = -999999.0;
                        }
                        fprintf(fp[piece], "    NG%11.2f,", -d4W_Log1[block1][net]);  //4WNG//SYLEE181113-1 //son231205_2
                    }
                    else
                    {
                        //son 양품 R 값으로 출력
                        if (d4W_Log1[block1][net] <= 200000.0) {//sylee200828  100->200  
                            fprintf(fp[piece], "    %11.2f,", d4W_Log1[block1][net]);   //son231205_2
                        }

                        //son R 값이 999999.0이면 역시 불량으로 출력.
                        else {
                            fprintf(fp[piece], "    NG%11.2f,", d4W_Log1[block1][net]);  //4WNG//SYLEE181113-1  //son231205_2
                        }
                    }
                }
                fprintf(fp[piece], "\n");

            }

            fclose(fp[piece]);
        }


    }   //son210715

    return 1;
}



int CChildView7::nFileSaveLowStartPin(int nLowStartPinNo )  //sylee241108
{
 	FILE *fp; 
	char  fName[200];  
	CString str; 

    ::ZeroMemory(&fName, sizeof(fName)); 
    //str.Format("%s\\SETUP2\\ManOpen.ini", SysInfoView01.m_pStrFilePath1);   
	str.Format("Z:\\LowPin.TXT");
    strcat(fName , str);    
 	fp = fopen(fName,"wt");
	if(fp == NULL) return 0;
	fprintf(fp, "[LowPin]\n");
  	fprintf(fp, "Start Pin = %d\n",nLowStartPinNo);
	fclose(fp); 
	return 1;
 }


 


int CChildView7::LogDebug1(int nblock, int nNet)     //SYLEE150812
{
    FILE* fp;
    char  fName[200];
    CString str;

    return 1;

    CTime curTime = CTime::GetCurrentTime();
    ::ZeroMemory(&fName, sizeof(fName));

    str.Format("D:\\log\\log_net_02dM%02dS.txt", curTime.GetHour(), curTime.GetMinute());
    strcat(fName, str);
    fp = fopen(fName, "at");
    if (fp == NULL) {
        AfxMessageBox(str, MB_OK); //error messege           
        return 0;
    }
    else {
        str.Format(" %02dM%02dD_%02dH%02dM%02dS    ::    block=%d, Net=%d   \n ", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), nblock + 1, nNet);    //SYLEE150812
    }
    fprintf(fp, str);
    fclose(fp);

    return 1;

}




//son SkipPcs.txt 파일을 Read한다.
int ReadFile_SkipPieceInfo()//sylee160203-ITS  //son220621 A_PieceDisable1() -> ReadFile_SkipPieceInfo() 
{

    FILE* fp;
    char fName[200], sLenth[200];
    int no, Total, k1, nPass, nT1;

    CString str;
    char    sT1[2048];  //son190620  sT1 type을 CString에서 char array로 변경. fscanf 버퍼문제 
    ::ZeroMemory(sT1, sizeof(sT1));


    if (SysSet211.m_nSet23 != 1) {//sylee180528-1
        g_nSkipPieceFlag1 = 0;      //son220624
        return 1;
    }

    nPass = 0;

    ::ZeroMemory(&fName, sizeof(fName));//sylee201201-1
    strcat(fName, SysInfoView01.m_pStrFileDrive1);//sylee201201-1
    strcat(fName, "\\SkipPcs.txt");//sylee201201-1


    //====================================================
    //son SkipPcs.txt 파일 Read 
    //====================================================
    if (g_nSkipPieceFlag1 == -1) {        //son220624 begin
        //sylee201201-1 DeleteFile("Z:\\SkipPcs.txt" );
        DeleteFile(fName);//sylee201201-1  

        fp = fopen(fName, "rt");
        if (fp == NULL) {
            g_nSkipPieceFlag1 = 0;// file delete complete             
        }
        else {
            fclose(fp);
            g_nSkipPieceFlag1 = -1;// file delete error
        }
        return -1;
    }   //son220624 end

    //====================================================

    g_nSkipPieceFlag1 = 0;//sylee160203-3           //son220624
    ::ZeroMemory(&g_nSkipPieceTemp, sizeof(g_nSkipPieceTemp));          //son220624
    ::ZeroMemory(&g_nSkipPieceInfo, sizeof(g_nSkipPieceInfo));          //son220624

//sylee201201-1 ::ZeroMemory(&fName, sizeof(fName));
//sylee201201-1 strcat( fName , "Z:\\SkipPcs.txt" );

    fp = fopen(fName, "rt");
    if (fp == NULL) {
        // str.Format("Error No 9001 :%s   file read error !.", fName);
        // AfxMessageBox(str, MB_OK);          
        return 0;
    }

    //-----------------------------------------------------
    //son  ex) 'T2'  total skip piece 개수를 read한다.
    ::ZeroMemory(&sLenth, sizeof(sLenth));
    fscanf(fp, "%s\n", sLenth);
    str.Format("%s", sLenth);
    str.TrimLeft('T');     //son 'T' 글자 포함 왼쪽을 잘라내어 숫자만 남긴다.
    // no=str.Find('T');
    //str=str.Right(no+1);
    Total = atoi(str);
    if (Total < 0) {
        Total = 0;
        goto Task1;
    }

    if (Total > 1000) {
        Total = 0;
        goto Task1;
    }

    //----------------------------------------------------------------------------------------------
    //son total 개수가 2라면  g_nSkipPieceTemp[1], g_nSkipPieceTemp[2]에 skip할 piece 번호를 보관.
    for (k1 = 1; k1 <= Total; k1++)
    {
        fscanf(fp, "%s\n", sT1);//sylee161227
        str.Format("%s", sT1);
        str.TrimLeft('V');
        //no=str.Find('T');
        //str=str.Right(no+1);
        nT1 = atoi(str);
        if (nT1 < 0) {
            nT1 = 0;
            goto Task1;
        }
        g_nSkipPieceTemp[k1] = nT1;//sylee161227 //son220624 begin
        //sylee161227   fscanf(fp, "%10d\n", &g_nSkipPieceTemp[k1] );
        if (g_nSkipPieceTemp[k1] <= 0) {
            goto Task1;
        }
        if (k1 == Total) {
            g_nSkipPieceTemp[0] = Total;    //son220624 end
        }
    }

    fscanf(fp, "%s\n", sLenth);
    str.Format("%s", sLenth);
    no = str.CompareNoCase("END");
    if (no != 0) {// 0=same    1=differ
        goto Task1;
        //return 0;
    }
    //  fscanf(fp, "%10d\n", &SysInfoPiece.m_nRow);          
    //  fscanf(fp, "%10d\n", &SysInfoPiece.m_nCol);
    nPass = 1;


Task1:

    fclose(fp);

    //sylee201201-1 DeleteFile("Z:\\SkipPcs.txt" );
    DeleteFile(fName);//sylee201201-1

    //-------------------------------------------------------------------------------
    //son SkipPcs.txt 파일의 내용을 piece를 index로 해서 찾을 수 있는 구조로 변경.
    fp = fopen(fName, "rt");
    if (fp == NULL)
    {
        //------------------------------------------
        g_nSkipPieceFlag1 = 1;// CATCH OK,<=============        //son220624 begin

        Total = g_nSkipPieceTemp[0];
        g_nSkipPieceInfo[0] = Total;
        for (k1 = 1; k1 <= Total; k1++) {
            no = g_nSkipPieceTemp[k1];
            g_nSkipPieceInfo[no] = 2; //skip disable piece    <=============  
            nOpenFail14W[no] = 0; //SYLEE180528-1
        }
        //------------------------------------------
        if (nPass != 1) {
            g_nSkipPieceFlag1 = 0;//CATCH ERROR  //son220624 end
        }

    }
    else {
        fclose(fp);
        g_nSkipPieceFlag1 = -1;// file delete ERROR //son220624
    }

    return 1;
}






int CChildView7::LogDebug3(CString str1)     //SYLEE180810-1-DUT16
{

    MyTrace(PRT_BASIC, "%s\n", str1);     //son210715 

    return 1; //sylee181116


    FILE* fp;
    char  fName[200];
    CString str;

    CTime curTime = CTime::GetCurrentTime();
    ::ZeroMemory(&fName, sizeof(fName));

    // str.Format("D:\\Debug\\Debug%02dM%02dD_%02dH02dM%02dS.txt",curTime.GetMonth(),curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(),curTime.GetSecond() );
    str.Format("D:\\logdut\\LogCom_Dut_%02dM_%02dD.txt", curTime.GetMonth(), curTime.GetDay());
    strcat(fName, str);
    fp = fopen(fName, "at");
    if (fp == NULL) {
        AfxMessageBox(str, MB_OK); //error messege          
        return 0;
    }
    else {
        //      str.Format(" %02dM%02dD_%02dH%02dM%02dS    ::   Block=%d, Piece=%d,  %s \n ",curTime.GetMonth(),curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(),Block,piece,str1) ;    
        str.Format(" %02d/%02d_%02d:%02d:%02d    -->       %s \n ", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), str1);
    }
    fprintf(fp, str);
    fclose(fp);

    return 1;

}

int CChildView7::LogDebug2(CString str1)     //SYLEE170618
{

    return 1;  //sylee170618


    FILE* fp;
    char  fName[200];
    CString str;

    CTime curTime = CTime::GetCurrentTime();
    ::ZeroMemory(&fName, sizeof(fName));

    str.Format("D:\\log_Debug%02dM02dD_%02dH02dM%02dS.txt", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
    strcat(fName, str);
    fp = fopen(fName, "at");
    if (fp == NULL) {
        AfxMessageBox(str, MB_OK); //error messege           
        return 0;
    }
    else {
        //      str.Format(" %02dM%02dD_%02dH%02dM%02dS    ::   Block=%d, Piece=%d,  %s \n ",curTime.GetMonth(),curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(),Block,piece,str1) ;    
        str.Format(" %02dM%02dD_%02dH%02dM%02dS    ::   Block=%d,    %s \n ", curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), nBlockCountP, str1);
    }
    fprintf(fp, str);
    fclose(fp);

    return 1;

}






//son 4W auto test 결과(d4W_Log2[dutIdx][j][net])를 '4W_Setup_A.txt'에 write한다.
//    4W-> Setup 화면에서 사용함.
//    Auto 화면을 빠져나갈때를 대비해서 현재 DUT의 모든  data를 모두 파일에 저장한다.
int CChildView7::ARun201_4w_Logging3_Sample2()     //SYLEE170114
{

    char fName1[200];
    CString str;
    FILE* fp;
    int nEnd;
    double nMin[MAX_4W_NET +1], nMax[MAX_4W_NET +1], nAve[MAX_4W_NET +1], nDif[MAX_4W_NET +1], nDifRate[MAX_4W_NET +1], nDifRate2[MAX_4W_NET +1]; //son231107
    float  dSigmaVar1[MAX_4W_NET +1];//sylee170125  //son231107
    float  dSum1, nCount1;//sylee170125

    ::ZeroMemory(&dSigmaVar1, sizeof(dSigmaVar1));//sylee170125 
    ::ZeroMemory(&nMin, sizeof(nMin));
    ::ZeroMemory(&nMax, sizeof(nMax));
    ::ZeroMemory(&nAve, sizeof(nAve));
    ::ZeroMemory(&nDif, sizeof(nDif));
    ::ZeroMemory(&nDifRate, sizeof(nDifRate));
    ::ZeroMemory(&nDifRate2, sizeof(nDifRate2));
    ::ZeroMemory(&fName1, sizeof(fName1));//SYLEE150806

    str.Format("%s", SysInfoView01.m_pStrFilePathBDL);//SYLEE150806
    strcat(fName1, str);//SYLEE150806


    //son200320-4WDUT16: Multi DUT 구조로 수정.
    //son 현재 dutIdx에 해당하는  4W_Setup_A.txt 또는  4W_Setup_A.txt%d (dut) 를 생성한다. 
    int dutIdx = get4wDutIdx();
    {

        if (dutIdx == 0)
            str.Format("\\4W_Setup_A.txt"); //SYLEE150806
        else
            str.Format("\\4W_Setup_A.txt%d", dutIdx + 1);
        strcat(fName1, str);


        fp = fopen(fName1, "wt");
        if (fp == NULL) {
            str.Format("Error    %s file open   ?  Error, Saving Error !     file close!   ", fName1);
            AfxMessageBox(str, MB_OK);
            return  0;
        }

        MyTrace(PRT_LEVEL2, "ARun201_4w_Logging3_Sample2(): file=%s\n\n\n", fName1); //son211215 추가

        //-------------------
        //son 헤더 출력
        //-------------------
        int i;

        //son200312-4WDUT16
        nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16
#ifdef __4WCSV_SHEETNO_BARCODE  //son231124

        //son211112 Unitech 요구사항. 4W_Setup_A.txt에 step, BarCode 정보 추가 요청
        //son 첫줄 헤더에 각 Block별로  BarCode 정보를 추가하여 출력한다.
        for (i = 1; i <= n4w_Sample_SetCount; i++)
        {
            if (i == 1)
                fprintf(fp, "      %d,    %d,    ,      ,      ,      ,   ", n4w_Sample_SetCount, nEnd);

            //son BarCode 정보 첫번째 줄 헤더에 출력 for Unitech
            fprintf(fp, " %s ,", g_4wSampling[dutIdx][i].strBarCode);  //son211112
        }
        fprintf(fp, "  \n ");   //son211112

#else
        fprintf(fp, "  %d,    %d, \n", n4w_Sample_SetCount, nEnd);//sylee1507=806 
#endif

        for (i = 1; i <= n4w_Sample_SetCount; i++)
        {
            if (i == 1)
                fprintf(fp, " NetNo.,  *  ,Pin1 , Pin2 , Pin3 , Pin4 ,   ");

#ifdef __4WCSV_SHEETNO_BARCODE  //son231124
            //son211112 Unitech 요구사항. 4W_Setup_A.txt에 step, BarCode 정보 추가 요청
            //son sampling 번호 두번째 줄 헤더에 sample Sheet 번호(불량, 양품 모두 증가) 추가하여 출력.  ex: "#1 S1"
            fprintf(fp, "  #%d_S%d     ,", i, g_4wSampling[dutIdx][i].wSheetNo);  //son211112
#else

            //son sampling 번호 두번째 줄 헤더에 출력.  ex: "#1 "
            fprintf(fp, "         #%d    ,    ", i);
#endif
        }
        fprintf(fp, "     Min    ,       Avg ,       Max ,           Dif.Value    ,   Dif.Rate%, ((Max.-MIn.)/2)/Avg. ,Sigma.1");
        fprintf(fp, "  \n ");
        nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16

        //-------------------
        //son data 출력
        //-------------------
        int net;    //son190704-4WDUT16
        for (net = 1; net <= nEnd; net++)
        {
            for (int j = 1; j <= n4w_Sample_SetCount; j++)
            {
                if (j == 1) {
                    if (g_bUseLowerCalJig_4W)     //son220426_3 begin
                        fprintf(fp, " Net%d,  PIN,   %d,   %d,   %d,   %d,      ",
                            net, (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0] + (SysSet12.m_nLowerJigStartPin - 1),
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1] + (SysSet12.m_nLowerJigStartPin - 1),
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2] + (SysSet12.m_nLowerJigStartPin - 1),
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3] + (SysSet12.m_nLowerJigStartPin - 1));

                    else    //son220426_3 end
                        fprintf(fp, " Net%d,  PIN,   %d,   %d,   %d,   %d,      ",
                            net, (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                            (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3]);///sylee150722-2
                    nMin[net] = d4W_Log2[dutIdx][j][net];
                    nMax[net] = d4W_Log2[dutIdx][j][net];
                }

                if (d4W_Log2[dutIdx][j][net] > 0) {
                    fprintf(fp, "   %11.2f,   ", d4W_Log2[dutIdx][j][net]); //son231205_2
                }
                else {
                    fprintf(fp, "     999999,  ");
                }

                if (j != 1) {
                    if (d4W_Log2[dutIdx][j][net] < nMin[net]) {
                        nMin[net] = d4W_Log2[dutIdx][j][net];
                    }
                    if (d4W_Log2[dutIdx][j][net] > nMax[net]) {
                        nMax[net] = d4W_Log2[dutIdx][j][net];
                    }
                }
                nAve[net] = nAve[net] + d4W_Log2[dutIdx][j][net];
            }
            nAve[net] = nAve[net] / n4w_Sample_SetCount;
            nDif[net] = nMax[net] - nMin[net];
            nDifRate[net] = nDif[net] / nAve[net] * 100.0;
            nDifRate2[net] = (nDif[net] / 2.) / nAve[net];
            //                        Min       Avg     Max              DifVal  DifRate   (Max-Min) 
            fprintf(fp, "           %11.2f,  %11.2f,  %11.2f,          %11.2f,  %11.2f,  %11.2f,    ",  //son231205_2
                nMin[net], nAve[net], nMax[net], nDif[net], nDifRate[net], nDifRate2[net]);
            //===========================
            //SIGMA
            dSum1 = 0;//SIGMA //sylee170125   //sylee170707
            nCount1 = 0; //SIGMA //sylee170125    //sylee170707

            //son sampling data 중에 최소값, 최대값은 제외하고 sigma를 계산한다.
            for (int k = 1; k <= n4w_Sample_SetCount; k++)  //sylee170125
            {
                if (d4W_Log2[dutIdx][k][net] < nMin[net]) { //<=
                    continue;
                }
                if (d4W_Log2[dutIdx][k][net] > nMax[net]) { //>=
                    continue;
                }
                nCount1++;
                dSum1 = dSum1 + (float)(d4W_Log2[dutIdx][k][net] - nAve[net]) * (float)(d4W_Log2[dutIdx][k][net] - nAve[net]);
                //}

                //sylee170707    dSum1=dSum1/nCount1;  
                //sylee170707    dSigmaVar1[net]=(float)sqrt(dSum1);         
            } //sylee170125

            if (nCount1 > 0)        //son210928
                dSum1 = dSum1 / nCount1;    //sylee170707
            dSigmaVar1[net] = (float)sqrt(dSum1);     //sylee170707

            fprintf(fp, "   %10.3f,    ", dSigmaVar1[net]);  //sylee170125
            fprintf(fp, "  \n ");
        }

        fprintf(fp, "  \n ");
        fclose(fp);
    }



    return 1;
}


//son VC log 출력
int CChildView7::ARun201_4w_Logging3_Sample3()     //SYLEE190220   V FILE
{

    char fName1[200];
    CString str;
    FILE* fp;
    int nEnd;
    double nMin[MAX_4W_NET +1], nMax[MAX_4W_NET +1], nAve[MAX_4W_NET +1], nDif[MAX_4W_NET +1], nDifRate[MAX_4W_NET +1], nDifRate2[MAX_4W_NET +1]; //son231107
    float  dSigmaVar1[MAX_4W_NET +1];//sylee170125  //son231107
    float  dSum1, nCount1;//sylee170125

    ::ZeroMemory(&dSigmaVar1, sizeof(dSigmaVar1));//sylee170125 
    ::ZeroMemory(&nMin, sizeof(nMin));
    ::ZeroMemory(&nMax, sizeof(nMax));
    ::ZeroMemory(&nAve, sizeof(nAve));
    ::ZeroMemory(&nDif, sizeof(nDif));
    ::ZeroMemory(&nDifRate, sizeof(nDifRate));
    ::ZeroMemory(&nDifRate2, sizeof(nDifRate2));
    ::ZeroMemory(&fName1, sizeof(fName1));//SYLEE150806

    str.Format("%s", SysInfoView01.m_pStrFilePathBDL);//SYLEE150806
    strcat(fName1, str);//SYLEE150806
    strcat(fName1, "\\4W_Setup_A_Votage.txt"); //SYLEE150806

    fp = fopen(fName1, "wt");
    if (fp == NULL) {
        str.Format("Error    %s file open   ?  Error, Saving Error !     file close!   ", fName1);
        AfxMessageBox(str, MB_OK);
        return  0;
    }

    //son200312-4WDUT16
    int dutIdx = get4wDutIdx();         //son190704-4WDUT16 g_s4WNet의 index. 0부터 시작함.
    nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16
    fprintf(fp, "  %d,    %d, \n", n4w_Sample_SetCount, nEnd);//sylee1507=806 

    for (int i = 1; i <= n4w_Sample_SetCount; i++) {
        if (i == 1) {
            fprintf(fp, " NetNo.,  *  ,Pin1 , Pin2 , Pin3 , Pin4 ,   ");
        }
        fprintf(fp, "         #%d    ,   ", i);
    }
    fprintf(fp, "             MIN.    ,       AVE. ,       MAX. ,           Dif.Value    ,   Dif.Rate%, ((Max.-MIn.)/2)/Avg. ,Sigma.1");
    fprintf(fp, "  \n ");
    nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16

    int net;        //son190704-4WDUT16
    for (net = 1; net <= nEnd; net++)
    {
        for (int j = 1; j <= n4w_Sample_SetCount; j++)
        {
            if (j == 1) {
                fprintf(fp, " Net%d,  PIN,   %d,   %d,   %d,   %d,      ",
                    net, (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3]);///sylee150722-2
                nMin[net] = d4W_Log3[j][net];
                nMax[net] = d4W_Log3[j][net];
            }

            //son231123 if (d4W_Log2[dutIdx][j][net] > 0) 
            if (d4W_Log3[j][net] > 0)   //son231123 버그수정. d4W_Log2 -> d4W_Log3 
                fprintf(fp, "     %11.2f,   ", d4W_Log3[j][net]);   //son231205_2
            
            else 
                fprintf(fp, "     999999,  ");
            

            if (j != 1) {
                if (d4W_Log3[j][net] < nMin[net]) {
                    nMin[net] = d4W_Log3[j][net];
                }
                if (d4W_Log3[j][net] > nMax[net]) {
                    nMax[net] = d4W_Log3[j][net];
                }
            }
            nAve[net] = nAve[net] + d4W_Log3[j][net];
        }
        nAve[net] = nAve[net] / n4w_Sample_SetCount;
        nDif[net] = nMax[net] - nMin[net];
        nDifRate[net] = nDif[net] / nAve[net] * 100.0;
        nDifRate2[net] = (nDif[net] / 2.) / nAve[net];
        fprintf(fp, "             %11.2f,  %11.2f,  %11.2f,          %11.2f,  %11.2f,%11.2f,    ",  //son231205_2
            nMin[net], nAve[net], nMax[net], nDif[net], nDifRate[net], nDifRate2[net]);
        //===========================
        //SIGMA
        dSum1 = 0;//SIGMA //sylee170125   //sylee170707
        nCount1 = 0; //SIGMA //sylee170125    //sylee170707

        for (int k = 1; k <= n4w_Sample_SetCount; k++) {  //sylee170125

            if (d4W_Log3[k][net] < nMin[net]) { //<=
                continue;
            }
            if (d4W_Log3[k][net] > nMax[net]) { //>=
                continue;
            }
            nCount1++;
            dSum1 = dSum1 + (float)(d4W_Log3[k][net] - nAve[net]) * (float)(d4W_Log3[k][net] - nAve[net]);
            //}

            //sylee170707    dSum1=dSum1/nCount1;  
            //sylee170707    dSigmaVar1[net]=(float)sqrt(dSum1);         
        } //sylee170125

        dSum1 = dSum1 / nCount1;    //sylee170707
        dSigmaVar1[net] = (float)sqrt(dSum1);     //sylee170707

        fprintf(fp, "   %10.3f,    ", dSigmaVar1[net]);  //sylee170125
        fprintf(fp, "  \n ");
    }

    fprintf(fp, "  \n ");
    fclose(fp);




    return 1;
}


//son I log 출력
int CChildView7::ARun201_4w_Logging3_Sample5()     //SYLEE190220   / CURRENT
{

    char fName1[200];
    CString str;
    FILE* fp;
    int nEnd;
    double nMin[MAX_4W_NET +1], nMax[MAX_4W_NET +1], nAve[MAX_4W_NET +1], nDif[MAX_4W_NET +1], nDifRate[MAX_4W_NET +1], nDifRate2[MAX_4W_NET +1];  //son231107
    float  dSigmaVar1[MAX_4W_NET +1];//sylee170125  //son231107
    float  dSum1, nCount1;//sylee170125

    ::ZeroMemory(&dSigmaVar1, sizeof(dSigmaVar1));//sylee170125 
    ::ZeroMemory(&nMin, sizeof(nMin));
    ::ZeroMemory(&nMax, sizeof(nMax));
    ::ZeroMemory(&nAve, sizeof(nAve));
    ::ZeroMemory(&nDif, sizeof(nDif));
    ::ZeroMemory(&nDifRate, sizeof(nDifRate));
    ::ZeroMemory(&nDifRate2, sizeof(nDifRate2));
    ::ZeroMemory(&fName1, sizeof(fName1));//SYLEE150806

    str.Format("%s", SysInfoView01.m_pStrFilePathBDL);//SYLEE150806
    strcat(fName1, str);//SYLEE150806
    strcat(fName1, "\\4W_Setup_A_Current.txt"); //SYLEE150806

    fp = fopen(fName1, "wt");
    if (fp == NULL) {
        str.Format("Error    %s file open   ?  Error, Saving Error !     file close!   ", fName1);
        AfxMessageBox(str, MB_OK);
        return  0;
    }

    //son200312-4WDUT16
    int dutIdx = get4wDutIdx();         // g_s4WNet의 index. 0부터 시작함.  //son190704-4WDUT16
    nEnd = (int)g_s4WNet[dutIdx].wCount;  //son190704-4WDUT16
    fprintf(fp, "  %d,    %d, \n", n4w_Sample_SetCount, nEnd);//sylee1507=806 

    for (int i = 1; i <= n4w_Sample_SetCount; i++) {
        if (i == 1) {
            fprintf(fp, " NetNo.,  *  ,Pin1 , Pin2 , Pin3 , Pin4 ,   ");
        }
        fprintf(fp, "         #%d    ,   ", i);
    }
    fprintf(fp, "             MIN.    ,       AVE. ,       MAX. ,           Dif.Value    ,   Dif.Rate%, ((Max.-MIn.)/2)/Avg. ,Sigma.1");
    fprintf(fp, "  \n ");
    nEnd = (int)g_s4WNet[dutIdx].wCount;

    int net;        //son190704-4WDUT16
    for (net = 1; net <= nEnd; net++)
    {
        for (int j = 1; j <= n4w_Sample_SetCount; j++)
        {
            if (j == 1) {
                fprintf(fp, " Net%d,  PIN,   %d,   %d,   %d,   %d,      ",
                    net, (int)g_s4WNet[dutIdx].saData[net - 1].waPin[0], //son190705-DUT16
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[1],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[2],
                    (int)g_s4WNet[dutIdx].saData[net - 1].waPin[3]);///sylee150722-2
                nMin[net] = d4W_Log5[j][net];
                nMax[net] = d4W_Log5[j][net];
            }

            //son231123 if (d4W_Log2[dutIdx][j][net] > 0) 
            if (d4W_Log5[j][net] > 0)   //son231123 버그수정. d4W_Log2 -> d4W_Log5
                fprintf(fp, "     %11.2f,   ", d4W_Log5[j][net]);   //son231205_2
            
            else 
                fprintf(fp, "     999999,  ");
            

            if (j != 1) {
                if (d4W_Log5[j][net] < nMin[net]) {
                    nMin[net] = d4W_Log5[j][net];
                }
                if (d4W_Log5[j][net] > nMax[net]) {
                    nMax[net] = d4W_Log5[j][net];
                }
            }
            nAve[net] = nAve[net] + d4W_Log5[j][net];
        }
        nAve[net] = nAve[net] / n4w_Sample_SetCount;
        nDif[net] = nMax[net] - nMin[net];
        nDifRate[net] = nDif[net] / nAve[net] * 100.0;
        nDifRate2[net] = (nDif[net] / 2.) / nAve[net];
        fprintf(fp, "             %11.2f,  %11.2f,  %11.2f,          %11.2f,  %11.2f,%11.2f,    ",  //son231205_2
            nMin[net], nAve[net], nMax[net], nDif[net], nDifRate[net], nDifRate2[net]);
        //===========================
        //SIGMA
        dSum1 = 0;//SIGMA //sylee170125   //sylee170707
        nCount1 = 0; //SIGMA //sylee170125    //sylee170707

        for (int k = 1; k <= n4w_Sample_SetCount; k++) {  //sylee170125

            if (d4W_Log5[k][net] < nMin[net]) { //<=
                continue;
            }
            if (d4W_Log5[k][net] > nMax[net]) { //>=
                continue;
            }
            nCount1++;
            dSum1 = dSum1 + (float)(d4W_Log5[k][net] - nAve[net]) * (float)(d4W_Log5[k][net] - nAve[net]);
            //}

            //sylee170707    dSum1=dSum1/nCount1;  
            //sylee170707    dSigmaVar1[net]=(float)sqrt(dSum1);         
        } //sylee170125

        dSum1 = dSum1 / nCount1;    //sylee170707
        dSigmaVar1[net] = (float)sqrt(dSum1);     //sylee170707

        fprintf(fp, "   %10.3f,    ", dSigmaVar1[net]);  //sylee170125
        fprintf(fp, "  \n ");
    }

    fprintf(fp, "  \n ");
    fclose(fp);

    return 1;
}





int CChildView7::n4wAutoCal2()//sylee171020-1
{

    /* //sylee180213-1
    if(SysSet19.m_nSet23>0){
         n4w_AutoCalCo1++;  //sylee171020-1
         if( SysSet19.m_nSet23<=n4w_AutoCalCo1){//sylee171020-1
              n4w_AutoCalCo1=0; //sylee171020-1
         }
         if(n4w_AutoCalCo1==1){
             n4wAutoCal1();//sylee171020-1
         }
     }
     */

    return 1;

}



int CChildView7::n4wAutoCal1()//sylee171020-1
{

    int a1, a2, a3, a4;

    Sub71.OnPinAllReset1(); ///PIN ALL RESET 

    a1 = (int)nPinAutoCal1[1] - 1;
    a2 = (int)nPinAutoCal1[3] - 1;
    a3 = (int)nPinAutoCal1[2] - 1;
    a4 = (int)nPinAutoCal1[4] - 1;

    Sub71.AOnPinSet1(2, a4, 4);//sylee170802  ok
    Sub71.Delay_100ns(1000);
    Sub71.AOnPinSet1(2, a2, 3);  //sylee170802  ok
    Sub71.Delay_100ns(1000);
    Sub71.AOnPinSet1(2, a3, 2);  //sylee170802  ok   
    Sub71.Delay_100ns(300);
    Sub71.AOnPinSet1(2, a1, 1);   //sylee170802  ok 

    Sub71.Delay_100ns(20000); //2mS


    double dSum1_W1, dSum1_Y1, dMin1, dMax1, dMin2, dMax2;//sylee170228-1


    dSum1_W1 = 0;
    dSum1_Y1 = 0;
    dMin1 = 0;
    dMax1 = 0; //sylee170228-1
    dMin2 = 0;
    dMax2 = 0; //sylee170228-1

    for (int k2 = 1; k2 <= 10; k2++) {

        Sub71.AOnReadV1I1(5); // READ  4W V  , I     

        if (k2 == 1) {
            dMax1 = Sub71.W1;
            dMin1 = Sub71.W1;
            dMax2 = Sub71.Y1;
            dMin2 = Sub71.Y1;
        }
        else {
            if (Sub71.W1 < dMin1) {
                dMin1 = Sub71.W1;
            }
            if (Sub71.W1 > dMax1) {
                dMax1 = Sub71.W1;
            }
            if (Sub71.Y1 < dMin2) {
                dMin2 = Sub71.Y1;
            }
            if (Sub71.Y1 > dMax2) {
                dMax2 = Sub71.Y1;
            }
        }
        dSum1_W1 = dSum1_W1 + Sub71.W1;
        dSum1_Y1 = dSum1_Y1 + Sub71.Y1;

    }

    Sub71.W1 = (dSum1_W1 - (dMax1 + dMin1)) / (10 - 2);
    Sub71.Y1 = (dSum1_Y1 - (dMax2 + dMin2)) / (10 - 2);

    //######################################################################################################

    Sub71.OnPinAllReset1(); ///PIN ALL RESET  

    if (Sub71.Y1 < 0.0000001) {
        Sub71.Y1 = 0.0000001;
    }

    if (Sub71.Y1 > 0) {
        if (nIR == 1 || nIR == 2) {//I mA                        
            Sub71.R1 = ((Sub71.W1) / Sub71.Y1) * 10.;//sylee  //sylee161207-0 x10     ok
        }
        else if (nIR == 3 || nIR == 4 || nIR == 5) {  //I uA                            
            Sub71.R1 = ((Sub71.W1) / Sub71.Y1) * 1000;//배율 /1000                                 
        }
        else {
            Sub71.R1 = 9999999999;
        }
    }
    else {
        Sub71.R1 = 9999999999;
    }
    ////////////////////////////////////////////////////////////////////////////////////////

    Sub71.R1 = Sub71.R1 * 1000;
    n4wAutoCal1_Save();//sylee171020-1

//  Sleep(10);

    return 1;
}



int CChildView7::n4wAutoCal1_Save()//sylee171020-1
{

    double q1, doffset1;
    CString str;

    int part = PART_UPPER;  //son220412
    FileSysInfo01.LoadSaveSer13(_LOAD, 171, PART_MIXED); //son220412

    doffset1 = SysInfoSer13.m_nData[part][171][CAL_REF_RAWR][1] - Sub71.R1;  //1mohm  sylee171027-1   //son220407 3:CAL_REF_RAWR

    if (doffset1 < -1000) {
        doffset1 = 0;
    }
    if (doffset1 > 1000) {
        doffset1 = 0;
    }

    q1 = SysInfoSer13.m_nData[part][171][CAL_REF_RAWR][1];//10mohm  sylee171027-1 //son220407 3:CAL_REF_RAWR

    for (int i = 1; i <= 15; i++) {
        SysInfoSer13.m_nData[part][171][CAL_REF_RAWR][i] = SysInfoSer13.m_nData[part][171][CAL_REF_RAWR][i] - doffset1; //son220407 3:CAL_REF_RAWR
    }

    return 1;
}


 
 

int  CChildView7::OnSelfTr1_Set_File1(int type)
{


    return 1;


    FILE* fp;
    char  fName[200];
    ::ZeroMemory(&fName, sizeof(fName));

    CString str;
    str.Format("%s\\SETUP\\Self_Tr1_Set.ini", SysInfoView01.m_pStrFilePath1);   //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1

    switch (type)
    {
    case 1: //SAVE :   
        fp = fopen(fName, "wt");
        if (fp == NULL) {
            //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1
            str.Format(" Error No 2011 !\n  %s\\SETUP\\Self_Tr1_Set.ini   file Data Saving Error !     file close!\n", SysInfoView01.m_pStrFilePath1);  //son210514
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str, MB_OK); //son201118  //son210514
            return 0;
        }
        fprintf(fp, "%10d\n ", nSelf1_Use);
        fprintf(fp, "%10d\n ", nSelf1_SetDelay);
        fprintf(fp, "%10d\n ", nSelf1_SetCount);
        fprintf(fp, "%10d\n ", nSelf1_SetStartPin);
        fprintf(fp, "%10d\n ", nSelf1_SetEndPin);
        break;


    case 2://LOAD :
        fp = fopen(fName, "rt");
        if (fp == NULL) {
            //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1
            str.Format(" Error No 2011 !\n   %s\\SETUP\\Self_Tr1_Set.ini   file Data Loading Error", SysInfoView01.m_pStrFilePath1);    //son210514
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str, MB_OK); //error messege  //son210514
            return 0;
        }
        fscanf(fp, "%10d\n", &nSelf1_Use);  // USE=1, NOT USE=0
        if (nSelf1_Use < 0 || nSelf1_Use>1) {
            nSelf1_Use = 0;
        }
        fscanf(fp, "%10d\n", &nSelf1_SetDelay);     //5      mS   
        if (nSelf1_SetDelay < 0 || nSelf1_SetDelay>20) {
            nSelf1_SetDelay = 1;
        }
        fscanf(fp, "%10d\n", &nSelf1_SetCount);     //5000   count
        if (nSelf1_SetCount < 0 || nSelf1_SetCount>10000) {
            nSelf1_SetDelay = 1;
        }
        fscanf(fp, "%10d\n", &nSelf1_SetStartPin);  // 1  SWITCH CARD NO 
        if (nSelf1_SetStartPin<0 || nSelf1_SetStartPin>(4096 * 4)) {
            nSelf1_SetStartPin = 1;
        }
        fscanf(fp, "%10d\n", &nSelf1_SetEndPin);    // 4096   8192  16384   12288 SWITCH CARD NO
        if (nSelf1_SetEndPin<0 || nSelf1_SetEndPin>(4096 * 4)) {
            nSelf1_SetEndPin = 1;
        }
        break;

    default:
        break;
    }
    fclose(fp);
    return 1;
}


int  CChildView7::OnSelfTr1_Run_File2(int type)
{

    return 1;


    FILE* fp;
    char  fName[200];
    ::ZeroMemory(&fName, sizeof(fName));
    //son210514 "C:\\ACE500"  => SysInfoView01.m_pStrFilePath1
    CString str;
    str.Format("%s\\SETUP\\Self_Tr1_Run.ini", SysInfoView01.m_pStrFilePath1);   //son210514
    strcat(fName, str);  //son210514

    switch (type)
    {
    case 1: //SAVE :   
        fp = fopen(fName, "wt");
        if (fp == NULL) {
            str.Format(" Error No 2011 !\n  %s\\SETUP\\Self_Tr1_Run.ini   file Data Saving Error !     file close!", SysInfoView01.m_pStrFilePath1); //son210514
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str, MB_OK); //error messege
            return 0;
        }
        fprintf(fp, "%10d\n ", nSelf1_RunPin1);
        fprintf(fp, "%10d\n ", nSelf1_RunErr1);
        fprintf(fp, "%10d\n ", nSelf1_RunSetSum1);
        break;


    case 2://LOAD :
        fp = fopen(fName, "rt");
        if (fp == NULL) {
            str.Format(" Error No 2011 !\n   %s\\SETUP\\Self_Tr1_Run.ini   file Data Loading Error", SysInfoView01.m_pStrFilePath1); //son210514
            MyTrace(PRT_BASIC, str);     //son221104_2
            AfxMessageBox(str, MB_OK); //son201118
            return 0;
        }
        fscanf(fp, "%10d\n", &nSelf1_RunPin1);
        fscanf(fp, "%10d\n", &nSelf1_RunErr1);
        fscanf(fp, "%10d\n", &nSelf1_RunSetSum1);
        break;

    default:
        break;
    }
    fclose(fp);
    return 1;

}

//int nMode1;

 
 


void CChildView7::OnSelfTr1_UnSet11() //sylee181117
{

    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET   
    Sub71.ARunoff1();   //vc sense off       /VC-SS  CMD off
    Sub71.AOnRelayOffSel(nVRel);
    Sub71.FilterSet(0);
    Sub71.I_Filter(0);
    Sub71.AOnReadV1Enable1(5);
    Sub71.OnPinResetInit();
    Sub71.AIRangeOff();

    return;
}




void CChildView7::OnSelfTr1_Result_File(int nDe1Co1)
{

    FILE* fp;
    char  fName[200];
    CString str;

    ::ZeroMemory(&fName, sizeof(fName));

    CTime  curTime = CTime::GetCurrentTime();  //sylee161122 
    str.Format("d:\\Self10_Auto_%04d%02d%02d_%02d%02d%02dS.txt", 
            curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());

    //  strcat( fName , "d:\\Debug_1.txt" ); 
    strcat(fName, str);
    fp = fopen(fName, "wt");
    if (fp == NULL) {
        str = "Error file open" + str;
        AfxMessageBox(str, MB_OK); //error messege
        //return 0;
    }
    else {
        for (int iii = 1; iii <= nDe1Co1; iii++) {
            //fprintf(fp, " No=%7d, user pin no=%7d , Loop=%7d, ErrCount=%7d \n",iii,nDe1[iii][0],nDe1[iii][1],nDe1[iii][2]);
            fprintf(fp, " *%04d/%02d/%02d  %02d:%02d:%02d   * No=%7d, user pin no=%7d , sw pin=%d, Loop=%7d,  AD=%7d   \n", 
                    curTime.GetYear(), curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond(), 
                    iii, nDe1[iii][0], nDe1[iii][3], nDe1[iii][1], nDe1[iii][4]);
        }
        fclose(fp);
    }

    ::ShellExecute(NULL, "open", "EXCEl.EXE", str, "NULL", SW_SHOWNORMAL);

    return;
}


void CChildView7::OnSelfTr1_Stop() //stop
{
    nFlag_Stop = 2;
    return;
}



int  CChildView7::OnSelfTr1_ADCI_Read1(double nProRv1, double nTimeOutSet1, int nntype) //sylee121016
{


    long TimeT1;
    double nOldAdc1, diff1;
    __int64   tStart1, tStart2, tStart3;
    int delay_time, nLoopSet1, nLoop1, nBuf1Sum, nAvg, nShort_Flag1;
    int nBuf1[100];


    nShort_Flag1 = __LV;  //1:__LV  2:__HV

    nOldAdc1 = 0;
    diff1 = 0;
    TimeT1 = 0;
    nLoop1 = 0;
    nBuf1Sum = 0;
    nAvg = 0;
    Sub71.R1 = 0.0;

    ::ZeroMemory(&nBuf1, sizeof(nBuf1));

    nLoopSet1 = 6;
    delay_time = 200;//100us

    if (nTimeOutSet1 < 1) {  //mS  
        nTimeOutSet1 = 1;
    }
    if (nTimeOutSet1 > 300) {
        nTimeOutSet1 = 300;
    }
    nTimeOutSet1 = nTimeOutSet1 * 1000;  //sylee190116  

    Sub71.Delay_100ns(delay_time);
    TimeT1 = delay_time;
    tStart1 = GetuSecond();
    Sub71.AOnReadV1I1_ADC_I();

    tStart2 = GetuSecond();
    tStart3 = (tStart2 - tStart1) * 10;
    TimeT1 = TimeT1 + (long)(tStart3);

    for (int nK1 = 1; nK1 < 500000; nK1++) {

        Sub71.AOnReadV1I1_ADC_I();

        TimeT1 = TimeT1 + (long)(tStart3);

        if (nLoop1 < nLoopSet1) {
            nLoop1++;
        }
        else {
            nLoop1 = 1;
        }
        nBuf1[nLoop1] = (int)Sub71.R1;
        nBuf1Sum = 0;

        for (int i = 1; i <= nLoopSet1; i++) {
            nBuf1Sum = nBuf1Sum + nBuf1[i];
        }

        if (nK1 > 6) {
            Sub71.R1 = nBuf1Sum / nLoopSet1;//avg            
        }

        //log   bb[nK1]=Sub71.R1;//log

        if (nK1 != 1) {
            diff1 = (double)(nOldAdc1 - Sub71.R1);
            if (diff1 <= 0) diff1 = -diff1;
            nOldAdc1 = Sub71.R1;
        }

        if (Sub71.R1 < 10) {//sylee201117
            Sub71.R1 = 99999;
        }


        if ((nK1 > 5 && diff1 >= 0 && diff1 < 10) && (Sub71.R1 < nProRv1)) {
            break;
        }
        if (TimeT1 > nTimeOutSet1) {
            break;
        }
        if ((TimeT1 > 800000) && (Sub71.R1 > 10000)) { //  80msec 
            break;
        }

        Sub71.Delay_100ns(delay_time); //1ms
        TimeT1 = TimeT1 + delay_time;

    }

    return 1;


}


/////////////////////////////



int  CChildView7::On_SparkFileLog1_V(int nMaxX, int nMaxY) //sylee200710 NEW_SPARK
{

    FILE* fp;
    char fName1[200];
    CString str;

    str.Format("D:\\Spark1_V.csv");
    ::ZeroMemory(&fName1, sizeof(fName1));
    strcat(fName1, str);

    fp = fopen(fName1, "wt");
    if (fp == NULL) {
        //son220701 str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ",str);
        str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ", fName1);   //son220701
        AfxMessageBox(str, MB_OK);
        return 0;
    }
    for (int j = 1; j <= nMaxY; j++) {
        for (int i = 1; i <= nMaxX; i++) {
            fprintf(fp, " %10.2f,   ", dSparkV1[j][i]);
        }
        fprintf(fp, "  \n ");
    }

    fprintf(fp, "  \n ");
    fclose(fp);

    return 1;


}



int  CChildView7::On_SparkFileLog1_I(int nMaxX, int nMaxY) //sylee200710 NEW_SPARK
{

    FILE* fp;
    char fName1[FILE_PATH_SIZE];    //son220701
    CString str;

    if (nMaxY < 1) {
        return 1;
    }

    //son220704  "d:\\logspark" 폴더가 없는 경우 file open 에러가 나는 문제 보완 
    //           폴더가 없는지 체크해서 없으면 만들어 주는 코드추가함.
    char buf[FILE_PATH_SIZE];       //son220704 begin
    sprintf(buf, "d:\\logspark");
    BOOL bRet = CheckDirExist(buf);
    if (bRet == FALSE)
    {
        str.Format("Error No 7014 \n\n %s folder is not exist.\n\n Can't create Spark LogFile!!", buf);
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    } //son220704 end


    CTime curTime = CTime::GetCurrentTime();

    //  str.Format("d:\\logspark\\0Spark1_Log_%02dM%02dD_%02dH%02dM_%02dS.CSV",
    //          curTime.GetMonth(), curTime.GetDay(),curTime.GetHour(), curTime.GetMinute(),curTime.GetSecond() ); //SYLEE130325    
    str.Format("d:\\logspark\\0Spark1_Log_%02dM%02dD_%02dH.CSV",
        curTime.GetMonth(), curTime.GetDay(), curTime.GetHour()); //SYLEE130325 

//  str.Format("D:\\Spark1_I.csv");   
    ::ZeroMemory(&fName1, sizeof(fName1));
    strcat(fName1, str);

    fp = fopen(fName1, "at");
    if (fp == NULL) {
        //son220701 영풍베트남 Spark 발생시 file open실패 문제 보완.
        // str을 %s로 주고 다시 str 을 생성하고 있어서 문제가 생김.
        //son220701 str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ",str);
        str.Format("Error      %s    file open   ?  Error, Saving Error !     file close!   ", fName1);     //son220701
        AfxMessageBox(str, MB_OK);
        return 0;
    }
    for (int j = 1; j <= nMaxY; j++) {

        fprintf(fp, "%02dM%02dD,%02dH%02dM,%02dS,",
            curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        for (int i = 1; i <= nMaxX; i++) {
            fprintf(fp, " %10.2f,   ", dSparkI1[j][i]);
        }
        fprintf(fp, "  \n ");

        fprintf(fp, "%02dM%02dD,%02dH%02dM,%02dS,",
            curTime.GetMonth(), curTime.GetDay(), curTime.GetHour(), curTime.GetMinute(), curTime.GetSecond());
        for (i = 1; i <= nMaxX; i++) {
            fprintf(fp, " %10.2f,   ", dSparkI12[j][i]); //sylee200724
        }
        fprintf(fp, "  \n ");
    }

    fprintf(fp, "  \n ");
    fclose(fp);

    return 1;


}




//----------------------
//son Auto OpenTest New             //son210712  
//----------------------
// nMod1    : TEST_TYPE (1: TEST_OPEN)
// m_nMode1 : Test mode
// nProRv1  : Test mode의 기준 R값? . R RAW, Cal 미적용 R
// nPSte1   : step (TEST_TYPE과 연관됨. ) 
int CChildView7::ARun201_O11_New(int nMod1, int m_nMode1, double nProRv1, int nPStep1) //SYLEE20111212  //SETUPCALIBRATION
{
    CString   str, str1, strfName, strfName1;

    char  fName[200], fName1[200];

    //  __int64   tStart11, tStart12, tStart13 ;  //sylee140407

    int dPinVC[200], dPinVB[200];// nTemp1[15000];
    int i, n4Wire, nRCount, nDelay10;
    int nEnd, nLoop, ipEnd, ipFlag, Lo1, nFil, nTCount;
    int nRetrySet, nReCo1, nPinA, nPinB, nRetrySet2;//sylee150604
    int nIFilter, nHVOffSet, nHVGain;//sylee130629  //

    int nDelay20, nDelay21, nIGain, n4wGain, nRCountToTal;//sylee150213
    int nOPenSetSkip, nReCo1_Old, nPass, nSelectFlag1, nRunFlag1_OPen, nRetrySet10;//sylee161018

    short  nOldPin1Flag;//sylee131221-2
    short nPiecefail[MAX_PIECE + 1];                 //son210730

    //son ConEr 체크 기능 관련. Retry1, Retry2를 모두 마쳐도 불량인 경우는 이 카운트를 증가시킴.
    //    SysInfo05.m_nConEr 에 이 값이 도달하면 해당 piece의 OpenTest를 중단시킨다.
    short nOpenFail_Co1[MAX_PIECE + 1];//sylee160731-3 /sylee161010- piecemax    //son210730


    double dR1[11][200], dVB1[11][200], dVC1[11][200], dI1[11][200], nT[10], nData[130][15];
    double nISet, dVbR1, dVbR2;
    double nISetPercentHigh, nISetPercentLow, nVBSetPercentHigh, nVBSetPercentLow;//sylee120914
    double nErrorRateToTalPin;//sylee150213

    int ip, j2;//sylee170816-1

    Sub71.OnRelay4W_OFF1();  //SYLEE181118      //son 4W Relay Off
    Sub71.OnDisCharge1(); //sylee170725-3 ray   //son 방전 수행

    if (SysInfo05.m_nConEr < 3) { //sylee161018
        nRetrySet10 = 3;
    }
    else if (SysInfo05.m_nConEr > 100) { //sylee161018
        nRetrySet10 = 100;
    }
    else {
        nRetrySet10 = SysInfo05.m_nConEr;//sylee161018
    }

    nRunFlag1_OPen = 0;
    ipEnd = 0;


    int dutId = getDutId();     //son210712

    g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];

    if ((g_nPieceMax1 >= 1)) {//PIECE
        ipEnd = g_nPieceMax1;
    }

    //--------------------------------------
    //son Open 테스트 필요 여부 점검

    for (int ip3 = 1; ip3 <= ipEnd; ip3++)
    {
        //son 모든 piece가 PASS 상태인 Cell이면 nRunFlag1_OPen=0으로 남아서 Open테스트 불가
        if (nReSheetFlag1 == 1) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip3];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                continue;
            }
        }
        //son 모든 piece가 Disable이면  nRunFlag1_OPen=0으로 남아서 Open테스트 불가. 
        if (SysInfo19.m_nUse == 1) {    //son PieceDisable Use 이면
            if (SysInfo19.m_nData[nBlockCountP][ip3] == 1) {//sylee130601
                continue;           //son Disable인 piece는 Open 테스트 대상이 아님. 
            }
        }
        //son 모든 piece에 open Pass가 있었다면 nRunFlag1_OPen=0으로 남아서 Open테스트 불가.
        if (gRun05.m_nReCh > 0) {
            if (nReFlagOpenOld[ip3] == 1) {  //son 이전 Piece Open Pass가 있었다면 넘어간다.  
                continue;                //    ReCheck는 이미 Pass인 piece는 빼고 다시 테스트하는 것임. 
            }
        }
        nRunFlag1_OPen++;   //son Open 테스트를 해야 하는 것으로 판단
    }


    if (nRunFlag1_OPen < 1) {   //son Open 테스트를 할 필요가 없다면 리턴
        return 1;
    }


    /////////////////////////////////////////////////////////////////////
    //son 초기화

    nPass = 0; //testmode

    ::ZeroMemory(&nPiecefail, sizeof(nPiecefail));//sylee150804-1

    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127

    nOPenSetSkip = 1;//sylee150519 disable

    tStart121 = GetuSecond();//TESTDEBUG

    nRCountToTal = 0;//sylee150213

    ::ZeroMemory(&nPiecefail, sizeof(nPiecefail));//sylee150804-1

    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dR1, sizeof(dR1));
    ::ZeroMemory(&dVB1, sizeof(dVB1));
    ::ZeroMemory(&dVC1, sizeof(dVC1));
    ::ZeroMemory(&dI1, sizeof(dI1));
    ::ZeroMemory(&nT, sizeof(nT));
    ::ZeroMemory(&nData, sizeof(nData));
    ::ZeroMemory(&dPinVC, sizeof(dPinVC));
    ::ZeroMemory(&dPinVB, sizeof(dPinVB));
    ::ZeroMemory(&fName, sizeof(fName));
    ::ZeroMemory(&fName1, sizeof(fName1));
    ::ZeroMemory(&nOpenFail1, sizeof(nOpenFail1));//sylee20121128 
    ::ZeroMemory(&nReFlagOpenCur, sizeof(nReFlagOpenCur));//SYLEE121129
    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3

    nOpenPassNetFlag = 0;
    nTCount = 0;
    nReCo1 = 0;
    nStop = 0;
    n4Wire = 0;
    ipFlag = 0;//PIECE    

    ipEnd = 1;//PIECE

    nRetrySet = 3;//sylee160621   //sylee160730  3
    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //mode ( 1~65)
    //step ( open, ㅏushort, short, hr, hv  4w)

    nCC = (int)dRec[m_nMode1][1];
    nVRel = (int)dRec[m_nMode1][2];
    nVSet = dRec[m_nMode1][3];

    //sylee15703    if(nUse_US==0  &&   nUse_4W==1 ){   //sylee150630
    if (nUse_US == 0 && (nUse_4W == 1 || nUse_HR == 1)) {   //sylee15703
        if (nVSet == 20) {//sylee150630
            nVRel = 2;
        }
    }


    nIR = (int)dRec[m_nMode1][4];
    nISet = dRec[m_nMode1][5];
    nDelay10 = (int)dRec[m_nMode1][6] * 10;
    nFil = (int)dRec[m_nMode1][8];
    nIFilter = (int)dRec[m_nMode1][9];   //SYLEE130629        
    nHVOffSet = (int)dRec[m_nMode1][10]; //SYLEE130629
    nHVGain = (int)dRec[m_nMode1][11];  //SYLEE130629 
    nIGain = (int)dRec[m_nMode1][12];       //SYLEE150123     
    n4wGain = (int)dRec[m_nMode1][13];     //SYLEE150123  
    nDelay20 = (int)dRec[m_nMode1][6]; //sylee160801-3  -22 delete 

    nDelay21 = 600; //sylee160801-3   //sylee170529

    nISetPercentHigh = nISet + nISet * 0.2;  //+20% //sylee120914
    nVBSetPercentHigh = nVSet + nVSet * 0.2; //+20% //sylee120914

    if (m_nMode1 == 7 || m_nMode1 == 8) {//sylee150530
        nISetPercentLow = nISet * 0.0001;   //0.1%  //sylee150530
        nVBSetPercentLow = nVSet * 0.00001;   //0.01%  //sylee150530
    }
    else {//sylee150530
        nISetPercentLow = nISet * 0.01;   //1%  //sylee120914
        nVBSetPercentLow = nVSet * 0.01;   //1%  //sylee120914
    }//sylee150530

    nIGain = (int)dRec[m_nMode1][12];       //ACE380 //SYLEE150123    

    if (nMod1 == TEST_OPEN) {//sylee20120306
        if (nVSet > 20) {
            nVRel = 4;   //VB RELAY   4
        }
    }

    //ADC COUNT
    Sub71.nADCount1 = (int)dRec[m_nMode1][7];
    if (Sub71.nADCount1 < 1) {
        Sub71.nADCount1 = 1;
    }
    if (Sub71.nADCount1 > 100) {
        Sub71.nADCount1 = 100;
    }

    //=========================================================================================
    //interlock    
    if (m_nMode1 < 1) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  <0 !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (m_nMode1 > 200) {
        AfxMessageBox(" Error No 7027, \n   Recipe Open  MODE  NO ERROR  >200 !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nCC != 1 && nCC != 2) {
        AfxMessageBox(" Error No 7024, \n    CC CV MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }

    if (nVSet < 1 || nVSet>300) {
        AfxMessageBox(" Error No 7704, \n    Votage Set Range Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }
    if (nVRel < 1 || nVRel>4) {
        AfxMessageBox(" Error No 7705, \n    Votage Set Mode 1~4 ( LV1,2, HV1,2)  Error ( 1~300V) MODE SET ERROR !,     OPEN Run Start Error!!!");
        return 0;
    }

    //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    //설정부 

    //sylee140215   Sub71.AOnReadVB1Run1(nVRel);//sylee130802 
    //sylee130903   Lo1=500; 

    //--------------------------
    //son 초기 VB Power Check
    Lo1 = 1000;//sylee200915  200->1000

Task101:

    if (nOPenSetSkip == 1)//sylee150428
    {
        //son VB Power Check
        Sub71.AOnReadVB1Run1(nVRel); //SYLEE20111213   // VB READING ,   nMode2     1=LV1,  2=LV2,  3=HV1, 4=HV2; 
        if (nVSet <= 5) {
            dVbR2 = nVSet * (0.35);//35%
        }
        else {
            dVbR2 = nVSet * (0.1);//10%
        }
        dVbR1 = nVSet - dVbR2;
        dVbR2 = nVSet + dVbR2;
        if (Simulator100 != 7) {
            if (Sub71.V1 > 300) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms //sylee121019  10->1mS  
                    goto Task101;
                }
                str.Format("Error No 1301,\n\n  Power Check? \n\n\n   Calibration NO=%d  VB READ Error!!! \n ***** HW CHECK Please! *****\n VB READING Error \nVB Set=%d, VB Read =%f.2,\n VB low=%.2f, VB high =%.2f,", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                nSelfTestHWError1 = 1;
                return 0;
            }

#ifdef _PC_TEST_
            Sub71.V1 = nVSet;      //son PC 테스트용 임시설정. HW error 넘어가기 위함
#endif
            if (Sub71.V1<dVbR1 || Sub71.V1>dVbR2) {
                if (Lo1-- > 0) {
                    Sub71.Delay_100ns(10000);  //1ms   //sylee121019  10->1mS   
                    goto Task101;
                }

                str.Format("Error No 1311,\n \n\n  Power Check? \n\n\n   VB READ Error!!    Calibration NO=%d ! \n VB Set=%.2f, VB Read =%.2f ,\n Range(VB low=%.2f, VB high =%.2f),", (int)m_nMode1, nVSet, Sub71.V1, dVbR1, dVbR2);
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str);
                if (nBlockCountP >= 1) {
                    nBlockCountP = 1;
                }
                nSelfTestHWError1 = 1;
                return 0;
            }
        }

        //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
        //설정부                
        if (nFil == 1 || nFil == 2) {//SYLEE130628
            Sub71.AOnReadV1Enable1(nVRel);
        }
        else {
            Sub71.AOnReadV1Enable1(5);
        }

        //son Gain Offset 설정
        if (nFil == 3) {//hv open

            Sub71.HV_OffSet_Gain(nHVOffSet, nHVGain);    //sylee140226
        }

        //son Filter 설정
        Sub71.FilterSet(nFil);//sylee130628 

        //son I Filter 설정
        if (nIFilter == 3) {
            AfxMessageBox(" Error No 2023, \n   FilterSet SET ERROR !  vb=3?,  select 1-2 !      ,  R Calibraion  Error!!!");
            nIFilter = 1;
        }
        Sub71.I_Filter(nIFilter);//sylee130629

        //**********************************************************//      
        //son Gain 설정
        if (nIGain == 2) {//sylee150123 //ACE380
            Sub71.I_Gain(2);  //10x  =io on     
        }
        else {
            Sub71.I_Gain(1);  //1x  =io off
        }
        //**********************************************************//

        //son I Range 설정, I Set,  V Relay On 
        Sub71.AOnISetOn1Run1(nCC, nVRel, nVSet, nIR, nISet);


    }//end of   if( nOPenSetSkip==1){//sylee150428

    //--------------------------------------------------------------------------------     
    ipEnd = 1;
    nEnd = 0;

    if (nMod1 == TEST_OPEN) {
        //son ???? 의미 없는 코드??
        //nRCount=nBDLData2Op[dutId][1][0][1];  //SYLEE180810-1-DUT16   //son190704-4WDUT16

        g_nPieceMax1 = SysInfoPieceRange.m_nPieceCount[dutId];    //SYLEE150920

        if ((g_nPieceMax1 > 1)) {//PIECE
            ipEnd = g_nPieceMax1;
            ipFlag = 1;
        }
    }
    else {
        str.Format("Error No 7207 ,     SET ERORR    OPEN, Short, HR, HV, uShort, 4w !    => [RECIPE] \n");
        MyTrace(PRT_BASIC, str);     //son221104_2
        AfxMessageBox(str);
        return 0;
    }

    nLoop = 0;//sylee20120724
    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee20120118

    //son OpenErr Data를 0으로 설정 
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//SYLEE121129
    if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) { //SYLEE130109-1
        ::ZeroMemory(&nOpenErrData, sizeof(nOpenErrData));
        ::ZeroMemory(&nOpenErrList, sizeof(nOpenErrList));
    }
    ::ZeroMemory(&nOpenErrFlag, sizeof(nOpenErrFlag));//sylee151208-1-import

    tStart2 = GetuSecond(); //SYLEE140108TEST  //SYLEE150509-1 RAYOK

    //========================
    //son 직렬 측정  설정부 
    //========================

    //son  VB_TB_CMD (0:OFF), BOT_SEN_CMD (0:OFF)  VB 하부 전압 출력 OFF

    //TBD...

    Sub71.OnSparkOn(0);//sylee150527    //son Spark 기능 OFF

    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    
    //-----------------------------------------------------
    //son Open 검사 라인 체크
    //    임의의 pin(0~31)을 선택하여 연결을 체크한다.
    //-----------------------------------------------------
    
    //son190902 32KPIN
    //2019.11.11 : 상부, 하부 모두 존재하지 않고 케이블로 상부 하부를 변경하면서 테스트시에는 
    //             아래의 체크코드를 #if 0 으로 전환해서 막아놓고 수행해야 한다.  하부 박스만 있는데 
    //             상부 박스의 pin1~32를 확인하므로 진행이 불가함.
//#if 1
#ifndef _PC_TEST_

    int nPin11;//sylee141017-1
    if (nOPenSetSkip == 1)//sylee150428
    {
        //ACE380TESTMODE    nPin11=rand()%(128*10);

        nPin11 = rand() % (32);  //CAN'T OPEN    17/08/14 JUNG  EXECUTIVE DIRECTOR 

        for (int j1 = 1; j1 <= 2000; j1++)  //sylee1608010-1    2000->20
        {

            //son230825 if (SysSet13.m_nPinBlockType == PIN_BLK_32K_TRANS //son190902 32KPIN    //son230216_1
            //son230825         || SysSet13.m_nPinBlockType == PIN_BLK_32K_ORG)   //son230216_1
            {
                
                //son HW적으로 pin 1~ 32 사이의 pin이 꽃혀 있는지를 확인하는 것이므로 
                //    HwPin 변환을 거치지 않고 고정값인 1~32를 써야 한다.  그래서  type 1으로 호출함.
                
                //son 같은 pin에 VB, VC를 붙여서 SelfTest  상황을 만든다.
                Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
                Sub71.AOnPinSet1(1, nPin11, 1); //=1Vb,    // 
                Sub71.Delay_100ns(50); //50us  
                Sub71.AOnPinSet1(1, nPin11, 2); //=1Vc,
                Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS

            }
            //son230825 s100-1에서 상부 첫번째 block이 없는 .CON을 가진 BDL일때 여기에 걸려서 7703 Pin Map 에러 다수 발생하고
            //   SW 죽여야 다시 사용할 수 있는 문제 발생. (230825) pin변환 없이 첫번째 block을 체크하고자 하는 것이므로  
            //   AOnPinSet1(1, nPin11, 1); 하는 코드만 남기고 아래 코드는 삭제. 
            //else
            //{
            //    Sub71.OnPinAllReset1(); ///PIN ALL RESET //sylee1608010-1
            //    Sub71.AOnPinSet1(2, nPin11, 1); //=1Vb, //sylee1608010-1
            //    Sub71.Delay_100ns(50); //50us  
            //    Sub71.AOnPinSet1(2, nPin11, 2); //=1Vc,//sylee1608010-1
            //    Sub71.Delay_100ns(5000); //50us  //sylee150618  //sylee1608010-1  50uS-> 500uS
            //}

            Sub71.Delay_100ns(10000); //50us //sylee200612-4W정도개선

            //sylee170814-1  Sub71.AOnReadV1I1_ADC_I();  
            //sylee170814-1  break;  
            if (nCC == 2) {
                Sub71.AOnReadV1I1(7);
            }
            else {
                Sub71.AOnReadV1I1(nVRel);
            }

            if (Sub71.Y1 < 0.0000001) {
                Sub71.Y1 = 0.0000001;
            }

            if (nFil == 3) {//HV OPEN ENABLE //SYLEE20120411   
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 5) {  //SYLEE150904 //ACE400
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {
                    //son R ohm = ((VB 전압 - VC 전압) / 전류) * (mA면 1000을 곱하고 uA면 1000000을 곱한다) 
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
                }
            }

            //son 100 ohm의  Raw R 값보다 작으면
            if (Sub71.R1 <= nProRv1_O) { //sylee170814-1
                break;
            }

            //-----------------
            //son Open 발생 
            //    같은핀을 VB, VC로 설정했는데 Open이 발생했다면  1번 scanner 카드에 무슨 문제가 있는 것.
            if (j1 == 2000) {    //sylee170814-1     

                Sub71.OnPinAllReset1(); ///PIN ALL RESET 
                int nCard, nPin;
                nPin11 = PinMap[2][nPin11];
                nCard = (int)(nPin11 / 128) + 1;
                nPin = (int)(nPin11 - (int)((nCard - 1) * 128)) + 1;
                nFlagInsul1 = 1;//sylee170816-1
                DisplayRes1_BigLabel(TEST_DIS_FAIL);//sylee170816-1 //son220824
                str.Format("Insulation Error!   Can't open!"); //sylee170816-1
                m_list1.AddString(str); //sylee170816-1 
                str.Format(" Error No 7011.   \n\n\n\n  Insulation  Error!    or   Can't open!    \n\n\n\n   1) PCB Clamp check! \n   2) Auto self check! \n\n  ");
                MyTrace(PRT_BASIC, str);     //son221104_2
                AfxMessageBox(str, MB_OK);  //sylee170816-1

                //goto Task201;//sylee170816-1

                break;
            }

        }

    }//end of if(   nOPenSetSkip==1){//sylee150428
#endif

    int nPin21, nPin22;//sylee170601 ray

    nPin21 = (*g_pvBDLData2Op[dutId][1])[1].wFirstPin;    //son200420-4WNET10000
    nPin22 = (*g_pvBDLData2Op[dutId][1])[1].wPin;     //son200420-4WNET10000

    //son Open검사중 사용할 중간 data 초기화
    ::ZeroMemory(&nBDLData2Op_Cur, sizeof(nBDLData2Op_Cur));//sylee160211-1  //sylee160308-1 //sylee180728-1 moveup
    ::ZeroMemory(&nBDLData2Op_Po, sizeof(nBDLData2Op_Po));//sylee160211-1 //sylee180728-1 moveup

    //son  5회 반복하여 핀 설정 초기화
    for (j2 = 1; j2 <= 5; j2++) { //sylee170601 ray
        Sub71.OnPinAllReset1();
        Sub71.AOnPinSet1(2, nPin21, 1);
        Sub71.Delay_100ns(50); //50us  
        Sub71.AOnPinSet1(2, nPin22, 2);
        Sub71.Delay_100ns(1000);
        Sub71.AOnReadV1I1_ADC_I();
    }

    Sub71.OnPinAllReset1(); ///PIN ALL RESET 


    //////////////////////////////////////////////////////////////////////////////sylee200320-4WCVMODE
/* //sylee2102203

    int n4WNet[MAX_4W_NET +1][NUM_4W_GRID_COL],net;    //son211022 10 -> NUM_4W_GRID_COL . 4W JigTest 안되는 현상 수정 //son231107
    net=0;
    nEnd=(int)g_s4WNet[1].wCount;
    ::ZeroMemory (&n4WNet, sizeof(n4WNet));
    Sub71.OnPinAllReset1();

    for(   net=1; net<=nEnd; net++)  {  //sylee200321
        n4WNet[net][_4W_PIN1]    =(int)g_s4WNet[1].saData[net-1].waPin[0];   // 1~4  pin, //son190705-DUT16
        n4WNet[net][_4W_PIN2]    =(int)g_s4WNet[1].saData[net-1].waPin[1];   // 1~4  pin,
        n4WNet[net][_4W_PIN3]    =(int)g_s4WNet[1].saData[net-1].waPin[2];   // 1~4  pin,
        n4WNet[net][_4W_PIN4]    =(int)g_s4WNet[1].saData[net-1].waPin[3];   // 1~4  pin,
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN1]-1, 2);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN3]-1, 2);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN2]-1, 1);
        Sub71.AOnPinSet1(2, n4WNet[net][_4W_PIN4]-1, 1);
        Sub71.Delay_100ns(5000);//500uS
        Sub71.OnPinAllReset1();
    }
    //////////////////////////////////////////////////////////////////////////////sylee200320-4WCVMODE
*/

    int nPCo;
    nPCo = 0;

    //son 모든 piece가 PASS 상태인 Cell이면 Open테스트 불가
    if (nReSheetFlag1 == 1) { //sylee150228
        for (int ip5 = 1; ip5 <= ipEnd; ip5++) {
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip5];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                nPCo++;
                continue;
            }
        }
        if (nPCo == ipEnd) {
            AfxMessageBox(" ALL  Piece  Passed,    Retest Open Run Error!  Engineer Call! ", MB_OK);
        }
    }

    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        nAutoPress_nConEr_old1 = SysInfo05.m_nConEr;//sylee150213
        SysInfo05.m_nConEr = 50000;
    }

    tStart1002 = GetuSecond();//SYLEE150426-2



    nReCo1_Old = 0;//sylee150527


    m_nopCC = nCC;
    m_nopIR = nIR;
    m_nopFil = nFil;
    m_dISetPercentHigh = nISetPercentHigh;
    m_dISetPercentLow = nISetPercentLow;
    m_dVBSetPercentHigh = nVBSetPercentHigh;
    m_dVBSetPercentLow = nVBSetPercentLow;

    m_nCurVSet = nVRel;
    m_dCurISet = nISet;

    m_nCurMod1 = nMod1;
    m_nCurMode1 = m_nMode1;
    m_dCurProRv1 = nProRv1;
    m_nCurPStep1 = nPStep1; //son 현재 Recipe step

    m_check_bChainTest = FALSE;
    m_nOpenTimeDelay = nDelay20;


    short   firstPin = -1, next_firstPin = -1;
    int     startPinIdx = 0, endPinIdx = 0;

    //son ConEr 체크를 위한 변수들을 초기화
    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//sylee160731-3   IMPORT

    for (ip = 1; ip <= ipEnd; ip++)
    {
        if (g_nSkipPieceFlag1 == 1) {// skip disable CATCH OK,<===//sylee160203-ITS       //son220624
            if (g_nSkipPieceInfo[ip] == 2) {//skip disable piece   <====//sylee160203-ITS     //son220624
                continue;
            }
        }
        //son 해당 piece가 PASS 상태인 Cell이면 Open테스트 의미없음
        if (nReSheetFlag1 == 1) { //sylee131127//resheet
            nReSheetCellNo = nBlockPieceNo1[nBlockCountP][ip];
            nReSheetCellStatus = nReSheetRes[nReSheetCellNo];
            if (nReSheetCellStatus == 1) {  //son PASS
                continue;
            }
        }

        //son 해당 piece가 Disable이면  Open테스트 의미없음
        if (SysInfo19.m_nUse == 1) {
            if (SysInfo19.m_nData[nBlockCountP][ip] == 1) {//sylee130601
                continue;
            }
        }

        //son 해당 piece에 open Pass가 있었다면 Open테스트 의미없음
        if (gRun05.m_nReCh > 0) {//sylee121129 
            if (nReFlagOpenOld[ip] == 1) { //SYLEE121129  2=OPEN
                continue;
            }
        }

        //nRCount=nBDLData2Op[dutId][ip][0][0];//SYLEE150817
        nRCount = g_pvBDLData2Op[dutId][ip]->size() - 1;//SYLEE150817    //son200420-4WNET10000

        nRCountToTal = nRCountToTal + nRCount;//sylee150213  //son nErrorRateToTalPin 계산용

        OpenErrC = 0;
        nOldPin1Flag = 0;//sylee140222
        nSelectFlag1 = 0;  //sylee151203
        int ret = 0;

        for (i = 1; i <= nRCount; i++) //SYLEE20111212
        {

            //son 현재 Recipe(Open) Step의 ErrCount가 SysInfo05.m_nConEr Range를 넘었는지 확인한다.
            //    nFailPiece[ip][nPStep1]:  Open step의 현재 Piece별 err Count  
            if (nFailPiece[ip][nPStep1] >= SysInfo05.m_nConEr)   //sylee20120410  
            {
                if (nAutoReTest[nBlockCountP] != gRun05.m_nReCh) { //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP  //SYLEE130221
                    break;
                } //SYLEE130109-LASTOPENSHORTLIST  //LAST STEP
                if (nFlagAutoPress1 == 2) {//sylee150604
                    break;
                }

            }

            // 첫번째 pin에서 대표핀을 지정한다. 
            // 대표핀은 같은 net의 핀이라면 같으므로 Net이 바뀔 때 지정한다.
            if (i == 1)
            {
                startPinIdx = i;
                endPinIdx = i;
                //firstPin = nBDLData2Op[dutId][ip][i][OPTI_FIRST_PIN]; // 대표핀
                firstPin = (*g_pvBDLData2Op[dutId][ip])[i].wFirstPin;  // 대표핀
            }

            // Last Pin   : next Pin은  더 이상 없음.
            // 마무리로 남아있는 start ~ end 까지 net의 OpenTest를 수행한다.
            if (i == nRCount)
            {
                endPinIdx = i;
                ret = OpenTest_forSameNet(ip, startPinIdx, endPinIdx);
                if (ret < 0)  //son210803 내부에서 ConEr등의 이유로  break를 위해 return한 경우.
                    break;
                continue;
            }

            // next_firsPin이 현재 대표핀과 같다면 다음 pin으로 넘어간다. (같은 net의 마지막을 찾기 위해 )
            //next_firstPin = nBDLData2Op[dutId][ip][i + 1][OPTI_FIRST_PIN];
            next_firstPin = (*g_pvBDLData2Op[dutId][ip])[i + 1].wFirstPin;
            if (next_firstPin == firstPin)  // next Net
                continue;

            // next Pin의 대표핀이 다르다면 같은 Net의 마지막 부분 
            // 여기서 현재 Net의 OpenTest를 수행한다.
            endPinIdx = i;
            ret = OpenTest_forSameNet(ip, startPinIdx, endPinIdx);
            if (ret < 0)  //son210803 내부에서 ConEr등의 이유로 break를 위해 return한 경우.
                break;

            // 남은 OpenTest List를 위해 next 대표핀을 다음번 startPinIdx로 지정
            startPinIdx = i + 1;
            //firstPin = nBDLData2Op[dutId][ip][i +1][OPTI_FIRST_PIN];  // 대표핀
            firstPin = (*g_pvBDLData2Op[dutId][ip])[i + 1].wFirstPin;    // 대표핀
        }

        //-------------------------------------------------------
        //son OpenErrFlag, OpenErrList(first Pin 위치 정보)  생성
        //-------------------------------------------------------
        // : 이상윤부장님 코드와 동일하게 작성.
        //   nOpenErrData[piece][err][]를 조사해서 같은 대표핀의 err를 찾기 쉽도록 nOpenErrList[대표핀][]으로 정리한다. 
        //   nOpenErrData는 같은 대표핀이 모여있으므로 nOpenErrList는 시작과 끝 위치만 표시함

        //son 해당 block의 모든 Retest를 마쳤다면
        if (nAutoReTest[nBlockCountP] == gRun05.m_nReCh) //SYLEE130109-1  //sylee130221
        {
            int pieceErrCnt = nOpenErrData[ip][0][1];
            if (pieceErrCnt > 0)
            {
                nOpenErrFlag[ip] = TRUE;        // piece Err Flag on

                for (int err = 1; err <= pieceErrCnt; err++)
                {

                    //son Open Err 가 아니면 pass 
                    if (nOpenErrData[ip][err][OP_TO_TEST_PIN] == -1)
                        continue;

                    //son 첫번째 err 저장이라면 start와 end에 모두 현재  nOpenErrData[piece] 에서의 OpenErr 위치를 저장
                    if (err == 1) //son 첫번째 err
                    {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;

                    }

                    //son  대표핀 pinNo가 앞의 대표핀 pinNo와 다른 경우 
                    //  => 다른 Net이므로  대표핀 No를 바꿔서 다음번 nOpenErrList[firstPin]을 처리한다.
                    if (firstPin != nOpenErrData[ip][err][OP_TO_FIRST_PIN])
                    {
                        firstPin = nOpenErrData[ip][err][OP_TO_FIRST_PIN];
                        nOpenErrList[firstPin][OPERR_START] = err;
                        nOpenErrList[firstPin][OPERR_END] = err;
                    }

                    //son 앞의 대표핀과 같은 대표핀이면 end위치만 갱신.
                    else
                        nOpenErrList[firstPin][OPERR_END] = err;


                    //son 마지막 err 이면 end만 write
                    if (err == pieceErrCnt)
                        nOpenErrList[firstPin][OPERR_END] = err;

                }
            }
        }

    }//ip

    ::ZeroMemory(&nOpenFail_Co1, sizeof(nOpenFail_Co1));//sylee160731-3
    ::ZeroMemory(&nFailPiece, sizeof(nFailPiece));//sylee160731-3   IMPORT


    //###################################################################################################
    //SYLEE160615-1 #1-1  //  current  first pin 
    //int nPinA2,nStart11,nEnd11,nStart21,nEnd21, nOpen2Pass1;
    //int nOpen2_1,nOpen2_2,nOpen2_3,nOpen2_co1;

    for (ip = 1; ip <= ipEnd; ip++) {
        if (nRCount > 0) {
            if (nReFlagOpenCur[ip] != 2) { //SYLEE121129 pass,    2=OPEN
                nReFlagOpenCur[ip] = 1;

                int tmp1;
                tmp1 = nBlockPieceNo1[nBlockCountP][ip];

                if (GraphDisplay1[tmp1] == 0) {
                    GraphDisplay1[tmp1] = 1;
                }
            }
        }


    }//ip

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //=========================================================================================
    //sylee131221  one-piece
    int nTempOpenCo1;

    nTempOpenCo1 = nProOneP_Open1[0][0];// total short list

    nRetrySet2 = 1; //sylee150604

    if ((nProOneP_Flag1 == 3) && (nProOneP_RunFlag1 == 1) && (nTempOpenCo1 > 0))
    {
        for (int k1 = 1; k1 <= nTempOpenCo1; k1++)
        {
            nReCo1 = 0;

        Task501:

            nPinA = nProOneP_Open1[k1][0];
            nPinB = nProOneP_Open1[k1][1];

            Sub71.AOnPinSet1(2, nPinB, 1); //vc  
            Sub71.AOnPinSet1(2, nPinA, 2);

            Sub71.Delay_100ns(2000); //sylee150618 ray   //sylee181031-1  300->2000
            Sub71.AOnReadV1I1(nVRel);  //sylee131011  
            Sub71.OnPinAllReset1();

            if (nFil == 3) {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
                else if (nIR == 3 || nIR == 4) {
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
                }
                else if (nIR == 5) { //sylee121115
                    Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
                }
            }
            else {
                if (nIR == 1 || nIR == 2) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
                }
                else if (nIR == 3 || nIR == 4 || nIR == 5) {
                    Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;
                }
            }

            if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
                Sub71.R1 = 9999999;
            }
            nReCo1++;

            if (Sub71.R1 > nProRv1) {//fail
                if (nReCo1 < nRetrySet2) {    //sylee150604                                        
                    goto  Task501;
                }

                if (gRun05.m_nReCh != 0) { //SYLEE150618
                    if (nAutoReTest[nBlockCountP] > 1) {//SYLEE181031-1
                        nProOneP_RunFlag1 = 0;
                    }
                }
                break;
            }
        }
    }//end of if((nProOneP_Flag1==3)&&(nProOneP_RunFlag1==1)) {


    //=========================================================================================

    tStart122 = GetuSecond();//TESTDEBUG
    tStart123 = (tStart122 - tStart121);//TESTDEBUG
    tStart1001 = GetuSecond();//SYLEE150509



    Sub71.OnPinAllReset1(); ///PIN ALL NO RESET  //SYEE20111018
    ////////////////////////////////////////////////////////


    Sub71.FilterSet(0);//sylee130704             
    Sub71.I_Filter(0);
    Sub71.ARunoff1();
    Sub71.AOnRelayOffSel(nVRel);  // lv relay off    
    Sub71.AOnReadV1Enable1(5); //sylee130711   lv  hv sen all off

    if (nAutoPress_Flag1 == 1 && nManualStartFlag == 1) {//sylee150213
        SysInfo05.m_nConEr = nAutoPress_nConEr_old1;//sylee150213 
        if (nRCountToTal > 0) {
            nErrorRateToTalPin = (double)((double)nFailL1CoOpen / (double)nRCountToTal);//sylee150213
        }
        else {
            nErrorRateToTalPin = 0.0;//sylee150213
        }
    }

    /////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////


    tStart1001 = GetuSecond();//SYLEE150701

    nPinSetSkipVb = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVbCnt = 0; //sylee151005 //ACE400    //son230127
    nPinSetSkipVc = 0; //sylee151005 //ACE400       //son230127
    nPinSetSkipVcCnt = 0; //sylee151005 //ACE400    //son230127

    Sub71.OnPinResetInit();//sylee151221   //ACE400

    return 1;
}


//son210712
// 같은 대표핀끼리 묶어서 OpenTest를 수행한다.   
// 대표핀이 같으면 같은 Net. Net 번호는 don't care.
int  CChildView7::OpenTest_forSameNet(int piece, int startPinIdx, int endPinIdx)
{

    int     firstPin, testPin;
    int     ret;

    // 연쇄 방식 (인접한 pin끼리 테스트)의 특별한 OpenTest
    if (m_check_bChainTest)
        ret = OpenTest_forSameNet_Phase1Chain(piece, startPinIdx, endPinIdx);

    // 대표핀 방식 OpenTest 
    else
        ret = OpenTest_forSameNet_Phase1Phase2(piece, startPinIdx, endPinIdx);

    if (ret < 0)
        return ret;



    /*
        //-------------------
        // CheckOpen Phase 3
        //-------------------
        // : 2차 불량핀 전체를 재측정하여 혹시 양품이 나온다면 정밀측정을 한번 더 수행한다.

        // TBD...
        for (err = 1; err <= m_wTempOpenErrCnt; err++)
        {
            // Open Err 가 아니면 pass
            if (m_waTempOpenErrData[err][OP_TO_TEST_PIN] == -1)
                continue;

            // Open 검사한다.
            firstPin = m_waTempOpenErrData[err][OP_TO_FIRST_PIN];
            testPin  = m_waTempOpenErrData[err][OP_TO_TEST_PIN];

            VB_SwOn(firstPin);
            VC_SwOn(testPin);

            // 측정값이 양품 근처이면 정밀 측정을 수행한다.
            ret = CheckOpen();
            if (ret == 0)   // 에러였다가 양품으로 바뀌었다면
            {

            }

            // 100k 측정 모드로 돌입한다.

            // 측정 범위를 벗어나면 100K 측정모드로 측정한다.
            VC_Reset();
            VB_Reset();

            // 최대 Open Error 수량이면 종료한다.
        }
    */


    //------------------------
    // ErrData 정리 & 저장 
    //------------------------
    // g_waOpenErrData[piece]와 g_waOpenErrList[]에 temp 결과를 정리하여  저장한다.
    int err, pieceErrCnt;


    // 같은 piece 안에 여러개의 Net이 있는 경우는 이전의 카운트값 이후로 증가시켜야 한다.
    pieceErrCnt = nOpenErrData[piece][0][1];
    for (err = 1; err <= m_wTempOpenErrCnt; err++)
    {
        // Open Err 가 아니면 pass  
        //   : 선별에서 걸러진 경우이므로 g_waOpenErrData[piece]에 저장하지 않는다. 
        if (m_waTempOpenErrData[err][OP_TO_TEST_PIN] == -1)
            continue;

        // Open불량 핀에 대하여 재검사를 수행한다. 
        firstPin = m_waTempOpenErrData[err][OP_TO_FIRST_PIN];
        testPin = m_waTempOpenErrData[err][OP_TO_TEST_PIN];

        VB_SwOn(firstPin);
        VC_SwOn(testPin);

        // 불량대상 재검사를 수행.  // CheckOpen Phase 3에 해당.
        ret = MeasureOpen();  //son Retry 없이  1회만 R값 측정.

        // Open불량
        if (ret != 0)
        {

            // 측정값이 큰경우 100k 측정 모드로 돌입한다.

            // 측정값이 양품 근처이면 정밀 측정을 수행한다.

            //-------------------
            // OpenErrData 저장  :  g_waOpenErrData[piece][m_wTempOpenErrCnt][]
            // : 선별된 불량의 갯수만큼 해당 piece의 open error count를 증가시키고 
            //   해당 error 위치에 firstPin, testPin OpenErr 정보를 기록한다. 
            //   ** OpenErrList는 여기 OpenTest_forSameNet()에서는  저장하면 안 된다. 
            //   OpenErrList[대표핀]이 piece 별로 따로 값을 가지지 않기도 하고, 
            //   OpenTest_forSameNet()는 같은 piece에서 여러번 호출 될 수 있으므로 OpenErrList 
            //   저장하다가 오류가 발생함. OpenTest_forSameNet()외부에서 따로 piece별로 저장한다.

            pieceErrCnt++;              // 선별된 err의 count + 이전 errCnt

            nOpenErrData[piece][pieceErrCnt][OP_TO_FIRST_PIN] = firstPin;
            nOpenErrData[piece][pieceErrCnt][OP_TO_TEST_PIN] = testPin;

            //son 불량대상 재검사 결과까지 반영한 측정 결과를 저장한다.
            //    phase1(1차 Retry, 2차 Retry), phase2, 불량재검사까지 모두 수행한 결과 나온 Fail을 저장하는 것.
            SaveOpenErrorData(piece, firstPin, testPin);
        }
        Sub71.OnPinAllReset1(); ///PIN ALL RESET    //son210729

    }
    nOpenErrData[piece][0][1] = pieceErrCnt;    // 새로 추가된 갯수만큼 더하여  write 되어야 한다.

    return 0;
}

//son210712
int  CChildView7::OpenTest_forSameNet_Phase1Phase2(int piece, int startPinIdx, int endPinIdx)
{
    int     firstPin, testPin;
    int     ret;
    int     nRetryCount = 0;     //son210730 nReCo1 에 해당


    ::ZeroMemory(m_waTempOpenErrData, sizeof(m_waTempOpenErrData));
    m_wTempOpenErrCnt = 0;

    //----------------------
    //  CheckOpen Phase 1 
    //----------------------

//  MyTrace(PRT_BASIC, "OpenTest_forSameNet(): piece=%d, startPinIdx=%d, endPinIdx=%d\n", 
//                                              piece, startPinIdx, endPinIdx);

    int dutId = getDutId();
    //son 대표핀 지정:  VB인 FirstPin은 모두 같으므로 VB_SwOn()은 1회만 수행 
    firstPin = (*g_pvBDLData2Op[dutId][piece])[startPinIdx].wFirstPin;
    VB_SwOn(firstPin); //son Sub71.AOnPinSet1(2, wVbPin, 1):  

    for (int pinIdx = startPinIdx; pinIdx <= endPinIdx; pinIdx++)
    {

        testPin = (*g_pvBDLData2Op[dutId][piece])[pinIdx].wPin;    // test 대상 핀
        // error check   :  range error로  read pin이  되지 않은 경우
        //                  이 경우가 있다면 "RANGE_OVER" 에러로 디버그 로그 출력이 되었을 것임
        //                  여기서는 pass.
        if (firstPin == 0 && testPin == 0)
            return -1;
        if (firstPin < 0 || testPin < 0) // pin값이 -1이면 pass
            continue;
        VC_SwOn(testPin);   //son  Sub71.AOnPinSet1(2, wVcPin, 2);
        ret = CheckOpen();
        if (ret < 0)    // 불량(Open Err) 발견
        {
            // piece별 error count가 max 5000개 이상인지 확인. (불량 정보 저장 불가)
            if (m_wTempOpenErrCnt >= MAX_ERR_COUNT)
                return -1;

            //----------------------------------------------------
            // OpenErr 정보 저장 :  m_waTempOpenErrData[m_wTempOpenErrCnt][]
            // : 불량이 발생했으므로 해당 piece의 open error count를 증가시키고 
            //   해당 count 위치에 firstPin, testPin OpenErr 정보를 기록한다.
            m_wTempOpenErrCnt++;
            m_waTempOpenErrData[m_wTempOpenErrCnt][OP_TO_FIRST_PIN] = firstPin;
            m_waTempOpenErrData[m_wTempOpenErrCnt][OP_TO_TEST_PIN] = testPin;

        }

        // Test 완료 후 VC 를 비운다.
        Sub71.OnPinResetVC();
    }
    // Test 완료 후 VB 를 비운다.
    Sub71.OnPinResetVB();


    //--------------------
    // CheckOpen Phase 2 
    //--------------------
    // : 불량핀 중에서 진짜 불량핀을 선별(pick out)한다.  (중복에러 제거)
    // ErrCount가 있는 경우에만 선별작업을 진행한다. 
    if (m_wTempOpenErrCnt <= 0)
        return 0;

    // 대표핀을 ErrList 중에서 첫번째 testPin부터  옮겨가면서 다시 체크한다.
    // errList에 n개가 등록이 되었다면 (n-1) + (n-2) + ... +1 횟수만큼 다시 체크하게 된다.    //
    // ex) errData[] :  (0,3), (0,5), (0,7) 이면 firstPin은 3으로 하고 5, 7을 testPin으로 재검한다. 
    //     즉 ,  (3,5), (3,7)을 OpenChck()하고 다시 firstPin을 5로 하고 (5,7)을 OpenCheck()한다.
    //     OpenCheck() 결과가 양품이라면 errData의 해당 testPin은 -1로 바꾸어서 list에서 제외한다. 
    //     Same Net 안의 Error에 대해서만 진행하므로 다음의 코드는 의미가 있다. 
    //     (OpenTest는 같은 net안에서의 연결여부를 검사하는 것. 같은 net이 아니면 검사할 수 없다)
    for (int firstErr = 1; firstErr <= (m_wTempOpenErrCnt - 1); firstErr++)
    {
        // first pin 지정  : firstErr의 testPin을 firstPin으로  지정.  
        firstPin = m_waTempOpenErrData[firstErr][OP_TO_TEST_PIN];
        VB_SwOn(firstPin);

        // test pin 지정 : firstErr 를 제외한 errData의 testPin을 testPin으로 지정
        for (int testErr = firstErr + 1; testErr <= m_wTempOpenErrCnt; testErr++)
        {

            testPin = m_waTempOpenErrData[testErr][OP_TO_TEST_PIN];    // test 대상 핀
            if (testPin < 0) // pin값이 -1이면 pass
                continue;

            //----------------------------------
            // 선택된 불량핀을 CheckOpen()한다.
            VC_SwOn(testPin);

            // 2차 OpenCheck()
            ret = CheckOpen();
            if (ret == 0)   // 에러였다가 양품으로 바뀌었다면 
            {
                // Open Err 해제  : testPin만 -1로 바꾼다.  대표핀(firstPin)은 같은 net 표시를 위해 유지한다.
                m_waTempOpenErrData[testErr][OP_TO_TEST_PIN] = -1;
            }

            Sub71.OnPinResetVC();

        }
        Sub71.OnPinResetVB();
    }
    return 0;
}

//son210712
int  CChildView7::OpenTest_forSameNet_Phase1Chain(int piece, int startPinIdx, int endPinIdx)
{
    int     firstPin_org, firstPin, testPin;
    int     ret;

    ::ZeroMemory(m_waTempOpenErrData, sizeof(m_waTempOpenErrData));
    m_wTempOpenErrCnt = 0;

    int dutId = getDutId();

    // Original 대표핀 보관 
    firstPin_org = firstPin = (*g_pvBDLData2Op[dutId][piece])[startPinIdx].wFirstPin;
    VB_SwOn(firstPin);
    for (int pinIdx = startPinIdx; pinIdx <= endPinIdx; pinIdx++)
    {

        testPin = (*g_pvBDLData2Op[dutId][piece])[pinIdx].wPin;    // test 대상 핀

        // error check   :  range error로  read pin이  되지 않은 경우
        //                  이 경우가 있다면 "RANGE_OVER" 에러로 디버그 로그 출력이 되었을 것임
        //                  여기서는 pass.
        if (firstPin == 0 && testPin == 0)
            return -1;

        if (firstPin < 0 || testPin < 0) // pin값이 -1이면 pass
            continue;

        // 1차 CheckOpen()에서는 level 없이 호출하여 default로 level1으로 테스트한다.
        VC_SwOn(testPin);       //son Sub71.AOnPinSet1(2, testPin, 2);
        ret = CheckOpen();
        if (ret < 0)    // 불량(Open Err) 발견
        {
            // piece별 error count가 max 5000개 이상인지 확인. (불량 정보 저장 불가)
            if (m_wTempOpenErrCnt >= MAX_ERR_COUNT)
                return -1;

            //----------------------------------------------------
            // OpenErr 정보 저장 :  m_waTempOpenErrData[m_wTempOpenErrCnt][]
            // : 불량이 발생했으므로 해당 piece의 open error count를 증가시키고 
            //   해당 count 위치에 firstPin, testPin OpenErr 정보를 기록한다.
            m_wTempOpenErrCnt++;
            m_waTempOpenErrData[m_wTempOpenErrCnt][OP_TO_FIRST_PIN] = firstPin;
            m_waTempOpenErrData[m_wTempOpenErrCnt][OP_TO_TEST_PIN] = testPin;
        }

        // Test 완료 후 VC 를 비운다.
        Sub71.OnPinResetVC();

        // 다음 Relay 테스트를 위해 현재 testPin을 다음번 대표핀으로 지정한다.
        Sub71.OnPinResetVB();
        firstPin = testPin;
        VB_SwOn(firstPin);

    }
    // Test 완료 후 VB 를 비운다.
    Sub71.OnPinResetVB();

    return 0;
}

//son210712
// Fail(-1)로 리턴하고,  그렇지 않으면 Pass(0)로 리턴한다.
int CChildView7::CheckOpen()
{
    int nIR = m_nopIR;
    __int64   tStart1, tStart2, tStart3; 


    Sub71.Delay_100ns(m_nOpenTimeDelay);
    tStart1 = GetuSecond();       //son 저항값 측정 시작 time 표시

 

    do
    {
        //-----------------------
        //son 저항값 측정
        if (m_nopCC == 2) {
            Sub71.AOnReadV1I1(7);
        }
        else {
            Sub71.AOnReadV1I1(nVRel);
        }

        if (Sub71.Y1 < 0.0000001) {
            Sub71.Y1 = 0.0000001;
        }

        if (m_nopFil == 3) {//HV OPEN ENABLE //SYLEE20120411                   
            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
            }
            else if (nIR == 5) {  //SYLEE150904 //ACE400
               //SYLEE200908   Sub71.R1=(Sub71.X1)/Sub71.Y1*1000000.0;
                Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;//SYLEE200908
            }
        }
        else {
            if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
            }
            else if (nIR == 5) {  //SYLEE150904 //ACE400
                Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
            }
        }

        if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
            Sub71.R1 = 9999999;
        }

        if (Sub71.Y1 > m_dISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
            Sub71.R1 = 9999999;
        }

        //  10v high R
        if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030
            if (Sub71.Y1 < m_dISetPercentLow) {//sylee120914   //I    ISEC 1%
                Sub71.R1 = 9999999;
            }
            if (nVSet == 10) {  //sylee140911                          
                if (Sub71.X1 > m_dVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                    Sub71.R1 = 9999999;
                }
                if (Sub71.X1 < m_dVBSetPercentLow) {//sylee120914  //VC   VB 1%
                    Sub71.R1 = 9999999;
                }
            }
        }
        // TimeOut Error Check
        tStart2 = GetuSecond();
        tStart3 = (tStart2 - tStart1);

        if (tStart3 > m_nOpenTimeDelay * 2)
            break;

        //son Open불량인 경우 Delay time까지 계속 retry.  (Phase1 1차 Retry)
    } while (Sub71.R1 > m_dCurProRv1);   //son Test mode의 기준 R값 보다 크면 Open 불량

    //son Open불량인 경우 
    if (Sub71.R1 > m_dCurProRv1)
        return -1;

    //son Open 불량이 아닌 경우
    else
        return 0;
}

//son210712 Retry 없이  1회만 R값 측정.
int CChildView7::MeasureOpen()  
{
    int nIR = m_nopIR;

    //  Sub71.AOnReadV1I1_ADC_I(); 
    Sub71.Delay_100ns(m_nOpenTimeDelay * 3);

    if (m_nopCC == 2) {
        Sub71.AOnReadV1I1(7);
    }
    else {
        Sub71.AOnReadV1I1(nVRel);
    }

    if (Sub71.Y1 < 0.0000001) {
        Sub71.Y1 = 0.0000001;
    }

    if (m_nopFil == 3) {//HV OPEN ENABLE //SYLEE20120411                   
        if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
            Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
        }
        else if (nIR == 5) {  //SYLEE150904 //ACE400
            Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000000.0;
        }
        else if (nIR == 5) { //sylee121115
            Sub71.R1 = (Sub71.X1) / Sub71.Y1 * 1000.0;
        }
    }
    else {
        if (nIR == 1 || nIR == 2 || nIR == 3 || nIR == 4) {//SYLEE150904 //ACE400
            Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000.0;
        }
        else if (nIR == 5) {  //SYLEE150904 //ACE400
            Sub71.R1 = ((Sub71.V1 - Sub71.X1) / Sub71.Y1) * 1000000.0;//sylee121027->1000000=>1000
        }
    }

    if ((Sub71.Y1 < 0.1) && (Sub71.X1 < 5)) {//interlock  //sylee121106
        Sub71.R1 = 9999999;
    }

    if (Sub71.Y1 > m_dISetPercentHigh) {//sylee120914   //I   ISEC+ISEC 20%
        Sub71.R1 = 9999999;
    }

    if ((nOpenHighRFlag != 1) && (SysSet13.m_nSet13 != 1)) {//sylee141030
        if (Sub71.Y1 < m_dISetPercentLow) {//sylee120914   //I    ISEC 1%
            Sub71.R1 = 9999999;
        }
        if (nVSet == 10) {  //sylee140911                          
            if (Sub71.X1 > m_dVBSetPercentHigh) {//sylee120914  //VC  VB+ VB20%
                Sub71.R1 = 9999999;
            }
            if (Sub71.X1 < m_dVBSetPercentLow) {//sylee120914  //VC   VB 1%
                Sub71.R1 = 9999999;
            }
        }
    }

    // Open불량인 경우 
    if (Sub71.R1 > m_dCurProRv1)
        return -1;
    else
        return 0;
}

//son210712  m_list1 출력을 위한 nFailL1Open[nFailL1CoOpen]를 생성한다.
//    phase1(1차 Retry, 2차 Retry), phase2, 불량재검사까지 모두 수행한 결과 나온 Fail을 저장한다.
void CChildView7::SaveOpenErrorData(int nPieceNo, int nPinA, int nPinB)
{
    int t1;
    if (nFailL1CoOpen < 3000)//array size nFailL1
    {
        //son m_nCurMod1: TEST_OPEN(1)   //son 검사종류 TEST_OPEN의 불량 개수 증가.         
        nFailCount[m_nCurMod1]++;

        //son 장비 RETEST를 위해 현재 Block의 Open Fail 개수를 증가시킨다. 
        //    nFailL1Open[nFailL1CoOpen] 상세 데이터도 함께 기록
        nFailL1CoOpen++;
        nFailL1Open[nFailL1CoOpen][1] = nFailL1CoOpen;//open 1    //son Open불량 상세data: 불량수량
        nFailL1Open[nFailL1CoOpen][F_BLOCK] = nBlockCountP;//block//son Open불량 상세data: blockNo  //2: F_BLOCK    

        t1 = nPinA + 1;//PIECE  pin no      
        t1 = nPinToPiece(t1);//SYLEE171225-2  //son210712

        //son Piece별 Fail 데이터 write ---------------------------

        //son Piece별 Open 불량 개수 증가 : nFailL1CoOpen를 piece별로 나누어 놓은 것.
        nOpenFail1[nPieceNo]++;//sylee20120921//100=piecemax    

        //son RETEST를 위해 현재 Piece Open 불량 표시. 
        // 여기서 Open(2) 표시를 함으로써 Retest할 때의 테스트 대상이 된다.
        // 이게 Pass(1)면 Retest 할 때 해당 piece는 넘어간다.
        nReFlagOpenCur[nPieceNo] = 2; //SYLEE121129  2            

        nFailPiece[nPieceNo][m_nCurPStep1]++;////PIECE  error count //son Piece별 검사순서별 불량 개수                  
        if (nFailPiece[nPieceNo][m_nCurPStep1] >= SysInfo05.m_nConEr) {
            nOpenMoreThanFlag = 1;//sylee12112
        }

        nFailL1Open[nFailL1CoOpen][F_PIECE] = t1;////PIECE  no          //son Open불량 상세data: pieceNo //son220419_4 3:F_PIECE

        if (nPinA < nPinB) {
            nFailL1Open[nFailL1CoOpen][F_VB_PIN] = nPinA;     //son Open불량 상세data: firstPin(VB) //son220419_4 4:F_VB_PIN
            nFailL1Open[nFailL1CoOpen][F_VC_PIN] = nPinB;     //son Open불량 상세data: testpin(VC) //son220419_4 5:F_VC_PIN
        }
        else {
            nFailL1Open[nFailL1CoOpen][F_VB_PIN] = nPinB;      //son220419_4 4:F_VB_PIN
            nFailL1Open[nFailL1CoOpen][F_VC_PIN] = nPinA;      //son220419_4 5:F_VC_PIN
        }

        if (nErrPin1O2[nPinA] == 0) {//sylee170810-1
            if (nErrPin1O[nPinA] < 100000) {
                nErrPin1O[nPinA]++;//sylee170810-1
                nErrPin1O2[nPinA] = 1;
            }
        }
        if (nPinA != nPinB) {//sylee170810-1
            if (nErrPin1O2[nPinB] == 0) {//sylee170810-1
                if (nErrPin1O[nPinB] < 100000) {
                    nErrPin1O[nPinB]++;//sylee170810-1
                    nErrPin1O2[nPinB] = 1;
                }
            }
        }
        //son220419_4 nFailL1Open[nFailL1CoOpen][] 관련 상수 enum으로 변경 
        nFailL1Open[nFailL1CoOpen][F_RAW_R] = Sub71.R1;//Sub71.R1                //son  6: Open불량 상세data: 측정 R
        nFailL1Open[nFailL1CoOpen][F_PRORV_RAW_R] = m_dCurProRv1;//nProRv1 판정 R //son 17: Open불량 상세data: 판정 R ADC
        nFailL1Open[nFailL1CoOpen][F_PRORV_REAL_R] = nProRv1Real;                 //son  7: Open불량 상세data: nProRv1 판정 R
        nFailL1Open[nFailL1CoOpen][F_PRO_STEP_REAL_R] = nProStep1[m_nCurMod1][1]; //son  8: Open불량 상세data: TEST_OPEN Cal 적용 R 값
        nFailL1Open[nFailL1CoOpen][F_VSET] = m_nCurVSet;                          //son  9: Open불량 상세data: nVSet 
        nFailL1Open[nFailL1CoOpen][F_ISET] = m_dCurISet;                          //son 10: Open불량 상세data: nISet
        nFailL1Open[nFailL1CoOpen][F_MODE1] = m_nCurMode1;                        //son 11: Open불량 상세data: dRec 배열 해당 Mode
        nFailL1Open[nFailL1CoOpen][F_VB] = Sub71.V1;//VB                          //son220419_2 12:F_VB
        nFailL1Open[nFailL1CoOpen][F_VC] = Sub71.X1;//VC                          //son220419_2 13:F_VC
        nFailL1Open[nFailL1CoOpen][F_I] = Sub71.Y1;//I                            //son220419_2 14:F_I
        nFailL1Open[nFailL1CoOpen][F_TEST_TYPE] = m_nCurMod1; //open ushort short hr hv   4w   //son Open불량 상세data: 1(TEST_OPEN)
                                                                        //son220419_2 16:F_TEST_TYPE

    }
    else//sylee130225joytech
    {
        //son m_nCurMod1: TEST_OPEN(1)   //son 검사종류 TEST_OPEN의 불량 개수 증가.         
        nFailCount[m_nCurMod1]++;//sylee130225joytech        

        //son 장비 RETEST를 위해 현재 Block의 Open Fail 개수를 증가
        //     3000개 max를 over해서 nFailL1Open[nFailL1CoOpen] 상세 데이터는 기록 못함.
        nFailL1CoOpen++;//sylee130225joytech

        //son Piece별 Open 불량 개수 증가
        nOpenFail1[nPieceNo]++;////sylee130225joytech

        //son RETEST를 위해 현재 Piece Open 불량 표시. 
        // 여기서 Open 표시를 함으로써 Retest할 때의 테스트 대상이 된다.
        // 이게 1(Pass)면 Retest 할 때 해당 piece는 넘어간다.
        nReFlagOpenCur[nPieceNo] = 2; ////sylee130225joytech

        nFailPiece[nPieceNo][m_nCurPStep1]++;////sylee130225joytech
    }
}



void CChildView7::VB_SwOn(int wVbPin)
{
    if (wVbPin < 0)
        return;
    Sub71.AOnPinSet1(2, wVbPin, 1);     //son VB 
}

void CChildView7::VB_SwOn(int nPieceNo, short wVbPin)
{
    if (wVbPin < 0)
        return;

    Sub71.AOnPinSet1(2, wVbPin, 1);     //son VB 

    // Open검사 불량핀을 연결한다. (동일 Net)
    if (nOpenErrFlag[nPieceNo] == 2)
    {
        if (nOpenErrList[wVbPin][0] > 0)
        {
            for (int s1 = nOpenErrList[wVbPin][0]; s1 <= nOpenErrList[wVbPin][1]; s1++)
            {
                Sub71.AOnPinSet1(2, nOpenErrData[nPieceNo][s1][OP_TO_TEST_PIN], 1);
            }
        }
    }
}

void CChildView7::VC_SwOn(int wVcPin)
{
    if (wVcPin < 0)
        return;
    Sub71.AOnPinSet1(2, wVcPin, 2);     //son VC 
}

void CChildView7::VC_SwOn(int nPieceNo, short wVcPin)
{
    if (wVcPin < 0)
        return;

    Sub71.AOnPinSet1(2, wVcPin, 2);     //son VC 

    // Open검사 불량핀을 연결한다. (동일 Net)
    if (nOpenErrFlag[nPieceNo] == 2) {
        if (nOpenErrList[wVcPin][0] > 0) {
            for (int s1 = nOpenErrList[wVcPin][0]; s1 <= nOpenErrList[wVcPin][1]; s1++) {
                Sub71.AOnPinSet1(2, nOpenErrData[nPieceNo][s1][OP_TO_TEST_PIN], 2);
            }
        }
    }
}

int CChildView7::FindLeakFailPin(short wVcPin, short wVbPin)
{
	int uFind = 0x0;

    for (int i = 1; i < nFailL1Co + 1; i++)
    {
//        if(Sub71.fpLeak)	fprintf(Sub71.fpLeak, "%2d : (%5.0f, %5.0f) (%5d, %5d) \n", i, nFailL1[i][4], nFailL1[i][5], wVcPin, wVbPin);

        if (nFailL1[i][4] == wVcPin || nFailL1[i][5] == wVcPin)
        {
			uFind = 0x1; 
            if (nFailL1[i][5] == wVbPin || nFailL1[i][4] == wVbPin)
            {
				uFind |= 0x2;
                //return TRUE;
            }
        }
    }

    return uFind;
}

void CChildView7::ResultSpark(int nPin, int nPieceNo, int nMod1, int nPStep1, double nProRv1, double nISet, int m_nMode1)
{
    nFailL1[nFailL1Co][1]                 = nMod1;  //1=open, 2=ushort, 3=short, 4=hr , 5=hv ,6=4W,  
    nFailL1[nFailL1Co][F_BLOCK]           = nBlockCountP;                               //son  2:F_BLOCK
    nFailL1[nFailL1Co][F_PIECE]           = nPieceNo; // t1;                            //son  3:F_PIECE
    nFailL1[nFailL1Co][F_VB_PIN]          = -1;//pin  vc                                //son  4:F_VB_PIN 
    nFailL1[nFailL1Co][F_VC_PIN]          = nPin; // nSQNet1[ik + 1][ih] + 1;//pin  vb  //son  5:F_VC_PIN
    nFailL1[nFailL1Co][F_RAW_R]           = -1;//Sub71.R1                               //son  6:F_RAW_R
    nFailL1[nFailL1Co][F_PRO_STEP_REAL_R] = nProStep1[nMod1][1];                        //son  8:F_PRO_STEP_REAL_R
    nFailL1[nFailL1Co][F_VSET]            = nVSet;                                      //son  9:F_VSET
    nFailL1[nFailL1Co][F_ISET]            = nISet;                                      //son 10:F_ISET
    nFailL1[nFailL1Co][F_MODE1]           = m_nMode1;                                   //son 11:F_MODE1
    nFailL1[nFailL1Co][F_VB]              = dSparkI1[nSparkI1Po2][nSparkMaxX + 2];//SPARK V1     //son 12:F_VB 측정값
    nFailL1[nFailL1Co][F_VC]              = dSparkI1[nSparkI1Po2][nSparkMaxX + 4];//SPARK V1     //son 13:F_VC 측정값
    nFailL1[nFailL1Co][F_I]               = dSparkI1[nSparkI1Po2][nSparkMaxX + 5];//Sub71.Y1;//I //son 14:F_I  측정값
    nFailL1[nFailL1Co][F_STEP]            = nPStep1;//sylee231016                       //son 18:F_STEP
    nFailL1[nFailL1Co][F_TEST_TYPE]       = nMod1;//I  //open ushort short hr hv   4w   //son 16:TEST_TYPE
    nFailL1[nFailL1Co][F_PRORV_RAW_R]     = nProRv1;//nProRv1 판정 raw R                //son 17:F_PRORV_RAW_R 
 }
 
// hdpark20240116
int CChildView7::SetSparkDetectionVolt(double dSetVolt/*=15.0*/, BOOL bUse/*=TRUE*/)
{
    if (bUse == FALSE)   return 0;
    int nSparkUse = 0;

    if (SysInfo05.m_nSp == 1)
    {
        if (SysInfo05.m_nSparkSet > 0)
        {
            nHV_Vset1 = (int)nVSet;
            Sub71.OnSparkADC(1);
            int nSparkset = 15;
//sylee241204          if (m_nUseACLeak)
//sylee241204          {
//sylee241204                nSparkset = dSetVolt + 10; // ac mode에서 더 많은 spark 발생하여 offset을 높임. 
//sylee241204           }
//sylee241204           else
//sylee241204           {
                nSparkset = dSetVolt + 5; // 양산 설정 10인데 불필요한 스파크가 많이 발생하여 15로 설정하기 위해 5를 더함. 고객사에서 바꾸기 어려워 S/W 내부 처리 
//sylee241204           }

            BOOL b32KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_32K_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_32K_U8K_L24K ||
                SysSet12.m_nPinTotMax == PIN_TOT_32K_ORG)
            {
                b32KPIN = TRUE;
            }

            BOOL b24KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_24K_UP_TR ||
                SysSet12.m_nPinTotMax == PIN_TOT_24K_TRANS)
            {
                b24KPIN = TRUE;
            }

            BOOL b20KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_20K_UP_TR ||
                //SysSet12.m_nPinTotMax == PIN_TOT_20K_U8K_L4K_UP_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_20K_U12K_L8K_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_24K_U12K_L8K_TRANS)
            {
                b20KPIN = TRUE;
            }

            BOOL b16KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_16K ||
                SysSet12.m_nPinTotMax == PIN_TOT_16K_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_16K_U12K_L4K_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_16K_U12K_L4K_UP_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_20K_U12K_L4K_UP_TRANS)
            {
                b16KPIN = TRUE;
            }

            BOOL b12KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_12K ||
                SysSet12.m_nPinTotMax == PIN_TOT_12K_TRANS ||
                SysSet12.m_nPinTotMax == PIN_TOT_20K_U8K_L4K_UP_TRANS)
            {
                b12KPIN = TRUE;
            }

            BOOL b8KPIN = FALSE;
            if (SysSet12.m_nPinTotMax == PIN_TOT_8K ||
                SysSet12.m_nPinTotMax == PIN_TOT_8K_LOW_STPIN ||
                SysSet12.m_nPinTotMax == PIN_TOT_8K_TRANS)
            {
                b8KPIN = TRUE;
            }

            BOOL b4KPIN = FALSE;

            if (SysSet12.m_nPinTotMax == PIN_TOT_4K)
            {
                b4KPIN = TRUE;
            }

            if (nSparkset > 25)
            {
                // 의미 없음..그냥 끼워 맞춤.
                if (b32KPIN)		    g_dSparkRatio = 0.20;
                else if (b24KPIN)		g_dSparkRatio = 0.25;
                else if (b20KPIN)		g_dSparkRatio = 0.30;
                else if (b16KPIN)		g_dSparkRatio = 0.50;
                else if (b8KPIN)		g_dSparkRatio = 0.70;
                else if (b4KPIN)		g_dSparkRatio = 1.00;
                else                    g_dSparkRatio = 1.00;
            }
            else
            {
                g_dSparkRatio = 1.0;
            }

            nSparkset *= g_dSparkRatio;
            if (nSparkset > dSparkLeakSet1_V)	nSparkset = dSparkLeakSet1_V;
            if (nSparkset < 4.0)				nSparkset = 4.0;

            Sub71.AOnVBSet1(5, nSparkset);
            Sub71.OnSparkOn(0);
            Sub71.Delay_100ns(10);
            Sub71.OnSparkOn(1);
            nSparkUse = 1;
            g_nSpark1_Use = 1;
        }
    }

    return nSparkUse;
}

//son240430 begin:
//son 직전에  메인장비로 보낸 Output 값을 확인하기 위해 bDOUT 값을 보관한다. 
//    g_ComiDaq2.DoPutAll 랩퍼 함수.  
//    ChildView7에서는 g_ComiDaq2.DoPutAll()을 직접 호출하지 말고 이 랩퍼 함수로 사용해야 함.
byte g_bComiDOutVal;
void CChildView7::Comi_DoPutByte(byte bDOUT) 
{
	g_bComiDOutVal = bDOUT;
	g_ComiDaq2.DoPutAll (bDOUT);
}
//son240430 end.


//son240712 m_Label101 출력시 디버그 프린트 출력 기능 추가
void CChildView7::Label101_Status_SetCaption(CString str)
{
    m_Label101.SetCaption(str);
    MyTrace(PRT_LEVEL3, "Status: %s\n", str.GetBuffer(150));
}

//son240712 m_Label102 출력시 디버그 프린트 출력 기능 추가
void CChildView7::Label102_Cycle_SetCaption(CString str, bool prtOn)
{
    CString label301_str; 
    label301_str = m_Label301.GetCaption();

    m_Label102.SetCaption(str);
    if (prtOn == true)
        MyTrace(PRT_BASIC, "%s: %s\n", label301_str.GetBuffer(50), str.GetBuffer(150));
}

